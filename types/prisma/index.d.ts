
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Clinician
 * 
 */
export type Clinician = $Result.DefaultSelection<Prisma.$ClinicianPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Foot
 * 
 */
export type Foot = $Result.DefaultSelection<Prisma.$FootPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model AssetAugment
 * 
 */
export type AssetAugment = $Result.DefaultSelection<Prisma.$AssetAugmentPayload>
/**
 * Model AssetAugmentMedia
 * 
 */
export type AssetAugmentMedia = $Result.DefaultSelection<Prisma.$AssetAugmentMediaPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Workbench
 * 
 */
export type Workbench = $Result.DefaultSelection<Prisma.$WorkbenchPayload>
/**
 * Model WorkbenchNotes
 * 
 */
export type WorkbenchNotes = $Result.DefaultSelection<Prisma.$WorkbenchNotesPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ShippingPackage
 * 
 */
export type ShippingPackage = $Result.DefaultSelection<Prisma.$ShippingPackagePayload>
/**
 * Model ShippingLabel
 * 
 */
export type ShippingLabel = $Result.DefaultSelection<Prisma.$ShippingLabelPayload>
/**
 * Model Physician
 * 
 */
export type Physician = $Result.DefaultSelection<Prisma.$PhysicianPayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model BillingCode
 * 
 */
export type BillingCode = $Result.DefaultSelection<Prisma.$BillingCodePayload>
/**
 * Model DeviceType
 * 
 */
export type DeviceType = $Result.DefaultSelection<Prisma.$DeviceTypePayload>
/**
 * Model VisitType
 * 
 */
export type VisitType = $Result.DefaultSelection<Prisma.$VisitTypePayload>
/**
 * Model FormSchema
 * 
 */
export type FormSchema = $Result.DefaultSelection<Prisma.$FormSchemaPayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model FormTemplate
 * 
 */
export type FormTemplate = $Result.DefaultSelection<Prisma.$FormTemplatePayload>
/**
 * Model CatalogProduct
 * 
 */
export type CatalogProduct = $Result.DefaultSelection<Prisma.$CatalogProductPayload>
/**
 * Model CatalogProductAttribute
 * 
 */
export type CatalogProductAttribute = $Result.DefaultSelection<Prisma.$CatalogProductAttributePayload>
/**
 * Model CatalogProductVariant
 * 
 */
export type CatalogProductVariant = $Result.DefaultSelection<Prisma.$CatalogProductVariantPayload>
/**
 * Model CatalogCategory
 * 
 */
export type CatalogCategory = $Result.DefaultSelection<Prisma.$CatalogCategoryPayload>
/**
 * Model CatalogVendor
 * 
 */
export type CatalogVendor = $Result.DefaultSelection<Prisma.$CatalogVendorPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Printer
 * 
 */
export type Printer = $Result.DefaultSelection<Prisma.$PrinterPayload>
/**
 * Model CompanyUser
 * 
 */
export type CompanyUser = $Result.DefaultSelection<Prisma.$CompanyUserPayload>
/**
 * Model DepartmentUser
 * 
 */
export type DepartmentUser = $Result.DefaultSelection<Prisma.$DepartmentUserPayload>
/**
 * Model CompanyPatient
 * 
 */
export type CompanyPatient = $Result.DefaultSelection<Prisma.$CompanyPatientPayload>
/**
 * Model FacilityPatient
 * 
 */
export type FacilityPatient = $Result.DefaultSelection<Prisma.$FacilityPatientPayload>
/**
 * Model StripeProduct
 * 
 */
export type StripeProduct = $Result.DefaultSelection<Prisma.$StripeProductPayload>
/**
 * Model StripeInvoice
 * 
 */
export type StripeInvoice = $Result.DefaultSelection<Prisma.$StripeInvoicePayload>
/**
 * Model StripeEntity
 * 
 */
export type StripeEntity = $Result.DefaultSelection<Prisma.$StripeEntityPayload>
/**
 * Model StripeSubscription
 * 
 */
export type StripeSubscription = $Result.DefaultSelection<Prisma.$StripeSubscriptionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationMessage
 * 
 */
export type NotificationMessage = $Result.DefaultSelection<Prisma.$NotificationMessagePayload>
/**
 * Model NotificationHistory
 * 
 */
export type NotificationHistory = $Result.DefaultSelection<Prisma.$NotificationHistoryPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserAgreement
 * 
 */
export type UserAgreement = $Result.DefaultSelection<Prisma.$UserAgreementPayload>
/**
 * Model Agreement
 * 
 */
export type Agreement = $Result.DefaultSelection<Prisma.$AgreementPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountVerification
 * 
 */
export type AccountVerification = $Result.DefaultSelection<Prisma.$AccountVerificationPayload>
/**
 * Model CompanyInvitation
 * 
 */
export type CompanyInvitation = $Result.DefaultSelection<Prisma.$CompanyInvitationPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model ViewFlattenedWorkbench
 * 
 */
export type ViewFlattenedWorkbench = $Result.DefaultSelection<Prisma.$ViewFlattenedWorkbenchPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FacilityType: {
  CLINIC: 'CLINIC',
  EMPLOYER: 'EMPLOYER',
  PARTNER: 'PARTNER',
  SITE: 'SITE'
};

export type FacilityType = (typeof FacilityType)[keyof typeof FacilityType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MaritalStatus: {
  S: 'S',
  M: 'M',
  D: 'D',
  W: 'W'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const CareType: {
  ORTHOTIC: 'ORTHOTIC',
  PROSTHETIC: 'PROSTHETIC'
};

export type CareType = (typeof CareType)[keyof typeof CareType]


export const Side: {
  LEFT: 'LEFT',
  RIGHT: 'RIGHT',
  BILATERAL: 'BILATERAL'
};

export type Side = (typeof Side)[keyof typeof Side]


export const VerticalPosition: {
  UPPER: 'UPPER',
  LOWER: 'LOWER',
  SPINAL: 'SPINAL',
  CRANIAL: 'CRANIAL'
};

export type VerticalPosition = (typeof VerticalPosition)[keyof typeof VerticalPosition]


export const ShoeWidth: {
  NARROW: 'NARROW',
  MEDIUM: 'MEDIUM',
  WIDE: 'WIDE',
  EXTRA_WIDE: 'EXTRA_WIDE',
  YOUTH: 'YOUTH',
  TODDLER: 'TODDLER'
};

export type ShoeWidth = (typeof ShoeWidth)[keyof typeof ShoeWidth]


export const ShoeSystem: {
  US: 'US',
  UK: 'UK',
  EU: 'EU'
};

export type ShoeSystem = (typeof ShoeSystem)[keyof typeof ShoeSystem]


export const InactiveFootReason: {
  AMPUTATION: 'AMPUTATION',
  SKIPPED: 'SKIPPED',
  TOE_FILLER: 'TOE_FILLER',
  PRE_FAB_HEAT_MOLDABLE: 'PRE_FAB_HEAT_MOLDABLE'
};

export type InactiveFootReason = (typeof InactiveFootReason)[keyof typeof InactiveFootReason]


export const ProductType: {
  FOOT_SCAN: 'FOOT_SCAN',
  FOOT_RENDER: 'FOOT_RENDER',
  INSOLE_RENDER: 'INSOLE_RENDER',
  INSOLE_GCODE: 'INSOLE_GCODE',
  INSOLE: 'INSOLE',
  PREFABRICATED_DEVICE: 'PREFABRICATED_DEVICE',
  FABRICATED_DEVICE: 'FABRICATED_DEVICE'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const AssetStatus: {
  AR_IDLE: 'AR_IDLE',
  AR_PENDING: 'AR_PENDING',
  AR_COMPLETED: 'AR_COMPLETED',
  AR_REJECTED: 'AR_REJECTED',
  AR_ERROR: 'AR_ERROR',
  AR_HOLD: 'AR_HOLD',
  AR_SKIP: 'AR_SKIP',
  CV_IDLE: 'CV_IDLE',
  CV_PENDING: 'CV_PENDING',
  CV_COMPLETED: 'CV_COMPLETED',
  CV_REJECTED: 'CV_REJECTED',
  CV_ERROR: 'CV_ERROR',
  CV_HOLD: 'CV_HOLD',
  CV_ADJUSTMENTS_IDLE: 'CV_ADJUSTMENTS_IDLE',
  CV_ADJUSTMENTS_PENDING: 'CV_ADJUSTMENTS_PENDING',
  CV_ADJUSTMENTS_COMPLETED: 'CV_ADJUSTMENTS_COMPLETED',
  CV_ADJUSTMENTS_REJECTED: 'CV_ADJUSTMENTS_REJECTED',
  CV_ADJUSTMENTS_ERROR: 'CV_ADJUSTMENTS_ERROR',
  CV_ADJUSTMENTS_SKIP: 'CV_ADJUSTMENTS_SKIP',
  CV_VALIDATE_IDLE: 'CV_VALIDATE_IDLE',
  CV_VALIDATE_PENDING: 'CV_VALIDATE_PENDING',
  CV_VALIDATE_COMPLETED: 'CV_VALIDATE_COMPLETED',
  CV_VALIDATE_REJECTED: 'CV_VALIDATE_REJECTED',
  CV_VALIDATE_ERROR: 'CV_VALIDATE_ERROR',
  NEEDS_COMPLETION: 'NEEDS_COMPLETION'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const AssetAugmentType: {
  ANCHOR_FRAMES: 'ANCHOR_FRAMES',
  PATHOLOGY_DETECTION: 'PATHOLOGY_DETECTION'
};

export type AssetAugmentType = (typeof AssetAugmentType)[keyof typeof AssetAugmentType]


export const WorkbenchCreatedReason: {
  REMAKE: 'REMAKE',
  REORDER: 'REORDER',
  EDIT: 'EDIT'
};

export type WorkbenchCreatedReason = (typeof WorkbenchCreatedReason)[keyof typeof WorkbenchCreatedReason]


export const WorkbenchStatus: {
  DRAFT: 'DRAFT',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type WorkbenchStatus = (typeof WorkbenchStatus)[keyof typeof WorkbenchStatus]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  TOE_FILLER: 'TOE_FILLER',
  NEEDS_MANUFACTURING: 'NEEDS_MANUFACTURING',
  PRINTING: 'PRINTING',
  NEEDS_GRINDING: 'NEEDS_GRINDING',
  NEEDS_GLUING: 'NEEDS_GLUING',
  NEEDS_FINISHING: 'NEEDS_FINISHING',
  NEEDS_SHIPPING: 'NEEDS_SHIPPING',
  NEEDS_ADDON: 'NEEDS_ADDON',
  PACKAGED: 'PACKAGED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderAuthorizationStatus: {
  NO_AUTH_NEEDED: 'NO_AUTH_NEEDED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PENDING: 'PENDING'
};

export type OrderAuthorizationStatus = (typeof OrderAuthorizationStatus)[keyof typeof OrderAuthorizationStatus]


export const Carrier: {
  UPS: 'UPS'
};

export type Carrier = (typeof Carrier)[keyof typeof Carrier]


export const WeightUnit: {
  KG: 'KG',
  LB: 'LB'
};

export type WeightUnit = (typeof WeightUnit)[keyof typeof WeightUnit]


export const DimensionUnit: {
  CM: 'CM',
  INCH: 'INCH'
};

export type DimensionUnit = (typeof DimensionUnit)[keyof typeof DimensionUnit]


export const ShippingTrackingStatus: {
  ACCEPTED: 'ACCEPTED',
  IN_TRANSIT: 'IN_TRANSIT',
  DELIVERED: 'DELIVERED',
  EXCEPTION: 'EXCEPTION',
  UNKNOWN: 'UNKNOWN',
  DELIVERY: 'DELIVERY'
};

export type ShippingTrackingStatus = (typeof ShippingTrackingStatus)[keyof typeof ShippingTrackingStatus]


export const DiagnosisStandard: {
  ICD10: 'ICD10'
};

export type DiagnosisStandard = (typeof DiagnosisStandard)[keyof typeof DiagnosisStandard]


export const FormSchemaType: {
  EVALUATION: 'EVALUATION',
  ORDER: 'ORDER',
  DELIVERY: 'DELIVERY'
};

export type FormSchemaType = (typeof FormSchemaType)[keyof typeof FormSchemaType]


export const ProductAttributeType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  LINK: 'LINK',
  RESOURCE: 'RESOURCE',
  LCODE: 'LCODE'
};

export type ProductAttributeType = (typeof ProductAttributeType)[keyof typeof ProductAttributeType]


export const CompanyRole: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER',
  PATIENT: 'PATIENT'
};

export type CompanyRole = (typeof CompanyRole)[keyof typeof CompanyRole]


export const CompanyDepartment: {
  MANUFACTURING: 'MANUFACTURING',
  PRINT_FARM: 'PRINT_FARM',
  SHIPPING: 'SHIPPING',
  STATIONS: 'STATIONS'
};

export type CompanyDepartment = (typeof CompanyDepartment)[keyof typeof CompanyDepartment]


export const StripeProductType: {
  DIABETIC_1: 'DIABETIC_1',
  DIABETIC_2: 'DIABETIC_2',
  DIABETIC_3: 'DIABETIC_3',
  FUNCTIONAL: 'FUNCTIONAL',
  BASE_FEE: 'BASE_FEE',
  FACILITY_SUBSCRIPTION: 'FACILITY_SUBSCRIPTION',
  ORTHOFEET_SHOES: 'ORTHOFEET_SHOES',
  ACCOMODATION_FEE: 'ACCOMODATION_FEE',
  UCBL_FEE: 'UCBL_FEE',
  PRE_FAB_HEAT_FEE: 'PRE_FAB_HEAT_FEE',
  FUNCTIONAL_REORDER: 'FUNCTIONAL_REORDER',
  BASE_SUBSCRIPTION: 'BASE_SUBSCRIPTION',
  EMPLOYER_PAY: 'EMPLOYER_PAY',
  EMPLOYEE_PAY: 'EMPLOYEE_PAY',
  UNVERIFIED_PAY: 'UNVERIFIED_PAY'
};

export type StripeProductType = (typeof StripeProductType)[keyof typeof StripeProductType]


export const StripeBillingFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type StripeBillingFrequency = (typeof StripeBillingFrequency)[keyof typeof StripeBillingFrequency]


export const StripeInvoiceType: {
  COMBINED: 'COMBINED',
  SUBSCRIPTION: 'SUBSCRIPTION',
  COMPANY_PAYS: 'COMPANY_PAYS',
  EMPLOYEE_PAYS: 'EMPLOYEE_PAYS'
};

export type StripeInvoiceType = (typeof StripeInvoiceType)[keyof typeof StripeInvoiceType]


export const StripeInvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  COMBINED: 'COMBINED',
  SUBSCRIPTION: 'SUBSCRIPTION',
  ERROR: 'ERROR'
};

export type StripeInvoiceStatus = (typeof StripeInvoiceStatus)[keyof typeof StripeInvoiceStatus]


export const StripeEntityType: {
  COMPANY: 'COMPANY',
  FACILITY: 'FACILITY',
  DEPARTMENT: 'DEPARTMENT'
};

export type StripeEntityType = (typeof StripeEntityType)[keyof typeof StripeEntityType]


export const NotificationType: {
  ABANDONED_CART: 'ABANDONED_CART',
  ORDER_CONFIRMATION: 'ORDER_CONFIRMATION',
  CAMPAIGN: 'CAMPAIGN',
  SURVEY: 'SURVEY'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationResponseType: {
  TOGGLE: 'TOGGLE',
  NUMERICAL: 'NUMERICAL',
  TEXT: 'TEXT'
};

export type NotificationResponseType = (typeof NotificationResponseType)[keyof typeof NotificationResponseType]


export const CommunicationChannel: {
  SMS: 'SMS',
  EMAIL: 'EMAIL'
};

export type CommunicationChannel = (typeof CommunicationChannel)[keyof typeof CommunicationChannel]


export const AgreementStatus: {
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type AgreementStatus = (typeof AgreementStatus)[keyof typeof AgreementStatus]


export const AgreementType: {
  CLINICAL_TC: 'CLINICAL_TC',
  CONSUMER_TC: 'CONSUMER_TC',
  SIMPLR_TC: 'SIMPLR_TC',
  ENABLE_SMS: 'ENABLE_SMS'
};

export type AgreementType = (typeof AgreementType)[keyof typeof AgreementType]


export const AccountRecoveryType: {
  RESET_PASSWORD: 'RESET_PASSWORD',
  EMAIL_LOGIN: 'EMAIL_LOGIN'
};

export type AccountRecoveryType = (typeof AccountRecoveryType)[keyof typeof AccountRecoveryType]


export const ContactType: {
  EMAIL: 'EMAIL'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]

}

export type FacilityType = $Enums.FacilityType

export const FacilityType: typeof $Enums.FacilityType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type CareType = $Enums.CareType

export const CareType: typeof $Enums.CareType

export type Side = $Enums.Side

export const Side: typeof $Enums.Side

export type VerticalPosition = $Enums.VerticalPosition

export const VerticalPosition: typeof $Enums.VerticalPosition

export type ShoeWidth = $Enums.ShoeWidth

export const ShoeWidth: typeof $Enums.ShoeWidth

export type ShoeSystem = $Enums.ShoeSystem

export const ShoeSystem: typeof $Enums.ShoeSystem

export type InactiveFootReason = $Enums.InactiveFootReason

export const InactiveFootReason: typeof $Enums.InactiveFootReason

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type AssetAugmentType = $Enums.AssetAugmentType

export const AssetAugmentType: typeof $Enums.AssetAugmentType

export type WorkbenchCreatedReason = $Enums.WorkbenchCreatedReason

export const WorkbenchCreatedReason: typeof $Enums.WorkbenchCreatedReason

export type WorkbenchStatus = $Enums.WorkbenchStatus

export const WorkbenchStatus: typeof $Enums.WorkbenchStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderAuthorizationStatus = $Enums.OrderAuthorizationStatus

export const OrderAuthorizationStatus: typeof $Enums.OrderAuthorizationStatus

export type Carrier = $Enums.Carrier

export const Carrier: typeof $Enums.Carrier

export type WeightUnit = $Enums.WeightUnit

export const WeightUnit: typeof $Enums.WeightUnit

export type DimensionUnit = $Enums.DimensionUnit

export const DimensionUnit: typeof $Enums.DimensionUnit

export type ShippingTrackingStatus = $Enums.ShippingTrackingStatus

export const ShippingTrackingStatus: typeof $Enums.ShippingTrackingStatus

export type DiagnosisStandard = $Enums.DiagnosisStandard

export const DiagnosisStandard: typeof $Enums.DiagnosisStandard

export type FormSchemaType = $Enums.FormSchemaType

export const FormSchemaType: typeof $Enums.FormSchemaType

export type ProductAttributeType = $Enums.ProductAttributeType

export const ProductAttributeType: typeof $Enums.ProductAttributeType

export type CompanyRole = $Enums.CompanyRole

export const CompanyRole: typeof $Enums.CompanyRole

export type CompanyDepartment = $Enums.CompanyDepartment

export const CompanyDepartment: typeof $Enums.CompanyDepartment

export type StripeProductType = $Enums.StripeProductType

export const StripeProductType: typeof $Enums.StripeProductType

export type StripeBillingFrequency = $Enums.StripeBillingFrequency

export const StripeBillingFrequency: typeof $Enums.StripeBillingFrequency

export type StripeInvoiceType = $Enums.StripeInvoiceType

export const StripeInvoiceType: typeof $Enums.StripeInvoiceType

export type StripeInvoiceStatus = $Enums.StripeInvoiceStatus

export const StripeInvoiceStatus: typeof $Enums.StripeInvoiceStatus

export type StripeEntityType = $Enums.StripeEntityType

export const StripeEntityType: typeof $Enums.StripeEntityType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationResponseType = $Enums.NotificationResponseType

export const NotificationResponseType: typeof $Enums.NotificationResponseType

export type CommunicationChannel = $Enums.CommunicationChannel

export const CommunicationChannel: typeof $Enums.CommunicationChannel

export type AgreementStatus = $Enums.AgreementStatus

export const AgreementStatus: typeof $Enums.AgreementStatus

export type AgreementType = $Enums.AgreementType

export const AgreementType: typeof $Enums.AgreementType

export type AccountRecoveryType = $Enums.AccountRecoveryType

export const AccountRecoveryType: typeof $Enums.AccountRecoveryType

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.clinician`: Exposes CRUD operations for the **Clinician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinicians
    * const clinicians = await prisma.clinician.findMany()
    * ```
    */
  get clinician(): Prisma.ClinicianDelegate<ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs>;

  /**
   * `prisma.foot`: Exposes CRUD operations for the **Foot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feet
    * const feet = await prisma.foot.findMany()
    * ```
    */
  get foot(): Prisma.FootDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.assetAugment`: Exposes CRUD operations for the **AssetAugment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetAugments
    * const assetAugments = await prisma.assetAugment.findMany()
    * ```
    */
  get assetAugment(): Prisma.AssetAugmentDelegate<ExtArgs>;

  /**
   * `prisma.assetAugmentMedia`: Exposes CRUD operations for the **AssetAugmentMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetAugmentMedias
    * const assetAugmentMedias = await prisma.assetAugmentMedia.findMany()
    * ```
    */
  get assetAugmentMedia(): Prisma.AssetAugmentMediaDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.workbench`: Exposes CRUD operations for the **Workbench** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workbenches
    * const workbenches = await prisma.workbench.findMany()
    * ```
    */
  get workbench(): Prisma.WorkbenchDelegate<ExtArgs>;

  /**
   * `prisma.workbenchNotes`: Exposes CRUD operations for the **WorkbenchNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkbenchNotes
    * const workbenchNotes = await prisma.workbenchNotes.findMany()
    * ```
    */
  get workbenchNotes(): Prisma.WorkbenchNotesDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.shippingPackage`: Exposes CRUD operations for the **ShippingPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingPackages
    * const shippingPackages = await prisma.shippingPackage.findMany()
    * ```
    */
  get shippingPackage(): Prisma.ShippingPackageDelegate<ExtArgs>;

  /**
   * `prisma.shippingLabel`: Exposes CRUD operations for the **ShippingLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingLabels
    * const shippingLabels = await prisma.shippingLabel.findMany()
    * ```
    */
  get shippingLabel(): Prisma.ShippingLabelDelegate<ExtArgs>;

  /**
   * `prisma.physician`: Exposes CRUD operations for the **Physician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physicians
    * const physicians = await prisma.physician.findMany()
    * ```
    */
  get physician(): Prisma.PhysicianDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.billingCode`: Exposes CRUD operations for the **BillingCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingCodes
    * const billingCodes = await prisma.billingCode.findMany()
    * ```
    */
  get billingCode(): Prisma.BillingCodeDelegate<ExtArgs>;

  /**
   * `prisma.deviceType`: Exposes CRUD operations for the **DeviceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTypes
    * const deviceTypes = await prisma.deviceType.findMany()
    * ```
    */
  get deviceType(): Prisma.DeviceTypeDelegate<ExtArgs>;

  /**
   * `prisma.visitType`: Exposes CRUD operations for the **VisitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitTypes
    * const visitTypes = await prisma.visitType.findMany()
    * ```
    */
  get visitType(): Prisma.VisitTypeDelegate<ExtArgs>;

  /**
   * `prisma.formSchema`: Exposes CRUD operations for the **FormSchema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSchemas
    * const formSchemas = await prisma.formSchema.findMany()
    * ```
    */
  get formSchema(): Prisma.FormSchemaDelegate<ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.formTemplate`: Exposes CRUD operations for the **FormTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTemplates
    * const formTemplates = await prisma.formTemplate.findMany()
    * ```
    */
  get formTemplate(): Prisma.FormTemplateDelegate<ExtArgs>;

  /**
   * `prisma.catalogProduct`: Exposes CRUD operations for the **CatalogProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProducts
    * const catalogProducts = await prisma.catalogProduct.findMany()
    * ```
    */
  get catalogProduct(): Prisma.CatalogProductDelegate<ExtArgs>;

  /**
   * `prisma.catalogProductAttribute`: Exposes CRUD operations for the **CatalogProductAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProductAttributes
    * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany()
    * ```
    */
  get catalogProductAttribute(): Prisma.CatalogProductAttributeDelegate<ExtArgs>;

  /**
   * `prisma.catalogProductVariant`: Exposes CRUD operations for the **CatalogProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProductVariants
    * const catalogProductVariants = await prisma.catalogProductVariant.findMany()
    * ```
    */
  get catalogProductVariant(): Prisma.CatalogProductVariantDelegate<ExtArgs>;

  /**
   * `prisma.catalogCategory`: Exposes CRUD operations for the **CatalogCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogCategories
    * const catalogCategories = await prisma.catalogCategory.findMany()
    * ```
    */
  get catalogCategory(): Prisma.CatalogCategoryDelegate<ExtArgs>;

  /**
   * `prisma.catalogVendor`: Exposes CRUD operations for the **CatalogVendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogVendors
    * const catalogVendors = await prisma.catalogVendor.findMany()
    * ```
    */
  get catalogVendor(): Prisma.CatalogVendorDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.printer`: Exposes CRUD operations for the **Printer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Printers
    * const printers = await prisma.printer.findMany()
    * ```
    */
  get printer(): Prisma.PrinterDelegate<ExtArgs>;

  /**
   * `prisma.companyUser`: Exposes CRUD operations for the **CompanyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUsers
    * const companyUsers = await prisma.companyUser.findMany()
    * ```
    */
  get companyUser(): Prisma.CompanyUserDelegate<ExtArgs>;

  /**
   * `prisma.departmentUser`: Exposes CRUD operations for the **DepartmentUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentUsers
    * const departmentUsers = await prisma.departmentUser.findMany()
    * ```
    */
  get departmentUser(): Prisma.DepartmentUserDelegate<ExtArgs>;

  /**
   * `prisma.companyPatient`: Exposes CRUD operations for the **CompanyPatient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyPatients
    * const companyPatients = await prisma.companyPatient.findMany()
    * ```
    */
  get companyPatient(): Prisma.CompanyPatientDelegate<ExtArgs>;

  /**
   * `prisma.facilityPatient`: Exposes CRUD operations for the **FacilityPatient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityPatients
    * const facilityPatients = await prisma.facilityPatient.findMany()
    * ```
    */
  get facilityPatient(): Prisma.FacilityPatientDelegate<ExtArgs>;

  /**
   * `prisma.stripeProduct`: Exposes CRUD operations for the **StripeProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeProducts
    * const stripeProducts = await prisma.stripeProduct.findMany()
    * ```
    */
  get stripeProduct(): Prisma.StripeProductDelegate<ExtArgs>;

  /**
   * `prisma.stripeInvoice`: Exposes CRUD operations for the **StripeInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeInvoices
    * const stripeInvoices = await prisma.stripeInvoice.findMany()
    * ```
    */
  get stripeInvoice(): Prisma.StripeInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.stripeEntity`: Exposes CRUD operations for the **StripeEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeEntities
    * const stripeEntities = await prisma.stripeEntity.findMany()
    * ```
    */
  get stripeEntity(): Prisma.StripeEntityDelegate<ExtArgs>;

  /**
   * `prisma.stripeSubscription`: Exposes CRUD operations for the **StripeSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeSubscriptions
    * const stripeSubscriptions = await prisma.stripeSubscription.findMany()
    * ```
    */
  get stripeSubscription(): Prisma.StripeSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationMessage`: Exposes CRUD operations for the **NotificationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationMessages
    * const notificationMessages = await prisma.notificationMessage.findMany()
    * ```
    */
  get notificationMessage(): Prisma.NotificationMessageDelegate<ExtArgs>;

  /**
   * `prisma.notificationHistory`: Exposes CRUD operations for the **NotificationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationHistories
    * const notificationHistories = await prisma.notificationHistory.findMany()
    * ```
    */
  get notificationHistory(): Prisma.NotificationHistoryDelegate<ExtArgs>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userAgreement`: Exposes CRUD operations for the **UserAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAgreements
    * const userAgreements = await prisma.userAgreement.findMany()
    * ```
    */
  get userAgreement(): Prisma.UserAgreementDelegate<ExtArgs>;

  /**
   * `prisma.agreement`: Exposes CRUD operations for the **Agreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agreements
    * const agreements = await prisma.agreement.findMany()
    * ```
    */
  get agreement(): Prisma.AgreementDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.accountVerification`: Exposes CRUD operations for the **AccountVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountVerifications
    * const accountVerifications = await prisma.accountVerification.findMany()
    * ```
    */
  get accountVerification(): Prisma.AccountVerificationDelegate<ExtArgs>;

  /**
   * `prisma.companyInvitation`: Exposes CRUD operations for the **CompanyInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyInvitations
    * const companyInvitations = await prisma.companyInvitation.findMany()
    * ```
    */
  get companyInvitation(): Prisma.CompanyInvitationDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.viewFlattenedWorkbench`: Exposes CRUD operations for the **ViewFlattenedWorkbench** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewFlattenedWorkbenches
    * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany()
    * ```
    */
  get viewFlattenedWorkbench(): Prisma.ViewFlattenedWorkbenchDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.14.0
   * Query Engine version: e9771e62de70f79a5e1c604a2d7c8e2a0a874b48
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Facility: 'Facility',
    Patient: 'Patient',
    Clinician: 'Clinician',
    Evaluation: 'Evaluation',
    Foot: 'Foot',
    Asset: 'Asset',
    AssetAugment: 'AssetAugment',
    AssetAugmentMedia: 'AssetAugmentMedia',
    Product: 'Product',
    Workbench: 'Workbench',
    WorkbenchNotes: 'WorkbenchNotes',
    Order: 'Order',
    Contact: 'Contact',
    ShippingPackage: 'ShippingPackage',
    ShippingLabel: 'ShippingLabel',
    Physician: 'Physician',
    Diagnosis: 'Diagnosis',
    BillingCode: 'BillingCode',
    DeviceType: 'DeviceType',
    VisitType: 'VisitType',
    FormSchema: 'FormSchema',
    FormSubmission: 'FormSubmission',
    FormTemplate: 'FormTemplate',
    CatalogProduct: 'CatalogProduct',
    CatalogProductAttribute: 'CatalogProductAttribute',
    CatalogProductVariant: 'CatalogProductVariant',
    CatalogCategory: 'CatalogCategory',
    CatalogVendor: 'CatalogVendor',
    AuditLog: 'AuditLog',
    Printer: 'Printer',
    CompanyUser: 'CompanyUser',
    DepartmentUser: 'DepartmentUser',
    CompanyPatient: 'CompanyPatient',
    FacilityPatient: 'FacilityPatient',
    StripeProduct: 'StripeProduct',
    StripeInvoice: 'StripeInvoice',
    StripeEntity: 'StripeEntity',
    StripeSubscription: 'StripeSubscription',
    Notification: 'Notification',
    NotificationMessage: 'NotificationMessage',
    NotificationHistory: 'NotificationHistory',
    EmailTemplate: 'EmailTemplate',
    User: 'User',
    UserAgreement: 'UserAgreement',
    Agreement: 'Agreement',
    Account: 'Account',
    AccountVerification: 'AccountVerification',
    CompanyInvitation: 'CompanyInvitation',
    ApiKey: 'ApiKey',
    ViewFlattenedWorkbench: 'ViewFlattenedWorkbench'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'company' | 'facility' | 'patient' | 'clinician' | 'evaluation' | 'foot' | 'asset' | 'assetAugment' | 'assetAugmentMedia' | 'product' | 'workbench' | 'workbenchNotes' | 'order' | 'contact' | 'shippingPackage' | 'shippingLabel' | 'physician' | 'diagnosis' | 'billingCode' | 'deviceType' | 'visitType' | 'formSchema' | 'formSubmission' | 'formTemplate' | 'catalogProduct' | 'catalogProductAttribute' | 'catalogProductVariant' | 'catalogCategory' | 'catalogVendor' | 'auditLog' | 'printer' | 'companyUser' | 'departmentUser' | 'companyPatient' | 'facilityPatient' | 'stripeProduct' | 'stripeInvoice' | 'stripeEntity' | 'stripeSubscription' | 'notification' | 'notificationMessage' | 'notificationHistory' | 'emailTemplate' | 'user' | 'userAgreement' | 'agreement' | 'account' | 'accountVerification' | 'companyInvitation' | 'apiKey' | 'viewFlattenedWorkbench'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>,
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Clinician: {
        payload: Prisma.$ClinicianPayload<ExtArgs>
        fields: Prisma.ClinicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          findFirst: {
            args: Prisma.ClinicianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          findMany: {
            args: Prisma.ClinicianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>[]
          }
          create: {
            args: Prisma.ClinicianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          createMany: {
            args: Prisma.ClinicianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicianCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>[]
          }
          delete: {
            args: Prisma.ClinicianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          update: {
            args: Prisma.ClinicianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          deleteMany: {
            args: Prisma.ClinicianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClinicianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          aggregate: {
            args: Prisma.ClinicianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClinician>
          }
          groupBy: {
            args: Prisma.ClinicianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClinicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicianCountArgs<ExtArgs>,
            result: $Utils.Optional<ClinicianCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Foot: {
        payload: Prisma.$FootPayload<ExtArgs>
        fields: Prisma.FootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FootFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FootFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          findFirst: {
            args: Prisma.FootFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FootFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          findMany: {
            args: Prisma.FootFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>[]
          }
          create: {
            args: Prisma.FootCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          createMany: {
            args: Prisma.FootCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FootCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>[]
          }
          delete: {
            args: Prisma.FootDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          update: {
            args: Prisma.FootUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          deleteMany: {
            args: Prisma.FootDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FootUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FootUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          aggregate: {
            args: Prisma.FootAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFoot>
          }
          groupBy: {
            args: Prisma.FootGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FootGroupByOutputType>[]
          }
          count: {
            args: Prisma.FootCountArgs<ExtArgs>,
            result: $Utils.Optional<FootCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>,
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      AssetAugment: {
        payload: Prisma.$AssetAugmentPayload<ExtArgs>
        fields: Prisma.AssetAugmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetAugmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetAugmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          findFirst: {
            args: Prisma.AssetAugmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetAugmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          findMany: {
            args: Prisma.AssetAugmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>[]
          }
          create: {
            args: Prisma.AssetAugmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          createMany: {
            args: Prisma.AssetAugmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetAugmentCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>[]
          }
          delete: {
            args: Prisma.AssetAugmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          update: {
            args: Prisma.AssetAugmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          deleteMany: {
            args: Prisma.AssetAugmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssetAugmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssetAugmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentPayload>
          }
          aggregate: {
            args: Prisma.AssetAugmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssetAugment>
          }
          groupBy: {
            args: Prisma.AssetAugmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssetAugmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetAugmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AssetAugmentCountAggregateOutputType> | number
          }
        }
      }
      AssetAugmentMedia: {
        payload: Prisma.$AssetAugmentMediaPayload<ExtArgs>
        fields: Prisma.AssetAugmentMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetAugmentMediaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetAugmentMediaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          findFirst: {
            args: Prisma.AssetAugmentMediaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetAugmentMediaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          findMany: {
            args: Prisma.AssetAugmentMediaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>[]
          }
          create: {
            args: Prisma.AssetAugmentMediaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          createMany: {
            args: Prisma.AssetAugmentMediaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetAugmentMediaCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>[]
          }
          delete: {
            args: Prisma.AssetAugmentMediaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          update: {
            args: Prisma.AssetAugmentMediaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          deleteMany: {
            args: Prisma.AssetAugmentMediaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssetAugmentMediaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssetAugmentMediaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetAugmentMediaPayload>
          }
          aggregate: {
            args: Prisma.AssetAugmentMediaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssetAugmentMedia>
          }
          groupBy: {
            args: Prisma.AssetAugmentMediaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssetAugmentMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetAugmentMediaCountArgs<ExtArgs>,
            result: $Utils.Optional<AssetAugmentMediaCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Workbench: {
        payload: Prisma.$WorkbenchPayload<ExtArgs>
        fields: Prisma.WorkbenchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkbenchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkbenchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          findFirst: {
            args: Prisma.WorkbenchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkbenchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          findMany: {
            args: Prisma.WorkbenchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>[]
          }
          create: {
            args: Prisma.WorkbenchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          createMany: {
            args: Prisma.WorkbenchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkbenchCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>[]
          }
          delete: {
            args: Prisma.WorkbenchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          update: {
            args: Prisma.WorkbenchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          deleteMany: {
            args: Prisma.WorkbenchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkbenchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkbenchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          aggregate: {
            args: Prisma.WorkbenchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkbench>
          }
          groupBy: {
            args: Prisma.WorkbenchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkbenchCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchCountAggregateOutputType> | number
          }
        }
      }
      WorkbenchNotes: {
        payload: Prisma.$WorkbenchNotesPayload<ExtArgs>
        fields: Prisma.WorkbenchNotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkbenchNotesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          findFirst: {
            args: Prisma.WorkbenchNotesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          findMany: {
            args: Prisma.WorkbenchNotesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>[]
          }
          create: {
            args: Prisma.WorkbenchNotesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          createMany: {
            args: Prisma.WorkbenchNotesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>[]
          }
          delete: {
            args: Prisma.WorkbenchNotesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          update: {
            args: Prisma.WorkbenchNotesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          deleteMany: {
            args: Prisma.WorkbenchNotesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkbenchNotesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkbenchNotesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          aggregate: {
            args: Prisma.WorkbenchNotesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkbenchNotes>
          }
          groupBy: {
            args: Prisma.WorkbenchNotesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchNotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkbenchNotesCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchNotesCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ShippingPackage: {
        payload: Prisma.$ShippingPackagePayload<ExtArgs>
        fields: Prisma.ShippingPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingPackageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingPackageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          findFirst: {
            args: Prisma.ShippingPackageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingPackageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          findMany: {
            args: Prisma.ShippingPackageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>[]
          }
          create: {
            args: Prisma.ShippingPackageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          createMany: {
            args: Prisma.ShippingPackageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingPackageCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>[]
          }
          delete: {
            args: Prisma.ShippingPackageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          update: {
            args: Prisma.ShippingPackageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          deleteMany: {
            args: Prisma.ShippingPackageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingPackageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShippingPackageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          aggregate: {
            args: Prisma.ShippingPackageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShippingPackage>
          }
          groupBy: {
            args: Prisma.ShippingPackageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShippingPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingPackageCountArgs<ExtArgs>,
            result: $Utils.Optional<ShippingPackageCountAggregateOutputType> | number
          }
        }
      }
      ShippingLabel: {
        payload: Prisma.$ShippingLabelPayload<ExtArgs>
        fields: Prisma.ShippingLabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingLabelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingLabelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          findFirst: {
            args: Prisma.ShippingLabelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingLabelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          findMany: {
            args: Prisma.ShippingLabelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>[]
          }
          create: {
            args: Prisma.ShippingLabelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          createMany: {
            args: Prisma.ShippingLabelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingLabelCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>[]
          }
          delete: {
            args: Prisma.ShippingLabelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          update: {
            args: Prisma.ShippingLabelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          deleteMany: {
            args: Prisma.ShippingLabelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingLabelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShippingLabelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingLabelPayload>
          }
          aggregate: {
            args: Prisma.ShippingLabelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShippingLabel>
          }
          groupBy: {
            args: Prisma.ShippingLabelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShippingLabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingLabelCountArgs<ExtArgs>,
            result: $Utils.Optional<ShippingLabelCountAggregateOutputType> | number
          }
        }
      }
      Physician: {
        payload: Prisma.$PhysicianPayload<ExtArgs>
        fields: Prisma.PhysicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhysicianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhysicianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findFirst: {
            args: Prisma.PhysicianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhysicianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findMany: {
            args: Prisma.PhysicianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          create: {
            args: Prisma.PhysicianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          createMany: {
            args: Prisma.PhysicianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhysicianCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          delete: {
            args: Prisma.PhysicianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          update: {
            args: Prisma.PhysicianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          deleteMany: {
            args: Prisma.PhysicianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PhysicianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PhysicianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          aggregate: {
            args: Prisma.PhysicianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhysician>
          }
          groupBy: {
            args: Prisma.PhysicianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhysicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhysicianCountArgs<ExtArgs>,
            result: $Utils.Optional<PhysicianCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      BillingCode: {
        payload: Prisma.$BillingCodePayload<ExtArgs>
        fields: Prisma.BillingCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingCodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingCodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          findFirst: {
            args: Prisma.BillingCodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingCodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          findMany: {
            args: Prisma.BillingCodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>[]
          }
          create: {
            args: Prisma.BillingCodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          createMany: {
            args: Prisma.BillingCodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingCodeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>[]
          }
          delete: {
            args: Prisma.BillingCodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          update: {
            args: Prisma.BillingCodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          deleteMany: {
            args: Prisma.BillingCodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillingCodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillingCodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          aggregate: {
            args: Prisma.BillingCodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillingCode>
          }
          groupBy: {
            args: Prisma.BillingCodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillingCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingCodeCountArgs<ExtArgs>,
            result: $Utils.Optional<BillingCodeCountAggregateOutputType> | number
          }
        }
      }
      DeviceType: {
        payload: Prisma.$DeviceTypePayload<ExtArgs>
        fields: Prisma.DeviceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          findFirst: {
            args: Prisma.DeviceTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          findMany: {
            args: Prisma.DeviceTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>[]
          }
          create: {
            args: Prisma.DeviceTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          createMany: {
            args: Prisma.DeviceTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTypeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>[]
          }
          delete: {
            args: Prisma.DeviceTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          update: {
            args: Prisma.DeviceTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          deleteMany: {
            args: Prisma.DeviceTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeviceTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          aggregate: {
            args: Prisma.DeviceTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeviceType>
          }
          groupBy: {
            args: Prisma.DeviceTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeviceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<DeviceTypeCountAggregateOutputType> | number
          }
        }
      }
      VisitType: {
        payload: Prisma.$VisitTypePayload<ExtArgs>
        fields: Prisma.VisitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findFirst: {
            args: Prisma.VisitTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findMany: {
            args: Prisma.VisitTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          create: {
            args: Prisma.VisitTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          createMany: {
            args: Prisma.VisitTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitTypeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          delete: {
            args: Prisma.VisitTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          update: {
            args: Prisma.VisitTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          deleteMany: {
            args: Prisma.VisitTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VisitTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VisitTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          aggregate: {
            args: Prisma.VisitTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVisitType>
          }
          groupBy: {
            args: Prisma.VisitTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VisitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<VisitTypeCountAggregateOutputType> | number
          }
        }
      }
      FormSchema: {
        payload: Prisma.$FormSchemaPayload<ExtArgs>
        fields: Prisma.FormSchemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSchemaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSchemaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          findFirst: {
            args: Prisma.FormSchemaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSchemaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          findMany: {
            args: Prisma.FormSchemaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>[]
          }
          create: {
            args: Prisma.FormSchemaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          createMany: {
            args: Prisma.FormSchemaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSchemaCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>[]
          }
          delete: {
            args: Prisma.FormSchemaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          update: {
            args: Prisma.FormSchemaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          deleteMany: {
            args: Prisma.FormSchemaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSchemaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSchemaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          aggregate: {
            args: Prisma.FormSchemaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSchema>
          }
          groupBy: {
            args: Prisma.FormSchemaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSchemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSchemaCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSchemaCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      FormTemplate: {
        payload: Prisma.$FormTemplatePayload<ExtArgs>
        fields: Prisma.FormTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findFirst: {
            args: Prisma.FormTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findMany: {
            args: Prisma.FormTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          create: {
            args: Prisma.FormTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          createMany: {
            args: Prisma.FormTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormTemplateCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          delete: {
            args: Prisma.FormTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          update: {
            args: Prisma.FormTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FormTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          aggregate: {
            args: Prisma.FormTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormTemplate>
          }
          groupBy: {
            args: Prisma.FormTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<FormTemplateCountAggregateOutputType> | number
          }
        }
      }
      CatalogProduct: {
        payload: Prisma.$CatalogProductPayload<ExtArgs>
        fields: Prisma.CatalogProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          findFirst: {
            args: Prisma.CatalogProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          findMany: {
            args: Prisma.CatalogProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>[]
          }
          create: {
            args: Prisma.CatalogProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          createMany: {
            args: Prisma.CatalogProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>[]
          }
          delete: {
            args: Prisma.CatalogProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          update: {
            args: Prisma.CatalogProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          aggregate: {
            args: Prisma.CatalogProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProduct>
          }
          groupBy: {
            args: Prisma.CatalogProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductCountAggregateOutputType> | number
          }
        }
      }
      CatalogProductAttribute: {
        payload: Prisma.$CatalogProductAttributePayload<ExtArgs>
        fields: Prisma.CatalogProductAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductAttributeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          findFirst: {
            args: Prisma.CatalogProductAttributeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          findMany: {
            args: Prisma.CatalogProductAttributeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>[]
          }
          create: {
            args: Prisma.CatalogProductAttributeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          createMany: {
            args: Prisma.CatalogProductAttributeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>[]
          }
          delete: {
            args: Prisma.CatalogProductAttributeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          update: {
            args: Prisma.CatalogProductAttributeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductAttributeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductAttributeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductAttributeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          aggregate: {
            args: Prisma.CatalogProductAttributeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProductAttribute>
          }
          groupBy: {
            args: Prisma.CatalogProductAttributeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductAttributeCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductAttributeCountAggregateOutputType> | number
          }
        }
      }
      CatalogProductVariant: {
        payload: Prisma.$CatalogProductVariantPayload<ExtArgs>
        fields: Prisma.CatalogProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductVariantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          findFirst: {
            args: Prisma.CatalogProductVariantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          findMany: {
            args: Prisma.CatalogProductVariantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>[]
          }
          create: {
            args: Prisma.CatalogProductVariantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          createMany: {
            args: Prisma.CatalogProductVariantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>[]
          }
          delete: {
            args: Prisma.CatalogProductVariantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          update: {
            args: Prisma.CatalogProductVariantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductVariantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductVariantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductVariantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          aggregate: {
            args: Prisma.CatalogProductVariantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProductVariant>
          }
          groupBy: {
            args: Prisma.CatalogProductVariantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductVariantCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductVariantCountAggregateOutputType> | number
          }
        }
      }
      CatalogCategory: {
        payload: Prisma.$CatalogCategoryPayload<ExtArgs>
        fields: Prisma.CatalogCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          findFirst: {
            args: Prisma.CatalogCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          findMany: {
            args: Prisma.CatalogCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>[]
          }
          create: {
            args: Prisma.CatalogCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          createMany: {
            args: Prisma.CatalogCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogCategoryCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>[]
          }
          delete: {
            args: Prisma.CatalogCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          update: {
            args: Prisma.CatalogCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CatalogCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          aggregate: {
            args: Prisma.CatalogCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogCategory>
          }
          groupBy: {
            args: Prisma.CatalogCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogCategoryCountAggregateOutputType> | number
          }
        }
      }
      CatalogVendor: {
        payload: Prisma.$CatalogVendorPayload<ExtArgs>
        fields: Prisma.CatalogVendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogVendorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogVendorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          findFirst: {
            args: Prisma.CatalogVendorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogVendorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          findMany: {
            args: Prisma.CatalogVendorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>[]
          }
          create: {
            args: Prisma.CatalogVendorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          createMany: {
            args: Prisma.CatalogVendorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogVendorCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>[]
          }
          delete: {
            args: Prisma.CatalogVendorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          update: {
            args: Prisma.CatalogVendorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          deleteMany: {
            args: Prisma.CatalogVendorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogVendorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogVendorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          aggregate: {
            args: Prisma.CatalogVendorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogVendor>
          }
          groupBy: {
            args: Prisma.CatalogVendorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogVendorCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVendorCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Printer: {
        payload: Prisma.$PrinterPayload<ExtArgs>
        fields: Prisma.PrinterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrinterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrinterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          findFirst: {
            args: Prisma.PrinterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrinterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          findMany: {
            args: Prisma.PrinterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>[]
          }
          create: {
            args: Prisma.PrinterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          createMany: {
            args: Prisma.PrinterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrinterCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>[]
          }
          delete: {
            args: Prisma.PrinterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          update: {
            args: Prisma.PrinterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          deleteMany: {
            args: Prisma.PrinterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PrinterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PrinterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          aggregate: {
            args: Prisma.PrinterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrinter>
          }
          groupBy: {
            args: Prisma.PrinterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrinterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrinterCountArgs<ExtArgs>,
            result: $Utils.Optional<PrinterCountAggregateOutputType> | number
          }
        }
      }
      CompanyUser: {
        payload: Prisma.$CompanyUserPayload<ExtArgs>
        fields: Prisma.CompanyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findMany: {
            args: Prisma.CompanyUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          create: {
            args: Prisma.CompanyUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          createMany: {
            args: Prisma.CompanyUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          update: {
            args: Prisma.CompanyUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyUser>
          }
          groupBy: {
            args: Prisma.CompanyUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserCountAggregateOutputType> | number
          }
        }
      }
      DepartmentUser: {
        payload: Prisma.$DepartmentUserPayload<ExtArgs>
        fields: Prisma.DepartmentUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          findFirst: {
            args: Prisma.DepartmentUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          findMany: {
            args: Prisma.DepartmentUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>[]
          }
          create: {
            args: Prisma.DepartmentUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          createMany: {
            args: Prisma.DepartmentUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentUserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>[]
          }
          delete: {
            args: Prisma.DepartmentUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          update: {
            args: Prisma.DepartmentUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DepartmentUserPayload>
          }
          aggregate: {
            args: Prisma.DepartmentUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDepartmentUser>
          }
          groupBy: {
            args: Prisma.DepartmentUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentUserCountArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentUserCountAggregateOutputType> | number
          }
        }
      }
      CompanyPatient: {
        payload: Prisma.$CompanyPatientPayload<ExtArgs>
        fields: Prisma.CompanyPatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyPatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyPatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          findFirst: {
            args: Prisma.CompanyPatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyPatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          findMany: {
            args: Prisma.CompanyPatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>[]
          }
          create: {
            args: Prisma.CompanyPatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          createMany: {
            args: Prisma.CompanyPatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyPatientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>[]
          }
          delete: {
            args: Prisma.CompanyPatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          update: {
            args: Prisma.CompanyPatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          deleteMany: {
            args: Prisma.CompanyPatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyPatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyPatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          aggregate: {
            args: Prisma.CompanyPatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyPatient>
          }
          groupBy: {
            args: Prisma.CompanyPatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyPatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyPatientCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyPatientCountAggregateOutputType> | number
          }
        }
      }
      FacilityPatient: {
        payload: Prisma.$FacilityPatientPayload<ExtArgs>
        fields: Prisma.FacilityPatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityPatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityPatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          findFirst: {
            args: Prisma.FacilityPatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityPatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          findMany: {
            args: Prisma.FacilityPatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>[]
          }
          create: {
            args: Prisma.FacilityPatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          createMany: {
            args: Prisma.FacilityPatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityPatientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>[]
          }
          delete: {
            args: Prisma.FacilityPatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          update: {
            args: Prisma.FacilityPatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          deleteMany: {
            args: Prisma.FacilityPatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityPatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacilityPatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPatientPayload>
          }
          aggregate: {
            args: Prisma.FacilityPatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacilityPatient>
          }
          groupBy: {
            args: Prisma.FacilityPatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacilityPatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityPatientCountArgs<ExtArgs>,
            result: $Utils.Optional<FacilityPatientCountAggregateOutputType> | number
          }
        }
      }
      StripeProduct: {
        payload: Prisma.$StripeProductPayload<ExtArgs>
        fields: Prisma.StripeProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          findFirst: {
            args: Prisma.StripeProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          findMany: {
            args: Prisma.StripeProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>[]
          }
          create: {
            args: Prisma.StripeProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          createMany: {
            args: Prisma.StripeProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeProductCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>[]
          }
          delete: {
            args: Prisma.StripeProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          update: {
            args: Prisma.StripeProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          deleteMany: {
            args: Prisma.StripeProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StripeProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StripeProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeProductPayload>
          }
          aggregate: {
            args: Prisma.StripeProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStripeProduct>
          }
          groupBy: {
            args: Prisma.StripeProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StripeProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeProductCountArgs<ExtArgs>,
            result: $Utils.Optional<StripeProductCountAggregateOutputType> | number
          }
        }
      }
      StripeInvoice: {
        payload: Prisma.$StripeInvoicePayload<ExtArgs>
        fields: Prisma.StripeInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeInvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeInvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          findFirst: {
            args: Prisma.StripeInvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeInvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          findMany: {
            args: Prisma.StripeInvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>[]
          }
          create: {
            args: Prisma.StripeInvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          createMany: {
            args: Prisma.StripeInvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeInvoiceCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>[]
          }
          delete: {
            args: Prisma.StripeInvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          update: {
            args: Prisma.StripeInvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          deleteMany: {
            args: Prisma.StripeInvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StripeInvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StripeInvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeInvoicePayload>
          }
          aggregate: {
            args: Prisma.StripeInvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStripeInvoice>
          }
          groupBy: {
            args: Prisma.StripeInvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StripeInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeInvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<StripeInvoiceCountAggregateOutputType> | number
          }
        }
      }
      StripeEntity: {
        payload: Prisma.$StripeEntityPayload<ExtArgs>
        fields: Prisma.StripeEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeEntityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeEntityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          findFirst: {
            args: Prisma.StripeEntityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeEntityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          findMany: {
            args: Prisma.StripeEntityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>[]
          }
          create: {
            args: Prisma.StripeEntityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          createMany: {
            args: Prisma.StripeEntityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeEntityCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>[]
          }
          delete: {
            args: Prisma.StripeEntityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          update: {
            args: Prisma.StripeEntityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          deleteMany: {
            args: Prisma.StripeEntityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StripeEntityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StripeEntityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeEntityPayload>
          }
          aggregate: {
            args: Prisma.StripeEntityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStripeEntity>
          }
          groupBy: {
            args: Prisma.StripeEntityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StripeEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeEntityCountArgs<ExtArgs>,
            result: $Utils.Optional<StripeEntityCountAggregateOutputType> | number
          }
        }
      }
      StripeSubscription: {
        payload: Prisma.$StripeSubscriptionPayload<ExtArgs>
        fields: Prisma.StripeSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeSubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.StripeSubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeSubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          findMany: {
            args: Prisma.StripeSubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>[]
          }
          create: {
            args: Prisma.StripeSubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          createMany: {
            args: Prisma.StripeSubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeSubscriptionCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.StripeSubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          update: {
            args: Prisma.StripeSubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.StripeSubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StripeSubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StripeSubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.StripeSubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStripeSubscription>
          }
          groupBy: {
            args: Prisma.StripeSubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StripeSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeSubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<StripeSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationMessage: {
        payload: Prisma.$NotificationMessagePayload<ExtArgs>
        fields: Prisma.NotificationMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          findFirst: {
            args: Prisma.NotificationMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          findMany: {
            args: Prisma.NotificationMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>[]
          }
          create: {
            args: Prisma.NotificationMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          createMany: {
            args: Prisma.NotificationMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationMessageCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>[]
          }
          delete: {
            args: Prisma.NotificationMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          update: {
            args: Prisma.NotificationMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          deleteMany: {
            args: Prisma.NotificationMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationMessagePayload>
          }
          aggregate: {
            args: Prisma.NotificationMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificationMessage>
          }
          groupBy: {
            args: Prisma.NotificationMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationMessageCountAggregateOutputType> | number
          }
        }
      }
      NotificationHistory: {
        payload: Prisma.$NotificationHistoryPayload<ExtArgs>
        fields: Prisma.NotificationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          findFirst: {
            args: Prisma.NotificationHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          findMany: {
            args: Prisma.NotificationHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>[]
          }
          create: {
            args: Prisma.NotificationHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          createMany: {
            args: Prisma.NotificationHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationHistoryCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>[]
          }
          delete: {
            args: Prisma.NotificationHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          update: {
            args: Prisma.NotificationHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.NotificationHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationHistoryPayload>
          }
          aggregate: {
            args: Prisma.NotificationHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificationHistory>
          }
          groupBy: {
            args: Prisma.NotificationHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationHistoryCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserAgreement: {
        payload: Prisma.$UserAgreementPayload<ExtArgs>
        fields: Prisma.UserAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAgreementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAgreementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          findFirst: {
            args: Prisma.UserAgreementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAgreementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          findMany: {
            args: Prisma.UserAgreementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>[]
          }
          create: {
            args: Prisma.UserAgreementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          createMany: {
            args: Prisma.UserAgreementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAgreementCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>[]
          }
          delete: {
            args: Prisma.UserAgreementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          update: {
            args: Prisma.UserAgreementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          deleteMany: {
            args: Prisma.UserAgreementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAgreementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAgreementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          aggregate: {
            args: Prisma.UserAgreementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAgreement>
          }
          groupBy: {
            args: Prisma.UserAgreementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAgreementCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAgreementCountAggregateOutputType> | number
          }
        }
      }
      Agreement: {
        payload: Prisma.$AgreementPayload<ExtArgs>
        fields: Prisma.AgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findFirst: {
            args: Prisma.AgreementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findMany: {
            args: Prisma.AgreementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          create: {
            args: Prisma.AgreementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          createMany: {
            args: Prisma.AgreementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgreementCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          delete: {
            args: Prisma.AgreementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          update: {
            args: Prisma.AgreementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          deleteMany: {
            args: Prisma.AgreementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgreementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          aggregate: {
            args: Prisma.AgreementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgreement>
          }
          groupBy: {
            args: Prisma.AgreementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementCountArgs<ExtArgs>,
            result: $Utils.Optional<AgreementCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountVerification: {
        payload: Prisma.$AccountVerificationPayload<ExtArgs>
        fields: Prisma.AccountVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountVerificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountVerificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          findFirst: {
            args: Prisma.AccountVerificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountVerificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          findMany: {
            args: Prisma.AccountVerificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>[]
          }
          create: {
            args: Prisma.AccountVerificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          createMany: {
            args: Prisma.AccountVerificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountVerificationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>[]
          }
          delete: {
            args: Prisma.AccountVerificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          update: {
            args: Prisma.AccountVerificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          deleteMany: {
            args: Prisma.AccountVerificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountVerificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountVerificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountVerificationPayload>
          }
          aggregate: {
            args: Prisma.AccountVerificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccountVerification>
          }
          groupBy: {
            args: Prisma.AccountVerificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountVerificationCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountVerificationCountAggregateOutputType> | number
          }
        }
      }
      CompanyInvitation: {
        payload: Prisma.$CompanyInvitationPayload<ExtArgs>
        fields: Prisma.CompanyInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyInvitationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyInvitationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          findFirst: {
            args: Prisma.CompanyInvitationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyInvitationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          findMany: {
            args: Prisma.CompanyInvitationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>[]
          }
          create: {
            args: Prisma.CompanyInvitationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          createMany: {
            args: Prisma.CompanyInvitationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyInvitationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>[]
          }
          delete: {
            args: Prisma.CompanyInvitationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          update: {
            args: Prisma.CompanyInvitationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          deleteMany: {
            args: Prisma.CompanyInvitationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyInvitationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyInvitationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          aggregate: {
            args: Prisma.CompanyInvitationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyInvitation>
          }
          groupBy: {
            args: Prisma.CompanyInvitationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyInvitationCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyInvitationCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      ViewFlattenedWorkbench: {
        payload: Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>
        fields: Prisma.ViewFlattenedWorkbenchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          findFirst: {
            args: Prisma.ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          findMany: {
            args: Prisma.ViewFlattenedWorkbenchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>[]
          }
          create: {
            args: Prisma.ViewFlattenedWorkbenchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          createMany: {
            args: Prisma.ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>[]
          }
          delete: {
            args: Prisma.ViewFlattenedWorkbenchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          update: {
            args: Prisma.ViewFlattenedWorkbenchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          deleteMany: {
            args: Prisma.ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ViewFlattenedWorkbenchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          aggregate: {
            args: Prisma.ViewFlattenedWorkbenchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateViewFlattenedWorkbench>
          }
          groupBy: {
            args: Prisma.ViewFlattenedWorkbenchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ViewFlattenedWorkbenchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewFlattenedWorkbenchCountArgs<ExtArgs>,
            result: $Utils.Optional<ViewFlattenedWorkbenchCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    facilities: number
    evaluations: number
    apiKeys: number
    packages: number
    users: number
    departments: number
    patients: number
    invitations: number
    auditLogs: number
    stripeEntities: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | CompanyCountOutputTypeCountFacilitiesArgs
    evaluations?: boolean | CompanyCountOutputTypeCountEvaluationsArgs
    apiKeys?: boolean | CompanyCountOutputTypeCountApiKeysArgs
    packages?: boolean | CompanyCountOutputTypeCountPackagesArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    departments?: boolean | CompanyCountOutputTypeCountDepartmentsArgs
    patients?: boolean | CompanyCountOutputTypeCountPatientsArgs
    invitations?: boolean | CompanyCountOutputTypeCountInvitationsArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    stripeEntities?: boolean | CompanyCountOutputTypeCountStripeEntitiesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingPackageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStripeEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeEntityWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    children: number
    patients: number
    evaluations: number
    shippingLabels: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FacilityCountOutputTypeCountChildrenArgs
    patients?: boolean | FacilityCountOutputTypeCountPatientsArgs
    evaluations?: boolean | FacilityCountOutputTypeCountEvaluationsArgs
    shippingLabels?: boolean | FacilityCountOutputTypeCountShippingLabelsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityPatientWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountShippingLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingLabelWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    feet: number
    evaluations: number
    workbenches: number
    companies: number
    notificationHistory: number
    facilities: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feet?: boolean | PatientCountOutputTypeCountFeetArgs
    evaluations?: boolean | PatientCountOutputTypeCountEvaluationsArgs
    workbenches?: boolean | PatientCountOutputTypeCountWorkbenchesArgs
    companies?: boolean | PatientCountOutputTypeCountCompaniesArgs
    notificationHistory?: boolean | PatientCountOutputTypeCountNotificationHistoryArgs
    facilities?: boolean | PatientCountOutputTypeCountFacilitiesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationHistoryWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityPatientWhereInput
  }


  /**
   * Count Type ClinicianCountOutputType
   */

  export type ClinicianCountOutputType = {
    evaluations: number
  }

  export type ClinicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | ClinicianCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * ClinicianCountOutputType without action
   */
  export type ClinicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicianCountOutputType
     */
    select?: ClinicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicianCountOutputType without action
   */
  export type ClinicianCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type EvaluationCountOutputType
   */

  export type EvaluationCountOutputType = {
    clinicians: number
    workbenches: number
  }

  export type EvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicians?: boolean | EvaluationCountOutputTypeCountCliniciansArgs
    workbenches?: boolean | EvaluationCountOutputTypeCountWorkbenchesArgs
  }

  // Custom InputTypes
  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationCountOutputType
     */
    select?: EvaluationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountCliniciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicianWhereInput
  }

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }


  /**
   * Count Type FootCountOutputType
   */

  export type FootCountOutputType = {
    assets: number
  }

  export type FootCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | FootCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * FootCountOutputType without action
   */
  export type FootCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FootCountOutputType
     */
    select?: FootCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FootCountOutputType without action
   */
  export type FootCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    workbenches: number
    augments: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbenches?: boolean | AssetCountOutputTypeCountWorkbenchesArgs
    augments?: boolean | AssetCountOutputTypeCountAugmentsArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAugmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAugmentWhereInput
  }


  /**
   * Count Type AssetAugmentCountOutputType
   */

  export type AssetAugmentCountOutputType = {
    media: number
  }

  export type AssetAugmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | AssetAugmentCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * AssetAugmentCountOutputType without action
   */
  export type AssetAugmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentCountOutputType
     */
    select?: AssetAugmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetAugmentCountOutputType without action
   */
  export type AssetAugmentCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAugmentMediaWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    buildingBlocks: number
    usedByProducts: number
    workbenches: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingBlocks?: boolean | ProductCountOutputTypeCountBuildingBlocksArgs
    usedByProducts?: boolean | ProductCountOutputTypeCountUsedByProductsArgs
    workbenches?: boolean | ProductCountOutputTypeCountWorkbenchesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBuildingBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountUsedByProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }


  /**
   * Count Type WorkbenchCountOutputType
   */

  export type WorkbenchCountOutputType = {
    assets: number
    orders: number
    feet: number
    formSubmissions: number
    notes: number
  }

  export type WorkbenchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | WorkbenchCountOutputTypeCountAssetsArgs
    orders?: boolean | WorkbenchCountOutputTypeCountOrdersArgs
    feet?: boolean | WorkbenchCountOutputTypeCountFeetArgs
    formSubmissions?: boolean | WorkbenchCountOutputTypeCountFormSubmissionsArgs
    notes?: boolean | WorkbenchCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchCountOutputType
     */
    select?: WorkbenchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountFormSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    facilities: number
    patients: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | ContactCountOutputTypeCountFacilitiesArgs
    patients?: boolean | ContactCountOutputTypeCountPatientsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
  }


  /**
   * Count Type ShippingLabelCountOutputType
   */

  export type ShippingLabelCountOutputType = {
    orders: number
  }

  export type ShippingLabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ShippingLabelCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ShippingLabelCountOutputType without action
   */
  export type ShippingLabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabelCountOutputType
     */
    select?: ShippingLabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShippingLabelCountOutputType without action
   */
  export type ShippingLabelCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type PhysicianCountOutputType
   */

  export type PhysicianCountOutputType = {
    evaluations: number
    patient: number
  }

  export type PhysicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | PhysicianCountOutputTypeCountEvaluationsArgs
    patient?: boolean | PhysicianCountOutputTypeCountPatientArgs
  }

  // Custom InputTypes
  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicianCountOutputType
     */
    select?: PhysicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Count Type DiagnosisCountOutputType
   */

  export type DiagnosisCountOutputType = {
    evaluations: number
  }

  export type DiagnosisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DiagnosisCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisCountOutputType
     */
    select?: DiagnosisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type DeviceTypeCountOutputType
   */

  export type DeviceTypeCountOutputType = {
    evaluations: number
  }

  export type DeviceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DeviceTypeCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * DeviceTypeCountOutputType without action
   */
  export type DeviceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTypeCountOutputType
     */
    select?: DeviceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceTypeCountOutputType without action
   */
  export type DeviceTypeCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type VisitTypeCountOutputType
   */

  export type VisitTypeCountOutputType = {
    evaluations: number
  }

  export type VisitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | VisitTypeCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTypeCountOutputType
     */
    select?: VisitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type FormSchemaCountOutputType
   */

  export type FormSchemaCountOutputType = {
    submissions: number
  }

  export type FormSchemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormSchemaCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FormSchemaCountOutputType without action
   */
  export type FormSchemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchemaCountOutputType
     */
    select?: FormSchemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormSchemaCountOutputType without action
   */
  export type FormSchemaCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }


  /**
   * Count Type CatalogProductCountOutputType
   */

  export type CatalogProductCountOutputType = {
    attributes: number
    variants: number
    categories: number
    vendors: number
  }

  export type CatalogProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | CatalogProductCountOutputTypeCountAttributesArgs
    variants?: boolean | CatalogProductCountOutputTypeCountVariantsArgs
    categories?: boolean | CatalogProductCountOutputTypeCountCategoriesArgs
    vendors?: boolean | CatalogProductCountOutputTypeCountVendorsArgs
  }

  // Custom InputTypes
  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductCountOutputType
     */
    select?: CatalogProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogVendorWhereInput
  }


  /**
   * Count Type CatalogCategoryCountOutputType
   */

  export type CatalogCategoryCountOutputType = {
    products: number
  }

  export type CatalogCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CatalogCategoryCountOutputType without action
   */
  export type CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategoryCountOutputType
     */
    select?: CatalogCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogCategoryCountOutputType without action
   */
  export type CatalogCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
  }


  /**
   * Count Type CatalogVendorCountOutputType
   */

  export type CatalogVendorCountOutputType = {
    products: number
  }

  export type CatalogVendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogVendorCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CatalogVendorCountOutputType without action
   */
  export type CatalogVendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendorCountOutputType
     */
    select?: CatalogVendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogVendorCountOutputType without action
   */
  export type CatalogVendorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
  }


  /**
   * Count Type StripeProductCountOutputType
   */

  export type StripeProductCountOutputType = {
    stripeInvoices: number
    stripeSubscriptions: number
  }

  export type StripeProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeInvoices?: boolean | StripeProductCountOutputTypeCountStripeInvoicesArgs
    stripeSubscriptions?: boolean | StripeProductCountOutputTypeCountStripeSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * StripeProductCountOutputType without action
   */
  export type StripeProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProductCountOutputType
     */
    select?: StripeProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StripeProductCountOutputType without action
   */
  export type StripeProductCountOutputTypeCountStripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeInvoiceWhereInput
  }

  /**
   * StripeProductCountOutputType without action
   */
  export type StripeProductCountOutputTypeCountStripeSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeSubscriptionWhereInput
  }


  /**
   * Count Type StripeInvoiceCountOutputType
   */

  export type StripeInvoiceCountOutputType = {
    stripeProducts: number
    combinedInvoices: number
    employerEvaluations: number
    checkoutEvaluations: number
  }

  export type StripeInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeProducts?: boolean | StripeInvoiceCountOutputTypeCountStripeProductsArgs
    combinedInvoices?: boolean | StripeInvoiceCountOutputTypeCountCombinedInvoicesArgs
    employerEvaluations?: boolean | StripeInvoiceCountOutputTypeCountEmployerEvaluationsArgs
    checkoutEvaluations?: boolean | StripeInvoiceCountOutputTypeCountCheckoutEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * StripeInvoiceCountOutputType without action
   */
  export type StripeInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoiceCountOutputType
     */
    select?: StripeInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StripeInvoiceCountOutputType without action
   */
  export type StripeInvoiceCountOutputTypeCountStripeProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeProductWhereInput
  }

  /**
   * StripeInvoiceCountOutputType without action
   */
  export type StripeInvoiceCountOutputTypeCountCombinedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeInvoiceWhereInput
  }

  /**
   * StripeInvoiceCountOutputType without action
   */
  export type StripeInvoiceCountOutputTypeCountEmployerEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * StripeInvoiceCountOutputType without action
   */
  export type StripeInvoiceCountOutputTypeCountCheckoutEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type StripeEntityCountOutputType
   */

  export type StripeEntityCountOutputType = {
    childEntities: number
    stripeProducts: number
    stripeSubscriptions: number
    stripeInvoices: number
  }

  export type StripeEntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childEntities?: boolean | StripeEntityCountOutputTypeCountChildEntitiesArgs
    stripeProducts?: boolean | StripeEntityCountOutputTypeCountStripeProductsArgs
    stripeSubscriptions?: boolean | StripeEntityCountOutputTypeCountStripeSubscriptionsArgs
    stripeInvoices?: boolean | StripeEntityCountOutputTypeCountStripeInvoicesArgs
  }

  // Custom InputTypes
  /**
   * StripeEntityCountOutputType without action
   */
  export type StripeEntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntityCountOutputType
     */
    select?: StripeEntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StripeEntityCountOutputType without action
   */
  export type StripeEntityCountOutputTypeCountChildEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeEntityWhereInput
  }

  /**
   * StripeEntityCountOutputType without action
   */
  export type StripeEntityCountOutputTypeCountStripeProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeProductWhereInput
  }

  /**
   * StripeEntityCountOutputType without action
   */
  export type StripeEntityCountOutputTypeCountStripeSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeSubscriptionWhereInput
  }

  /**
   * StripeEntityCountOutputType without action
   */
  export type StripeEntityCountOutputTypeCountStripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeInvoiceWhereInput
  }


  /**
   * Count Type StripeSubscriptionCountOutputType
   */

  export type StripeSubscriptionCountOutputType = {
    stripeInvoices: number
  }

  export type StripeSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeInvoices?: boolean | StripeSubscriptionCountOutputTypeCountStripeInvoicesArgs
  }

  // Custom InputTypes
  /**
   * StripeSubscriptionCountOutputType without action
   */
  export type StripeSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscriptionCountOutputType
     */
    select?: StripeSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StripeSubscriptionCountOutputType without action
   */
  export type StripeSubscriptionCountOutputTypeCountStripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeInvoiceWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    messages: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | NotificationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationMessageWhereInput
  }


  /**
   * Count Type NotificationMessageCountOutputType
   */

  export type NotificationMessageCountOutputType = {
    notificationHistory: number
  }

  export type NotificationMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationHistory?: boolean | NotificationMessageCountOutputTypeCountNotificationHistoryArgs
  }

  // Custom InputTypes
  /**
   * NotificationMessageCountOutputType without action
   */
  export type NotificationMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessageCountOutputType
     */
    select?: NotificationMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationMessageCountOutputType without action
   */
  export type NotificationMessageCountOutputTypeCountNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationHistoryWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    NotificationMessages: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationMessages?: boolean | EmailTemplateCountOutputTypeCountNotificationMessagesArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountNotificationMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationMessageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    companies: number
    departments: number
    notes: number
    auditsLogs: number
    agreements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    departments?: boolean | UserCountOutputTypeCountDepartmentsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    auditsLogs?: boolean | UserCountOutputTypeCountAuditsLogsArgs
    agreements?: boolean | UserCountOutputTypeCountAgreementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAgreementWhereInput
  }


  /**
   * Count Type AgreementCountOutputType
   */

  export type AgreementCountOutputType = {
    userAgreements: number
  }

  export type AgreementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAgreements?: boolean | AgreementCountOutputTypeCountUserAgreementsArgs
  }

  // Custom InputTypes
  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementCountOutputType
     */
    select?: AgreementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeCountUserAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAgreementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logoUrl: string | null
    slug: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logoUrl: string | null
    slug: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    url: number
    logoUrl: number
    slug: number
    preferences: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    preferences?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    url: string | null
    logoUrl: string | null
    slug: string
    preferences: JsonValue | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    logoUrl?: boolean
    slug?: boolean
    preferences?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilities?: boolean | Company$facilitiesArgs<ExtArgs>
    evaluations?: boolean | Company$evaluationsArgs<ExtArgs>
    apiKeys?: boolean | Company$apiKeysArgs<ExtArgs>
    packages?: boolean | Company$packagesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    patients?: boolean | Company$patientsArgs<ExtArgs>
    invitations?: boolean | Company$invitationsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    stripeEntities?: boolean | Company$stripeEntitiesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    logoUrl?: boolean
    slug?: boolean
    preferences?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | Company$facilitiesArgs<ExtArgs>
    evaluations?: boolean | Company$evaluationsArgs<ExtArgs>
    apiKeys?: boolean | Company$apiKeysArgs<ExtArgs>
    packages?: boolean | Company$packagesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    patients?: boolean | Company$patientsArgs<ExtArgs>
    invitations?: boolean | Company$invitationsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    stripeEntities?: boolean | Company$stripeEntitiesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      packages: Prisma.$ShippingPackagePayload<ExtArgs>[]
      users: Prisma.$CompanyUserPayload<ExtArgs>[]
      departments: Prisma.$DepartmentUserPayload<ExtArgs>[]
      patients: Prisma.$CompanyPatientPayload<ExtArgs>[]
      invitations: Prisma.$CompanyInvitationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      stripeEntities: Prisma.$StripeEntityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string | null
      logoUrl: string | null
      slug: string
      preferences: Prisma.JsonValue | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facilities<T extends Company$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Company$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Company$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    apiKeys<T extends Company$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Company$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'> | Null>;

    packages<T extends Company$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Company$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    departments<T extends Company$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    patients<T extends Company$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Company$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    invitations<T extends Company$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findMany'> | Null>;

    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeEntities<T extends Company$stripeEntitiesArgs<ExtArgs> = {}>(args?: Subset<T, Company$stripeEntitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly url: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly slug: FieldRef<"Company", 'String'>
    readonly preferences: FieldRef<"Company", 'Json'>
    readonly active: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.facilities
   */
  export type Company$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Company.evaluations
   */
  export type Company$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Company.apiKeys
   */
  export type Company$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Company.packages
   */
  export type Company$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    where?: ShippingPackageWhereInput
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    cursor?: ShippingPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * Company.departments
   */
  export type Company$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    where?: DepartmentUserWhereInput
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    cursor?: DepartmentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentUserScalarFieldEnum | DepartmentUserScalarFieldEnum[]
  }

  /**
   * Company.patients
   */
  export type Company$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    cursor?: CompanyPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * Company.invitations
   */
  export type Company$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    cursor?: CompanyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.stripeEntities
   */
  export type Company$stripeEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    where?: StripeEntityWhereInput
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    cursor?: StripeEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeEntityScalarFieldEnum | StripeEntityScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    id: string | null
    name: string | null
    companyId: string | null
    type: $Enums.FacilityType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    contactId: string | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    companyId: string | null
    type: $Enums.FacilityType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    contactId: string | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    name: number
    companyId: number
    type: number
    active: number
    createdAt: number
    updatedAt: number
    parentId: number
    contactId: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    contactId?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    contactId?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    contactId?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active: boolean
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    contactId: string | null
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    contactId?: boolean
    parent?: boolean | Facility$parentArgs<ExtArgs>
    children?: boolean | Facility$childrenArgs<ExtArgs>
    contact?: boolean | Facility$contactArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patients?: boolean | Facility$patientsArgs<ExtArgs>
    evaluations?: boolean | Facility$evaluationsArgs<ExtArgs>
    shippingLabels?: boolean | Facility$shippingLabelsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    id?: boolean
    name?: boolean
    companyId?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    contactId?: boolean
  }


  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Facility$parentArgs<ExtArgs>
    children?: boolean | Facility$childrenArgs<ExtArgs>
    contact?: boolean | Facility$contactArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patients?: boolean | Facility$patientsArgs<ExtArgs>
    evaluations?: boolean | Facility$evaluationsArgs<ExtArgs>
    shippingLabels?: boolean | Facility$shippingLabelsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      parent: Prisma.$FacilityPayload<ExtArgs> | null
      children: Prisma.$FacilityPayload<ExtArgs>[]
      contact: Prisma.$ContactPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      patients: Prisma.$FacilityPatientPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      shippingLabels: Prisma.$ShippingLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      companyId: string
      type: $Enums.FacilityType
      active: boolean
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      contactId: string | null
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }


  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacilityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
    **/
    create<T extends FacilityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FacilityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
    **/
    delete<T extends FacilityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parent<T extends Facility$parentArgs<ExtArgs> = {}>(args?: Subset<T, Facility$parentArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    children<T extends Facility$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Facility$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    contact<T extends Facility$contactArgs<ExtArgs> = {}>(args?: Subset<T, Facility$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patients<T extends Facility$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Facility$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    shippingLabels<T extends Facility$shippingLabelsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$shippingLabelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Facility model
   */ 
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'String'>
    readonly name: FieldRef<"Facility", 'String'>
    readonly companyId: FieldRef<"Facility", 'String'>
    readonly type: FieldRef<"Facility", 'FacilityType'>
    readonly active: FieldRef<"Facility", 'Boolean'>
    readonly createdAt: FieldRef<"Facility", 'DateTime'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
    readonly parentId: FieldRef<"Facility", 'String'>
    readonly contactId: FieldRef<"Facility", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility.parent
   */
  export type Facility$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * Facility.children
   */
  export type Facility$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility.contact
   */
  export type Facility$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Facility.patients
   */
  export type Facility$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    where?: FacilityPatientWhereInput
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    cursor?: FacilityPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityPatientScalarFieldEnum | FacilityPatientScalarFieldEnum[]
  }

  /**
   * Facility.evaluations
   */
  export type Facility$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Facility.shippingLabels
   */
  export type Facility$shippingLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    where?: ShippingLabelWhereInput
    orderBy?: ShippingLabelOrderByWithRelationInput | ShippingLabelOrderByWithRelationInput[]
    cursor?: ShippingLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingLabelScalarFieldEnum | ShippingLabelScalarFieldEnum[]
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type PatientSumAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean | null
    deceasedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryPhysicianId: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean | null
    deceasedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryPhysicianId: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    birthDate: number
    height: number
    weight: number
    maritalStatus: number
    photoUrl: number
    active: number
    deceasedAt: number
    createdAt: number
    updatedAt: number
    primaryPhysicianId: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    height?: true
    weight?: true
  }

  export type PatientSumAggregateInputType = {
    height?: true
    weight?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean
    deceasedAt: Date | null
    createdAt: Date
    updatedAt: Date
    primaryPhysicianId: string | null
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    birthDate?: boolean
    height?: boolean
    weight?: boolean
    maritalStatus?: boolean
    photoUrl?: boolean
    active?: boolean
    deceasedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryPhysicianId?: boolean
    primaryPhysician?: boolean | Patient$primaryPhysicianArgs<ExtArgs>
    feet?: boolean | Patient$feetArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    workbenches?: boolean | Patient$workbenchesArgs<ExtArgs>
    companies?: boolean | Patient$companiesArgs<ExtArgs>
    notificationHistory?: boolean | Patient$notificationHistoryArgs<ExtArgs>
    facilities?: boolean | Patient$facilitiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    birthDate?: boolean
    height?: boolean
    weight?: boolean
    maritalStatus?: boolean
    photoUrl?: boolean
    active?: boolean
    deceasedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryPhysicianId?: boolean
  }


  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryPhysician?: boolean | Patient$primaryPhysicianArgs<ExtArgs>
    feet?: boolean | Patient$feetArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    workbenches?: boolean | Patient$workbenchesArgs<ExtArgs>
    companies?: boolean | Patient$companiesArgs<ExtArgs>
    notificationHistory?: boolean | Patient$notificationHistoryArgs<ExtArgs>
    facilities?: boolean | Patient$facilitiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      primaryPhysician: Prisma.$PhysicianPayload<ExtArgs> | null
      feet: Prisma.$FootPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
      companies: Prisma.$CompanyPatientPayload<ExtArgs>[]
      notificationHistory: Prisma.$NotificationHistoryPayload<ExtArgs>[]
      facilities: Prisma.$FacilityPatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      middleName: string | null
      lastName: string | null
      gender: $Enums.Gender | null
      birthDate: Date | null
      height: number | null
      weight: number | null
      maritalStatus: $Enums.MaritalStatus | null
      photoUrl: string | null
      active: boolean
      deceasedAt: Date | null
      createdAt: Date
      updatedAt: Date
      primaryPhysicianId: string | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    primaryPhysician<T extends Patient$primaryPhysicianArgs<ExtArgs> = {}>(args?: Subset<T, Patient$primaryPhysicianArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    feet<T extends Patient$feetArgs<ExtArgs> = {}>(args?: Subset<T, Patient$feetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Patient$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Patient$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    companies<T extends Patient$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    notificationHistory<T extends Patient$notificationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Patient$notificationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    facilities<T extends Patient$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly middleName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly maritalStatus: FieldRef<"Patient", 'MaritalStatus'>
    readonly photoUrl: FieldRef<"Patient", 'String'>
    readonly active: FieldRef<"Patient", 'Boolean'>
    readonly deceasedAt: FieldRef<"Patient", 'DateTime'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly primaryPhysicianId: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data?: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.primaryPhysician
   */
  export type Patient$primaryPhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    where?: PhysicianWhereInput
  }

  /**
   * Patient.feet
   */
  export type Patient$feetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    where?: FootWhereInput
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    cursor?: FootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Patient.evaluations
   */
  export type Patient$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Patient.workbenches
   */
  export type Patient$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Patient.companies
   */
  export type Patient$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    cursor?: CompanyPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * Patient.notificationHistory
   */
  export type Patient$notificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    where?: NotificationHistoryWhereInput
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    cursor?: NotificationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationHistoryScalarFieldEnum | NotificationHistoryScalarFieldEnum[]
  }

  /**
   * Patient.facilities
   */
  export type Patient$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    where?: FacilityPatientWhereInput
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    cursor?: FacilityPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityPatientScalarFieldEnum | FacilityPatientScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Clinician
   */

  export type AggregateClinician = {
    _count: ClinicianCountAggregateOutputType | null
    _min: ClinicianMinAggregateOutputType | null
    _max: ClinicianMaxAggregateOutputType | null
  }

  export type ClinicianMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicianMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicianCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicianMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicianMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicianCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinician to aggregate.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinicians
    **/
    _count?: true | ClinicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicianMaxAggregateInputType
  }

  export type GetClinicianAggregateType<T extends ClinicianAggregateArgs> = {
        [P in keyof T & keyof AggregateClinician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinician[P]>
      : GetScalarType<T[P], AggregateClinician[P]>
  }




  export type ClinicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicianWhereInput
    orderBy?: ClinicianOrderByWithAggregationInput | ClinicianOrderByWithAggregationInput[]
    by: ClinicianScalarFieldEnum[] | ClinicianScalarFieldEnum
    having?: ClinicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicianCountAggregateInputType | true
    _min?: ClinicianMinAggregateInputType
    _max?: ClinicianMaxAggregateInputType
  }

  export type ClinicianGroupByOutputType = {
    id: string
    name: string
    userId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicianCountAggregateOutputType | null
    _min: ClinicianMinAggregateOutputType | null
    _max: ClinicianMaxAggregateOutputType | null
  }

  type GetClinicianGroupByPayload<T extends ClinicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicianGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicianGroupByOutputType[P]>
        }
      >
    >


  export type ClinicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Clinician$userArgs<ExtArgs>
    evaluations?: boolean | Clinician$evaluationsArgs<ExtArgs>
    _count?: boolean | ClinicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinician"]>

  export type ClinicianSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ClinicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Clinician$userArgs<ExtArgs>
    evaluations?: boolean | Clinician$evaluationsArgs<ExtArgs>
    _count?: boolean | ClinicianCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClinicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinician"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinician"]>
    composites: {}
  }


  type ClinicianGetPayload<S extends boolean | null | undefined | ClinicianDefaultArgs> = $Result.GetResult<Prisma.$ClinicianPayload, S>

  type ClinicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicianCountAggregateInputType | true
    }

  export interface ClinicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinician'], meta: { name: 'Clinician' } }
    /**
     * Find zero or one Clinician that matches the filter.
     * @param {ClinicianFindUniqueArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClinicianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianFindUniqueArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Clinician that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClinicianFindUniqueOrThrowArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClinicianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Clinician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindFirstArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClinicianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindFirstArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Clinician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindFirstOrThrowArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClinicianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clinicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinicians
     * const clinicians = await prisma.clinician.findMany()
     * 
     * // Get first 10 Clinicians
     * const clinicians = await prisma.clinician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicianWithIdOnly = await prisma.clinician.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClinicianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Clinician.
     * @param {ClinicianCreateArgs} args - Arguments to create a Clinician.
     * @example
     * // Create one Clinician
     * const Clinician = await prisma.clinician.create({
     *   data: {
     *     // ... data to create a Clinician
     *   }
     * })
     * 
    **/
    create<T extends ClinicianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianCreateArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clinicians.
     * @param {ClinicianCreateManyArgs} args - Arguments to create many Clinicians.
     * @example
     * // Create many Clinicians
     * const clinician = await prisma.clinician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClinicianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinicians and returns the data saved in the database.
     * @param {ClinicianCreateManyAndReturnArgs} args - Arguments to create many Clinicians.
     * @example
     * // Create many Clinicians
     * const clinician = await prisma.clinician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinicians and only return the `id`
     * const clinicianWithIdOnly = await prisma.clinician.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ClinicianCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Clinician.
     * @param {ClinicianDeleteArgs} args - Arguments to delete one Clinician.
     * @example
     * // Delete one Clinician
     * const Clinician = await prisma.clinician.delete({
     *   where: {
     *     // ... filter to delete one Clinician
     *   }
     * })
     * 
    **/
    delete<T extends ClinicianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianDeleteArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Clinician.
     * @param {ClinicianUpdateArgs} args - Arguments to update one Clinician.
     * @example
     * // Update one Clinician
     * const clinician = await prisma.clinician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClinicianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpdateArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clinicians.
     * @param {ClinicianDeleteManyArgs} args - Arguments to filter Clinicians to delete.
     * @example
     * // Delete a few Clinicians
     * const { count } = await prisma.clinician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClinicianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinicians
     * const clinician = await prisma.clinician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClinicianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinician.
     * @param {ClinicianUpsertArgs} args - Arguments to update or create a Clinician.
     * @example
     * // Update or create a Clinician
     * const clinician = await prisma.clinician.upsert({
     *   create: {
     *     // ... data to create a Clinician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinician we want to update
     *   }
     * })
    **/
    upsert<T extends ClinicianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpsertArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clinicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianCountArgs} args - Arguments to filter Clinicians to count.
     * @example
     * // Count the number of Clinicians
     * const count = await prisma.clinician.count({
     *   where: {
     *     // ... the filter for the Clinicians we want to count
     *   }
     * })
    **/
    count<T extends ClinicianCountArgs>(
      args?: Subset<T, ClinicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicianAggregateArgs>(args: Subset<T, ClinicianAggregateArgs>): Prisma.PrismaPromise<GetClinicianAggregateType<T>>

    /**
     * Group by Clinician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicianGroupByArgs['orderBy'] }
        : { orderBy?: ClinicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinician model
   */
  readonly fields: ClinicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Clinician$userArgs<ExtArgs> = {}>(args?: Subset<T, Clinician$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    evaluations<T extends Clinician$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Clinician$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Clinician model
   */ 
  interface ClinicianFieldRefs {
    readonly id: FieldRef<"Clinician", 'String'>
    readonly name: FieldRef<"Clinician", 'String'>
    readonly userId: FieldRef<"Clinician", 'String'>
    readonly active: FieldRef<"Clinician", 'Boolean'>
    readonly createdAt: FieldRef<"Clinician", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinician", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinician findUnique
   */
  export type ClinicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician findUniqueOrThrow
   */
  export type ClinicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician findFirst
   */
  export type ClinicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinicians.
     */
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician findFirstOrThrow
   */
  export type ClinicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinicians.
     */
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician findMany
   */
  export type ClinicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinicians to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician create
   */
  export type ClinicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinician.
     */
    data: XOR<ClinicianCreateInput, ClinicianUncheckedCreateInput>
  }

  /**
   * Clinician createMany
   */
  export type ClinicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinicians.
     */
    data: ClinicianCreateManyInput | ClinicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinician createManyAndReturn
   */
  export type ClinicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data used to create many Clinicians.
     */
    data: ClinicianCreateManyInput | ClinicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinician update
   */
  export type ClinicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinician.
     */
    data: XOR<ClinicianUpdateInput, ClinicianUncheckedUpdateInput>
    /**
     * Choose, which Clinician to update.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician updateMany
   */
  export type ClinicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinicians.
     */
    data: XOR<ClinicianUpdateManyMutationInput, ClinicianUncheckedUpdateManyInput>
    /**
     * Filter which Clinicians to update
     */
    where?: ClinicianWhereInput
  }

  /**
   * Clinician upsert
   */
  export type ClinicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinician to update in case it exists.
     */
    where: ClinicianWhereUniqueInput
    /**
     * In case the Clinician found by the `where` argument doesn't exist, create a new Clinician with this data.
     */
    create: XOR<ClinicianCreateInput, ClinicianUncheckedCreateInput>
    /**
     * In case the Clinician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicianUpdateInput, ClinicianUncheckedUpdateInput>
  }

  /**
   * Clinician delete
   */
  export type ClinicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter which Clinician to delete.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician deleteMany
   */
  export type ClinicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinicians to delete
     */
    where?: ClinicianWhereInput
  }

  /**
   * Clinician.user
   */
  export type Clinician$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Clinician.evaluations
   */
  export type Clinician$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Clinician without action
   */
  export type ClinicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType | null
    patientId: string | null
    companyId: string | null
    deviceTypeId: string | null
    isDiabetic: boolean | null
    isVeteran: boolean | null
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean | null
    stripeInvoiceId: string | null
    stripeCheckoutInvoiceId: string | null
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType | null
    patientId: string | null
    companyId: string | null
    deviceTypeId: string | null
    isDiabetic: boolean | null
    isVeteran: boolean | null
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean | null
    stripeInvoiceId: string | null
    stripeCheckoutInvoiceId: string | null
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    externalId: number
    poNumber: number
    type: number
    patientId: number
    companyId: number
    deviceTypeId: number
    isDiabetic: number
    isVeteran: number
    deviceSide: number
    devicePosition: number
    appointmentAt: number
    appointmentStatus: number
    referringPhysicianId: number
    diagnosisId: number
    diagnosisedAt: number
    visitTypeId: number
    visitedAt: number
    facilityId: number
    location: number
    prescribedAt: number
    prescribedActive: number
    stripeInvoiceId: number
    stripeCheckoutInvoiceId: number
    primaryInsurance: number
    secondaryInsurance: number
    submittedAt: number
    startedAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationMinAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    stripeInvoiceId?: true
    stripeCheckoutInvoiceId?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    stripeInvoiceId?: true
    stripeCheckoutInvoiceId?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    stripeInvoiceId?: true
    stripeCheckoutInvoiceId?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: string
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId: string | null
    isDiabetic: boolean
    isVeteran: boolean
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean
    stripeInvoiceId: string | null
    stripeCheckoutInvoiceId: string | null
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EvaluationCountAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    poNumber?: boolean
    type?: boolean
    patientId?: boolean
    companyId?: boolean
    deviceTypeId?: boolean
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: boolean
    devicePosition?: boolean
    appointmentAt?: boolean
    appointmentStatus?: boolean
    referringPhysicianId?: boolean
    diagnosisId?: boolean
    diagnosisedAt?: boolean
    visitTypeId?: boolean
    visitedAt?: boolean
    facilityId?: boolean
    location?: boolean
    prescribedAt?: boolean
    prescribedActive?: boolean
    stripeInvoiceId?: boolean
    stripeCheckoutInvoiceId?: boolean
    primaryInsurance?: boolean
    secondaryInsurance?: boolean
    submittedAt?: boolean
    startedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deviceType?: boolean | Evaluation$deviceTypeArgs<ExtArgs>
    visitType?: boolean | Evaluation$visitTypeArgs<ExtArgs>
    referringPhysician?: boolean | Evaluation$referringPhysicianArgs<ExtArgs>
    diagnosis?: boolean | Evaluation$diagnosisArgs<ExtArgs>
    facility?: boolean | Evaluation$facilityArgs<ExtArgs>
    stripeInvoice?: boolean | Evaluation$stripeInvoiceArgs<ExtArgs>
    stripeCheckoutInvoice?: boolean | Evaluation$stripeCheckoutInvoiceArgs<ExtArgs>
    clinicians?: boolean | Evaluation$cliniciansArgs<ExtArgs>
    workbenches?: boolean | Evaluation$workbenchesArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    externalId?: boolean
    poNumber?: boolean
    type?: boolean
    patientId?: boolean
    companyId?: boolean
    deviceTypeId?: boolean
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: boolean
    devicePosition?: boolean
    appointmentAt?: boolean
    appointmentStatus?: boolean
    referringPhysicianId?: boolean
    diagnosisId?: boolean
    diagnosisedAt?: boolean
    visitTypeId?: boolean
    visitedAt?: boolean
    facilityId?: boolean
    location?: boolean
    prescribedAt?: boolean
    prescribedActive?: boolean
    stripeInvoiceId?: boolean
    stripeCheckoutInvoiceId?: boolean
    primaryInsurance?: boolean
    secondaryInsurance?: boolean
    submittedAt?: boolean
    startedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deviceType?: boolean | Evaluation$deviceTypeArgs<ExtArgs>
    visitType?: boolean | Evaluation$visitTypeArgs<ExtArgs>
    referringPhysician?: boolean | Evaluation$referringPhysicianArgs<ExtArgs>
    diagnosis?: boolean | Evaluation$diagnosisArgs<ExtArgs>
    facility?: boolean | Evaluation$facilityArgs<ExtArgs>
    stripeInvoice?: boolean | Evaluation$stripeInvoiceArgs<ExtArgs>
    stripeCheckoutInvoice?: boolean | Evaluation$stripeCheckoutInvoiceArgs<ExtArgs>
    clinicians?: boolean | Evaluation$cliniciansArgs<ExtArgs>
    workbenches?: boolean | Evaluation$workbenchesArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      deviceType: Prisma.$DeviceTypePayload<ExtArgs> | null
      visitType: Prisma.$VisitTypePayload<ExtArgs> | null
      referringPhysician: Prisma.$PhysicianPayload<ExtArgs> | null
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs> | null
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      stripeInvoice: Prisma.$StripeInvoicePayload<ExtArgs> | null
      stripeCheckoutInvoice: Prisma.$StripeInvoicePayload<ExtArgs> | null
      clinicians: Prisma.$ClinicianPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      poNumber: string | null
      type: $Enums.CareType
      patientId: string
      companyId: string
      deviceTypeId: string | null
      isDiabetic: boolean
      isVeteran: boolean
      deviceSide: $Enums.Side | null
      devicePosition: $Enums.VerticalPosition | null
      appointmentAt: Date | null
      appointmentStatus: string | null
      referringPhysicianId: string | null
      diagnosisId: string | null
      diagnosisedAt: Date | null
      visitTypeId: string | null
      visitedAt: Date | null
      facilityId: string | null
      location: string | null
      prescribedAt: Date | null
      prescribedActive: boolean
      stripeInvoiceId: string | null
      stripeCheckoutInvoiceId: string | null
      primaryInsurance: string | null
      secondaryInsurance: string | null
      submittedAt: Date | null
      startedAt: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }


  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
    **/
    create<T extends EvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluations and returns the data saved in the database.
     * @param {EvaluationCreateManyAndReturnArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends EvaluationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    deviceType<T extends Evaluation$deviceTypeArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$deviceTypeArgs<ExtArgs>>): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    visitType<T extends Evaluation$visitTypeArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$visitTypeArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    referringPhysician<T extends Evaluation$referringPhysicianArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$referringPhysicianArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    diagnosis<T extends Evaluation$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$diagnosisArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    facility<T extends Evaluation$facilityArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    stripeInvoice<T extends Evaluation$stripeInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$stripeInvoiceArgs<ExtArgs>>): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    stripeCheckoutInvoice<T extends Evaluation$stripeCheckoutInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$stripeCheckoutInvoiceArgs<ExtArgs>>): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clinicians<T extends Evaluation$cliniciansArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$cliniciansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Evaluation$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'String'>
    readonly externalId: FieldRef<"Evaluation", 'String'>
    readonly poNumber: FieldRef<"Evaluation", 'String'>
    readonly type: FieldRef<"Evaluation", 'CareType'>
    readonly patientId: FieldRef<"Evaluation", 'String'>
    readonly companyId: FieldRef<"Evaluation", 'String'>
    readonly deviceTypeId: FieldRef<"Evaluation", 'String'>
    readonly isDiabetic: FieldRef<"Evaluation", 'Boolean'>
    readonly isVeteran: FieldRef<"Evaluation", 'Boolean'>
    readonly deviceSide: FieldRef<"Evaluation", 'Side'>
    readonly devicePosition: FieldRef<"Evaluation", 'VerticalPosition'>
    readonly appointmentAt: FieldRef<"Evaluation", 'DateTime'>
    readonly appointmentStatus: FieldRef<"Evaluation", 'String'>
    readonly referringPhysicianId: FieldRef<"Evaluation", 'String'>
    readonly diagnosisId: FieldRef<"Evaluation", 'String'>
    readonly diagnosisedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly visitTypeId: FieldRef<"Evaluation", 'String'>
    readonly visitedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly facilityId: FieldRef<"Evaluation", 'String'>
    readonly location: FieldRef<"Evaluation", 'String'>
    readonly prescribedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly prescribedActive: FieldRef<"Evaluation", 'Boolean'>
    readonly stripeInvoiceId: FieldRef<"Evaluation", 'String'>
    readonly stripeCheckoutInvoiceId: FieldRef<"Evaluation", 'String'>
    readonly primaryInsurance: FieldRef<"Evaluation", 'String'>
    readonly secondaryInsurance: FieldRef<"Evaluation", 'String'>
    readonly submittedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly startedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly cancelledAt: FieldRef<"Evaluation", 'DateTime'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"Evaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation createManyAndReturn
   */
  export type EvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation.deviceType
   */
  export type Evaluation$deviceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    where?: DeviceTypeWhereInput
  }

  /**
   * Evaluation.visitType
   */
  export type Evaluation$visitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    where?: VisitTypeWhereInput
  }

  /**
   * Evaluation.referringPhysician
   */
  export type Evaluation$referringPhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    where?: PhysicianWhereInput
  }

  /**
   * Evaluation.diagnosis
   */
  export type Evaluation$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
  }

  /**
   * Evaluation.facility
   */
  export type Evaluation$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * Evaluation.stripeInvoice
   */
  export type Evaluation$stripeInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
  }

  /**
   * Evaluation.stripeCheckoutInvoice
   */
  export type Evaluation$stripeCheckoutInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
  }

  /**
   * Evaluation.clinicians
   */
  export type Evaluation$cliniciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    where?: ClinicianWhereInput
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    cursor?: ClinicianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Evaluation.workbenches
   */
  export type Evaluation$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Foot
   */

  export type AggregateFoot = {
    _count: FootCountAggregateOutputType | null
    _avg: FootAvgAggregateOutputType | null
    _sum: FootSumAggregateOutputType | null
    _min: FootMinAggregateOutputType | null
    _max: FootMaxAggregateOutputType | null
  }

  export type FootAvgAggregateOutputType = {
    shoeSize: number | null
  }

  export type FootSumAggregateOutputType = {
    shoeSize: number | null
  }

  export type FootMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    workbenchId: string | null
    side: $Enums.Side | null
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth | null
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem | null
    shoeBrand: string | null
    shoeModel: string | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FootMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    workbenchId: string | null
    side: $Enums.Side | null
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth | null
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem | null
    shoeBrand: string | null
    shoeModel: string | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FootCountAggregateOutputType = {
    id: number
    patientId: number
    workbenchId: number
    side: number
    shoeSize: number
    shoeWidth: number
    shoeGender: number
    shoeSystem: number
    shoeBrand: number
    shoeModel: number
    questionnaire: number
    inactiveReason: number
    isChild: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FootAvgAggregateInputType = {
    shoeSize?: true
  }

  export type FootSumAggregateInputType = {
    shoeSize?: true
  }

  export type FootMinAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FootMaxAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FootCountAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    questionnaire?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foot to aggregate.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feet
    **/
    _count?: true | FootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FootMaxAggregateInputType
  }

  export type GetFootAggregateType<T extends FootAggregateArgs> = {
        [P in keyof T & keyof AggregateFoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoot[P]>
      : GetScalarType<T[P], AggregateFoot[P]>
  }




  export type FootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
    orderBy?: FootOrderByWithAggregationInput | FootOrderByWithAggregationInput[]
    by: FootScalarFieldEnum[] | FootScalarFieldEnum
    having?: FootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FootCountAggregateInputType | true
    _avg?: FootAvgAggregateInputType
    _sum?: FootSumAggregateInputType
    _min?: FootMinAggregateInputType
    _max?: FootMaxAggregateInputType
  }

  export type FootGroupByOutputType = {
    id: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth | null
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem
    shoeBrand: string | null
    shoeModel: string | null
    questionnaire: JsonValue | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FootCountAggregateOutputType | null
    _avg: FootAvgAggregateOutputType | null
    _sum: FootSumAggregateOutputType | null
    _min: FootMinAggregateOutputType | null
    _max: FootMaxAggregateOutputType | null
  }

  type GetFootGroupByPayload<T extends FootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FootGroupByOutputType[P]>
            : GetScalarType<T[P], FootGroupByOutputType[P]>
        }
      >
    >


  export type FootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    workbenchId?: boolean
    side?: boolean
    shoeSize?: boolean
    shoeWidth?: boolean
    shoeGender?: boolean
    shoeSystem?: boolean
    shoeBrand?: boolean
    shoeModel?: boolean
    questionnaire?: boolean
    inactiveReason?: boolean
    isChild?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    assets?: boolean | Foot$assetsArgs<ExtArgs>
    _count?: boolean | FootCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foot"]>

  export type FootSelectScalar = {
    id?: boolean
    patientId?: boolean
    workbenchId?: boolean
    side?: boolean
    shoeSize?: boolean
    shoeWidth?: boolean
    shoeGender?: boolean
    shoeSystem?: boolean
    shoeBrand?: boolean
    shoeModel?: boolean
    questionnaire?: boolean
    inactiveReason?: boolean
    isChild?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    assets?: boolean | Foot$assetsArgs<ExtArgs>
    _count?: boolean | FootCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foot"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      workbenchId: string
      side: $Enums.Side
      shoeSize: number | null
      shoeWidth: $Enums.ShoeWidth | null
      shoeGender: $Enums.Gender | null
      shoeSystem: $Enums.ShoeSystem
      shoeBrand: string | null
      shoeModel: string | null
      questionnaire: Prisma.JsonValue | null
      inactiveReason: $Enums.InactiveFootReason | null
      isChild: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foot"]>
    composites: {}
  }


  type FootGetPayload<S extends boolean | null | undefined | FootDefaultArgs> = $Result.GetResult<Prisma.$FootPayload, S>

  type FootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FootFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FootCountAggregateInputType | true
    }

  export interface FootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foot'], meta: { name: 'Foot' } }
    /**
     * Find zero or one Foot that matches the filter.
     * @param {FootFindUniqueArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FootFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FootFindUniqueArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FootFindUniqueOrThrowArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FootFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindFirstArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FootFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindFirstArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindFirstOrThrowArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FootFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feet
     * const feet = await prisma.foot.findMany()
     * 
     * // Get first 10 Feet
     * const feet = await prisma.foot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footWithIdOnly = await prisma.foot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FootFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foot.
     * @param {FootCreateArgs} args - Arguments to create a Foot.
     * @example
     * // Create one Foot
     * const Foot = await prisma.foot.create({
     *   data: {
     *     // ... data to create a Foot
     *   }
     * })
     * 
    **/
    create<T extends FootCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FootCreateArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feet.
     * @param {FootCreateManyArgs} args - Arguments to create many Feet.
     * @example
     * // Create many Feet
     * const foot = await prisma.foot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FootCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feet and returns the data saved in the database.
     * @param {FootCreateManyAndReturnArgs} args - Arguments to create many Feet.
     * @example
     * // Create many Feet
     * const foot = await prisma.foot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feet and only return the `id`
     * const footWithIdOnly = await prisma.foot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FootCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FootCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Foot.
     * @param {FootDeleteArgs} args - Arguments to delete one Foot.
     * @example
     * // Delete one Foot
     * const Foot = await prisma.foot.delete({
     *   where: {
     *     // ... filter to delete one Foot
     *   }
     * })
     * 
    **/
    delete<T extends FootDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FootDeleteArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foot.
     * @param {FootUpdateArgs} args - Arguments to update one Foot.
     * @example
     * // Update one Foot
     * const foot = await prisma.foot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FootUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpdateArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feet.
     * @param {FootDeleteManyArgs} args - Arguments to filter Feet to delete.
     * @example
     * // Delete a few Feet
     * const { count } = await prisma.foot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FootDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feet
     * const foot = await prisma.foot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FootUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foot.
     * @param {FootUpsertArgs} args - Arguments to update or create a Foot.
     * @example
     * // Update or create a Foot
     * const foot = await prisma.foot.upsert({
     *   create: {
     *     // ... data to create a Foot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foot we want to update
     *   }
     * })
    **/
    upsert<T extends FootUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpsertArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootCountArgs} args - Arguments to filter Feet to count.
     * @example
     * // Count the number of Feet
     * const count = await prisma.foot.count({
     *   where: {
     *     // ... the filter for the Feet we want to count
     *   }
     * })
    **/
    count<T extends FootCountArgs>(
      args?: Subset<T, FootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FootAggregateArgs>(args: Subset<T, FootAggregateArgs>): Prisma.PrismaPromise<GetFootAggregateType<T>>

    /**
     * Group by Foot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FootGroupByArgs['orderBy'] }
        : { orderBy?: FootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foot model
   */
  readonly fields: FootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assets<T extends Foot$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Foot$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Foot model
   */ 
  interface FootFieldRefs {
    readonly id: FieldRef<"Foot", 'String'>
    readonly patientId: FieldRef<"Foot", 'String'>
    readonly workbenchId: FieldRef<"Foot", 'String'>
    readonly side: FieldRef<"Foot", 'Side'>
    readonly shoeSize: FieldRef<"Foot", 'Float'>
    readonly shoeWidth: FieldRef<"Foot", 'ShoeWidth'>
    readonly shoeGender: FieldRef<"Foot", 'Gender'>
    readonly shoeSystem: FieldRef<"Foot", 'ShoeSystem'>
    readonly shoeBrand: FieldRef<"Foot", 'String'>
    readonly shoeModel: FieldRef<"Foot", 'String'>
    readonly questionnaire: FieldRef<"Foot", 'Json'>
    readonly inactiveReason: FieldRef<"Foot", 'InactiveFootReason'>
    readonly isChild: FieldRef<"Foot", 'Boolean'>
    readonly active: FieldRef<"Foot", 'Boolean'>
    readonly createdAt: FieldRef<"Foot", 'DateTime'>
    readonly updatedAt: FieldRef<"Foot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Foot findUnique
   */
  export type FootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot findUniqueOrThrow
   */
  export type FootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot findFirst
   */
  export type FootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feet.
     */
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot findFirstOrThrow
   */
  export type FootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feet.
     */
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot findMany
   */
  export type FootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Feet to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot create
   */
  export type FootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data needed to create a Foot.
     */
    data: XOR<FootCreateInput, FootUncheckedCreateInput>
  }

  /**
   * Foot createMany
   */
  export type FootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feet.
     */
    data: FootCreateManyInput | FootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foot createManyAndReturn
   */
  export type FootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data used to create many Feet.
     */
    data: FootCreateManyInput | FootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foot update
   */
  export type FootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data needed to update a Foot.
     */
    data: XOR<FootUpdateInput, FootUncheckedUpdateInput>
    /**
     * Choose, which Foot to update.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot updateMany
   */
  export type FootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feet.
     */
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyInput>
    /**
     * Filter which Feet to update
     */
    where?: FootWhereInput
  }

  /**
   * Foot upsert
   */
  export type FootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The filter to search for the Foot to update in case it exists.
     */
    where: FootWhereUniqueInput
    /**
     * In case the Foot found by the `where` argument doesn't exist, create a new Foot with this data.
     */
    create: XOR<FootCreateInput, FootUncheckedCreateInput>
    /**
     * In case the Foot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FootUpdateInput, FootUncheckedUpdateInput>
  }

  /**
   * Foot delete
   */
  export type FootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter which Foot to delete.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot deleteMany
   */
  export type FootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feet to delete
     */
    where?: FootWhereInput
  }

  /**
   * Foot.assets
   */
  export type Foot$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Foot without action
   */
  export type FootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    footId: string | null
    type: $Enums.ProductType | null
    fileUrl: string | null
    status: $Enums.AssetStatus | null
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    footId: string | null
    type: $Enums.ProductType | null
    fileUrl: string | null
    status: $Enums.AssetStatus | null
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    footId: number
    type: number
    fileUrl: number
    metadata: number
    status: number
    statusCheckpoints: number
    statusReason: number
    statusUpdatedAt: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    status?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    status?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    metadata?: true
    status?: true
    statusCheckpoints?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    footId: string
    type: $Enums.ProductType
    fileUrl: string | null
    metadata: JsonValue | null
    status: $Enums.AssetStatus
    statusCheckpoints: $Enums.AssetStatus[]
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footId?: boolean
    type?: boolean
    fileUrl?: boolean
    metadata?: boolean
    status?: boolean
    statusCheckpoints?: boolean
    statusReason?: boolean
    statusUpdatedAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foot?: boolean | FootDefaultArgs<ExtArgs>
    workbenches?: boolean | Asset$workbenchesArgs<ExtArgs>
    augments?: boolean | Asset$augmentsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    footId?: boolean
    type?: boolean
    fileUrl?: boolean
    metadata?: boolean
    status?: boolean
    statusCheckpoints?: boolean
    statusReason?: boolean
    statusUpdatedAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foot?: boolean | FootDefaultArgs<ExtArgs>
    workbenches?: boolean | Asset$workbenchesArgs<ExtArgs>
    augments?: boolean | Asset$augmentsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      foot: Prisma.$FootPayload<ExtArgs>
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
      augments: Prisma.$AssetAugmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      footId: string
      type: $Enums.ProductType
      fileUrl: string | null
      metadata: Prisma.JsonValue | null
      status: $Enums.AssetStatus
      statusCheckpoints: $Enums.AssetStatus[]
      statusReason: string | null
      statusUpdatedAt: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }


  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
    **/
    create<T extends AssetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetCreateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
    **/
    delete<T extends AssetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
    **/
    upsert<T extends AssetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    foot<T extends FootDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FootDefaultArgs<ExtArgs>>): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbenches<T extends Asset$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Asset$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    augments<T extends Asset$augmentsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$augmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly footId: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'ProductType'>
    readonly fileUrl: FieldRef<"Asset", 'String'>
    readonly metadata: FieldRef<"Asset", 'Json'>
    readonly status: FieldRef<"Asset", 'AssetStatus'>
    readonly statusCheckpoints: FieldRef<"Asset", 'AssetStatus[]'>
    readonly statusReason: FieldRef<"Asset", 'String'>
    readonly statusUpdatedAt: FieldRef<"Asset", 'DateTime'>
    readonly active: FieldRef<"Asset", 'Boolean'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset.workbenches
   */
  export type Asset$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Asset.augments
   */
  export type Asset$augmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    where?: AssetAugmentWhereInput
    orderBy?: AssetAugmentOrderByWithRelationInput | AssetAugmentOrderByWithRelationInput[]
    cursor?: AssetAugmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetAugmentScalarFieldEnum | AssetAugmentScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model AssetAugment
   */

  export type AggregateAssetAugment = {
    _count: AssetAugmentCountAggregateOutputType | null
    _min: AssetAugmentMinAggregateOutputType | null
    _max: AssetAugmentMaxAggregateOutputType | null
  }

  export type AssetAugmentMinAggregateOutputType = {
    id: string | null
    assetId: string | null
    type: $Enums.AssetAugmentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetAugmentMaxAggregateOutputType = {
    id: string | null
    assetId: string | null
    type: $Enums.AssetAugmentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetAugmentCountAggregateOutputType = {
    id: number
    assetId: number
    type: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetAugmentMinAggregateInputType = {
    id?: true
    assetId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetAugmentMaxAggregateInputType = {
    id?: true
    assetId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetAugmentCountAggregateInputType = {
    id?: true
    assetId?: true
    type?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAugmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAugment to aggregate.
     */
    where?: AssetAugmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugments to fetch.
     */
    orderBy?: AssetAugmentOrderByWithRelationInput | AssetAugmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetAugmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetAugments
    **/
    _count?: true | AssetAugmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetAugmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetAugmentMaxAggregateInputType
  }

  export type GetAssetAugmentAggregateType<T extends AssetAugmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetAugment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetAugment[P]>
      : GetScalarType<T[P], AggregateAssetAugment[P]>
  }




  export type AssetAugmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAugmentWhereInput
    orderBy?: AssetAugmentOrderByWithAggregationInput | AssetAugmentOrderByWithAggregationInput[]
    by: AssetAugmentScalarFieldEnum[] | AssetAugmentScalarFieldEnum
    having?: AssetAugmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetAugmentCountAggregateInputType | true
    _min?: AssetAugmentMinAggregateInputType
    _max?: AssetAugmentMaxAggregateInputType
  }

  export type AssetAugmentGroupByOutputType = {
    id: string
    assetId: string
    type: $Enums.AssetAugmentType
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AssetAugmentCountAggregateOutputType | null
    _min: AssetAugmentMinAggregateOutputType | null
    _max: AssetAugmentMaxAggregateOutputType | null
  }

  type GetAssetAugmentGroupByPayload<T extends AssetAugmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetAugmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetAugmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetAugmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssetAugmentGroupByOutputType[P]>
        }
      >
    >


  export type AssetAugmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    media?: boolean | AssetAugment$mediaArgs<ExtArgs>
    _count?: boolean | AssetAugmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAugment"]>

  export type AssetAugmentSelectScalar = {
    id?: boolean
    assetId?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AssetAugmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    media?: boolean | AssetAugment$mediaArgs<ExtArgs>
    _count?: boolean | AssetAugmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AssetAugmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetAugment"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      media: Prisma.$AssetAugmentMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetId: string
      type: $Enums.AssetAugmentType
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assetAugment"]>
    composites: {}
  }


  type AssetAugmentGetPayload<S extends boolean | null | undefined | AssetAugmentDefaultArgs> = $Result.GetResult<Prisma.$AssetAugmentPayload, S>

  type AssetAugmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetAugmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetAugmentCountAggregateInputType | true
    }

  export interface AssetAugmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetAugment'], meta: { name: 'AssetAugment' } }
    /**
     * Find zero or one AssetAugment that matches the filter.
     * @param {AssetAugmentFindUniqueArgs} args - Arguments to find a AssetAugment
     * @example
     * // Get one AssetAugment
     * const assetAugment = await prisma.assetAugment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssetAugmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentFindUniqueArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AssetAugment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetAugmentFindUniqueOrThrowArgs} args - Arguments to find a AssetAugment
     * @example
     * // Get one AssetAugment
     * const assetAugment = await prisma.assetAugment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssetAugmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AssetAugment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentFindFirstArgs} args - Arguments to find a AssetAugment
     * @example
     * // Get one AssetAugment
     * const assetAugment = await prisma.assetAugment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssetAugmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentFindFirstArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AssetAugment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentFindFirstOrThrowArgs} args - Arguments to find a AssetAugment
     * @example
     * // Get one AssetAugment
     * const assetAugment = await prisma.assetAugment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssetAugmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AssetAugments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetAugments
     * const assetAugments = await prisma.assetAugment.findMany()
     * 
     * // Get first 10 AssetAugments
     * const assetAugments = await prisma.assetAugment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetAugmentWithIdOnly = await prisma.assetAugment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssetAugmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AssetAugment.
     * @param {AssetAugmentCreateArgs} args - Arguments to create a AssetAugment.
     * @example
     * // Create one AssetAugment
     * const AssetAugment = await prisma.assetAugment.create({
     *   data: {
     *     // ... data to create a AssetAugment
     *   }
     * })
     * 
    **/
    create<T extends AssetAugmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentCreateArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AssetAugments.
     * @param {AssetAugmentCreateManyArgs} args - Arguments to create many AssetAugments.
     * @example
     * // Create many AssetAugments
     * const assetAugment = await prisma.assetAugment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssetAugmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetAugments and returns the data saved in the database.
     * @param {AssetAugmentCreateManyAndReturnArgs} args - Arguments to create many AssetAugments.
     * @example
     * // Create many AssetAugments
     * const assetAugment = await prisma.assetAugment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetAugments and only return the `id`
     * const assetAugmentWithIdOnly = await prisma.assetAugment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AssetAugmentCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AssetAugment.
     * @param {AssetAugmentDeleteArgs} args - Arguments to delete one AssetAugment.
     * @example
     * // Delete one AssetAugment
     * const AssetAugment = await prisma.assetAugment.delete({
     *   where: {
     *     // ... filter to delete one AssetAugment
     *   }
     * })
     * 
    **/
    delete<T extends AssetAugmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentDeleteArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AssetAugment.
     * @param {AssetAugmentUpdateArgs} args - Arguments to update one AssetAugment.
     * @example
     * // Update one AssetAugment
     * const assetAugment = await prisma.assetAugment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssetAugmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentUpdateArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AssetAugments.
     * @param {AssetAugmentDeleteManyArgs} args - Arguments to filter AssetAugments to delete.
     * @example
     * // Delete a few AssetAugments
     * const { count } = await prisma.assetAugment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssetAugmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAugments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetAugments
     * const assetAugment = await prisma.assetAugment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssetAugmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetAugment.
     * @param {AssetAugmentUpsertArgs} args - Arguments to update or create a AssetAugment.
     * @example
     * // Update or create a AssetAugment
     * const assetAugment = await prisma.assetAugment.upsert({
     *   create: {
     *     // ... data to create a AssetAugment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetAugment we want to update
     *   }
     * })
    **/
    upsert<T extends AssetAugmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentUpsertArgs<ExtArgs>>
    ): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AssetAugments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentCountArgs} args - Arguments to filter AssetAugments to count.
     * @example
     * // Count the number of AssetAugments
     * const count = await prisma.assetAugment.count({
     *   where: {
     *     // ... the filter for the AssetAugments we want to count
     *   }
     * })
    **/
    count<T extends AssetAugmentCountArgs>(
      args?: Subset<T, AssetAugmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetAugmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetAugment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAugmentAggregateArgs>(args: Subset<T, AssetAugmentAggregateArgs>): Prisma.PrismaPromise<GetAssetAugmentAggregateType<T>>

    /**
     * Group by AssetAugment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetAugmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetAugmentGroupByArgs['orderBy'] }
        : { orderBy?: AssetAugmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetAugmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetAugmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetAugment model
   */
  readonly fields: AssetAugmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetAugment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetAugmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    media<T extends AssetAugment$mediaArgs<ExtArgs> = {}>(args?: Subset<T, AssetAugment$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AssetAugment model
   */ 
  interface AssetAugmentFieldRefs {
    readonly id: FieldRef<"AssetAugment", 'String'>
    readonly assetId: FieldRef<"AssetAugment", 'String'>
    readonly type: FieldRef<"AssetAugment", 'AssetAugmentType'>
    readonly data: FieldRef<"AssetAugment", 'Json'>
    readonly createdAt: FieldRef<"AssetAugment", 'DateTime'>
    readonly updatedAt: FieldRef<"AssetAugment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetAugment findUnique
   */
  export type AssetAugmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugment to fetch.
     */
    where: AssetAugmentWhereUniqueInput
  }

  /**
   * AssetAugment findUniqueOrThrow
   */
  export type AssetAugmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugment to fetch.
     */
    where: AssetAugmentWhereUniqueInput
  }

  /**
   * AssetAugment findFirst
   */
  export type AssetAugmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugment to fetch.
     */
    where?: AssetAugmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugments to fetch.
     */
    orderBy?: AssetAugmentOrderByWithRelationInput | AssetAugmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAugments.
     */
    cursor?: AssetAugmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAugments.
     */
    distinct?: AssetAugmentScalarFieldEnum | AssetAugmentScalarFieldEnum[]
  }

  /**
   * AssetAugment findFirstOrThrow
   */
  export type AssetAugmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugment to fetch.
     */
    where?: AssetAugmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugments to fetch.
     */
    orderBy?: AssetAugmentOrderByWithRelationInput | AssetAugmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAugments.
     */
    cursor?: AssetAugmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAugments.
     */
    distinct?: AssetAugmentScalarFieldEnum | AssetAugmentScalarFieldEnum[]
  }

  /**
   * AssetAugment findMany
   */
  export type AssetAugmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugments to fetch.
     */
    where?: AssetAugmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugments to fetch.
     */
    orderBy?: AssetAugmentOrderByWithRelationInput | AssetAugmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetAugments.
     */
    cursor?: AssetAugmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugments.
     */
    skip?: number
    distinct?: AssetAugmentScalarFieldEnum | AssetAugmentScalarFieldEnum[]
  }

  /**
   * AssetAugment create
   */
  export type AssetAugmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetAugment.
     */
    data: XOR<AssetAugmentCreateInput, AssetAugmentUncheckedCreateInput>
  }

  /**
   * AssetAugment createMany
   */
  export type AssetAugmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetAugments.
     */
    data: AssetAugmentCreateManyInput | AssetAugmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAugment createManyAndReturn
   */
  export type AssetAugmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * The data used to create many AssetAugments.
     */
    data: AssetAugmentCreateManyInput | AssetAugmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAugment update
   */
  export type AssetAugmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetAugment.
     */
    data: XOR<AssetAugmentUpdateInput, AssetAugmentUncheckedUpdateInput>
    /**
     * Choose, which AssetAugment to update.
     */
    where: AssetAugmentWhereUniqueInput
  }

  /**
   * AssetAugment updateMany
   */
  export type AssetAugmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetAugments.
     */
    data: XOR<AssetAugmentUpdateManyMutationInput, AssetAugmentUncheckedUpdateManyInput>
    /**
     * Filter which AssetAugments to update
     */
    where?: AssetAugmentWhereInput
  }

  /**
   * AssetAugment upsert
   */
  export type AssetAugmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetAugment to update in case it exists.
     */
    where: AssetAugmentWhereUniqueInput
    /**
     * In case the AssetAugment found by the `where` argument doesn't exist, create a new AssetAugment with this data.
     */
    create: XOR<AssetAugmentCreateInput, AssetAugmentUncheckedCreateInput>
    /**
     * In case the AssetAugment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetAugmentUpdateInput, AssetAugmentUncheckedUpdateInput>
  }

  /**
   * AssetAugment delete
   */
  export type AssetAugmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
    /**
     * Filter which AssetAugment to delete.
     */
    where: AssetAugmentWhereUniqueInput
  }

  /**
   * AssetAugment deleteMany
   */
  export type AssetAugmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAugments to delete
     */
    where?: AssetAugmentWhereInput
  }

  /**
   * AssetAugment.media
   */
  export type AssetAugment$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    where?: AssetAugmentMediaWhereInput
    orderBy?: AssetAugmentMediaOrderByWithRelationInput | AssetAugmentMediaOrderByWithRelationInput[]
    cursor?: AssetAugmentMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetAugmentMediaScalarFieldEnum | AssetAugmentMediaScalarFieldEnum[]
  }

  /**
   * AssetAugment without action
   */
  export type AssetAugmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugment
     */
    select?: AssetAugmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentInclude<ExtArgs> | null
  }


  /**
   * Model AssetAugmentMedia
   */

  export type AggregateAssetAugmentMedia = {
    _count: AssetAugmentMediaCountAggregateOutputType | null
    _min: AssetAugmentMediaMinAggregateOutputType | null
    _max: AssetAugmentMediaMaxAggregateOutputType | null
  }

  export type AssetAugmentMediaMinAggregateOutputType = {
    id: string | null
    augmentId: string | null
    region: string | null
    bucket: string | null
    key: string | null
    active: boolean | null
    inactiveReason: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetAugmentMediaMaxAggregateOutputType = {
    id: string | null
    augmentId: string | null
    region: string | null
    bucket: string | null
    key: string | null
    active: boolean | null
    inactiveReason: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetAugmentMediaCountAggregateOutputType = {
    id: number
    augmentId: number
    data: number
    originalData: number
    region: number
    bucket: number
    key: number
    active: number
    inactiveReason: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetAugmentMediaMinAggregateInputType = {
    id?: true
    augmentId?: true
    region?: true
    bucket?: true
    key?: true
    active?: true
    inactiveReason?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetAugmentMediaMaxAggregateInputType = {
    id?: true
    augmentId?: true
    region?: true
    bucket?: true
    key?: true
    active?: true
    inactiveReason?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetAugmentMediaCountAggregateInputType = {
    id?: true
    augmentId?: true
    data?: true
    originalData?: true
    region?: true
    bucket?: true
    key?: true
    active?: true
    inactiveReason?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAugmentMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAugmentMedia to aggregate.
     */
    where?: AssetAugmentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugmentMedias to fetch.
     */
    orderBy?: AssetAugmentMediaOrderByWithRelationInput | AssetAugmentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetAugmentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugmentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugmentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetAugmentMedias
    **/
    _count?: true | AssetAugmentMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetAugmentMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetAugmentMediaMaxAggregateInputType
  }

  export type GetAssetAugmentMediaAggregateType<T extends AssetAugmentMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetAugmentMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetAugmentMedia[P]>
      : GetScalarType<T[P], AggregateAssetAugmentMedia[P]>
  }




  export type AssetAugmentMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAugmentMediaWhereInput
    orderBy?: AssetAugmentMediaOrderByWithAggregationInput | AssetAugmentMediaOrderByWithAggregationInput[]
    by: AssetAugmentMediaScalarFieldEnum[] | AssetAugmentMediaScalarFieldEnum
    having?: AssetAugmentMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetAugmentMediaCountAggregateInputType | true
    _min?: AssetAugmentMediaMinAggregateInputType
    _max?: AssetAugmentMediaMaxAggregateInputType
  }

  export type AssetAugmentMediaGroupByOutputType = {
    id: string
    augmentId: string
    data: JsonValue | null
    originalData: JsonValue | null
    region: string | null
    bucket: string | null
    key: string | null
    active: boolean
    inactiveReason: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AssetAugmentMediaCountAggregateOutputType | null
    _min: AssetAugmentMediaMinAggregateOutputType | null
    _max: AssetAugmentMediaMaxAggregateOutputType | null
  }

  type GetAssetAugmentMediaGroupByPayload<T extends AssetAugmentMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetAugmentMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetAugmentMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetAugmentMediaGroupByOutputType[P]>
            : GetScalarType<T[P], AssetAugmentMediaGroupByOutputType[P]>
        }
      >
    >


  export type AssetAugmentMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    augmentId?: boolean
    data?: boolean
    originalData?: boolean
    region?: boolean
    bucket?: boolean
    key?: boolean
    active?: boolean
    inactiveReason?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    augment?: boolean | AssetAugmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAugmentMedia"]>

  export type AssetAugmentMediaSelectScalar = {
    id?: boolean
    augmentId?: boolean
    data?: boolean
    originalData?: boolean
    region?: boolean
    bucket?: boolean
    key?: boolean
    active?: boolean
    inactiveReason?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AssetAugmentMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    augment?: boolean | AssetAugmentDefaultArgs<ExtArgs>
  }


  export type $AssetAugmentMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetAugmentMedia"
    objects: {
      augment: Prisma.$AssetAugmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      augmentId: string
      data: Prisma.JsonValue | null
      originalData: Prisma.JsonValue | null
      region: string | null
      bucket: string | null
      key: string | null
      active: boolean
      inactiveReason: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assetAugmentMedia"]>
    composites: {}
  }


  type AssetAugmentMediaGetPayload<S extends boolean | null | undefined | AssetAugmentMediaDefaultArgs> = $Result.GetResult<Prisma.$AssetAugmentMediaPayload, S>

  type AssetAugmentMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetAugmentMediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetAugmentMediaCountAggregateInputType | true
    }

  export interface AssetAugmentMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetAugmentMedia'], meta: { name: 'AssetAugmentMedia' } }
    /**
     * Find zero or one AssetAugmentMedia that matches the filter.
     * @param {AssetAugmentMediaFindUniqueArgs} args - Arguments to find a AssetAugmentMedia
     * @example
     * // Get one AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssetAugmentMediaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaFindUniqueArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AssetAugmentMedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetAugmentMediaFindUniqueOrThrowArgs} args - Arguments to find a AssetAugmentMedia
     * @example
     * // Get one AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssetAugmentMediaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AssetAugmentMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaFindFirstArgs} args - Arguments to find a AssetAugmentMedia
     * @example
     * // Get one AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssetAugmentMediaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaFindFirstArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AssetAugmentMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaFindFirstOrThrowArgs} args - Arguments to find a AssetAugmentMedia
     * @example
     * // Get one AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssetAugmentMediaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AssetAugmentMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetAugmentMedias
     * const assetAugmentMedias = await prisma.assetAugmentMedia.findMany()
     * 
     * // Get first 10 AssetAugmentMedias
     * const assetAugmentMedias = await prisma.assetAugmentMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetAugmentMediaWithIdOnly = await prisma.assetAugmentMedia.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssetAugmentMediaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AssetAugmentMedia.
     * @param {AssetAugmentMediaCreateArgs} args - Arguments to create a AssetAugmentMedia.
     * @example
     * // Create one AssetAugmentMedia
     * const AssetAugmentMedia = await prisma.assetAugmentMedia.create({
     *   data: {
     *     // ... data to create a AssetAugmentMedia
     *   }
     * })
     * 
    **/
    create<T extends AssetAugmentMediaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaCreateArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AssetAugmentMedias.
     * @param {AssetAugmentMediaCreateManyArgs} args - Arguments to create many AssetAugmentMedias.
     * @example
     * // Create many AssetAugmentMedias
     * const assetAugmentMedia = await prisma.assetAugmentMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssetAugmentMediaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetAugmentMedias and returns the data saved in the database.
     * @param {AssetAugmentMediaCreateManyAndReturnArgs} args - Arguments to create many AssetAugmentMedias.
     * @example
     * // Create many AssetAugmentMedias
     * const assetAugmentMedia = await prisma.assetAugmentMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetAugmentMedias and only return the `id`
     * const assetAugmentMediaWithIdOnly = await prisma.assetAugmentMedia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AssetAugmentMediaCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AssetAugmentMedia.
     * @param {AssetAugmentMediaDeleteArgs} args - Arguments to delete one AssetAugmentMedia.
     * @example
     * // Delete one AssetAugmentMedia
     * const AssetAugmentMedia = await prisma.assetAugmentMedia.delete({
     *   where: {
     *     // ... filter to delete one AssetAugmentMedia
     *   }
     * })
     * 
    **/
    delete<T extends AssetAugmentMediaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaDeleteArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AssetAugmentMedia.
     * @param {AssetAugmentMediaUpdateArgs} args - Arguments to update one AssetAugmentMedia.
     * @example
     * // Update one AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssetAugmentMediaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaUpdateArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AssetAugmentMedias.
     * @param {AssetAugmentMediaDeleteManyArgs} args - Arguments to filter AssetAugmentMedias to delete.
     * @example
     * // Delete a few AssetAugmentMedias
     * const { count } = await prisma.assetAugmentMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssetAugmentMediaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetAugmentMediaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAugmentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetAugmentMedias
     * const assetAugmentMedia = await prisma.assetAugmentMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssetAugmentMediaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetAugmentMedia.
     * @param {AssetAugmentMediaUpsertArgs} args - Arguments to update or create a AssetAugmentMedia.
     * @example
     * // Update or create a AssetAugmentMedia
     * const assetAugmentMedia = await prisma.assetAugmentMedia.upsert({
     *   create: {
     *     // ... data to create a AssetAugmentMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetAugmentMedia we want to update
     *   }
     * })
    **/
    upsert<T extends AssetAugmentMediaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssetAugmentMediaUpsertArgs<ExtArgs>>
    ): Prisma__AssetAugmentMediaClient<$Result.GetResult<Prisma.$AssetAugmentMediaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AssetAugmentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaCountArgs} args - Arguments to filter AssetAugmentMedias to count.
     * @example
     * // Count the number of AssetAugmentMedias
     * const count = await prisma.assetAugmentMedia.count({
     *   where: {
     *     // ... the filter for the AssetAugmentMedias we want to count
     *   }
     * })
    **/
    count<T extends AssetAugmentMediaCountArgs>(
      args?: Subset<T, AssetAugmentMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetAugmentMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetAugmentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAugmentMediaAggregateArgs>(args: Subset<T, AssetAugmentMediaAggregateArgs>): Prisma.PrismaPromise<GetAssetAugmentMediaAggregateType<T>>

    /**
     * Group by AssetAugmentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAugmentMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetAugmentMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetAugmentMediaGroupByArgs['orderBy'] }
        : { orderBy?: AssetAugmentMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetAugmentMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetAugmentMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetAugmentMedia model
   */
  readonly fields: AssetAugmentMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetAugmentMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetAugmentMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    augment<T extends AssetAugmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetAugmentDefaultArgs<ExtArgs>>): Prisma__AssetAugmentClient<$Result.GetResult<Prisma.$AssetAugmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AssetAugmentMedia model
   */ 
  interface AssetAugmentMediaFieldRefs {
    readonly id: FieldRef<"AssetAugmentMedia", 'String'>
    readonly augmentId: FieldRef<"AssetAugmentMedia", 'String'>
    readonly data: FieldRef<"AssetAugmentMedia", 'Json'>
    readonly originalData: FieldRef<"AssetAugmentMedia", 'Json'>
    readonly region: FieldRef<"AssetAugmentMedia", 'String'>
    readonly bucket: FieldRef<"AssetAugmentMedia", 'String'>
    readonly key: FieldRef<"AssetAugmentMedia", 'String'>
    readonly active: FieldRef<"AssetAugmentMedia", 'Boolean'>
    readonly inactiveReason: FieldRef<"AssetAugmentMedia", 'String'>
    readonly reviewedAt: FieldRef<"AssetAugmentMedia", 'DateTime'>
    readonly createdAt: FieldRef<"AssetAugmentMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"AssetAugmentMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetAugmentMedia findUnique
   */
  export type AssetAugmentMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugmentMedia to fetch.
     */
    where: AssetAugmentMediaWhereUniqueInput
  }

  /**
   * AssetAugmentMedia findUniqueOrThrow
   */
  export type AssetAugmentMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugmentMedia to fetch.
     */
    where: AssetAugmentMediaWhereUniqueInput
  }

  /**
   * AssetAugmentMedia findFirst
   */
  export type AssetAugmentMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugmentMedia to fetch.
     */
    where?: AssetAugmentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugmentMedias to fetch.
     */
    orderBy?: AssetAugmentMediaOrderByWithRelationInput | AssetAugmentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAugmentMedias.
     */
    cursor?: AssetAugmentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugmentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugmentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAugmentMedias.
     */
    distinct?: AssetAugmentMediaScalarFieldEnum | AssetAugmentMediaScalarFieldEnum[]
  }

  /**
   * AssetAugmentMedia findFirstOrThrow
   */
  export type AssetAugmentMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugmentMedia to fetch.
     */
    where?: AssetAugmentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugmentMedias to fetch.
     */
    orderBy?: AssetAugmentMediaOrderByWithRelationInput | AssetAugmentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAugmentMedias.
     */
    cursor?: AssetAugmentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugmentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugmentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAugmentMedias.
     */
    distinct?: AssetAugmentMediaScalarFieldEnum | AssetAugmentMediaScalarFieldEnum[]
  }

  /**
   * AssetAugmentMedia findMany
   */
  export type AssetAugmentMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter, which AssetAugmentMedias to fetch.
     */
    where?: AssetAugmentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAugmentMedias to fetch.
     */
    orderBy?: AssetAugmentMediaOrderByWithRelationInput | AssetAugmentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetAugmentMedias.
     */
    cursor?: AssetAugmentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAugmentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAugmentMedias.
     */
    skip?: number
    distinct?: AssetAugmentMediaScalarFieldEnum | AssetAugmentMediaScalarFieldEnum[]
  }

  /**
   * AssetAugmentMedia create
   */
  export type AssetAugmentMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetAugmentMedia.
     */
    data: XOR<AssetAugmentMediaCreateInput, AssetAugmentMediaUncheckedCreateInput>
  }

  /**
   * AssetAugmentMedia createMany
   */
  export type AssetAugmentMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetAugmentMedias.
     */
    data: AssetAugmentMediaCreateManyInput | AssetAugmentMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAugmentMedia createManyAndReturn
   */
  export type AssetAugmentMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * The data used to create many AssetAugmentMedias.
     */
    data: AssetAugmentMediaCreateManyInput | AssetAugmentMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAugmentMedia update
   */
  export type AssetAugmentMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetAugmentMedia.
     */
    data: XOR<AssetAugmentMediaUpdateInput, AssetAugmentMediaUncheckedUpdateInput>
    /**
     * Choose, which AssetAugmentMedia to update.
     */
    where: AssetAugmentMediaWhereUniqueInput
  }

  /**
   * AssetAugmentMedia updateMany
   */
  export type AssetAugmentMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetAugmentMedias.
     */
    data: XOR<AssetAugmentMediaUpdateManyMutationInput, AssetAugmentMediaUncheckedUpdateManyInput>
    /**
     * Filter which AssetAugmentMedias to update
     */
    where?: AssetAugmentMediaWhereInput
  }

  /**
   * AssetAugmentMedia upsert
   */
  export type AssetAugmentMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetAugmentMedia to update in case it exists.
     */
    where: AssetAugmentMediaWhereUniqueInput
    /**
     * In case the AssetAugmentMedia found by the `where` argument doesn't exist, create a new AssetAugmentMedia with this data.
     */
    create: XOR<AssetAugmentMediaCreateInput, AssetAugmentMediaUncheckedCreateInput>
    /**
     * In case the AssetAugmentMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetAugmentMediaUpdateInput, AssetAugmentMediaUncheckedUpdateInput>
  }

  /**
   * AssetAugmentMedia delete
   */
  export type AssetAugmentMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
    /**
     * Filter which AssetAugmentMedia to delete.
     */
    where: AssetAugmentMediaWhereUniqueInput
  }

  /**
   * AssetAugmentMedia deleteMany
   */
  export type AssetAugmentMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAugmentMedias to delete
     */
    where?: AssetAugmentMediaWhereInput
  }

  /**
   * AssetAugmentMedia without action
   */
  export type AssetAugmentMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAugmentMedia
     */
    select?: AssetAugmentMediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAugmentMediaInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProductType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProductType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    type: number
    sides: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    sides?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ProductType
    sides: $Enums.Side[]
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    sides?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buildingBlocks?: boolean | Product$buildingBlocksArgs<ExtArgs>
    usedByProducts?: boolean | Product$usedByProductsArgs<ExtArgs>
    workbenches?: boolean | Product$workbenchesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    sides?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingBlocks?: boolean | Product$buildingBlocksArgs<ExtArgs>
    usedByProducts?: boolean | Product$usedByProductsArgs<ExtArgs>
    workbenches?: boolean | Product$workbenchesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      buildingBlocks: Prisma.$ProductPayload<ExtArgs>[]
      usedByProducts: Prisma.$ProductPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ProductType
      sides: $Enums.Side[]
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingBlocks<T extends Product$buildingBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Product$buildingBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    usedByProducts<T extends Product$usedByProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$usedByProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Product$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Product$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly sides: FieldRef<"Product", 'Side[]'>
    readonly description: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.buildingBlocks
   */
  export type Product$buildingBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.usedByProducts
   */
  export type Product$usedByProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.workbenches
   */
  export type Product$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Workbench
   */

  export type AggregateWorkbench = {
    _count: WorkbenchCountAggregateOutputType | null
    _min: WorkbenchMinAggregateOutputType | null
    _max: WorkbenchMaxAggregateOutputType | null
  }

  export type WorkbenchMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    productId: string | null
    evaluationId: string | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus | null
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkbenchMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    productId: string | null
    evaluationId: string | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus | null
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkbenchCountAggregateOutputType = {
    id: number
    patientId: number
    productId: number
    evaluationId: number
    customization: number
    webhookUrl: number
    createdReason: number
    status: number
    failedAt: number
    completedAt: number
    submittedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkbenchMinAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkbenchMaxAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkbenchCountAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    customization?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkbenchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workbench to aggregate.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workbenches
    **/
    _count?: true | WorkbenchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkbenchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkbenchMaxAggregateInputType
  }

  export type GetWorkbenchAggregateType<T extends WorkbenchAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkbench]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkbench[P]>
      : GetScalarType<T[P], AggregateWorkbench[P]>
  }




  export type WorkbenchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithAggregationInput | WorkbenchOrderByWithAggregationInput[]
    by: WorkbenchScalarFieldEnum[] | WorkbenchScalarFieldEnum
    having?: WorkbenchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkbenchCountAggregateInputType | true
    _min?: WorkbenchMinAggregateInputType
    _max?: WorkbenchMaxAggregateInputType
  }

  export type WorkbenchGroupByOutputType = {
    id: string
    patientId: string
    productId: string
    evaluationId: string
    customization: JsonValue | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WorkbenchCountAggregateOutputType | null
    _min: WorkbenchMinAggregateOutputType | null
    _max: WorkbenchMaxAggregateOutputType | null
  }

  type GetWorkbenchGroupByPayload<T extends WorkbenchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkbenchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkbenchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkbenchGroupByOutputType[P]>
            : GetScalarType<T[P], WorkbenchGroupByOutputType[P]>
        }
      >
    >


  export type WorkbenchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    productId?: boolean
    evaluationId?: boolean
    customization?: boolean
    webhookUrl?: boolean
    createdReason?: boolean
    status?: boolean
    failedAt?: boolean
    completedAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    assets?: boolean | Workbench$assetsArgs<ExtArgs>
    orders?: boolean | Workbench$ordersArgs<ExtArgs>
    feet?: boolean | Workbench$feetArgs<ExtArgs>
    formSubmissions?: boolean | Workbench$formSubmissionsArgs<ExtArgs>
    notes?: boolean | Workbench$notesArgs<ExtArgs>
    _count?: boolean | WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workbench"]>

  export type WorkbenchSelectScalar = {
    id?: boolean
    patientId?: boolean
    productId?: boolean
    evaluationId?: boolean
    customization?: boolean
    webhookUrl?: boolean
    createdReason?: boolean
    status?: boolean
    failedAt?: boolean
    completedAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WorkbenchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    assets?: boolean | Workbench$assetsArgs<ExtArgs>
    orders?: boolean | Workbench$ordersArgs<ExtArgs>
    feet?: boolean | Workbench$feetArgs<ExtArgs>
    formSubmissions?: boolean | Workbench$formSubmissionsArgs<ExtArgs>
    notes?: boolean | Workbench$notesArgs<ExtArgs>
    _count?: boolean | WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WorkbenchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workbench"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      feet: Prisma.$FootPayload<ExtArgs>[]
      formSubmissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
      notes: Prisma.$WorkbenchNotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      productId: string
      evaluationId: string
      customization: Prisma.JsonValue | null
      webhookUrl: string | null
      createdReason: $Enums.WorkbenchCreatedReason | null
      status: $Enums.WorkbenchStatus
      failedAt: Date | null
      completedAt: Date | null
      submittedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workbench"]>
    composites: {}
  }


  type WorkbenchGetPayload<S extends boolean | null | undefined | WorkbenchDefaultArgs> = $Result.GetResult<Prisma.$WorkbenchPayload, S>

  type WorkbenchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkbenchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkbenchCountAggregateInputType | true
    }

  export interface WorkbenchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workbench'], meta: { name: 'Workbench' } }
    /**
     * Find zero or one Workbench that matches the filter.
     * @param {WorkbenchFindUniqueArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkbenchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Workbench that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkbenchFindUniqueOrThrowArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkbenchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Workbench that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindFirstArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkbenchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindFirstArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Workbench that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindFirstOrThrowArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkbenchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Workbenches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workbenches
     * const workbenches = await prisma.workbench.findMany()
     * 
     * // Get first 10 Workbenches
     * const workbenches = await prisma.workbench.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workbenchWithIdOnly = await prisma.workbench.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkbenchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Workbench.
     * @param {WorkbenchCreateArgs} args - Arguments to create a Workbench.
     * @example
     * // Create one Workbench
     * const Workbench = await prisma.workbench.create({
     *   data: {
     *     // ... data to create a Workbench
     *   }
     * })
     * 
    **/
    create<T extends WorkbenchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchCreateArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Workbenches.
     * @param {WorkbenchCreateManyArgs} args - Arguments to create many Workbenches.
     * @example
     * // Create many Workbenches
     * const workbench = await prisma.workbench.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkbenchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workbenches and returns the data saved in the database.
     * @param {WorkbenchCreateManyAndReturnArgs} args - Arguments to create many Workbenches.
     * @example
     * // Create many Workbenches
     * const workbench = await prisma.workbench.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workbenches and only return the `id`
     * const workbenchWithIdOnly = await prisma.workbench.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkbenchCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Workbench.
     * @param {WorkbenchDeleteArgs} args - Arguments to delete one Workbench.
     * @example
     * // Delete one Workbench
     * const Workbench = await prisma.workbench.delete({
     *   where: {
     *     // ... filter to delete one Workbench
     *   }
     * })
     * 
    **/
    delete<T extends WorkbenchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchDeleteArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Workbench.
     * @param {WorkbenchUpdateArgs} args - Arguments to update one Workbench.
     * @example
     * // Update one Workbench
     * const workbench = await prisma.workbench.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkbenchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpdateArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Workbenches.
     * @param {WorkbenchDeleteManyArgs} args - Arguments to filter Workbenches to delete.
     * @example
     * // Delete a few Workbenches
     * const { count } = await prisma.workbench.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkbenchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workbenches
     * const workbench = await prisma.workbench.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkbenchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workbench.
     * @param {WorkbenchUpsertArgs} args - Arguments to update or create a Workbench.
     * @example
     * // Update or create a Workbench
     * const workbench = await prisma.workbench.upsert({
     *   create: {
     *     // ... data to create a Workbench
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workbench we want to update
     *   }
     * })
    **/
    upsert<T extends WorkbenchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpsertArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Workbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchCountArgs} args - Arguments to filter Workbenches to count.
     * @example
     * // Count the number of Workbenches
     * const count = await prisma.workbench.count({
     *   where: {
     *     // ... the filter for the Workbenches we want to count
     *   }
     * })
    **/
    count<T extends WorkbenchCountArgs>(
      args?: Subset<T, WorkbenchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkbenchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkbenchAggregateArgs>(args: Subset<T, WorkbenchAggregateArgs>): Prisma.PrismaPromise<GetWorkbenchAggregateType<T>>

    /**
     * Group by Workbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkbenchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkbenchGroupByArgs['orderBy'] }
        : { orderBy?: WorkbenchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkbenchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkbenchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workbench model
   */
  readonly fields: WorkbenchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workbench.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkbenchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assets<T extends Workbench$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Workbench$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    feet<T extends Workbench$feetArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$feetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'> | Null>;

    formSubmissions<T extends Workbench$formSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$formSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends Workbench$notesArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Workbench model
   */ 
  interface WorkbenchFieldRefs {
    readonly id: FieldRef<"Workbench", 'String'>
    readonly patientId: FieldRef<"Workbench", 'String'>
    readonly productId: FieldRef<"Workbench", 'String'>
    readonly evaluationId: FieldRef<"Workbench", 'String'>
    readonly customization: FieldRef<"Workbench", 'Json'>
    readonly webhookUrl: FieldRef<"Workbench", 'String'>
    readonly createdReason: FieldRef<"Workbench", 'WorkbenchCreatedReason'>
    readonly status: FieldRef<"Workbench", 'WorkbenchStatus'>
    readonly failedAt: FieldRef<"Workbench", 'DateTime'>
    readonly completedAt: FieldRef<"Workbench", 'DateTime'>
    readonly submittedAt: FieldRef<"Workbench", 'DateTime'>
    readonly createdAt: FieldRef<"Workbench", 'DateTime'>
    readonly updatedAt: FieldRef<"Workbench", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workbench findUnique
   */
  export type WorkbenchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench findUniqueOrThrow
   */
  export type WorkbenchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench findFirst
   */
  export type WorkbenchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workbenches.
     */
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench findFirstOrThrow
   */
  export type WorkbenchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workbenches.
     */
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench findMany
   */
  export type WorkbenchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbenches to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench create
   */
  export type WorkbenchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data needed to create a Workbench.
     */
    data: XOR<WorkbenchCreateInput, WorkbenchUncheckedCreateInput>
  }

  /**
   * Workbench createMany
   */
  export type WorkbenchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workbenches.
     */
    data: WorkbenchCreateManyInput | WorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workbench createManyAndReturn
   */
  export type WorkbenchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data used to create many Workbenches.
     */
    data: WorkbenchCreateManyInput | WorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workbench update
   */
  export type WorkbenchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data needed to update a Workbench.
     */
    data: XOR<WorkbenchUpdateInput, WorkbenchUncheckedUpdateInput>
    /**
     * Choose, which Workbench to update.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench updateMany
   */
  export type WorkbenchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workbenches.
     */
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyInput>
    /**
     * Filter which Workbenches to update
     */
    where?: WorkbenchWhereInput
  }

  /**
   * Workbench upsert
   */
  export type WorkbenchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The filter to search for the Workbench to update in case it exists.
     */
    where: WorkbenchWhereUniqueInput
    /**
     * In case the Workbench found by the `where` argument doesn't exist, create a new Workbench with this data.
     */
    create: XOR<WorkbenchCreateInput, WorkbenchUncheckedCreateInput>
    /**
     * In case the Workbench was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkbenchUpdateInput, WorkbenchUncheckedUpdateInput>
  }

  /**
   * Workbench delete
   */
  export type WorkbenchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter which Workbench to delete.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench deleteMany
   */
  export type WorkbenchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workbenches to delete
     */
    where?: WorkbenchWhereInput
  }

  /**
   * Workbench.assets
   */
  export type Workbench$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Workbench.orders
   */
  export type Workbench$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Workbench.feet
   */
  export type Workbench$feetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    where?: FootWhereInput
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    cursor?: FootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Workbench.formSubmissions
   */
  export type Workbench$formSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Workbench.notes
   */
  export type Workbench$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    cursor?: WorkbenchNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * Workbench without action
   */
  export type WorkbenchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
  }


  /**
   * Model WorkbenchNotes
   */

  export type AggregateWorkbenchNotes = {
    _count: WorkbenchNotesCountAggregateOutputType | null
    _min: WorkbenchNotesMinAggregateOutputType | null
    _max: WorkbenchNotesMaxAggregateOutputType | null
  }

  export type WorkbenchNotesMinAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkbenchNotesMaxAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkbenchNotesCountAggregateOutputType = {
    id: number
    workbenchId: number
    title: number
    content: number
    tags: number
    blocks: number
    createdAt: number
    createdBy: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WorkbenchNotesMinAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkbenchNotesMaxAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkbenchNotesCountAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    tags?: true
    blocks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkbenchNotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkbenchNotes to aggregate.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkbenchNotes
    **/
    _count?: true | WorkbenchNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkbenchNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkbenchNotesMaxAggregateInputType
  }

  export type GetWorkbenchNotesAggregateType<T extends WorkbenchNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkbenchNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkbenchNotes[P]>
      : GetScalarType<T[P], AggregateWorkbenchNotes[P]>
  }




  export type WorkbenchNotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithAggregationInput | WorkbenchNotesOrderByWithAggregationInput[]
    by: WorkbenchNotesScalarFieldEnum[] | WorkbenchNotesScalarFieldEnum
    having?: WorkbenchNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkbenchNotesCountAggregateInputType | true
    _min?: WorkbenchNotesMinAggregateInputType
    _max?: WorkbenchNotesMaxAggregateInputType
  }

  export type WorkbenchNotesGroupByOutputType = {
    id: string
    workbenchId: string
    title: string | null
    content: string | null
    tags: string[]
    blocks: JsonValue | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    deletedAt: Date | null
    _count: WorkbenchNotesCountAggregateOutputType | null
    _min: WorkbenchNotesMinAggregateOutputType | null
    _max: WorkbenchNotesMaxAggregateOutputType | null
  }

  type GetWorkbenchNotesGroupByPayload<T extends WorkbenchNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkbenchNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkbenchNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkbenchNotesGroupByOutputType[P]>
            : GetScalarType<T[P], WorkbenchNotesGroupByOutputType[P]>
        }
      >
    >


  export type WorkbenchNotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workbenchId?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    blocks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    createdByUser?: boolean | WorkbenchNotes$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["workbenchNotes"]>

  export type WorkbenchNotesSelectScalar = {
    id?: boolean
    workbenchId?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    blocks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }


  export type WorkbenchNotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    createdByUser?: boolean | WorkbenchNotes$createdByUserArgs<ExtArgs>
  }


  export type $WorkbenchNotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkbenchNotes"
    objects: {
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workbenchId: string
      title: string | null
      content: string | null
      tags: string[]
      blocks: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["workbenchNotes"]>
    composites: {}
  }


  type WorkbenchNotesGetPayload<S extends boolean | null | undefined | WorkbenchNotesDefaultArgs> = $Result.GetResult<Prisma.$WorkbenchNotesPayload, S>

  type WorkbenchNotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkbenchNotesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkbenchNotesCountAggregateInputType | true
    }

  export interface WorkbenchNotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkbenchNotes'], meta: { name: 'WorkbenchNotes' } }
    /**
     * Find zero or one WorkbenchNotes that matches the filter.
     * @param {WorkbenchNotesFindUniqueArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkbenchNotesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WorkbenchNotes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkbenchNotesFindUniqueOrThrowArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WorkbenchNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindFirstArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkbenchNotesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindFirstArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WorkbenchNotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindFirstOrThrowArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WorkbenchNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findMany()
     * 
     * // Get first 10 WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workbenchNotesWithIdOnly = await prisma.workbenchNotes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkbenchNotesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WorkbenchNotes.
     * @param {WorkbenchNotesCreateArgs} args - Arguments to create a WorkbenchNotes.
     * @example
     * // Create one WorkbenchNotes
     * const WorkbenchNotes = await prisma.workbenchNotes.create({
     *   data: {
     *     // ... data to create a WorkbenchNotes
     *   }
     * })
     * 
    **/
    create<T extends WorkbenchNotesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesCreateArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WorkbenchNotes.
     * @param {WorkbenchNotesCreateManyArgs} args - Arguments to create many WorkbenchNotes.
     * @example
     * // Create many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkbenchNotesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkbenchNotes and returns the data saved in the database.
     * @param {WorkbenchNotesCreateManyAndReturnArgs} args - Arguments to create many WorkbenchNotes.
     * @example
     * // Create many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkbenchNotes and only return the `id`
     * const workbenchNotesWithIdOnly = await prisma.workbenchNotes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a WorkbenchNotes.
     * @param {WorkbenchNotesDeleteArgs} args - Arguments to delete one WorkbenchNotes.
     * @example
     * // Delete one WorkbenchNotes
     * const WorkbenchNotes = await prisma.workbenchNotes.delete({
     *   where: {
     *     // ... filter to delete one WorkbenchNotes
     *   }
     * })
     * 
    **/
    delete<T extends WorkbenchNotesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesDeleteArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WorkbenchNotes.
     * @param {WorkbenchNotesUpdateArgs} args - Arguments to update one WorkbenchNotes.
     * @example
     * // Update one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkbenchNotesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpdateArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WorkbenchNotes.
     * @param {WorkbenchNotesDeleteManyArgs} args - Arguments to filter WorkbenchNotes to delete.
     * @example
     * // Delete a few WorkbenchNotes
     * const { count } = await prisma.workbenchNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkbenchNotesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkbenchNotesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkbenchNotes.
     * @param {WorkbenchNotesUpsertArgs} args - Arguments to update or create a WorkbenchNotes.
     * @example
     * // Update or create a WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.upsert({
     *   create: {
     *     // ... data to create a WorkbenchNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkbenchNotes we want to update
     *   }
     * })
    **/
    upsert<T extends WorkbenchNotesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpsertArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesCountArgs} args - Arguments to filter WorkbenchNotes to count.
     * @example
     * // Count the number of WorkbenchNotes
     * const count = await prisma.workbenchNotes.count({
     *   where: {
     *     // ... the filter for the WorkbenchNotes we want to count
     *   }
     * })
    **/
    count<T extends WorkbenchNotesCountArgs>(
      args?: Subset<T, WorkbenchNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkbenchNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkbenchNotesAggregateArgs>(args: Subset<T, WorkbenchNotesAggregateArgs>): Prisma.PrismaPromise<GetWorkbenchNotesAggregateType<T>>

    /**
     * Group by WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkbenchNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkbenchNotesGroupByArgs['orderBy'] }
        : { orderBy?: WorkbenchNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkbenchNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkbenchNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkbenchNotes model
   */
  readonly fields: WorkbenchNotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkbenchNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkbenchNotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    createdByUser<T extends WorkbenchNotes$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchNotes$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WorkbenchNotes model
   */ 
  interface WorkbenchNotesFieldRefs {
    readonly id: FieldRef<"WorkbenchNotes", 'String'>
    readonly workbenchId: FieldRef<"WorkbenchNotes", 'String'>
    readonly title: FieldRef<"WorkbenchNotes", 'String'>
    readonly content: FieldRef<"WorkbenchNotes", 'String'>
    readonly tags: FieldRef<"WorkbenchNotes", 'String[]'>
    readonly blocks: FieldRef<"WorkbenchNotes", 'Json'>
    readonly createdAt: FieldRef<"WorkbenchNotes", 'DateTime'>
    readonly createdBy: FieldRef<"WorkbenchNotes", 'String'>
    readonly updatedAt: FieldRef<"WorkbenchNotes", 'DateTime'>
    readonly deletedAt: FieldRef<"WorkbenchNotes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkbenchNotes findUnique
   */
  export type WorkbenchNotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes findUniqueOrThrow
   */
  export type WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes findFirst
   */
  export type WorkbenchNotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkbenchNotes.
     */
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes findFirstOrThrow
   */
  export type WorkbenchNotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkbenchNotes.
     */
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes findMany
   */
  export type WorkbenchNotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes create
   */
  export type WorkbenchNotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesCreateInput, WorkbenchNotesUncheckedCreateInput>
  }

  /**
   * WorkbenchNotes createMany
   */
  export type WorkbenchNotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkbenchNotes.
     */
    data: WorkbenchNotesCreateManyInput | WorkbenchNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkbenchNotes createManyAndReturn
   */
  export type WorkbenchNotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data used to create many WorkbenchNotes.
     */
    data: WorkbenchNotesCreateManyInput | WorkbenchNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkbenchNotes update
   */
  export type WorkbenchNotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesUpdateInput, WorkbenchNotesUncheckedUpdateInput>
    /**
     * Choose, which WorkbenchNotes to update.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes updateMany
   */
  export type WorkbenchNotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyInput>
    /**
     * Filter which WorkbenchNotes to update
     */
    where?: WorkbenchNotesWhereInput
  }

  /**
   * WorkbenchNotes upsert
   */
  export type WorkbenchNotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkbenchNotes to update in case it exists.
     */
    where: WorkbenchNotesWhereUniqueInput
    /**
     * In case the WorkbenchNotes found by the `where` argument doesn't exist, create a new WorkbenchNotes with this data.
     */
    create: XOR<WorkbenchNotesCreateInput, WorkbenchNotesUncheckedCreateInput>
    /**
     * In case the WorkbenchNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkbenchNotesUpdateInput, WorkbenchNotesUncheckedUpdateInput>
  }

  /**
   * WorkbenchNotes delete
   */
  export type WorkbenchNotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter which WorkbenchNotes to delete.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes deleteMany
   */
  export type WorkbenchNotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkbenchNotes to delete
     */
    where?: WorkbenchNotesWhereInput
  }

  /**
   * WorkbenchNotes.createdByUser
   */
  export type WorkbenchNotes$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkbenchNotes without action
   */
  export type WorkbenchNotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    status: $Enums.OrderStatus | null
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean | null
    authorizationStatus: $Enums.OrderAuthorizationStatus | null
    shippingLabelId: string | null
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    status: $Enums.OrderStatus | null
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean | null
    authorizationStatus: $Enums.OrderAuthorizationStatus | null
    shippingLabelId: string | null
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    workbenchId: number
    status: number
    statusUpdatedAt: number
    committedDeliveryAt: number
    parcelId: number
    active: number
    authorizationStatus: number
    shippingLabelId: number
    authorizationUpdatedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    shippingLabelId?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    shippingLabelId?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    shippingLabelId?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    workbenchId: string
    status: $Enums.OrderStatus
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    shippingLabelId: string | null
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workbenchId?: boolean
    status?: boolean
    statusUpdatedAt?: boolean
    committedDeliveryAt?: boolean
    parcelId?: boolean
    active?: boolean
    authorizationStatus?: boolean
    shippingLabelId?: boolean
    authorizationUpdatedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    shippingLabel?: boolean | Order$shippingLabelArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    workbenchId?: boolean
    status?: boolean
    statusUpdatedAt?: boolean
    committedDeliveryAt?: boolean
    parcelId?: boolean
    active?: boolean
    authorizationStatus?: boolean
    shippingLabelId?: boolean
    authorizationUpdatedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    shippingLabel?: boolean | Order$shippingLabelArgs<ExtArgs>
  }


  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
      shippingLabel: Prisma.$ShippingLabelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workbenchId: string
      status: $Enums.OrderStatus
      statusUpdatedAt: Date | null
      committedDeliveryAt: Date | null
      parcelId: string | null
      active: boolean
      authorizationStatus: $Enums.OrderAuthorizationStatus
      shippingLabelId: string | null
      authorizationUpdatedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shippingLabel<T extends Order$shippingLabelArgs<ExtArgs> = {}>(args?: Subset<T, Order$shippingLabelArgs<ExtArgs>>): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly workbenchId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly statusUpdatedAt: FieldRef<"Order", 'DateTime'>
    readonly committedDeliveryAt: FieldRef<"Order", 'DateTime'>
    readonly parcelId: FieldRef<"Order", 'String'>
    readonly active: FieldRef<"Order", 'Boolean'>
    readonly authorizationStatus: FieldRef<"Order", 'OrderAuthorizationStatus'>
    readonly shippingLabelId: FieldRef<"Order", 'String'>
    readonly authorizationUpdatedAt: FieldRef<"Order", 'DateTime'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.shippingLabel
   */
  export type Order$shippingLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    where?: ShippingLabelWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    stateOrProvince: string | null
    postalCode: string | null
    countryCode: string | null
    shippingAccountId: string | null
    phoneNumber: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    stateOrProvince: string | null
    postalCode: string | null
    countryCode: string | null
    shippingAccountId: string | null
    phoneNumber: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    addressLine1: number
    addressLine2: number
    city: number
    stateOrProvince: number
    postalCode: number
    countryCode: number
    shippingAccountId: number
    phoneNumber: number
    shippingAccountCarrier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    phoneNumber?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    phoneNumber?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    phoneNumber?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string | null
    addressLine1: string
    addressLine2: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId: string | null
    phoneNumber: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    stateOrProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    shippingAccountId?: boolean
    phoneNumber?: boolean
    shippingAccountCarrier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilities?: boolean | Contact$facilitiesArgs<ExtArgs>
    patients?: boolean | Contact$patientsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    stateOrProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    shippingAccountId?: boolean
    phoneNumber?: boolean
    shippingAccountCarrier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | Contact$facilitiesArgs<ExtArgs>
    patients?: boolean | Contact$patientsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
      patients: Prisma.$CompanyPatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      addressLine1: string
      addressLine2: string | null
      city: string
      stateOrProvince: string
      postalCode: string
      countryCode: string
      shippingAccountId: string | null
      phoneNumber: string | null
      shippingAccountCarrier: $Enums.Carrier | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }


  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
    **/
    create<T extends ContactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactCreateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ContactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
    **/
    delete<T extends ContactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facilities<T extends Contact$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    patients<T extends Contact$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly addressLine1: FieldRef<"Contact", 'String'>
    readonly addressLine2: FieldRef<"Contact", 'String'>
    readonly city: FieldRef<"Contact", 'String'>
    readonly stateOrProvince: FieldRef<"Contact", 'String'>
    readonly postalCode: FieldRef<"Contact", 'String'>
    readonly countryCode: FieldRef<"Contact", 'String'>
    readonly shippingAccountId: FieldRef<"Contact", 'String'>
    readonly phoneNumber: FieldRef<"Contact", 'String'>
    readonly shippingAccountCarrier: FieldRef<"Contact", 'Carrier'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.facilities
   */
  export type Contact$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Contact.patients
   */
  export type Contact$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    cursor?: CompanyPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ShippingPackage
   */

  export type AggregateShippingPackage = {
    _count: ShippingPackageCountAggregateOutputType | null
    _avg: ShippingPackageAvgAggregateOutputType | null
    _sum: ShippingPackageSumAggregateOutputType | null
    _min: ShippingPackageMinAggregateOutputType | null
    _max: ShippingPackageMaxAggregateOutputType | null
  }

  export type ShippingPackageAvgAggregateOutputType = {
    weight: number | null
    length: number | null
    width: number | null
    height: number | null
    insoleCapacity: number | null
  }

  export type ShippingPackageSumAggregateOutputType = {
    weight: number | null
    length: number | null
    width: number | null
    height: number | null
    insoleCapacity: number | null
  }

  export type ShippingPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    weightUnit: $Enums.WeightUnit | null
    length: number | null
    width: number | null
    height: number | null
    dimensionUnit: $Enums.DimensionUnit | null
    insoleCapacity: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    weightUnit: $Enums.WeightUnit | null
    length: number | null
    width: number | null
    height: number | null
    dimensionUnit: $Enums.DimensionUnit | null
    insoleCapacity: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingPackageCountAggregateOutputType = {
    id: number
    name: number
    weight: number
    weightUnit: number
    length: number
    width: number
    height: number
    dimensionUnit: number
    insoleCapacity: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingPackageAvgAggregateInputType = {
    weight?: true
    length?: true
    width?: true
    height?: true
    insoleCapacity?: true
  }

  export type ShippingPackageSumAggregateInputType = {
    weight?: true
    length?: true
    width?: true
    height?: true
    insoleCapacity?: true
  }

  export type ShippingPackageMinAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingPackageMaxAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingPackageCountAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingPackage to aggregate.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingPackages
    **/
    _count?: true | ShippingPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingPackageMaxAggregateInputType
  }

  export type GetShippingPackageAggregateType<T extends ShippingPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingPackage[P]>
      : GetScalarType<T[P], AggregateShippingPackage[P]>
  }




  export type ShippingPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingPackageWhereInput
    orderBy?: ShippingPackageOrderByWithAggregationInput | ShippingPackageOrderByWithAggregationInput[]
    by: ShippingPackageScalarFieldEnum[] | ShippingPackageScalarFieldEnum
    having?: ShippingPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingPackageCountAggregateInputType | true
    _avg?: ShippingPackageAvgAggregateInputType
    _sum?: ShippingPackageSumAggregateInputType
    _min?: ShippingPackageMinAggregateInputType
    _max?: ShippingPackageMaxAggregateInputType
  }

  export type ShippingPackageGroupByOutputType = {
    id: string
    name: string
    weight: number
    weightUnit: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: ShippingPackageCountAggregateOutputType | null
    _avg: ShippingPackageAvgAggregateOutputType | null
    _sum: ShippingPackageSumAggregateOutputType | null
    _min: ShippingPackageMinAggregateOutputType | null
    _max: ShippingPackageMaxAggregateOutputType | null
  }

  type GetShippingPackageGroupByPayload<T extends ShippingPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingPackageGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingPackageGroupByOutputType[P]>
        }
      >
    >


  export type ShippingPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    weightUnit?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    dimensionUnit?: boolean
    insoleCapacity?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingPackage"]>

  export type ShippingPackageSelectScalar = {
    id?: boolean
    name?: boolean
    weight?: boolean
    weightUnit?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    dimensionUnit?: boolean
    insoleCapacity?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ShippingPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $ShippingPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingPackage"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weight: number
      weightUnit: $Enums.WeightUnit
      length: number
      width: number
      height: number
      dimensionUnit: $Enums.DimensionUnit
      insoleCapacity: number
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingPackage"]>
    composites: {}
  }


  type ShippingPackageGetPayload<S extends boolean | null | undefined | ShippingPackageDefaultArgs> = $Result.GetResult<Prisma.$ShippingPackagePayload, S>

  type ShippingPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShippingPackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShippingPackageCountAggregateInputType | true
    }

  export interface ShippingPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingPackage'], meta: { name: 'ShippingPackage' } }
    /**
     * Find zero or one ShippingPackage that matches the filter.
     * @param {ShippingPackageFindUniqueArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingPackageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageFindUniqueArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShippingPackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShippingPackageFindUniqueOrThrowArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShippingPackageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShippingPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindFirstArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingPackageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindFirstArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShippingPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindFirstOrThrowArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShippingPackageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShippingPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingPackages
     * const shippingPackages = await prisma.shippingPackage.findMany()
     * 
     * // Get first 10 ShippingPackages
     * const shippingPackages = await prisma.shippingPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingPackageWithIdOnly = await prisma.shippingPackage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingPackageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShippingPackage.
     * @param {ShippingPackageCreateArgs} args - Arguments to create a ShippingPackage.
     * @example
     * // Create one ShippingPackage
     * const ShippingPackage = await prisma.shippingPackage.create({
     *   data: {
     *     // ... data to create a ShippingPackage
     *   }
     * })
     * 
    **/
    create<T extends ShippingPackageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageCreateArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShippingPackages.
     * @param {ShippingPackageCreateManyArgs} args - Arguments to create many ShippingPackages.
     * @example
     * // Create many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShippingPackageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingPackages and returns the data saved in the database.
     * @param {ShippingPackageCreateManyAndReturnArgs} args - Arguments to create many ShippingPackages.
     * @example
     * // Create many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingPackages and only return the `id`
     * const shippingPackageWithIdOnly = await prisma.shippingPackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShippingPackageCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ShippingPackage.
     * @param {ShippingPackageDeleteArgs} args - Arguments to delete one ShippingPackage.
     * @example
     * // Delete one ShippingPackage
     * const ShippingPackage = await prisma.shippingPackage.delete({
     *   where: {
     *     // ... filter to delete one ShippingPackage
     *   }
     * })
     * 
    **/
    delete<T extends ShippingPackageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageDeleteArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShippingPackage.
     * @param {ShippingPackageUpdateArgs} args - Arguments to update one ShippingPackage.
     * @example
     * // Update one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingPackageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpdateArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShippingPackages.
     * @param {ShippingPackageDeleteManyArgs} args - Arguments to filter ShippingPackages to delete.
     * @example
     * // Delete a few ShippingPackages
     * const { count } = await prisma.shippingPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingPackageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingPackageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingPackage.
     * @param {ShippingPackageUpsertArgs} args - Arguments to update or create a ShippingPackage.
     * @example
     * // Update or create a ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.upsert({
     *   create: {
     *     // ... data to create a ShippingPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingPackage we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingPackageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpsertArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShippingPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageCountArgs} args - Arguments to filter ShippingPackages to count.
     * @example
     * // Count the number of ShippingPackages
     * const count = await prisma.shippingPackage.count({
     *   where: {
     *     // ... the filter for the ShippingPackages we want to count
     *   }
     * })
    **/
    count<T extends ShippingPackageCountArgs>(
      args?: Subset<T, ShippingPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingPackageAggregateArgs>(args: Subset<T, ShippingPackageAggregateArgs>): Prisma.PrismaPromise<GetShippingPackageAggregateType<T>>

    /**
     * Group by ShippingPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingPackageGroupByArgs['orderBy'] }
        : { orderBy?: ShippingPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingPackage model
   */
  readonly fields: ShippingPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShippingPackage model
   */ 
  interface ShippingPackageFieldRefs {
    readonly id: FieldRef<"ShippingPackage", 'String'>
    readonly name: FieldRef<"ShippingPackage", 'String'>
    readonly weight: FieldRef<"ShippingPackage", 'Float'>
    readonly weightUnit: FieldRef<"ShippingPackage", 'WeightUnit'>
    readonly length: FieldRef<"ShippingPackage", 'Float'>
    readonly width: FieldRef<"ShippingPackage", 'Float'>
    readonly height: FieldRef<"ShippingPackage", 'Float'>
    readonly dimensionUnit: FieldRef<"ShippingPackage", 'DimensionUnit'>
    readonly insoleCapacity: FieldRef<"ShippingPackage", 'Int'>
    readonly companyId: FieldRef<"ShippingPackage", 'String'>
    readonly createdAt: FieldRef<"ShippingPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingPackage findUnique
   */
  export type ShippingPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage findUniqueOrThrow
   */
  export type ShippingPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage findFirst
   */
  export type ShippingPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingPackages.
     */
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage findFirstOrThrow
   */
  export type ShippingPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingPackages.
     */
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage findMany
   */
  export type ShippingPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackages to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage create
   */
  export type ShippingPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingPackage.
     */
    data: XOR<ShippingPackageCreateInput, ShippingPackageUncheckedCreateInput>
  }

  /**
   * ShippingPackage createMany
   */
  export type ShippingPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingPackages.
     */
    data: ShippingPackageCreateManyInput | ShippingPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingPackage createManyAndReturn
   */
  export type ShippingPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data used to create many ShippingPackages.
     */
    data: ShippingPackageCreateManyInput | ShippingPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingPackage update
   */
  export type ShippingPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingPackage.
     */
    data: XOR<ShippingPackageUpdateInput, ShippingPackageUncheckedUpdateInput>
    /**
     * Choose, which ShippingPackage to update.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage updateMany
   */
  export type ShippingPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingPackages.
     */
    data: XOR<ShippingPackageUpdateManyMutationInput, ShippingPackageUncheckedUpdateManyInput>
    /**
     * Filter which ShippingPackages to update
     */
    where?: ShippingPackageWhereInput
  }

  /**
   * ShippingPackage upsert
   */
  export type ShippingPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingPackage to update in case it exists.
     */
    where: ShippingPackageWhereUniqueInput
    /**
     * In case the ShippingPackage found by the `where` argument doesn't exist, create a new ShippingPackage with this data.
     */
    create: XOR<ShippingPackageCreateInput, ShippingPackageUncheckedCreateInput>
    /**
     * In case the ShippingPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingPackageUpdateInput, ShippingPackageUncheckedUpdateInput>
  }

  /**
   * ShippingPackage delete
   */
  export type ShippingPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter which ShippingPackage to delete.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage deleteMany
   */
  export type ShippingPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingPackages to delete
     */
    where?: ShippingPackageWhereInput
  }

  /**
   * ShippingPackage without action
   */
  export type ShippingPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
  }


  /**
   * Model ShippingLabel
   */

  export type AggregateShippingLabel = {
    _count: ShippingLabelCountAggregateOutputType | null
    _min: ShippingLabelMinAggregateOutputType | null
    _max: ShippingLabelMaxAggregateOutputType | null
  }

  export type ShippingLabelMinAggregateOutputType = {
    id: string | null
    addressName: string | null
    facilityId: string | null
    labelId: string | null
    trackingNumber: string | null
    trackingStatus: $Enums.ShippingTrackingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingLabelMaxAggregateOutputType = {
    id: string | null
    addressName: string | null
    facilityId: string | null
    labelId: string | null
    trackingNumber: string | null
    trackingStatus: $Enums.ShippingTrackingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingLabelCountAggregateOutputType = {
    id: number
    addressName: number
    facilityId: number
    labelId: number
    trackingNumber: number
    trackingStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingLabelMinAggregateInputType = {
    id?: true
    addressName?: true
    facilityId?: true
    labelId?: true
    trackingNumber?: true
    trackingStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingLabelMaxAggregateInputType = {
    id?: true
    addressName?: true
    facilityId?: true
    labelId?: true
    trackingNumber?: true
    trackingStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingLabelCountAggregateInputType = {
    id?: true
    addressName?: true
    facilityId?: true
    labelId?: true
    trackingNumber?: true
    trackingStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingLabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingLabel to aggregate.
     */
    where?: ShippingLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingLabels to fetch.
     */
    orderBy?: ShippingLabelOrderByWithRelationInput | ShippingLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingLabels
    **/
    _count?: true | ShippingLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingLabelMaxAggregateInputType
  }

  export type GetShippingLabelAggregateType<T extends ShippingLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingLabel[P]>
      : GetScalarType<T[P], AggregateShippingLabel[P]>
  }




  export type ShippingLabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingLabelWhereInput
    orderBy?: ShippingLabelOrderByWithAggregationInput | ShippingLabelOrderByWithAggregationInput[]
    by: ShippingLabelScalarFieldEnum[] | ShippingLabelScalarFieldEnum
    having?: ShippingLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingLabelCountAggregateInputType | true
    _min?: ShippingLabelMinAggregateInputType
    _max?: ShippingLabelMaxAggregateInputType
  }

  export type ShippingLabelGroupByOutputType = {
    id: string
    addressName: string
    facilityId: string | null
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt: Date
    updatedAt: Date
    _count: ShippingLabelCountAggregateOutputType | null
    _min: ShippingLabelMinAggregateOutputType | null
    _max: ShippingLabelMaxAggregateOutputType | null
  }

  type GetShippingLabelGroupByPayload<T extends ShippingLabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingLabelGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingLabelGroupByOutputType[P]>
        }
      >
    >


  export type ShippingLabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressName?: boolean
    facilityId?: boolean
    labelId?: boolean
    trackingNumber?: boolean
    trackingStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facility?: boolean | ShippingLabel$facilityArgs<ExtArgs>
    orders?: boolean | ShippingLabel$ordersArgs<ExtArgs>
    _count?: boolean | ShippingLabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingLabel"]>

  export type ShippingLabelSelectScalar = {
    id?: boolean
    addressName?: boolean
    facilityId?: boolean
    labelId?: boolean
    trackingNumber?: boolean
    trackingStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ShippingLabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | ShippingLabel$facilityArgs<ExtArgs>
    orders?: boolean | ShippingLabel$ordersArgs<ExtArgs>
    _count?: boolean | ShippingLabelCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ShippingLabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingLabel"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      addressName: string
      facilityId: string | null
      labelId: string
      trackingNumber: string
      trackingStatus: $Enums.ShippingTrackingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingLabel"]>
    composites: {}
  }


  type ShippingLabelGetPayload<S extends boolean | null | undefined | ShippingLabelDefaultArgs> = $Result.GetResult<Prisma.$ShippingLabelPayload, S>

  type ShippingLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShippingLabelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShippingLabelCountAggregateInputType | true
    }

  export interface ShippingLabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingLabel'], meta: { name: 'ShippingLabel' } }
    /**
     * Find zero or one ShippingLabel that matches the filter.
     * @param {ShippingLabelFindUniqueArgs} args - Arguments to find a ShippingLabel
     * @example
     * // Get one ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingLabelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelFindUniqueArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShippingLabel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShippingLabelFindUniqueOrThrowArgs} args - Arguments to find a ShippingLabel
     * @example
     * // Get one ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShippingLabelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShippingLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelFindFirstArgs} args - Arguments to find a ShippingLabel
     * @example
     * // Get one ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingLabelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelFindFirstArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShippingLabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelFindFirstOrThrowArgs} args - Arguments to find a ShippingLabel
     * @example
     * // Get one ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShippingLabelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShippingLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingLabels
     * const shippingLabels = await prisma.shippingLabel.findMany()
     * 
     * // Get first 10 ShippingLabels
     * const shippingLabels = await prisma.shippingLabel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingLabelWithIdOnly = await prisma.shippingLabel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingLabelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShippingLabel.
     * @param {ShippingLabelCreateArgs} args - Arguments to create a ShippingLabel.
     * @example
     * // Create one ShippingLabel
     * const ShippingLabel = await prisma.shippingLabel.create({
     *   data: {
     *     // ... data to create a ShippingLabel
     *   }
     * })
     * 
    **/
    create<T extends ShippingLabelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelCreateArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShippingLabels.
     * @param {ShippingLabelCreateManyArgs} args - Arguments to create many ShippingLabels.
     * @example
     * // Create many ShippingLabels
     * const shippingLabel = await prisma.shippingLabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShippingLabelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingLabels and returns the data saved in the database.
     * @param {ShippingLabelCreateManyAndReturnArgs} args - Arguments to create many ShippingLabels.
     * @example
     * // Create many ShippingLabels
     * const shippingLabel = await prisma.shippingLabel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingLabels and only return the `id`
     * const shippingLabelWithIdOnly = await prisma.shippingLabel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShippingLabelCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ShippingLabel.
     * @param {ShippingLabelDeleteArgs} args - Arguments to delete one ShippingLabel.
     * @example
     * // Delete one ShippingLabel
     * const ShippingLabel = await prisma.shippingLabel.delete({
     *   where: {
     *     // ... filter to delete one ShippingLabel
     *   }
     * })
     * 
    **/
    delete<T extends ShippingLabelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelDeleteArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShippingLabel.
     * @param {ShippingLabelUpdateArgs} args - Arguments to update one ShippingLabel.
     * @example
     * // Update one ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingLabelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelUpdateArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShippingLabels.
     * @param {ShippingLabelDeleteManyArgs} args - Arguments to filter ShippingLabels to delete.
     * @example
     * // Delete a few ShippingLabels
     * const { count } = await prisma.shippingLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingLabelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingLabelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingLabels
     * const shippingLabel = await prisma.shippingLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingLabelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingLabel.
     * @param {ShippingLabelUpsertArgs} args - Arguments to update or create a ShippingLabel.
     * @example
     * // Update or create a ShippingLabel
     * const shippingLabel = await prisma.shippingLabel.upsert({
     *   create: {
     *     // ... data to create a ShippingLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingLabel we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingLabelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingLabelUpsertArgs<ExtArgs>>
    ): Prisma__ShippingLabelClient<$Result.GetResult<Prisma.$ShippingLabelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShippingLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelCountArgs} args - Arguments to filter ShippingLabels to count.
     * @example
     * // Count the number of ShippingLabels
     * const count = await prisma.shippingLabel.count({
     *   where: {
     *     // ... the filter for the ShippingLabels we want to count
     *   }
     * })
    **/
    count<T extends ShippingLabelCountArgs>(
      args?: Subset<T, ShippingLabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingLabelAggregateArgs>(args: Subset<T, ShippingLabelAggregateArgs>): Prisma.PrismaPromise<GetShippingLabelAggregateType<T>>

    /**
     * Group by ShippingLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingLabelGroupByArgs['orderBy'] }
        : { orderBy?: ShippingLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingLabel model
   */
  readonly fields: ShippingLabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingLabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facility<T extends ShippingLabel$facilityArgs<ExtArgs> = {}>(args?: Subset<T, ShippingLabel$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    orders<T extends ShippingLabel$ordersArgs<ExtArgs> = {}>(args?: Subset<T, ShippingLabel$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShippingLabel model
   */ 
  interface ShippingLabelFieldRefs {
    readonly id: FieldRef<"ShippingLabel", 'String'>
    readonly addressName: FieldRef<"ShippingLabel", 'String'>
    readonly facilityId: FieldRef<"ShippingLabel", 'String'>
    readonly labelId: FieldRef<"ShippingLabel", 'String'>
    readonly trackingNumber: FieldRef<"ShippingLabel", 'String'>
    readonly trackingStatus: FieldRef<"ShippingLabel", 'ShippingTrackingStatus'>
    readonly createdAt: FieldRef<"ShippingLabel", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingLabel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingLabel findUnique
   */
  export type ShippingLabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter, which ShippingLabel to fetch.
     */
    where: ShippingLabelWhereUniqueInput
  }

  /**
   * ShippingLabel findUniqueOrThrow
   */
  export type ShippingLabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter, which ShippingLabel to fetch.
     */
    where: ShippingLabelWhereUniqueInput
  }

  /**
   * ShippingLabel findFirst
   */
  export type ShippingLabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter, which ShippingLabel to fetch.
     */
    where?: ShippingLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingLabels to fetch.
     */
    orderBy?: ShippingLabelOrderByWithRelationInput | ShippingLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingLabels.
     */
    cursor?: ShippingLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingLabels.
     */
    distinct?: ShippingLabelScalarFieldEnum | ShippingLabelScalarFieldEnum[]
  }

  /**
   * ShippingLabel findFirstOrThrow
   */
  export type ShippingLabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter, which ShippingLabel to fetch.
     */
    where?: ShippingLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingLabels to fetch.
     */
    orderBy?: ShippingLabelOrderByWithRelationInput | ShippingLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingLabels.
     */
    cursor?: ShippingLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingLabels.
     */
    distinct?: ShippingLabelScalarFieldEnum | ShippingLabelScalarFieldEnum[]
  }

  /**
   * ShippingLabel findMany
   */
  export type ShippingLabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter, which ShippingLabels to fetch.
     */
    where?: ShippingLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingLabels to fetch.
     */
    orderBy?: ShippingLabelOrderByWithRelationInput | ShippingLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingLabels.
     */
    cursor?: ShippingLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingLabels.
     */
    skip?: number
    distinct?: ShippingLabelScalarFieldEnum | ShippingLabelScalarFieldEnum[]
  }

  /**
   * ShippingLabel create
   */
  export type ShippingLabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingLabel.
     */
    data: XOR<ShippingLabelCreateInput, ShippingLabelUncheckedCreateInput>
  }

  /**
   * ShippingLabel createMany
   */
  export type ShippingLabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingLabels.
     */
    data: ShippingLabelCreateManyInput | ShippingLabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingLabel createManyAndReturn
   */
  export type ShippingLabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * The data used to create many ShippingLabels.
     */
    data: ShippingLabelCreateManyInput | ShippingLabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingLabel update
   */
  export type ShippingLabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingLabel.
     */
    data: XOR<ShippingLabelUpdateInput, ShippingLabelUncheckedUpdateInput>
    /**
     * Choose, which ShippingLabel to update.
     */
    where: ShippingLabelWhereUniqueInput
  }

  /**
   * ShippingLabel updateMany
   */
  export type ShippingLabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingLabels.
     */
    data: XOR<ShippingLabelUpdateManyMutationInput, ShippingLabelUncheckedUpdateManyInput>
    /**
     * Filter which ShippingLabels to update
     */
    where?: ShippingLabelWhereInput
  }

  /**
   * ShippingLabel upsert
   */
  export type ShippingLabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingLabel to update in case it exists.
     */
    where: ShippingLabelWhereUniqueInput
    /**
     * In case the ShippingLabel found by the `where` argument doesn't exist, create a new ShippingLabel with this data.
     */
    create: XOR<ShippingLabelCreateInput, ShippingLabelUncheckedCreateInput>
    /**
     * In case the ShippingLabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingLabelUpdateInput, ShippingLabelUncheckedUpdateInput>
  }

  /**
   * ShippingLabel delete
   */
  export type ShippingLabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
    /**
     * Filter which ShippingLabel to delete.
     */
    where: ShippingLabelWhereUniqueInput
  }

  /**
   * ShippingLabel deleteMany
   */
  export type ShippingLabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingLabels to delete
     */
    where?: ShippingLabelWhereInput
  }

  /**
   * ShippingLabel.facility
   */
  export type ShippingLabel$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * ShippingLabel.orders
   */
  export type ShippingLabel$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * ShippingLabel without action
   */
  export type ShippingLabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingLabel
     */
    select?: ShippingLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingLabelInclude<ExtArgs> | null
  }


  /**
   * Model Physician
   */

  export type AggregatePhysician = {
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  export type PhysicianMinAggregateOutputType = {
    id: string | null
    name: string | null
    npi: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicianMaxAggregateOutputType = {
    id: string | null
    name: string | null
    npi: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicianCountAggregateOutputType = {
    id: number
    name: number
    npi: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhysicianMinAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicianMaxAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicianCountAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhysicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physician to aggregate.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Physicians
    **/
    _count?: true | PhysicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhysicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhysicianMaxAggregateInputType
  }

  export type GetPhysicianAggregateType<T extends PhysicianAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician[P]>
      : GetScalarType<T[P], AggregatePhysician[P]>
  }




  export type PhysicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhysicianWhereInput
    orderBy?: PhysicianOrderByWithAggregationInput | PhysicianOrderByWithAggregationInput[]
    by: PhysicianScalarFieldEnum[] | PhysicianScalarFieldEnum
    having?: PhysicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhysicianCountAggregateInputType | true
    _min?: PhysicianMinAggregateInputType
    _max?: PhysicianMaxAggregateInputType
  }

  export type PhysicianGroupByOutputType = {
    id: string
    name: string
    npi: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  type GetPhysicianGroupByPayload<T extends PhysicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhysicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhysicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
            : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
        }
      >
    >


  export type PhysicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    npi?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Physician$evaluationsArgs<ExtArgs>
    patient?: boolean | Physician$patientArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physician"]>

  export type PhysicianSelectScalar = {
    id?: boolean
    name?: boolean
    npi?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type PhysicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Physician$evaluationsArgs<ExtArgs>
    patient?: boolean | Physician$patientArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PhysicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Physician"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      npi: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["physician"]>
    composites: {}
  }


  type PhysicianGetPayload<S extends boolean | null | undefined | PhysicianDefaultArgs> = $Result.GetResult<Prisma.$PhysicianPayload, S>

  type PhysicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhysicianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhysicianCountAggregateInputType | true
    }

  export interface PhysicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Physician'], meta: { name: 'Physician' } }
    /**
     * Find zero or one Physician that matches the filter.
     * @param {PhysicianFindUniqueArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhysicianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianFindUniqueArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Physician that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhysicianFindUniqueOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhysicianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Physician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhysicianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindFirstArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Physician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhysicianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Physicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physicians
     * const physicians = await prisma.physician.findMany()
     * 
     * // Get first 10 Physicians
     * const physicians = await prisma.physician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physicianWithIdOnly = await prisma.physician.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhysicianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Physician.
     * @param {PhysicianCreateArgs} args - Arguments to create a Physician.
     * @example
     * // Create one Physician
     * const Physician = await prisma.physician.create({
     *   data: {
     *     // ... data to create a Physician
     *   }
     * })
     * 
    **/
    create<T extends PhysicianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianCreateArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Physicians.
     * @param {PhysicianCreateManyArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PhysicianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Physicians and returns the data saved in the database.
     * @param {PhysicianCreateManyAndReturnArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Physicians and only return the `id`
     * const physicianWithIdOnly = await prisma.physician.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PhysicianCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Physician.
     * @param {PhysicianDeleteArgs} args - Arguments to delete one Physician.
     * @example
     * // Delete one Physician
     * const Physician = await prisma.physician.delete({
     *   where: {
     *     // ... filter to delete one Physician
     *   }
     * })
     * 
    **/
    delete<T extends PhysicianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianDeleteArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Physician.
     * @param {PhysicianUpdateArgs} args - Arguments to update one Physician.
     * @example
     * // Update one Physician
     * const physician = await prisma.physician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhysicianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpdateArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Physicians.
     * @param {PhysicianDeleteManyArgs} args - Arguments to filter Physicians to delete.
     * @example
     * // Delete a few Physicians
     * const { count } = await prisma.physician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhysicianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physicians
     * const physician = await prisma.physician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhysicianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician.
     * @param {PhysicianUpsertArgs} args - Arguments to update or create a Physician.
     * @example
     * // Update or create a Physician
     * const physician = await prisma.physician.upsert({
     *   create: {
     *     // ... data to create a Physician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician we want to update
     *   }
     * })
    **/
    upsert<T extends PhysicianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpsertArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianCountArgs} args - Arguments to filter Physicians to count.
     * @example
     * // Count the number of Physicians
     * const count = await prisma.physician.count({
     *   where: {
     *     // ... the filter for the Physicians we want to count
     *   }
     * })
    **/
    count<T extends PhysicianCountArgs>(
      args?: Subset<T, PhysicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhysicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhysicianAggregateArgs>(args: Subset<T, PhysicianAggregateArgs>): Prisma.PrismaPromise<GetPhysicianAggregateType<T>>

    /**
     * Group by Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhysicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhysicianGroupByArgs['orderBy'] }
        : { orderBy?: PhysicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhysicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Physician model
   */
  readonly fields: PhysicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Physician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhysicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Physician$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Physician$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    patient<T extends Physician$patientArgs<ExtArgs> = {}>(args?: Subset<T, Physician$patientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Physician model
   */ 
  interface PhysicianFieldRefs {
    readonly id: FieldRef<"Physician", 'String'>
    readonly name: FieldRef<"Physician", 'String'>
    readonly npi: FieldRef<"Physician", 'String'>
    readonly active: FieldRef<"Physician", 'Boolean'>
    readonly createdAt: FieldRef<"Physician", 'DateTime'>
    readonly updatedAt: FieldRef<"Physician", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Physician findUnique
   */
  export type PhysicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findUniqueOrThrow
   */
  export type PhysicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findFirst
   */
  export type PhysicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findFirstOrThrow
   */
  export type PhysicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findMany
   */
  export type PhysicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physicians to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician create
   */
  export type PhysicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Physician.
     */
    data: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
  }

  /**
   * Physician createMany
   */
  export type PhysicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Physician createManyAndReturn
   */
  export type PhysicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Physician update
   */
  export type PhysicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Physician.
     */
    data: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
    /**
     * Choose, which Physician to update.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician updateMany
   */
  export type PhysicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Physicians.
     */
    data: XOR<PhysicianUpdateManyMutationInput, PhysicianUncheckedUpdateManyInput>
    /**
     * Filter which Physicians to update
     */
    where?: PhysicianWhereInput
  }

  /**
   * Physician upsert
   */
  export type PhysicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Physician to update in case it exists.
     */
    where: PhysicianWhereUniqueInput
    /**
     * In case the Physician found by the `where` argument doesn't exist, create a new Physician with this data.
     */
    create: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
    /**
     * In case the Physician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
  }

  /**
   * Physician delete
   */
  export type PhysicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter which Physician to delete.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician deleteMany
   */
  export type PhysicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physicians to delete
     */
    where?: PhysicianWhereInput
  }

  /**
   * Physician.evaluations
   */
  export type Physician$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Physician.patient
   */
  export type Physician$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Physician without action
   */
  export type PhysicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    diabetic: boolean | null
    standard: $Enums.DiagnosisStandard | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    diabetic: boolean | null
    standard: $Enums.DiagnosisStandard | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    code: number
    description: number
    diabetic: number
    standard: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiagnosisMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: string
    code: string
    description: string
    diabetic: boolean
    standard: $Enums.DiagnosisStandard
    createdAt: Date
    updatedAt: Date
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    diabetic?: boolean
    standard?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Diagnosis$evaluationsArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    diabetic?: boolean
    standard?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Diagnosis$evaluationsArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
      diabetic: boolean
      standard: $Enums.DiagnosisStandard
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }


  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiagnosisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiagnosisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiagnosisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
    **/
    create<T extends DiagnosisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DiagnosisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
    **/
    delete<T extends DiagnosisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiagnosisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiagnosisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiagnosisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
    **/
    upsert<T extends DiagnosisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Diagnosis$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Diagnosis model
   */ 
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'String'>
    readonly code: FieldRef<"Diagnosis", 'String'>
    readonly description: FieldRef<"Diagnosis", 'String'>
    readonly diabetic: FieldRef<"Diagnosis", 'Boolean'>
    readonly standard: FieldRef<"Diagnosis", 'DiagnosisStandard'>
    readonly createdAt: FieldRef<"Diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis.evaluations
   */
  export type Diagnosis$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model BillingCode
   */

  export type AggregateBillingCode = {
    _count: BillingCodeCountAggregateOutputType | null
    _min: BillingCodeMinAggregateOutputType | null
    _max: BillingCodeMaxAggregateOutputType | null
  }

  export type BillingCodeMinAggregateOutputType = {
    id: string | null
    summary: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingCodeMaxAggregateOutputType = {
    id: string | null
    summary: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingCodeCountAggregateOutputType = {
    id: number
    summary: number
    description: number
    justifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingCodeMinAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingCodeMaxAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingCodeCountAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    justifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingCode to aggregate.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingCodes
    **/
    _count?: true | BillingCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingCodeMaxAggregateInputType
  }

  export type GetBillingCodeAggregateType<T extends BillingCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingCode[P]>
      : GetScalarType<T[P], AggregateBillingCode[P]>
  }




  export type BillingCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingCodeWhereInput
    orderBy?: BillingCodeOrderByWithAggregationInput | BillingCodeOrderByWithAggregationInput[]
    by: BillingCodeScalarFieldEnum[] | BillingCodeScalarFieldEnum
    having?: BillingCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingCodeCountAggregateInputType | true
    _min?: BillingCodeMinAggregateInputType
    _max?: BillingCodeMaxAggregateInputType
  }

  export type BillingCodeGroupByOutputType = {
    id: string
    summary: string | null
    description: string
    justifications: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BillingCodeCountAggregateOutputType | null
    _min: BillingCodeMinAggregateOutputType | null
    _max: BillingCodeMaxAggregateOutputType | null
  }

  type GetBillingCodeGroupByPayload<T extends BillingCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingCodeGroupByOutputType[P]>
            : GetScalarType<T[P], BillingCodeGroupByOutputType[P]>
        }
      >
    >


  export type BillingCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summary?: boolean
    description?: boolean
    justifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingCode"]>

  export type BillingCodeSelectScalar = {
    id?: boolean
    summary?: boolean
    description?: boolean
    justifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }



  export type $BillingCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      summary: string | null
      description: string
      justifications: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingCode"]>
    composites: {}
  }


  type BillingCodeGetPayload<S extends boolean | null | undefined | BillingCodeDefaultArgs> = $Result.GetResult<Prisma.$BillingCodePayload, S>

  type BillingCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingCodeCountAggregateInputType | true
    }

  export interface BillingCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingCode'], meta: { name: 'BillingCode' } }
    /**
     * Find zero or one BillingCode that matches the filter.
     * @param {BillingCodeFindUniqueArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillingCodeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeFindUniqueArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BillingCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingCodeFindUniqueOrThrowArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillingCodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BillingCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindFirstArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillingCodeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindFirstArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BillingCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindFirstOrThrowArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillingCodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BillingCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingCodes
     * const billingCodes = await prisma.billingCode.findMany()
     * 
     * // Get first 10 BillingCodes
     * const billingCodes = await prisma.billingCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingCodeWithIdOnly = await prisma.billingCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillingCodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BillingCode.
     * @param {BillingCodeCreateArgs} args - Arguments to create a BillingCode.
     * @example
     * // Create one BillingCode
     * const BillingCode = await prisma.billingCode.create({
     *   data: {
     *     // ... data to create a BillingCode
     *   }
     * })
     * 
    **/
    create<T extends BillingCodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeCreateArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BillingCodes.
     * @param {BillingCodeCreateManyArgs} args - Arguments to create many BillingCodes.
     * @example
     * // Create many BillingCodes
     * const billingCode = await prisma.billingCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends BillingCodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingCodes and returns the data saved in the database.
     * @param {BillingCodeCreateManyAndReturnArgs} args - Arguments to create many BillingCodes.
     * @example
     * // Create many BillingCodes
     * const billingCode = await prisma.billingCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingCodes and only return the `id`
     * const billingCodeWithIdOnly = await prisma.billingCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends BillingCodeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a BillingCode.
     * @param {BillingCodeDeleteArgs} args - Arguments to delete one BillingCode.
     * @example
     * // Delete one BillingCode
     * const BillingCode = await prisma.billingCode.delete({
     *   where: {
     *     // ... filter to delete one BillingCode
     *   }
     * })
     * 
    **/
    delete<T extends BillingCodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeDeleteArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BillingCode.
     * @param {BillingCodeUpdateArgs} args - Arguments to update one BillingCode.
     * @example
     * // Update one BillingCode
     * const billingCode = await prisma.billingCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillingCodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpdateArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BillingCodes.
     * @param {BillingCodeDeleteManyArgs} args - Arguments to filter BillingCodes to delete.
     * @example
     * // Delete a few BillingCodes
     * const { count } = await prisma.billingCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillingCodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingCodes
     * const billingCode = await prisma.billingCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillingCodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingCode.
     * @param {BillingCodeUpsertArgs} args - Arguments to update or create a BillingCode.
     * @example
     * // Update or create a BillingCode
     * const billingCode = await prisma.billingCode.upsert({
     *   create: {
     *     // ... data to create a BillingCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingCode we want to update
     *   }
     * })
    **/
    upsert<T extends BillingCodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpsertArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BillingCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeCountArgs} args - Arguments to filter BillingCodes to count.
     * @example
     * // Count the number of BillingCodes
     * const count = await prisma.billingCode.count({
     *   where: {
     *     // ... the filter for the BillingCodes we want to count
     *   }
     * })
    **/
    count<T extends BillingCodeCountArgs>(
      args?: Subset<T, BillingCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingCodeAggregateArgs>(args: Subset<T, BillingCodeAggregateArgs>): Prisma.PrismaPromise<GetBillingCodeAggregateType<T>>

    /**
     * Group by BillingCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingCodeGroupByArgs['orderBy'] }
        : { orderBy?: BillingCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingCode model
   */
  readonly fields: BillingCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BillingCode model
   */ 
  interface BillingCodeFieldRefs {
    readonly id: FieldRef<"BillingCode", 'String'>
    readonly summary: FieldRef<"BillingCode", 'String'>
    readonly description: FieldRef<"BillingCode", 'String'>
    readonly justifications: FieldRef<"BillingCode", 'Json'>
    readonly createdAt: FieldRef<"BillingCode", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingCode findUnique
   */
  export type BillingCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode findUniqueOrThrow
   */
  export type BillingCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode findFirst
   */
  export type BillingCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingCodes.
     */
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode findFirstOrThrow
   */
  export type BillingCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingCodes.
     */
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode findMany
   */
  export type BillingCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCodes to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode create
   */
  export type BillingCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data needed to create a BillingCode.
     */
    data: XOR<BillingCodeCreateInput, BillingCodeUncheckedCreateInput>
  }

  /**
   * BillingCode createMany
   */
  export type BillingCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingCodes.
     */
    data: BillingCodeCreateManyInput | BillingCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingCode createManyAndReturn
   */
  export type BillingCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data used to create many BillingCodes.
     */
    data: BillingCodeCreateManyInput | BillingCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingCode update
   */
  export type BillingCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data needed to update a BillingCode.
     */
    data: XOR<BillingCodeUpdateInput, BillingCodeUncheckedUpdateInput>
    /**
     * Choose, which BillingCode to update.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode updateMany
   */
  export type BillingCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingCodes.
     */
    data: XOR<BillingCodeUpdateManyMutationInput, BillingCodeUncheckedUpdateManyInput>
    /**
     * Filter which BillingCodes to update
     */
    where?: BillingCodeWhereInput
  }

  /**
   * BillingCode upsert
   */
  export type BillingCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The filter to search for the BillingCode to update in case it exists.
     */
    where: BillingCodeWhereUniqueInput
    /**
     * In case the BillingCode found by the `where` argument doesn't exist, create a new BillingCode with this data.
     */
    create: XOR<BillingCodeCreateInput, BillingCodeUncheckedCreateInput>
    /**
     * In case the BillingCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingCodeUpdateInput, BillingCodeUncheckedUpdateInput>
  }

  /**
   * BillingCode delete
   */
  export type BillingCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter which BillingCode to delete.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode deleteMany
   */
  export type BillingCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingCodes to delete
     */
    where?: BillingCodeWhereInput
  }

  /**
   * BillingCode without action
   */
  export type BillingCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
  }


  /**
   * Model DeviceType
   */

  export type AggregateDeviceType = {
    _count: DeviceTypeCountAggregateOutputType | null
    _min: DeviceTypeMinAggregateOutputType | null
    _max: DeviceTypeMaxAggregateOutputType | null
  }

  export type DeviceTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    diabetic: boolean | null
    custom: boolean | null
  }

  export type DeviceTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    diabetic: boolean | null
    custom: boolean | null
  }

  export type DeviceTypeCountAggregateOutputType = {
    id: number
    name: number
    diabetic: number
    custom: number
    _all: number
  }


  export type DeviceTypeMinAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
  }

  export type DeviceTypeMaxAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
  }

  export type DeviceTypeCountAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
    _all?: true
  }

  export type DeviceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceType to aggregate.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTypes
    **/
    _count?: true | DeviceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTypeMaxAggregateInputType
  }

  export type GetDeviceTypeAggregateType<T extends DeviceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceType[P]>
      : GetScalarType<T[P], AggregateDeviceType[P]>
  }




  export type DeviceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTypeWhereInput
    orderBy?: DeviceTypeOrderByWithAggregationInput | DeviceTypeOrderByWithAggregationInput[]
    by: DeviceTypeScalarFieldEnum[] | DeviceTypeScalarFieldEnum
    having?: DeviceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTypeCountAggregateInputType | true
    _min?: DeviceTypeMinAggregateInputType
    _max?: DeviceTypeMaxAggregateInputType
  }

  export type DeviceTypeGroupByOutputType = {
    id: string
    name: string
    diabetic: boolean
    custom: boolean | null
    _count: DeviceTypeCountAggregateOutputType | null
    _min: DeviceTypeMinAggregateOutputType | null
    _max: DeviceTypeMaxAggregateOutputType | null
  }

  type GetDeviceTypeGroupByPayload<T extends DeviceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTypeGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    diabetic?: boolean
    custom?: boolean
    evaluations?: boolean | DeviceType$evaluationsArgs<ExtArgs>
    _count?: boolean | DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceType"]>

  export type DeviceTypeSelectScalar = {
    id?: boolean
    name?: boolean
    diabetic?: boolean
    custom?: boolean
  }


  export type DeviceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DeviceType$evaluationsArgs<ExtArgs>
    _count?: boolean | DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DeviceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceType"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      diabetic: boolean
      custom: boolean | null
    }, ExtArgs["result"]["deviceType"]>
    composites: {}
  }


  type DeviceTypeGetPayload<S extends boolean | null | undefined | DeviceTypeDefaultArgs> = $Result.GetResult<Prisma.$DeviceTypePayload, S>

  type DeviceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceTypeCountAggregateInputType | true
    }

  export interface DeviceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceType'], meta: { name: 'DeviceType' } }
    /**
     * Find zero or one DeviceType that matches the filter.
     * @param {DeviceTypeFindUniqueArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DeviceType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceTypeFindUniqueOrThrowArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DeviceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindFirstArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindFirstArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DeviceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindFirstOrThrowArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DeviceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTypes
     * const deviceTypes = await prisma.deviceType.findMany()
     * 
     * // Get first 10 DeviceTypes
     * const deviceTypes = await prisma.deviceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTypeWithIdOnly = await prisma.deviceType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DeviceType.
     * @param {DeviceTypeCreateArgs} args - Arguments to create a DeviceType.
     * @example
     * // Create one DeviceType
     * const DeviceType = await prisma.deviceType.create({
     *   data: {
     *     // ... data to create a DeviceType
     *   }
     * })
     * 
    **/
    create<T extends DeviceTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeCreateArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DeviceTypes.
     * @param {DeviceTypeCreateManyArgs} args - Arguments to create many DeviceTypes.
     * @example
     * // Create many DeviceTypes
     * const deviceType = await prisma.deviceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DeviceTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTypes and returns the data saved in the database.
     * @param {DeviceTypeCreateManyAndReturnArgs} args - Arguments to create many DeviceTypes.
     * @example
     * // Create many DeviceTypes
     * const deviceType = await prisma.deviceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTypes and only return the `id`
     * const deviceTypeWithIdOnly = await prisma.deviceType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DeviceTypeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a DeviceType.
     * @param {DeviceTypeDeleteArgs} args - Arguments to delete one DeviceType.
     * @example
     * // Delete one DeviceType
     * const DeviceType = await prisma.deviceType.delete({
     *   where: {
     *     // ... filter to delete one DeviceType
     *   }
     * })
     * 
    **/
    delete<T extends DeviceTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeDeleteArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DeviceType.
     * @param {DeviceTypeUpdateArgs} args - Arguments to update one DeviceType.
     * @example
     * // Update one DeviceType
     * const deviceType = await prisma.deviceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpdateArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DeviceTypes.
     * @param {DeviceTypeDeleteManyArgs} args - Arguments to filter DeviceTypes to delete.
     * @example
     * // Delete a few DeviceTypes
     * const { count } = await prisma.deviceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTypes
     * const deviceType = await prisma.deviceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceType.
     * @param {DeviceTypeUpsertArgs} args - Arguments to update or create a DeviceType.
     * @example
     * // Update or create a DeviceType
     * const deviceType = await prisma.deviceType.upsert({
     *   create: {
     *     // ... data to create a DeviceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceType we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpsertArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DeviceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeCountArgs} args - Arguments to filter DeviceTypes to count.
     * @example
     * // Count the number of DeviceTypes
     * const count = await prisma.deviceType.count({
     *   where: {
     *     // ... the filter for the DeviceTypes we want to count
     *   }
     * })
    **/
    count<T extends DeviceTypeCountArgs>(
      args?: Subset<T, DeviceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTypeAggregateArgs>(args: Subset<T, DeviceTypeAggregateArgs>): Prisma.PrismaPromise<GetDeviceTypeAggregateType<T>>

    /**
     * Group by DeviceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTypeGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceType model
   */
  readonly fields: DeviceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends DeviceType$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceType$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DeviceType model
   */ 
  interface DeviceTypeFieldRefs {
    readonly id: FieldRef<"DeviceType", 'String'>
    readonly name: FieldRef<"DeviceType", 'String'>
    readonly diabetic: FieldRef<"DeviceType", 'Boolean'>
    readonly custom: FieldRef<"DeviceType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DeviceType findUnique
   */
  export type DeviceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType findUniqueOrThrow
   */
  export type DeviceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType findFirst
   */
  export type DeviceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTypes.
     */
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType findFirstOrThrow
   */
  export type DeviceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTypes.
     */
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType findMany
   */
  export type DeviceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTypes to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType create
   */
  export type DeviceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceType.
     */
    data: XOR<DeviceTypeCreateInput, DeviceTypeUncheckedCreateInput>
  }

  /**
   * DeviceType createMany
   */
  export type DeviceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTypes.
     */
    data: DeviceTypeCreateManyInput | DeviceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceType createManyAndReturn
   */
  export type DeviceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data used to create many DeviceTypes.
     */
    data: DeviceTypeCreateManyInput | DeviceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceType update
   */
  export type DeviceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceType.
     */
    data: XOR<DeviceTypeUpdateInput, DeviceTypeUncheckedUpdateInput>
    /**
     * Choose, which DeviceType to update.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType updateMany
   */
  export type DeviceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTypes.
     */
    data: XOR<DeviceTypeUpdateManyMutationInput, DeviceTypeUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTypes to update
     */
    where?: DeviceTypeWhereInput
  }

  /**
   * DeviceType upsert
   */
  export type DeviceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceType to update in case it exists.
     */
    where: DeviceTypeWhereUniqueInput
    /**
     * In case the DeviceType found by the `where` argument doesn't exist, create a new DeviceType with this data.
     */
    create: XOR<DeviceTypeCreateInput, DeviceTypeUncheckedCreateInput>
    /**
     * In case the DeviceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTypeUpdateInput, DeviceTypeUncheckedUpdateInput>
  }

  /**
   * DeviceType delete
   */
  export type DeviceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter which DeviceType to delete.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType deleteMany
   */
  export type DeviceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTypes to delete
     */
    where?: DeviceTypeWhereInput
  }

  /**
   * DeviceType.evaluations
   */
  export type DeviceType$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * DeviceType without action
   */
  export type DeviceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
  }


  /**
   * Model VisitType
   */

  export type AggregateVisitType = {
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  export type VisitTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VisitTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VisitTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type VisitTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type VisitTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type VisitTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type VisitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitType to aggregate.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitTypes
    **/
    _count?: true | VisitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitTypeMaxAggregateInputType
  }

  export type GetVisitTypeAggregateType<T extends VisitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitType[P]>
      : GetScalarType<T[P], AggregateVisitType[P]>
  }




  export type VisitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTypeWhereInput
    orderBy?: VisitTypeOrderByWithAggregationInput | VisitTypeOrderByWithAggregationInput[]
    by: VisitTypeScalarFieldEnum[] | VisitTypeScalarFieldEnum
    having?: VisitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitTypeCountAggregateInputType | true
    _min?: VisitTypeMinAggregateInputType
    _max?: VisitTypeMaxAggregateInputType
  }

  export type VisitTypeGroupByOutputType = {
    id: string
    name: string
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  type GetVisitTypeGroupByPayload<T extends VisitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
        }
      >
    >


  export type VisitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    evaluations?: boolean | VisitType$evaluationsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type VisitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | VisitType$evaluationsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VisitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitType"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["visitType"]>
    composites: {}
  }


  type VisitTypeGetPayload<S extends boolean | null | undefined | VisitTypeDefaultArgs> = $Result.GetResult<Prisma.$VisitTypePayload, S>

  type VisitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitTypeCountAggregateInputType | true
    }

  export interface VisitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitType'], meta: { name: 'VisitType' } }
    /**
     * Find zero or one VisitType that matches the filter.
     * @param {VisitTypeFindUniqueArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VisitTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VisitType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitTypeFindUniqueOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VisitTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VisitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VisitTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindFirstArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VisitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VisitTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VisitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitTypes
     * const visitTypes = await prisma.visitType.findMany()
     * 
     * // Get first 10 VisitTypes
     * const visitTypes = await prisma.visitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VisitTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VisitType.
     * @param {VisitTypeCreateArgs} args - Arguments to create a VisitType.
     * @example
     * // Create one VisitType
     * const VisitType = await prisma.visitType.create({
     *   data: {
     *     // ... data to create a VisitType
     *   }
     * })
     * 
    **/
    create<T extends VisitTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeCreateArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VisitTypes.
     * @param {VisitTypeCreateManyArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends VisitTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitTypes and returns the data saved in the database.
     * @param {VisitTypeCreateManyAndReturnArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends VisitTypeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a VisitType.
     * @param {VisitTypeDeleteArgs} args - Arguments to delete one VisitType.
     * @example
     * // Delete one VisitType
     * const VisitType = await prisma.visitType.delete({
     *   where: {
     *     // ... filter to delete one VisitType
     *   }
     * })
     * 
    **/
    delete<T extends VisitTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeDeleteArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VisitType.
     * @param {VisitTypeUpdateArgs} args - Arguments to update one VisitType.
     * @example
     * // Update one VisitType
     * const visitType = await prisma.visitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VisitTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpdateArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VisitTypes.
     * @param {VisitTypeDeleteManyArgs} args - Arguments to filter VisitTypes to delete.
     * @example
     * // Delete a few VisitTypes
     * const { count } = await prisma.visitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VisitTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VisitTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitType.
     * @param {VisitTypeUpsertArgs} args - Arguments to update or create a VisitType.
     * @example
     * // Update or create a VisitType
     * const visitType = await prisma.visitType.upsert({
     *   create: {
     *     // ... data to create a VisitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitType we want to update
     *   }
     * })
    **/
    upsert<T extends VisitTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpsertArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeCountArgs} args - Arguments to filter VisitTypes to count.
     * @example
     * // Count the number of VisitTypes
     * const count = await prisma.visitType.count({
     *   where: {
     *     // ... the filter for the VisitTypes we want to count
     *   }
     * })
    **/
    count<T extends VisitTypeCountArgs>(
      args?: Subset<T, VisitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitTypeAggregateArgs>(args: Subset<T, VisitTypeAggregateArgs>): Prisma.PrismaPromise<GetVisitTypeAggregateType<T>>

    /**
     * Group by VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitTypeGroupByArgs['orderBy'] }
        : { orderBy?: VisitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitType model
   */
  readonly fields: VisitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends VisitType$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, VisitType$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VisitType model
   */ 
  interface VisitTypeFieldRefs {
    readonly id: FieldRef<"VisitType", 'String'>
    readonly name: FieldRef<"VisitType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisitType findUnique
   */
  export type VisitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findUniqueOrThrow
   */
  export type VisitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findFirst
   */
  export type VisitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findFirstOrThrow
   */
  export type VisitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findMany
   */
  export type VisitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitTypes to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType create
   */
  export type VisitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitType.
     */
    data: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
  }

  /**
   * VisitType createMany
   */
  export type VisitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType createManyAndReturn
   */
  export type VisitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType update
   */
  export type VisitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitType.
     */
    data: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
    /**
     * Choose, which VisitType to update.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType updateMany
   */
  export type VisitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
  }

  /**
   * VisitType upsert
   */
  export type VisitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitType to update in case it exists.
     */
    where: VisitTypeWhereUniqueInput
    /**
     * In case the VisitType found by the `where` argument doesn't exist, create a new VisitType with this data.
     */
    create: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
    /**
     * In case the VisitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
  }

  /**
   * VisitType delete
   */
  export type VisitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter which VisitType to delete.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType deleteMany
   */
  export type VisitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTypes to delete
     */
    where?: VisitTypeWhereInput
  }

  /**
   * VisitType.evaluations
   */
  export type VisitType$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * VisitType without action
   */
  export type VisitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
  }


  /**
   * Model FormSchema
   */

  export type AggregateFormSchema = {
    _count: FormSchemaCountAggregateOutputType | null
    _min: FormSchemaMinAggregateOutputType | null
    _max: FormSchemaMaxAggregateOutputType | null
  }

  export type FormSchemaMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.FormSchemaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSchemaMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.FormSchemaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSchemaCountAggregateOutputType = {
    id: number
    title: number
    type: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormSchemaMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSchemaMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSchemaCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormSchemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSchema to aggregate.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSchemas
    **/
    _count?: true | FormSchemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSchemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSchemaMaxAggregateInputType
  }

  export type GetFormSchemaAggregateType<T extends FormSchemaAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSchema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSchema[P]>
      : GetScalarType<T[P], AggregateFormSchema[P]>
  }




  export type FormSchemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSchemaWhereInput
    orderBy?: FormSchemaOrderByWithAggregationInput | FormSchemaOrderByWithAggregationInput[]
    by: FormSchemaScalarFieldEnum[] | FormSchemaScalarFieldEnum
    having?: FormSchemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSchemaCountAggregateInputType | true
    _min?: FormSchemaMinAggregateInputType
    _max?: FormSchemaMaxAggregateInputType
  }

  export type FormSchemaGroupByOutputType = {
    id: string
    title: string
    type: $Enums.FormSchemaType | null
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormSchemaCountAggregateOutputType | null
    _min: FormSchemaMinAggregateOutputType | null
    _max: FormSchemaMaxAggregateOutputType | null
  }

  type GetFormSchemaGroupByPayload<T extends FormSchemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSchemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSchemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSchemaGroupByOutputType[P]>
            : GetScalarType<T[P], FormSchemaGroupByOutputType[P]>
        }
      >
    >


  export type FormSchemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submissions?: boolean | FormSchema$submissionsArgs<ExtArgs>
    _count?: boolean | FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSchema"]>

  export type FormSchemaSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FormSchemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormSchema$submissionsArgs<ExtArgs>
    _count?: boolean | FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FormSchemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSchema"
    objects: {
      submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: $Enums.FormSchemaType | null
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formSchema"]>
    composites: {}
  }


  type FormSchemaGetPayload<S extends boolean | null | undefined | FormSchemaDefaultArgs> = $Result.GetResult<Prisma.$FormSchemaPayload, S>

  type FormSchemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSchemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSchemaCountAggregateInputType | true
    }

  export interface FormSchemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSchema'], meta: { name: 'FormSchema' } }
    /**
     * Find zero or one FormSchema that matches the filter.
     * @param {FormSchemaFindUniqueArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSchemaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormSchema that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSchemaFindUniqueOrThrowArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSchemaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormSchema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindFirstArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSchemaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindFirstArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormSchema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindFirstOrThrowArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSchemaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormSchemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSchemas
     * const formSchemas = await prisma.formSchema.findMany()
     * 
     * // Get first 10 FormSchemas
     * const formSchemas = await prisma.formSchema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSchemaWithIdOnly = await prisma.formSchema.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSchemaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormSchema.
     * @param {FormSchemaCreateArgs} args - Arguments to create a FormSchema.
     * @example
     * // Create one FormSchema
     * const FormSchema = await prisma.formSchema.create({
     *   data: {
     *     // ... data to create a FormSchema
     *   }
     * })
     * 
    **/
    create<T extends FormSchemaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaCreateArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormSchemas.
     * @param {FormSchemaCreateManyArgs} args - Arguments to create many FormSchemas.
     * @example
     * // Create many FormSchemas
     * const formSchema = await prisma.formSchema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormSchemaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSchemas and returns the data saved in the database.
     * @param {FormSchemaCreateManyAndReturnArgs} args - Arguments to create many FormSchemas.
     * @example
     * // Create many FormSchemas
     * const formSchema = await prisma.formSchema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSchemas and only return the `id`
     * const formSchemaWithIdOnly = await prisma.formSchema.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormSchemaCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormSchema.
     * @param {FormSchemaDeleteArgs} args - Arguments to delete one FormSchema.
     * @example
     * // Delete one FormSchema
     * const FormSchema = await prisma.formSchema.delete({
     *   where: {
     *     // ... filter to delete one FormSchema
     *   }
     * })
     * 
    **/
    delete<T extends FormSchemaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaDeleteArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormSchema.
     * @param {FormSchemaUpdateArgs} args - Arguments to update one FormSchema.
     * @example
     * // Update one FormSchema
     * const formSchema = await prisma.formSchema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSchemaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpdateArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormSchemas.
     * @param {FormSchemaDeleteManyArgs} args - Arguments to filter FormSchemas to delete.
     * @example
     * // Delete a few FormSchemas
     * const { count } = await prisma.formSchema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSchemaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSchemas
     * const formSchema = await prisma.formSchema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSchemaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSchema.
     * @param {FormSchemaUpsertArgs} args - Arguments to update or create a FormSchema.
     * @example
     * // Update or create a FormSchema
     * const formSchema = await prisma.formSchema.upsert({
     *   create: {
     *     // ... data to create a FormSchema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSchema we want to update
     *   }
     * })
    **/
    upsert<T extends FormSchemaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpsertArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaCountArgs} args - Arguments to filter FormSchemas to count.
     * @example
     * // Count the number of FormSchemas
     * const count = await prisma.formSchema.count({
     *   where: {
     *     // ... the filter for the FormSchemas we want to count
     *   }
     * })
    **/
    count<T extends FormSchemaCountArgs>(
      args?: Subset<T, FormSchemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSchemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSchemaAggregateArgs>(args: Subset<T, FormSchemaAggregateArgs>): Prisma.PrismaPromise<GetFormSchemaAggregateType<T>>

    /**
     * Group by FormSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSchemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSchemaGroupByArgs['orderBy'] }
        : { orderBy?: FormSchemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSchemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSchemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSchema model
   */
  readonly fields: FormSchemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSchema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSchemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submissions<T extends FormSchema$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, FormSchema$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormSchema model
   */ 
  interface FormSchemaFieldRefs {
    readonly id: FieldRef<"FormSchema", 'String'>
    readonly title: FieldRef<"FormSchema", 'String'>
    readonly type: FieldRef<"FormSchema", 'FormSchemaType'>
    readonly data: FieldRef<"FormSchema", 'Json'>
    readonly createdAt: FieldRef<"FormSchema", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSchema", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSchema findUnique
   */
  export type FormSchemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema findUniqueOrThrow
   */
  export type FormSchemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema findFirst
   */
  export type FormSchemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSchemas.
     */
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema findFirstOrThrow
   */
  export type FormSchemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSchemas.
     */
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema findMany
   */
  export type FormSchemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchemas to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema create
   */
  export type FormSchemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSchema.
     */
    data: XOR<FormSchemaCreateInput, FormSchemaUncheckedCreateInput>
  }

  /**
   * FormSchema createMany
   */
  export type FormSchemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSchemas.
     */
    data: FormSchemaCreateManyInput | FormSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSchema createManyAndReturn
   */
  export type FormSchemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data used to create many FormSchemas.
     */
    data: FormSchemaCreateManyInput | FormSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSchema update
   */
  export type FormSchemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSchema.
     */
    data: XOR<FormSchemaUpdateInput, FormSchemaUncheckedUpdateInput>
    /**
     * Choose, which FormSchema to update.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema updateMany
   */
  export type FormSchemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSchemas.
     */
    data: XOR<FormSchemaUpdateManyMutationInput, FormSchemaUncheckedUpdateManyInput>
    /**
     * Filter which FormSchemas to update
     */
    where?: FormSchemaWhereInput
  }

  /**
   * FormSchema upsert
   */
  export type FormSchemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSchema to update in case it exists.
     */
    where: FormSchemaWhereUniqueInput
    /**
     * In case the FormSchema found by the `where` argument doesn't exist, create a new FormSchema with this data.
     */
    create: XOR<FormSchemaCreateInput, FormSchemaUncheckedCreateInput>
    /**
     * In case the FormSchema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSchemaUpdateInput, FormSchemaUncheckedUpdateInput>
  }

  /**
   * FormSchema delete
   */
  export type FormSchemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter which FormSchema to delete.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema deleteMany
   */
  export type FormSchemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSchemas to delete
     */
    where?: FormSchemaWhereInput
  }

  /**
   * FormSchema.submissions
   */
  export type FormSchema$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSchema without action
   */
  export type FormSchemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    schemaId: string | null
    workbenchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    schemaId: string | null
    workbenchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    schemaId: number
    workbenchId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    schemaId: string
    workbenchId: string
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    workbenchId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schema?: boolean | FormSchemaDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    schemaId?: boolean
    workbenchId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | FormSchemaDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }


  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      schema: Prisma.$FormSchemaPayload<ExtArgs>
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schemaId: string
      workbenchId: string
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }


  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSubmissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSubmissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSubmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
    **/
    create<T extends FormSubmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormSubmissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSubmissions and returns the data saved in the database.
     * @param {FormSubmissionCreateManyAndReturnArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSubmissions and only return the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormSubmissionCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
    **/
    delete<T extends FormSubmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSubmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSubmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSubmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends FormSubmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    schema<T extends FormSchemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormSchemaDefaultArgs<ExtArgs>>): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormSubmission model
   */ 
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly schemaId: FieldRef<"FormSubmission", 'String'>
    readonly workbenchId: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly createdAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission createManyAndReturn
   */
  export type FormSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model FormTemplate
   */

  export type AggregateFormTemplate = {
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  export type FormTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplate to aggregate.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormTemplates
    **/
    _count?: true | FormTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTemplateMaxAggregateInputType
  }

  export type GetFormTemplateAggregateType<T extends FormTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTemplate[P]>
      : GetScalarType<T[P], AggregateFormTemplate[P]>
  }




  export type FormTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithAggregationInput | FormTemplateOrderByWithAggregationInput[]
    by: FormTemplateScalarFieldEnum[] | FormTemplateScalarFieldEnum
    having?: FormTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTemplateCountAggregateInputType | true
    _min?: FormTemplateMinAggregateInputType
    _max?: FormTemplateMaxAggregateInputType
  }

  export type FormTemplateGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  type GetFormTemplateGroupByPayload<T extends FormTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FormTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }



  export type $FormTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formTemplate"]>
    composites: {}
  }


  type FormTemplateGetPayload<S extends boolean | null | undefined | FormTemplateDefaultArgs> = $Result.GetResult<Prisma.$FormTemplatePayload, S>

  type FormTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormTemplateCountAggregateInputType | true
    }

  export interface FormTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormTemplate'], meta: { name: 'FormTemplate' } }
    /**
     * Find zero or one FormTemplate that matches the filter.
     * @param {FormTemplateFindUniqueArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormTemplateFindUniqueOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany()
     * 
     * // Get first 10 FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormTemplate.
     * @param {FormTemplateCreateArgs} args - Arguments to create a FormTemplate.
     * @example
     * // Create one FormTemplate
     * const FormTemplate = await prisma.formTemplate.create({
     *   data: {
     *     // ... data to create a FormTemplate
     *   }
     * })
     * 
    **/
    create<T extends FormTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateCreateArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormTemplates.
     * @param {FormTemplateCreateManyArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTemplates and returns the data saved in the database.
     * @param {FormTemplateCreateManyAndReturnArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTemplates and only return the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormTemplateCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormTemplate.
     * @param {FormTemplateDeleteArgs} args - Arguments to delete one FormTemplate.
     * @example
     * // Delete one FormTemplate
     * const FormTemplate = await prisma.formTemplate.delete({
     *   where: {
     *     // ... filter to delete one FormTemplate
     *   }
     * })
     * 
    **/
    delete<T extends FormTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateDeleteArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormTemplate.
     * @param {FormTemplateUpdateArgs} args - Arguments to update one FormTemplate.
     * @example
     * // Update one FormTemplate
     * const formTemplate = await prisma.formTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpdateArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormTemplates.
     * @param {FormTemplateDeleteManyArgs} args - Arguments to filter FormTemplates to delete.
     * @example
     * // Delete a few FormTemplates
     * const { count } = await prisma.formTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTemplates
     * const formTemplate = await prisma.formTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormTemplate.
     * @param {FormTemplateUpsertArgs} args - Arguments to update or create a FormTemplate.
     * @example
     * // Update or create a FormTemplate
     * const formTemplate = await prisma.formTemplate.upsert({
     *   create: {
     *     // ... data to create a FormTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends FormTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpsertArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateCountArgs} args - Arguments to filter FormTemplates to count.
     * @example
     * // Count the number of FormTemplates
     * const count = await prisma.formTemplate.count({
     *   where: {
     *     // ... the filter for the FormTemplates we want to count
     *   }
     * })
    **/
    count<T extends FormTemplateCountArgs>(
      args?: Subset<T, FormTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTemplateAggregateArgs>(args: Subset<T, FormTemplateAggregateArgs>): Prisma.PrismaPromise<GetFormTemplateAggregateType<T>>

    /**
     * Group by FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FormTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormTemplate model
   */
  readonly fields: FormTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormTemplate model
   */ 
  interface FormTemplateFieldRefs {
    readonly id: FieldRef<"FormTemplate", 'String'>
    readonly userId: FieldRef<"FormTemplate", 'String'>
    readonly title: FieldRef<"FormTemplate", 'String'>
    readonly description: FieldRef<"FormTemplate", 'String'>
    readonly data: FieldRef<"FormTemplate", 'Json'>
    readonly createdAt: FieldRef<"FormTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"FormTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormTemplate findUnique
   */
  export type FormTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findUniqueOrThrow
   */
  export type FormTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findFirst
   */
  export type FormTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findFirstOrThrow
   */
  export type FormTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findMany
   */
  export type FormTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplates to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate create
   */
  export type FormTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a FormTemplate.
     */
    data: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
  }

  /**
   * FormTemplate createMany
   */
  export type FormTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate createManyAndReturn
   */
  export type FormTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate update
   */
  export type FormTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a FormTemplate.
     */
    data: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
    /**
     * Choose, which FormTemplate to update.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate updateMany
   */
  export type FormTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormTemplates.
     */
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FormTemplates to update
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate upsert
   */
  export type FormTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the FormTemplate to update in case it exists.
     */
    where: FormTemplateWhereUniqueInput
    /**
     * In case the FormTemplate found by the `where` argument doesn't exist, create a new FormTemplate with this data.
     */
    create: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
    /**
     * In case the FormTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
  }

  /**
   * FormTemplate delete
   */
  export type FormTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter which FormTemplate to delete.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate deleteMany
   */
  export type FormTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplates to delete
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate without action
   */
  export type FormTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
  }


  /**
   * Model CatalogProduct
   */

  export type AggregateCatalogProduct = {
    _count: CatalogProductCountAggregateOutputType | null
    _avg: CatalogProductAvgAggregateOutputType | null
    _sum: CatalogProductSumAggregateOutputType | null
    _min: CatalogProductMinAggregateOutputType | null
    _max: CatalogProductMaxAggregateOutputType | null
  }

  export type CatalogProductAvgAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductSumAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    active: boolean | null
    favorite: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    active: boolean | null
    favorite: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    price: number
    active: number
    favorite: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductAvgAggregateInputType = {
    price?: true
  }

  export type CatalogProductSumAggregateInputType = {
    price?: true
  }

  export type CatalogProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    favorite?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    favorite?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    favorite?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProduct to aggregate.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProducts
    **/
    _count?: true | CatalogProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductMaxAggregateInputType
  }

  export type GetCatalogProductAggregateType<T extends CatalogProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProduct[P]>
      : GetScalarType<T[P], AggregateCatalogProduct[P]>
  }




  export type CatalogProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithAggregationInput | CatalogProductOrderByWithAggregationInput[]
    by: CatalogProductScalarFieldEnum[] | CatalogProductScalarFieldEnum
    having?: CatalogProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductCountAggregateInputType | true
    _avg?: CatalogProductAvgAggregateInputType
    _sum?: CatalogProductSumAggregateInputType
    _min?: CatalogProductMinAggregateInputType
    _max?: CatalogProductMaxAggregateInputType
  }

  export type CatalogProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    price: number | null
    active: boolean
    favorite: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductCountAggregateOutputType | null
    _avg: CatalogProductAvgAggregateOutputType | null
    _sum: CatalogProductSumAggregateOutputType | null
    _min: CatalogProductMinAggregateOutputType | null
    _max: CatalogProductMaxAggregateOutputType | null
  }

  type GetCatalogProductGroupByPayload<T extends CatalogProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    active?: boolean
    favorite?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attributes?: boolean | CatalogProduct$attributesArgs<ExtArgs>
    variants?: boolean | CatalogProduct$variantsArgs<ExtArgs>
    categories?: boolean | CatalogProduct$categoriesArgs<ExtArgs>
    vendors?: boolean | CatalogProduct$vendorsArgs<ExtArgs>
    _count?: boolean | CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProduct"]>

  export type CatalogProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    active?: boolean
    favorite?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | CatalogProduct$attributesArgs<ExtArgs>
    variants?: boolean | CatalogProduct$variantsArgs<ExtArgs>
    categories?: boolean | CatalogProduct$categoriesArgs<ExtArgs>
    vendors?: boolean | CatalogProduct$vendorsArgs<ExtArgs>
    _count?: boolean | CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProduct"
    objects: {
      attributes: Prisma.$CatalogProductAttributePayload<ExtArgs>[]
      variants: Prisma.$CatalogProductVariantPayload<ExtArgs>[]
      categories: Prisma.$CatalogCategoryPayload<ExtArgs>[]
      vendors: Prisma.$CatalogVendorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      price: number | null
      active: boolean
      favorite: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProduct"]>
    composites: {}
  }


  type CatalogProductGetPayload<S extends boolean | null | undefined | CatalogProductDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductPayload, S>

  type CatalogProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductCountAggregateInputType | true
    }

  export interface CatalogProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProduct'], meta: { name: 'CatalogProduct' } }
    /**
     * Find zero or one CatalogProduct that matches the filter.
     * @param {CatalogProductFindUniqueArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductFindUniqueOrThrowArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindFirstArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindFirstOrThrowArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProducts
     * const catalogProducts = await prisma.catalogProduct.findMany()
     * 
     * // Get first 10 CatalogProducts
     * const catalogProducts = await prisma.catalogProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductWithIdOnly = await prisma.catalogProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProduct.
     * @param {CatalogProductCreateArgs} args - Arguments to create a CatalogProduct.
     * @example
     * // Create one CatalogProduct
     * const CatalogProduct = await prisma.catalogProduct.create({
     *   data: {
     *     // ... data to create a CatalogProduct
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProducts.
     * @param {CatalogProductCreateManyArgs} args - Arguments to create many CatalogProducts.
     * @example
     * // Create many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProducts and returns the data saved in the database.
     * @param {CatalogProductCreateManyAndReturnArgs} args - Arguments to create many CatalogProducts.
     * @example
     * // Create many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProducts and only return the `id`
     * const catalogProductWithIdOnly = await prisma.catalogProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProduct.
     * @param {CatalogProductDeleteArgs} args - Arguments to delete one CatalogProduct.
     * @example
     * // Delete one CatalogProduct
     * const CatalogProduct = await prisma.catalogProduct.delete({
     *   where: {
     *     // ... filter to delete one CatalogProduct
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProduct.
     * @param {CatalogProductUpdateArgs} args - Arguments to update one CatalogProduct.
     * @example
     * // Update one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProducts.
     * @param {CatalogProductDeleteManyArgs} args - Arguments to filter CatalogProducts to delete.
     * @example
     * // Delete a few CatalogProducts
     * const { count } = await prisma.catalogProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProduct.
     * @param {CatalogProductUpsertArgs} args - Arguments to update or create a CatalogProduct.
     * @example
     * // Update or create a CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.upsert({
     *   create: {
     *     // ... data to create a CatalogProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductCountArgs} args - Arguments to filter CatalogProducts to count.
     * @example
     * // Count the number of CatalogProducts
     * const count = await prisma.catalogProduct.count({
     *   where: {
     *     // ... the filter for the CatalogProducts we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductCountArgs>(
      args?: Subset<T, CatalogProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductAggregateArgs>(args: Subset<T, CatalogProductAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductAggregateType<T>>

    /**
     * Group by CatalogProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProduct model
   */
  readonly fields: CatalogProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    attributes<T extends CatalogProduct$attributesArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findMany'> | Null>;

    variants<T extends CatalogProduct$variantsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findMany'> | Null>;

    categories<T extends CatalogProduct$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    vendors<T extends CatalogProduct$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProduct model
   */ 
  interface CatalogProductFieldRefs {
    readonly id: FieldRef<"CatalogProduct", 'String'>
    readonly name: FieldRef<"CatalogProduct", 'String'>
    readonly description: FieldRef<"CatalogProduct", 'String'>
    readonly image: FieldRef<"CatalogProduct", 'String'>
    readonly price: FieldRef<"CatalogProduct", 'Float'>
    readonly active: FieldRef<"CatalogProduct", 'Boolean'>
    readonly favorite: FieldRef<"CatalogProduct", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProduct findUnique
   */
  export type CatalogProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct findUniqueOrThrow
   */
  export type CatalogProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct findFirst
   */
  export type CatalogProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProducts.
     */
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct findFirstOrThrow
   */
  export type CatalogProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProducts.
     */
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct findMany
   */
  export type CatalogProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProducts to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct create
   */
  export type CatalogProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProduct.
     */
    data: XOR<CatalogProductCreateInput, CatalogProductUncheckedCreateInput>
  }

  /**
   * CatalogProduct createMany
   */
  export type CatalogProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProducts.
     */
    data: CatalogProductCreateManyInput | CatalogProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProduct createManyAndReturn
   */
  export type CatalogProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProducts.
     */
    data: CatalogProductCreateManyInput | CatalogProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProduct update
   */
  export type CatalogProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProduct.
     */
    data: XOR<CatalogProductUpdateInput, CatalogProductUncheckedUpdateInput>
    /**
     * Choose, which CatalogProduct to update.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct updateMany
   */
  export type CatalogProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProducts.
     */
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProducts to update
     */
    where?: CatalogProductWhereInput
  }

  /**
   * CatalogProduct upsert
   */
  export type CatalogProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProduct to update in case it exists.
     */
    where: CatalogProductWhereUniqueInput
    /**
     * In case the CatalogProduct found by the `where` argument doesn't exist, create a new CatalogProduct with this data.
     */
    create: XOR<CatalogProductCreateInput, CatalogProductUncheckedCreateInput>
    /**
     * In case the CatalogProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductUpdateInput, CatalogProductUncheckedUpdateInput>
  }

  /**
   * CatalogProduct delete
   */
  export type CatalogProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter which CatalogProduct to delete.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct deleteMany
   */
  export type CatalogProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProducts to delete
     */
    where?: CatalogProductWhereInput
  }

  /**
   * CatalogProduct.attributes
   */
  export type CatalogProduct$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    where?: CatalogProductAttributeWhereInput
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    cursor?: CatalogProductAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProduct.variants
   */
  export type CatalogProduct$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    where?: CatalogProductVariantWhereInput
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    cursor?: CatalogProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProduct.categories
   */
  export type CatalogProduct$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    where?: CatalogCategoryWhereInput
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    cursor?: CatalogCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogProduct.vendors
   */
  export type CatalogProduct$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    where?: CatalogVendorWhereInput
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    cursor?: CatalogVendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogProduct without action
   */
  export type CatalogProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
  }


  /**
   * Model CatalogProductAttribute
   */

  export type AggregateCatalogProductAttribute = {
    _count: CatalogProductAttributeCountAggregateOutputType | null
    _min: CatalogProductAttributeMinAggregateOutputType | null
    _max: CatalogProductAttributeMaxAggregateOutputType | null
  }

  export type CatalogProductAttributeMinAggregateOutputType = {
    id: string | null
    productId: string | null
    type: $Enums.ProductAttributeType | null
    value: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductAttributeMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    type: $Enums.ProductAttributeType | null
    value: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductAttributeCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    value: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductAttributeMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductAttributeMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductAttributeCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductAttribute to aggregate.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProductAttributes
    **/
    _count?: true | CatalogProductAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductAttributeMaxAggregateInputType
  }

  export type GetCatalogProductAttributeAggregateType<T extends CatalogProductAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProductAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProductAttribute[P]>
      : GetScalarType<T[P], AggregateCatalogProductAttribute[P]>
  }




  export type CatalogProductAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductAttributeWhereInput
    orderBy?: CatalogProductAttributeOrderByWithAggregationInput | CatalogProductAttributeOrderByWithAggregationInput[]
    by: CatalogProductAttributeScalarFieldEnum[] | CatalogProductAttributeScalarFieldEnum
    having?: CatalogProductAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductAttributeCountAggregateInputType | true
    _min?: CatalogProductAttributeMinAggregateInputType
    _max?: CatalogProductAttributeMaxAggregateInputType
  }

  export type CatalogProductAttributeGroupByOutputType = {
    id: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductAttributeCountAggregateOutputType | null
    _min: CatalogProductAttributeMinAggregateOutputType | null
    _max: CatalogProductAttributeMaxAggregateOutputType | null
  }

  type GetCatalogProductAttributeGroupByPayload<T extends CatalogProductAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductAttributeGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProductAttribute"]>

  export type CatalogProductAttributeSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }


  export type $CatalogProductAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProductAttribute"
    objects: {
      product: Prisma.$CatalogProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      type: $Enums.ProductAttributeType
      value: string
      description: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProductAttribute"]>
    composites: {}
  }


  type CatalogProductAttributeGetPayload<S extends boolean | null | undefined | CatalogProductAttributeDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductAttributePayload, S>

  type CatalogProductAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductAttributeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductAttributeCountAggregateInputType | true
    }

  export interface CatalogProductAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProductAttribute'], meta: { name: 'CatalogProductAttribute' } }
    /**
     * Find zero or one CatalogProductAttribute that matches the filter.
     * @param {CatalogProductAttributeFindUniqueArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductAttributeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProductAttribute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductAttributeFindUniqueOrThrowArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProductAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindFirstArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductAttributeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProductAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindFirstOrThrowArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProductAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProductAttributes
     * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany()
     * 
     * // Get first 10 CatalogProductAttributes
     * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductAttributeWithIdOnly = await prisma.catalogProductAttribute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductAttributeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProductAttribute.
     * @param {CatalogProductAttributeCreateArgs} args - Arguments to create a CatalogProductAttribute.
     * @example
     * // Create one CatalogProductAttribute
     * const CatalogProductAttribute = await prisma.catalogProductAttribute.create({
     *   data: {
     *     // ... data to create a CatalogProductAttribute
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductAttributeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProductAttributes.
     * @param {CatalogProductAttributeCreateManyArgs} args - Arguments to create many CatalogProductAttributes.
     * @example
     * // Create many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductAttributeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProductAttributes and returns the data saved in the database.
     * @param {CatalogProductAttributeCreateManyAndReturnArgs} args - Arguments to create many CatalogProductAttributes.
     * @example
     * // Create many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProductAttributes and only return the `id`
     * const catalogProductAttributeWithIdOnly = await prisma.catalogProductAttribute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProductAttribute.
     * @param {CatalogProductAttributeDeleteArgs} args - Arguments to delete one CatalogProductAttribute.
     * @example
     * // Delete one CatalogProductAttribute
     * const CatalogProductAttribute = await prisma.catalogProductAttribute.delete({
     *   where: {
     *     // ... filter to delete one CatalogProductAttribute
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductAttributeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProductAttribute.
     * @param {CatalogProductAttributeUpdateArgs} args - Arguments to update one CatalogProductAttribute.
     * @example
     * // Update one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductAttributeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProductAttributes.
     * @param {CatalogProductAttributeDeleteManyArgs} args - Arguments to filter CatalogProductAttributes to delete.
     * @example
     * // Delete a few CatalogProductAttributes
     * const { count } = await prisma.catalogProductAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductAttributeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductAttributeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProductAttribute.
     * @param {CatalogProductAttributeUpsertArgs} args - Arguments to update or create a CatalogProductAttribute.
     * @example
     * // Update or create a CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.upsert({
     *   create: {
     *     // ... data to create a CatalogProductAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProductAttribute we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductAttributeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeCountArgs} args - Arguments to filter CatalogProductAttributes to count.
     * @example
     * // Count the number of CatalogProductAttributes
     * const count = await prisma.catalogProductAttribute.count({
     *   where: {
     *     // ... the filter for the CatalogProductAttributes we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductAttributeCountArgs>(
      args?: Subset<T, CatalogProductAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductAttributeAggregateArgs>(args: Subset<T, CatalogProductAttributeAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductAttributeAggregateType<T>>

    /**
     * Group by CatalogProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductAttributeGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProductAttribute model
   */
  readonly fields: CatalogProductAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProductAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends CatalogProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProductDefaultArgs<ExtArgs>>): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProductAttribute model
   */ 
  interface CatalogProductAttributeFieldRefs {
    readonly id: FieldRef<"CatalogProductAttribute", 'String'>
    readonly productId: FieldRef<"CatalogProductAttribute", 'String'>
    readonly type: FieldRef<"CatalogProductAttribute", 'ProductAttributeType'>
    readonly value: FieldRef<"CatalogProductAttribute", 'String'>
    readonly description: FieldRef<"CatalogProductAttribute", 'String'>
    readonly active: FieldRef<"CatalogProductAttribute", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProductAttribute", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProductAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProductAttribute findUnique
   */
  export type CatalogProductAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute findUniqueOrThrow
   */
  export type CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute findFirst
   */
  export type CatalogProductAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductAttributes.
     */
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute findFirstOrThrow
   */
  export type CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductAttributes.
     */
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute findMany
   */
  export type CatalogProductAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttributes to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute create
   */
  export type CatalogProductAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProductAttribute.
     */
    data: XOR<CatalogProductAttributeCreateInput, CatalogProductAttributeUncheckedCreateInput>
  }

  /**
   * CatalogProductAttribute createMany
   */
  export type CatalogProductAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProductAttributes.
     */
    data: CatalogProductAttributeCreateManyInput | CatalogProductAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductAttribute createManyAndReturn
   */
  export type CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProductAttributes.
     */
    data: CatalogProductAttributeCreateManyInput | CatalogProductAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductAttribute update
   */
  export type CatalogProductAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProductAttribute.
     */
    data: XOR<CatalogProductAttributeUpdateInput, CatalogProductAttributeUncheckedUpdateInput>
    /**
     * Choose, which CatalogProductAttribute to update.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute updateMany
   */
  export type CatalogProductAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProductAttributes.
     */
    data: XOR<CatalogProductAttributeUpdateManyMutationInput, CatalogProductAttributeUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProductAttributes to update
     */
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductAttribute upsert
   */
  export type CatalogProductAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProductAttribute to update in case it exists.
     */
    where: CatalogProductAttributeWhereUniqueInput
    /**
     * In case the CatalogProductAttribute found by the `where` argument doesn't exist, create a new CatalogProductAttribute with this data.
     */
    create: XOR<CatalogProductAttributeCreateInput, CatalogProductAttributeUncheckedCreateInput>
    /**
     * In case the CatalogProductAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductAttributeUpdateInput, CatalogProductAttributeUncheckedUpdateInput>
  }

  /**
   * CatalogProductAttribute delete
   */
  export type CatalogProductAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter which CatalogProductAttribute to delete.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute deleteMany
   */
  export type CatalogProductAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductAttributes to delete
     */
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductAttribute without action
   */
  export type CatalogProductAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
  }


  /**
   * Model CatalogProductVariant
   */

  export type AggregateCatalogProductVariant = {
    _count: CatalogProductVariantCountAggregateOutputType | null
    _avg: CatalogProductVariantAvgAggregateOutputType | null
    _sum: CatalogProductVariantSumAggregateOutputType | null
    _min: CatalogProductVariantMinAggregateOutputType | null
    _max: CatalogProductVariantMaxAggregateOutputType | null
  }

  export type CatalogProductVariantAvgAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductVariantSumAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    name: number
    description: number
    caption: number
    barcode: number
    price: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductVariantAvgAggregateInputType = {
    price?: true
  }

  export type CatalogProductVariantSumAggregateInputType = {
    price?: true
  }

  export type CatalogProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductVariant to aggregate.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProductVariants
    **/
    _count?: true | CatalogProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductVariantMaxAggregateInputType
  }

  export type GetCatalogProductVariantAggregateType<T extends CatalogProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProductVariant[P]>
      : GetScalarType<T[P], AggregateCatalogProductVariant[P]>
  }




  export type CatalogProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductVariantWhereInput
    orderBy?: CatalogProductVariantOrderByWithAggregationInput | CatalogProductVariantOrderByWithAggregationInput[]
    by: CatalogProductVariantScalarFieldEnum[] | CatalogProductVariantScalarFieldEnum
    having?: CatalogProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductVariantCountAggregateInputType | true
    _avg?: CatalogProductVariantAvgAggregateInputType
    _sum?: CatalogProductVariantSumAggregateInputType
    _min?: CatalogProductVariantMinAggregateInputType
    _max?: CatalogProductVariantMaxAggregateInputType
  }

  export type CatalogProductVariantGroupByOutputType = {
    id: string
    productId: string
    sku: string
    name: string
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductVariantCountAggregateOutputType | null
    _avg: CatalogProductVariantAvgAggregateOutputType | null
    _sum: CatalogProductVariantSumAggregateOutputType | null
    _min: CatalogProductVariantMinAggregateOutputType | null
    _max: CatalogProductVariantMaxAggregateOutputType | null
  }

  type GetCatalogProductVariantGroupByPayload<T extends CatalogProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    caption?: boolean
    barcode?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProductVariant"]>

  export type CatalogProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    caption?: boolean
    barcode?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }


  export type $CatalogProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProductVariant"
    objects: {
      product: Prisma.$CatalogProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      name: string
      description: string | null
      caption: string | null
      barcode: string | null
      price: number | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProductVariant"]>
    composites: {}
  }


  type CatalogProductVariantGetPayload<S extends boolean | null | undefined | CatalogProductVariantDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductVariantPayload, S>

  type CatalogProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductVariantCountAggregateInputType | true
    }

  export interface CatalogProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProductVariant'], meta: { name: 'CatalogProductVariant' } }
    /**
     * Find zero or one CatalogProductVariant that matches the filter.
     * @param {CatalogProductVariantFindUniqueArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductVariantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProductVariant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductVariantFindUniqueOrThrowArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindFirstArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductVariantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindFirstOrThrowArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProductVariants
     * const catalogProductVariants = await prisma.catalogProductVariant.findMany()
     * 
     * // Get first 10 CatalogProductVariants
     * const catalogProductVariants = await prisma.catalogProductVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductVariantWithIdOnly = await prisma.catalogProductVariant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductVariantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProductVariant.
     * @param {CatalogProductVariantCreateArgs} args - Arguments to create a CatalogProductVariant.
     * @example
     * // Create one CatalogProductVariant
     * const CatalogProductVariant = await prisma.catalogProductVariant.create({
     *   data: {
     *     // ... data to create a CatalogProductVariant
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductVariantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProductVariants.
     * @param {CatalogProductVariantCreateManyArgs} args - Arguments to create many CatalogProductVariants.
     * @example
     * // Create many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductVariantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProductVariants and returns the data saved in the database.
     * @param {CatalogProductVariantCreateManyAndReturnArgs} args - Arguments to create many CatalogProductVariants.
     * @example
     * // Create many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProductVariants and only return the `id`
     * const catalogProductVariantWithIdOnly = await prisma.catalogProductVariant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProductVariant.
     * @param {CatalogProductVariantDeleteArgs} args - Arguments to delete one CatalogProductVariant.
     * @example
     * // Delete one CatalogProductVariant
     * const CatalogProductVariant = await prisma.catalogProductVariant.delete({
     *   where: {
     *     // ... filter to delete one CatalogProductVariant
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductVariantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProductVariant.
     * @param {CatalogProductVariantUpdateArgs} args - Arguments to update one CatalogProductVariant.
     * @example
     * // Update one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductVariantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProductVariants.
     * @param {CatalogProductVariantDeleteManyArgs} args - Arguments to filter CatalogProductVariants to delete.
     * @example
     * // Delete a few CatalogProductVariants
     * const { count } = await prisma.catalogProductVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductVariantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductVariantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProductVariant.
     * @param {CatalogProductVariantUpsertArgs} args - Arguments to update or create a CatalogProductVariant.
     * @example
     * // Update or create a CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.upsert({
     *   create: {
     *     // ... data to create a CatalogProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProductVariant we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductVariantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantCountArgs} args - Arguments to filter CatalogProductVariants to count.
     * @example
     * // Count the number of CatalogProductVariants
     * const count = await prisma.catalogProductVariant.count({
     *   where: {
     *     // ... the filter for the CatalogProductVariants we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductVariantCountArgs>(
      args?: Subset<T, CatalogProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductVariantAggregateArgs>(args: Subset<T, CatalogProductVariantAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductVariantAggregateType<T>>

    /**
     * Group by CatalogProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProductVariant model
   */
  readonly fields: CatalogProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends CatalogProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProductDefaultArgs<ExtArgs>>): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProductVariant model
   */ 
  interface CatalogProductVariantFieldRefs {
    readonly id: FieldRef<"CatalogProductVariant", 'String'>
    readonly productId: FieldRef<"CatalogProductVariant", 'String'>
    readonly sku: FieldRef<"CatalogProductVariant", 'String'>
    readonly name: FieldRef<"CatalogProductVariant", 'String'>
    readonly description: FieldRef<"CatalogProductVariant", 'String'>
    readonly caption: FieldRef<"CatalogProductVariant", 'String'>
    readonly barcode: FieldRef<"CatalogProductVariant", 'String'>
    readonly price: FieldRef<"CatalogProductVariant", 'Float'>
    readonly active: FieldRef<"CatalogProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProductVariant findUnique
   */
  export type CatalogProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant findUniqueOrThrow
   */
  export type CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant findFirst
   */
  export type CatalogProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductVariants.
     */
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant findFirstOrThrow
   */
  export type CatalogProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductVariants.
     */
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant findMany
   */
  export type CatalogProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariants to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant create
   */
  export type CatalogProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProductVariant.
     */
    data: XOR<CatalogProductVariantCreateInput, CatalogProductVariantUncheckedCreateInput>
  }

  /**
   * CatalogProductVariant createMany
   */
  export type CatalogProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProductVariants.
     */
    data: CatalogProductVariantCreateManyInput | CatalogProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductVariant createManyAndReturn
   */
  export type CatalogProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProductVariants.
     */
    data: CatalogProductVariantCreateManyInput | CatalogProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductVariant update
   */
  export type CatalogProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProductVariant.
     */
    data: XOR<CatalogProductVariantUpdateInput, CatalogProductVariantUncheckedUpdateInput>
    /**
     * Choose, which CatalogProductVariant to update.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant updateMany
   */
  export type CatalogProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProductVariants.
     */
    data: XOR<CatalogProductVariantUpdateManyMutationInput, CatalogProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProductVariants to update
     */
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductVariant upsert
   */
  export type CatalogProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProductVariant to update in case it exists.
     */
    where: CatalogProductVariantWhereUniqueInput
    /**
     * In case the CatalogProductVariant found by the `where` argument doesn't exist, create a new CatalogProductVariant with this data.
     */
    create: XOR<CatalogProductVariantCreateInput, CatalogProductVariantUncheckedCreateInput>
    /**
     * In case the CatalogProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductVariantUpdateInput, CatalogProductVariantUncheckedUpdateInput>
  }

  /**
   * CatalogProductVariant delete
   */
  export type CatalogProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter which CatalogProductVariant to delete.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant deleteMany
   */
  export type CatalogProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductVariants to delete
     */
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductVariant without action
   */
  export type CatalogProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model CatalogCategory
   */

  export type AggregateCatalogCategory = {
    _count: CatalogCategoryCountAggregateOutputType | null
    _min: CatalogCategoryMinAggregateOutputType | null
    _max: CatalogCategoryMaxAggregateOutputType | null
  }

  export type CatalogCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCategoryCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogCategoryMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCategoryCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCategory to aggregate.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogCategories
    **/
    _count?: true | CatalogCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogCategoryMaxAggregateInputType
  }

  export type GetCatalogCategoryAggregateType<T extends CatalogCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogCategory[P]>
      : GetScalarType<T[P], AggregateCatalogCategory[P]>
  }




  export type CatalogCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCategoryWhereInput
    orderBy?: CatalogCategoryOrderByWithAggregationInput | CatalogCategoryOrderByWithAggregationInput[]
    by: CatalogCategoryScalarFieldEnum[] | CatalogCategoryScalarFieldEnum
    having?: CatalogCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogCategoryCountAggregateInputType | true
    _min?: CatalogCategoryMinAggregateInputType
    _max?: CatalogCategoryMaxAggregateInputType
  }

  export type CatalogCategoryGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogCategoryCountAggregateOutputType | null
    _min: CatalogCategoryMinAggregateOutputType | null
    _max: CatalogCategoryMaxAggregateOutputType | null
  }

  type GetCatalogCategoryGroupByPayload<T extends CatalogCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CatalogCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | CatalogCategory$productsArgs<ExtArgs>
    _count?: boolean | CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogCategory"]>

  export type CatalogCategorySelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogCategory$productsArgs<ExtArgs>
    _count?: boolean | CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogCategory"
    objects: {
      products: Prisma.$CatalogProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogCategory"]>
    composites: {}
  }


  type CatalogCategoryGetPayload<S extends boolean | null | undefined | CatalogCategoryDefaultArgs> = $Result.GetResult<Prisma.$CatalogCategoryPayload, S>

  type CatalogCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogCategoryCountAggregateInputType | true
    }

  export interface CatalogCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogCategory'], meta: { name: 'CatalogCategory' } }
    /**
     * Find zero or one CatalogCategory that matches the filter.
     * @param {CatalogCategoryFindUniqueArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogCategoryFindUniqueOrThrowArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindFirstArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindFirstOrThrowArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogCategories
     * const catalogCategories = await prisma.catalogCategory.findMany()
     * 
     * // Get first 10 CatalogCategories
     * const catalogCategories = await prisma.catalogCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogCategoryWithIdOnly = await prisma.catalogCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogCategory.
     * @param {CatalogCategoryCreateArgs} args - Arguments to create a CatalogCategory.
     * @example
     * // Create one CatalogCategory
     * const CatalogCategory = await prisma.catalogCategory.create({
     *   data: {
     *     // ... data to create a CatalogCategory
     *   }
     * })
     * 
    **/
    create<T extends CatalogCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryCreateArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogCategories.
     * @param {CatalogCategoryCreateManyArgs} args - Arguments to create many CatalogCategories.
     * @example
     * // Create many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogCategories and returns the data saved in the database.
     * @param {CatalogCategoryCreateManyAndReturnArgs} args - Arguments to create many CatalogCategories.
     * @example
     * // Create many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogCategories and only return the `id`
     * const catalogCategoryWithIdOnly = await prisma.catalogCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogCategoryCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogCategory.
     * @param {CatalogCategoryDeleteArgs} args - Arguments to delete one CatalogCategory.
     * @example
     * // Delete one CatalogCategory
     * const CatalogCategory = await prisma.catalogCategory.delete({
     *   where: {
     *     // ... filter to delete one CatalogCategory
     *   }
     * })
     * 
    **/
    delete<T extends CatalogCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryDeleteArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogCategory.
     * @param {CatalogCategoryUpdateArgs} args - Arguments to update one CatalogCategory.
     * @example
     * // Update one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpdateArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogCategories.
     * @param {CatalogCategoryDeleteManyArgs} args - Arguments to filter CatalogCategories to delete.
     * @example
     * // Delete a few CatalogCategories
     * const { count } = await prisma.catalogCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogCategory.
     * @param {CatalogCategoryUpsertArgs} args - Arguments to update or create a CatalogCategory.
     * @example
     * // Update or create a CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.upsert({
     *   create: {
     *     // ... data to create a CatalogCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogCategory we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpsertArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryCountArgs} args - Arguments to filter CatalogCategories to count.
     * @example
     * // Count the number of CatalogCategories
     * const count = await prisma.catalogCategory.count({
     *   where: {
     *     // ... the filter for the CatalogCategories we want to count
     *   }
     * })
    **/
    count<T extends CatalogCategoryCountArgs>(
      args?: Subset<T, CatalogCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogCategoryAggregateArgs>(args: Subset<T, CatalogCategoryAggregateArgs>): Prisma.PrismaPromise<GetCatalogCategoryAggregateType<T>>

    /**
     * Group by CatalogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CatalogCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogCategory model
   */
  readonly fields: CatalogCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends CatalogCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogCategory model
   */ 
  interface CatalogCategoryFieldRefs {
    readonly id: FieldRef<"CatalogCategory", 'String'>
    readonly name: FieldRef<"CatalogCategory", 'String'>
    readonly parentId: FieldRef<"CatalogCategory", 'String'>
    readonly active: FieldRef<"CatalogCategory", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogCategory findUnique
   */
  export type CatalogCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory findUniqueOrThrow
   */
  export type CatalogCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory findFirst
   */
  export type CatalogCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCategories.
     */
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory findFirstOrThrow
   */
  export type CatalogCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCategories.
     */
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory findMany
   */
  export type CatalogCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategories to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory create
   */
  export type CatalogCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogCategory.
     */
    data: XOR<CatalogCategoryCreateInput, CatalogCategoryUncheckedCreateInput>
  }

  /**
   * CatalogCategory createMany
   */
  export type CatalogCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogCategories.
     */
    data: CatalogCategoryCreateManyInput | CatalogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogCategory createManyAndReturn
   */
  export type CatalogCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogCategories.
     */
    data: CatalogCategoryCreateManyInput | CatalogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogCategory update
   */
  export type CatalogCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogCategory.
     */
    data: XOR<CatalogCategoryUpdateInput, CatalogCategoryUncheckedUpdateInput>
    /**
     * Choose, which CatalogCategory to update.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory updateMany
   */
  export type CatalogCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogCategories.
     */
    data: XOR<CatalogCategoryUpdateManyMutationInput, CatalogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CatalogCategories to update
     */
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogCategory upsert
   */
  export type CatalogCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogCategory to update in case it exists.
     */
    where: CatalogCategoryWhereUniqueInput
    /**
     * In case the CatalogCategory found by the `where` argument doesn't exist, create a new CatalogCategory with this data.
     */
    create: XOR<CatalogCategoryCreateInput, CatalogCategoryUncheckedCreateInput>
    /**
     * In case the CatalogCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogCategoryUpdateInput, CatalogCategoryUncheckedUpdateInput>
  }

  /**
   * CatalogCategory delete
   */
  export type CatalogCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter which CatalogCategory to delete.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory deleteMany
   */
  export type CatalogCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCategories to delete
     */
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogCategory.products
   */
  export type CatalogCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    cursor?: CatalogProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogCategory without action
   */
  export type CatalogCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CatalogVendor
   */

  export type AggregateCatalogVendor = {
    _count: CatalogVendorCountAggregateOutputType | null
    _min: CatalogVendorMinAggregateOutputType | null
    _max: CatalogVendorMaxAggregateOutputType | null
  }

  export type CatalogVendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogVendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogVendorCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogVendorMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogVendorMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogVendorCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogVendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVendor to aggregate.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogVendors
    **/
    _count?: true | CatalogVendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogVendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogVendorMaxAggregateInputType
  }

  export type GetCatalogVendorAggregateType<T extends CatalogVendorAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogVendor[P]>
      : GetScalarType<T[P], AggregateCatalogVendor[P]>
  }




  export type CatalogVendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogVendorWhereInput
    orderBy?: CatalogVendorOrderByWithAggregationInput | CatalogVendorOrderByWithAggregationInput[]
    by: CatalogVendorScalarFieldEnum[] | CatalogVendorScalarFieldEnum
    having?: CatalogVendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogVendorCountAggregateInputType | true
    _min?: CatalogVendorMinAggregateInputType
    _max?: CatalogVendorMaxAggregateInputType
  }

  export type CatalogVendorGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogVendorCountAggregateOutputType | null
    _min: CatalogVendorMinAggregateOutputType | null
    _max: CatalogVendorMaxAggregateOutputType | null
  }

  type GetCatalogVendorGroupByPayload<T extends CatalogVendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogVendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogVendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogVendorGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogVendorGroupByOutputType[P]>
        }
      >
    >


  export type CatalogVendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | CatalogVendor$productsArgs<ExtArgs>
    _count?: boolean | CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogVendor"]>

  export type CatalogVendorSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogVendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogVendor$productsArgs<ExtArgs>
    _count?: boolean | CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogVendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogVendor"
    objects: {
      products: Prisma.$CatalogProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogVendor"]>
    composites: {}
  }


  type CatalogVendorGetPayload<S extends boolean | null | undefined | CatalogVendorDefaultArgs> = $Result.GetResult<Prisma.$CatalogVendorPayload, S>

  type CatalogVendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogVendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogVendorCountAggregateInputType | true
    }

  export interface CatalogVendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogVendor'], meta: { name: 'CatalogVendor' } }
    /**
     * Find zero or one CatalogVendor that matches the filter.
     * @param {CatalogVendorFindUniqueArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogVendorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogVendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogVendorFindUniqueOrThrowArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogVendorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogVendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindFirstArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogVendorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogVendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindFirstOrThrowArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogVendorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogVendors
     * const catalogVendors = await prisma.catalogVendor.findMany()
     * 
     * // Get first 10 CatalogVendors
     * const catalogVendors = await prisma.catalogVendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogVendorWithIdOnly = await prisma.catalogVendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogVendorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogVendor.
     * @param {CatalogVendorCreateArgs} args - Arguments to create a CatalogVendor.
     * @example
     * // Create one CatalogVendor
     * const CatalogVendor = await prisma.catalogVendor.create({
     *   data: {
     *     // ... data to create a CatalogVendor
     *   }
     * })
     * 
    **/
    create<T extends CatalogVendorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorCreateArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogVendors.
     * @param {CatalogVendorCreateManyArgs} args - Arguments to create many CatalogVendors.
     * @example
     * // Create many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogVendorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogVendors and returns the data saved in the database.
     * @param {CatalogVendorCreateManyAndReturnArgs} args - Arguments to create many CatalogVendors.
     * @example
     * // Create many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogVendors and only return the `id`
     * const catalogVendorWithIdOnly = await prisma.catalogVendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogVendorCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogVendor.
     * @param {CatalogVendorDeleteArgs} args - Arguments to delete one CatalogVendor.
     * @example
     * // Delete one CatalogVendor
     * const CatalogVendor = await prisma.catalogVendor.delete({
     *   where: {
     *     // ... filter to delete one CatalogVendor
     *   }
     * })
     * 
    **/
    delete<T extends CatalogVendorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorDeleteArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogVendor.
     * @param {CatalogVendorUpdateArgs} args - Arguments to update one CatalogVendor.
     * @example
     * // Update one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogVendorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpdateArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogVendors.
     * @param {CatalogVendorDeleteManyArgs} args - Arguments to filter CatalogVendors to delete.
     * @example
     * // Delete a few CatalogVendors
     * const { count } = await prisma.catalogVendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogVendorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogVendorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogVendor.
     * @param {CatalogVendorUpsertArgs} args - Arguments to update or create a CatalogVendor.
     * @example
     * // Update or create a CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.upsert({
     *   create: {
     *     // ... data to create a CatalogVendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogVendor we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogVendorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpsertArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorCountArgs} args - Arguments to filter CatalogVendors to count.
     * @example
     * // Count the number of CatalogVendors
     * const count = await prisma.catalogVendor.count({
     *   where: {
     *     // ... the filter for the CatalogVendors we want to count
     *   }
     * })
    **/
    count<T extends CatalogVendorCountArgs>(
      args?: Subset<T, CatalogVendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogVendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogVendorAggregateArgs>(args: Subset<T, CatalogVendorAggregateArgs>): Prisma.PrismaPromise<GetCatalogVendorAggregateType<T>>

    /**
     * Group by CatalogVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogVendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogVendorGroupByArgs['orderBy'] }
        : { orderBy?: CatalogVendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogVendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogVendor model
   */
  readonly fields: CatalogVendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogVendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogVendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends CatalogVendor$productsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogVendor$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogVendor model
   */ 
  interface CatalogVendorFieldRefs {
    readonly id: FieldRef<"CatalogVendor", 'String'>
    readonly name: FieldRef<"CatalogVendor", 'String'>
    readonly description: FieldRef<"CatalogVendor", 'String'>
    readonly image: FieldRef<"CatalogVendor", 'String'>
    readonly active: FieldRef<"CatalogVendor", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogVendor", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogVendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogVendor findUnique
   */
  export type CatalogVendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor findUniqueOrThrow
   */
  export type CatalogVendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor findFirst
   */
  export type CatalogVendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVendors.
     */
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor findFirstOrThrow
   */
  export type CatalogVendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVendors.
     */
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor findMany
   */
  export type CatalogVendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendors to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor create
   */
  export type CatalogVendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogVendor.
     */
    data: XOR<CatalogVendorCreateInput, CatalogVendorUncheckedCreateInput>
  }

  /**
   * CatalogVendor createMany
   */
  export type CatalogVendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogVendors.
     */
    data: CatalogVendorCreateManyInput | CatalogVendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogVendor createManyAndReturn
   */
  export type CatalogVendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogVendors.
     */
    data: CatalogVendorCreateManyInput | CatalogVendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogVendor update
   */
  export type CatalogVendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogVendor.
     */
    data: XOR<CatalogVendorUpdateInput, CatalogVendorUncheckedUpdateInput>
    /**
     * Choose, which CatalogVendor to update.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor updateMany
   */
  export type CatalogVendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogVendors.
     */
    data: XOR<CatalogVendorUpdateManyMutationInput, CatalogVendorUncheckedUpdateManyInput>
    /**
     * Filter which CatalogVendors to update
     */
    where?: CatalogVendorWhereInput
  }

  /**
   * CatalogVendor upsert
   */
  export type CatalogVendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogVendor to update in case it exists.
     */
    where: CatalogVendorWhereUniqueInput
    /**
     * In case the CatalogVendor found by the `where` argument doesn't exist, create a new CatalogVendor with this data.
     */
    create: XOR<CatalogVendorCreateInput, CatalogVendorUncheckedCreateInput>
    /**
     * In case the CatalogVendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogVendorUpdateInput, CatalogVendorUncheckedUpdateInput>
  }

  /**
   * CatalogVendor delete
   */
  export type CatalogVendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter which CatalogVendor to delete.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor deleteMany
   */
  export type CatalogVendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVendors to delete
     */
    where?: CatalogVendorWhereInput
  }

  /**
   * CatalogVendor.products
   */
  export type CatalogVendor$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    cursor?: CatalogProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogVendor without action
   */
  export type CatalogVendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    entityId: string | null
    entityType: string | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    entityId: string | null
    entityType: string | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    entityId: number
    entityType: number
    action: number
    context: number
    comment: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    context?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    entityId: string | null
    entityType: string | null
    action: string
    context: JsonValue | null
    comment: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    entityId?: boolean
    entityType?: boolean
    action?: boolean
    context?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    entityId?: boolean
    entityType?: boolean
    action?: boolean
    context?: boolean
    comment?: boolean
    createdAt?: boolean
  }


  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      entityId: string | null
      entityType: string | null
      action: string
      context: Prisma.JsonValue | null
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly context: FieldRef<"AuditLog", 'Json'>
    readonly comment: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Printer
   */

  export type AggregatePrinter = {
    _count: PrinterCountAggregateOutputType | null
    _min: PrinterMinAggregateOutputType | null
    _max: PrinterMaxAggregateOutputType | null
  }

  export type PrinterMinAggregateOutputType = {
    id: string | null
    printerIdentifier: string | null
    tailScaleIP: string | null
    portNumber: string | null
    privateIPAddress: string | null
  }

  export type PrinterMaxAggregateOutputType = {
    id: string | null
    printerIdentifier: string | null
    tailScaleIP: string | null
    portNumber: string | null
    privateIPAddress: string | null
  }

  export type PrinterCountAggregateOutputType = {
    id: number
    printerIdentifier: number
    tailScaleIP: number
    portNumber: number
    privateIPAddress: number
    _all: number
  }


  export type PrinterMinAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
  }

  export type PrinterMaxAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
  }

  export type PrinterCountAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
    _all?: true
  }

  export type PrinterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Printer to aggregate.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Printers
    **/
    _count?: true | PrinterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrinterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrinterMaxAggregateInputType
  }

  export type GetPrinterAggregateType<T extends PrinterAggregateArgs> = {
        [P in keyof T & keyof AggregatePrinter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrinter[P]>
      : GetScalarType<T[P], AggregatePrinter[P]>
  }




  export type PrinterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrinterWhereInput
    orderBy?: PrinterOrderByWithAggregationInput | PrinterOrderByWithAggregationInput[]
    by: PrinterScalarFieldEnum[] | PrinterScalarFieldEnum
    having?: PrinterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrinterCountAggregateInputType | true
    _min?: PrinterMinAggregateInputType
    _max?: PrinterMaxAggregateInputType
  }

  export type PrinterGroupByOutputType = {
    id: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
    _count: PrinterCountAggregateOutputType | null
    _min: PrinterMinAggregateOutputType | null
    _max: PrinterMaxAggregateOutputType | null
  }

  type GetPrinterGroupByPayload<T extends PrinterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrinterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrinterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrinterGroupByOutputType[P]>
            : GetScalarType<T[P], PrinterGroupByOutputType[P]>
        }
      >
    >


  export type PrinterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    printerIdentifier?: boolean
    tailScaleIP?: boolean
    portNumber?: boolean
    privateIPAddress?: boolean
  }, ExtArgs["result"]["printer"]>

  export type PrinterSelectScalar = {
    id?: boolean
    printerIdentifier?: boolean
    tailScaleIP?: boolean
    portNumber?: boolean
    privateIPAddress?: boolean
  }



  export type $PrinterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Printer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      printerIdentifier: string
      tailScaleIP: string
      portNumber: string
      privateIPAddress: string
    }, ExtArgs["result"]["printer"]>
    composites: {}
  }


  type PrinterGetPayload<S extends boolean | null | undefined | PrinterDefaultArgs> = $Result.GetResult<Prisma.$PrinterPayload, S>

  type PrinterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrinterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrinterCountAggregateInputType | true
    }

  export interface PrinterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Printer'], meta: { name: 'Printer' } }
    /**
     * Find zero or one Printer that matches the filter.
     * @param {PrinterFindUniqueArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrinterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterFindUniqueArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Printer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrinterFindUniqueOrThrowArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PrinterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Printer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindFirstArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrinterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindFirstArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Printer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindFirstOrThrowArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PrinterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Printers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Printers
     * const printers = await prisma.printer.findMany()
     * 
     * // Get first 10 Printers
     * const printers = await prisma.printer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printerWithIdOnly = await prisma.printer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PrinterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Printer.
     * @param {PrinterCreateArgs} args - Arguments to create a Printer.
     * @example
     * // Create one Printer
     * const Printer = await prisma.printer.create({
     *   data: {
     *     // ... data to create a Printer
     *   }
     * })
     * 
    **/
    create<T extends PrinterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterCreateArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Printers.
     * @param {PrinterCreateManyArgs} args - Arguments to create many Printers.
     * @example
     * // Create many Printers
     * const printer = await prisma.printer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PrinterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Printers and returns the data saved in the database.
     * @param {PrinterCreateManyAndReturnArgs} args - Arguments to create many Printers.
     * @example
     * // Create many Printers
     * const printer = await prisma.printer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Printers and only return the `id`
     * const printerWithIdOnly = await prisma.printer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PrinterCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Printer.
     * @param {PrinterDeleteArgs} args - Arguments to delete one Printer.
     * @example
     * // Delete one Printer
     * const Printer = await prisma.printer.delete({
     *   where: {
     *     // ... filter to delete one Printer
     *   }
     * })
     * 
    **/
    delete<T extends PrinterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterDeleteArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Printer.
     * @param {PrinterUpdateArgs} args - Arguments to update one Printer.
     * @example
     * // Update one Printer
     * const printer = await prisma.printer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrinterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpdateArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Printers.
     * @param {PrinterDeleteManyArgs} args - Arguments to filter Printers to delete.
     * @example
     * // Delete a few Printers
     * const { count } = await prisma.printer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrinterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Printers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Printers
     * const printer = await prisma.printer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrinterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Printer.
     * @param {PrinterUpsertArgs} args - Arguments to update or create a Printer.
     * @example
     * // Update or create a Printer
     * const printer = await prisma.printer.upsert({
     *   create: {
     *     // ... data to create a Printer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Printer we want to update
     *   }
     * })
    **/
    upsert<T extends PrinterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpsertArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Printers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterCountArgs} args - Arguments to filter Printers to count.
     * @example
     * // Count the number of Printers
     * const count = await prisma.printer.count({
     *   where: {
     *     // ... the filter for the Printers we want to count
     *   }
     * })
    **/
    count<T extends PrinterCountArgs>(
      args?: Subset<T, PrinterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrinterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Printer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrinterAggregateArgs>(args: Subset<T, PrinterAggregateArgs>): Prisma.PrismaPromise<GetPrinterAggregateType<T>>

    /**
     * Group by Printer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrinterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrinterGroupByArgs['orderBy'] }
        : { orderBy?: PrinterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrinterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrinterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Printer model
   */
  readonly fields: PrinterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Printer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrinterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Printer model
   */ 
  interface PrinterFieldRefs {
    readonly id: FieldRef<"Printer", 'String'>
    readonly printerIdentifier: FieldRef<"Printer", 'String'>
    readonly tailScaleIP: FieldRef<"Printer", 'String'>
    readonly portNumber: FieldRef<"Printer", 'String'>
    readonly privateIPAddress: FieldRef<"Printer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Printer findUnique
   */
  export type PrinterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer findUniqueOrThrow
   */
  export type PrinterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer findFirst
   */
  export type PrinterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Printers.
     */
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer findFirstOrThrow
   */
  export type PrinterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Printers.
     */
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer findMany
   */
  export type PrinterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printers to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer create
   */
  export type PrinterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data needed to create a Printer.
     */
    data: XOR<PrinterCreateInput, PrinterUncheckedCreateInput>
  }

  /**
   * Printer createMany
   */
  export type PrinterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Printers.
     */
    data: PrinterCreateManyInput | PrinterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Printer createManyAndReturn
   */
  export type PrinterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data used to create many Printers.
     */
    data: PrinterCreateManyInput | PrinterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Printer update
   */
  export type PrinterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data needed to update a Printer.
     */
    data: XOR<PrinterUpdateInput, PrinterUncheckedUpdateInput>
    /**
     * Choose, which Printer to update.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer updateMany
   */
  export type PrinterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Printers.
     */
    data: XOR<PrinterUpdateManyMutationInput, PrinterUncheckedUpdateManyInput>
    /**
     * Filter which Printers to update
     */
    where?: PrinterWhereInput
  }

  /**
   * Printer upsert
   */
  export type PrinterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The filter to search for the Printer to update in case it exists.
     */
    where: PrinterWhereUniqueInput
    /**
     * In case the Printer found by the `where` argument doesn't exist, create a new Printer with this data.
     */
    create: XOR<PrinterCreateInput, PrinterUncheckedCreateInput>
    /**
     * In case the Printer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrinterUpdateInput, PrinterUncheckedUpdateInput>
  }

  /**
   * Printer delete
   */
  export type PrinterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter which Printer to delete.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer deleteMany
   */
  export type PrinterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Printers to delete
     */
    where?: PrinterWhereInput
  }

  /**
   * Printer without action
   */
  export type PrinterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
  }


  /**
   * Model CompanyUser
   */

  export type AggregateCompanyUser = {
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  export type CompanyUserMinAggregateOutputType = {
    userId: string | null
    companyId: string | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserMaxAggregateOutputType = {
    userId: string | null
    companyId: string | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserCountAggregateOutputType = {
    userId: number
    companyId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyUserMinAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserMaxAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserCountAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUser to aggregate.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUsers
    **/
    _count?: true | CompanyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserMaxAggregateInputType
  }

  export type GetCompanyUserAggregateType<T extends CompanyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUser[P]>
      : GetScalarType<T[P], AggregateCompanyUser[P]>
  }




  export type CompanyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithAggregationInput | CompanyUserOrderByWithAggregationInput[]
    by: CompanyUserScalarFieldEnum[] | CompanyUserScalarFieldEnum
    having?: CompanyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserCountAggregateInputType | true
    _min?: CompanyUserMinAggregateInputType
    _max?: CompanyUserMaxAggregateInputType
  }

  export type CompanyUserGroupByOutputType = {
    userId: string
    companyId: string
    role: $Enums.CompanyRole
    createdAt: Date
    updatedAt: Date
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  type GetCompanyUserGroupByPayload<T extends CompanyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectScalar = {
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $CompanyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUser"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      companyId: string
      role: $Enums.CompanyRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyUser"]>
    composites: {}
  }


  type CompanyUserGetPayload<S extends boolean | null | undefined | CompanyUserDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPayload, S>

  type CompanyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyUserCountAggregateInputType | true
    }

  export interface CompanyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUser'], meta: { name: 'CompanyUser' } }
    /**
     * Find zero or one CompanyUser that matches the filter.
     * @param {CompanyUserFindUniqueArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyUserFindUniqueOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany()
     * 
     * // Get first 10 CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const companyUserWithUserIdOnly = await prisma.companyUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CompanyUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyUser.
     * @param {CompanyUserCreateArgs} args - Arguments to create a CompanyUser.
     * @example
     * // Create one CompanyUser
     * const CompanyUser = await prisma.companyUser.create({
     *   data: {
     *     // ... data to create a CompanyUser
     *   }
     * })
     * 
    **/
    create<T extends CompanyUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserCreateArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyUsers.
     * @param {CompanyUserCreateManyArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUsers and returns the data saved in the database.
     * @param {CompanyUserCreateManyAndReturnArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUsers and only return the `userId`
     * const companyUserWithUserIdOnly = await prisma.companyUser.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyUserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyUser.
     * @param {CompanyUserDeleteArgs} args - Arguments to delete one CompanyUser.
     * @example
     * // Delete one CompanyUser
     * const CompanyUser = await prisma.companyUser.delete({
     *   where: {
     *     // ... filter to delete one CompanyUser
     *   }
     * })
     * 
    **/
    delete<T extends CompanyUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserDeleteArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyUser.
     * @param {CompanyUserUpdateArgs} args - Arguments to update one CompanyUser.
     * @example
     * // Update one CompanyUser
     * const companyUser = await prisma.companyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpdateArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyUsers.
     * @param {CompanyUserDeleteManyArgs} args - Arguments to filter CompanyUsers to delete.
     * @example
     * // Delete a few CompanyUsers
     * const { count } = await prisma.companyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyUser.
     * @param {CompanyUserUpsertArgs} args - Arguments to update or create a CompanyUser.
     * @example
     * // Update or create a CompanyUser
     * const companyUser = await prisma.companyUser.upsert({
     *   create: {
     *     // ... data to create a CompanyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUser we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpsertArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserCountArgs} args - Arguments to filter CompanyUsers to count.
     * @example
     * // Count the number of CompanyUsers
     * const count = await prisma.companyUser.count({
     *   where: {
     *     // ... the filter for the CompanyUsers we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserCountArgs>(
      args?: Subset<T, CompanyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserAggregateArgs>(args: Subset<T, CompanyUserAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserAggregateType<T>>

    /**
     * Group by CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUser model
   */
  readonly fields: CompanyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyUser model
   */ 
  interface CompanyUserFieldRefs {
    readonly userId: FieldRef<"CompanyUser", 'String'>
    readonly companyId: FieldRef<"CompanyUser", 'String'>
    readonly role: FieldRef<"CompanyUser", 'CompanyRole'>
    readonly createdAt: FieldRef<"CompanyUser", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUser findUnique
   */
  export type CompanyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findUniqueOrThrow
   */
  export type CompanyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findFirst
   */
  export type CompanyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findFirstOrThrow
   */
  export type CompanyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findMany
   */
  export type CompanyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUsers to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser create
   */
  export type CompanyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUser.
     */
    data: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
  }

  /**
   * CompanyUser createMany
   */
  export type CompanyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser createManyAndReturn
   */
  export type CompanyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser update
   */
  export type CompanyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUser.
     */
    data: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
    /**
     * Choose, which CompanyUser to update.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser updateMany
   */
  export type CompanyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser upsert
   */
  export type CompanyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUser to update in case it exists.
     */
    where: CompanyUserWhereUniqueInput
    /**
     * In case the CompanyUser found by the `where` argument doesn't exist, create a new CompanyUser with this data.
     */
    create: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
    /**
     * In case the CompanyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
  }

  /**
   * CompanyUser delete
   */
  export type CompanyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter which CompanyUser to delete.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser deleteMany
   */
  export type CompanyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUsers to delete
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser without action
   */
  export type CompanyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentUser
   */

  export type AggregateDepartmentUser = {
    _count: DepartmentUserCountAggregateOutputType | null
    _min: DepartmentUserMinAggregateOutputType | null
    _max: DepartmentUserMaxAggregateOutputType | null
  }

  export type DepartmentUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    department: $Enums.CompanyDepartment | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    department: $Enums.CompanyDepartment | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentUserCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    department: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentUserMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    department?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentUserMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    department?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentUserCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    department?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentUser to aggregate.
     */
    where?: DepartmentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentUsers to fetch.
     */
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentUsers
    **/
    _count?: true | DepartmentUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentUserMaxAggregateInputType
  }

  export type GetDepartmentUserAggregateType<T extends DepartmentUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentUser[P]>
      : GetScalarType<T[P], AggregateDepartmentUser[P]>
  }




  export type DepartmentUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentUserWhereInput
    orderBy?: DepartmentUserOrderByWithAggregationInput | DepartmentUserOrderByWithAggregationInput[]
    by: DepartmentUserScalarFieldEnum[] | DepartmentUserScalarFieldEnum
    having?: DepartmentUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentUserCountAggregateInputType | true
    _min?: DepartmentUserMinAggregateInputType
    _max?: DepartmentUserMaxAggregateInputType
  }

  export type DepartmentUserGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    department: $Enums.CompanyDepartment
    role: $Enums.CompanyRole
    createdAt: Date
    updatedAt: Date
    _count: DepartmentUserCountAggregateOutputType | null
    _min: DepartmentUserMinAggregateOutputType | null
    _max: DepartmentUserMaxAggregateOutputType | null
  }

  type GetDepartmentUserGroupByPayload<T extends DepartmentUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentUserGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentUserGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    department?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentUser"]>

  export type DepartmentUserSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    department?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DepartmentUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $DepartmentUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      department: $Enums.CompanyDepartment
      role: $Enums.CompanyRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentUser"]>
    composites: {}
  }


  type DepartmentUserGetPayload<S extends boolean | null | undefined | DepartmentUserDefaultArgs> = $Result.GetResult<Prisma.$DepartmentUserPayload, S>

  type DepartmentUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentUserCountAggregateInputType | true
    }

  export interface DepartmentUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentUser'], meta: { name: 'DepartmentUser' } }
    /**
     * Find zero or one DepartmentUser that matches the filter.
     * @param {DepartmentUserFindUniqueArgs} args - Arguments to find a DepartmentUser
     * @example
     * // Get one DepartmentUser
     * const departmentUser = await prisma.departmentUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartmentUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserFindUniqueArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DepartmentUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentUserFindUniqueOrThrowArgs} args - Arguments to find a DepartmentUser
     * @example
     * // Get one DepartmentUser
     * const departmentUser = await prisma.departmentUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DepartmentUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DepartmentUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserFindFirstArgs} args - Arguments to find a DepartmentUser
     * @example
     * // Get one DepartmentUser
     * const departmentUser = await prisma.departmentUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartmentUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserFindFirstArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DepartmentUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserFindFirstOrThrowArgs} args - Arguments to find a DepartmentUser
     * @example
     * // Get one DepartmentUser
     * const departmentUser = await prisma.departmentUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DepartmentUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DepartmentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentUsers
     * const departmentUsers = await prisma.departmentUser.findMany()
     * 
     * // Get first 10 DepartmentUsers
     * const departmentUsers = await prisma.departmentUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentUserWithIdOnly = await prisma.departmentUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DepartmentUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DepartmentUser.
     * @param {DepartmentUserCreateArgs} args - Arguments to create a DepartmentUser.
     * @example
     * // Create one DepartmentUser
     * const DepartmentUser = await prisma.departmentUser.create({
     *   data: {
     *     // ... data to create a DepartmentUser
     *   }
     * })
     * 
    **/
    create<T extends DepartmentUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserCreateArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DepartmentUsers.
     * @param {DepartmentUserCreateManyArgs} args - Arguments to create many DepartmentUsers.
     * @example
     * // Create many DepartmentUsers
     * const departmentUser = await prisma.departmentUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DepartmentUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentUsers and returns the data saved in the database.
     * @param {DepartmentUserCreateManyAndReturnArgs} args - Arguments to create many DepartmentUsers.
     * @example
     * // Create many DepartmentUsers
     * const departmentUser = await prisma.departmentUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentUsers and only return the `id`
     * const departmentUserWithIdOnly = await prisma.departmentUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DepartmentUserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a DepartmentUser.
     * @param {DepartmentUserDeleteArgs} args - Arguments to delete one DepartmentUser.
     * @example
     * // Delete one DepartmentUser
     * const DepartmentUser = await prisma.departmentUser.delete({
     *   where: {
     *     // ... filter to delete one DepartmentUser
     *   }
     * })
     * 
    **/
    delete<T extends DepartmentUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserDeleteArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DepartmentUser.
     * @param {DepartmentUserUpdateArgs} args - Arguments to update one DepartmentUser.
     * @example
     * // Update one DepartmentUser
     * const departmentUser = await prisma.departmentUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartmentUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserUpdateArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DepartmentUsers.
     * @param {DepartmentUserDeleteManyArgs} args - Arguments to filter DepartmentUsers to delete.
     * @example
     * // Delete a few DepartmentUsers
     * const { count } = await prisma.departmentUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartmentUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DepartmentUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentUsers
     * const departmentUser = await prisma.departmentUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartmentUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentUser.
     * @param {DepartmentUserUpsertArgs} args - Arguments to update or create a DepartmentUser.
     * @example
     * // Update or create a DepartmentUser
     * const departmentUser = await prisma.departmentUser.upsert({
     *   create: {
     *     // ... data to create a DepartmentUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentUser we want to update
     *   }
     * })
    **/
    upsert<T extends DepartmentUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DepartmentUserUpsertArgs<ExtArgs>>
    ): Prisma__DepartmentUserClient<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DepartmentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserCountArgs} args - Arguments to filter DepartmentUsers to count.
     * @example
     * // Count the number of DepartmentUsers
     * const count = await prisma.departmentUser.count({
     *   where: {
     *     // ... the filter for the DepartmentUsers we want to count
     *   }
     * })
    **/
    count<T extends DepartmentUserCountArgs>(
      args?: Subset<T, DepartmentUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentUserAggregateArgs>(args: Subset<T, DepartmentUserAggregateArgs>): Prisma.PrismaPromise<GetDepartmentUserAggregateType<T>>

    /**
     * Group by DepartmentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentUserGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentUser model
   */
  readonly fields: DepartmentUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DepartmentUser model
   */ 
  interface DepartmentUserFieldRefs {
    readonly id: FieldRef<"DepartmentUser", 'String'>
    readonly userId: FieldRef<"DepartmentUser", 'String'>
    readonly companyId: FieldRef<"DepartmentUser", 'String'>
    readonly department: FieldRef<"DepartmentUser", 'CompanyDepartment'>
    readonly role: FieldRef<"DepartmentUser", 'CompanyRole'>
    readonly createdAt: FieldRef<"DepartmentUser", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentUser findUnique
   */
  export type DepartmentUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentUser to fetch.
     */
    where: DepartmentUserWhereUniqueInput
  }

  /**
   * DepartmentUser findUniqueOrThrow
   */
  export type DepartmentUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentUser to fetch.
     */
    where: DepartmentUserWhereUniqueInput
  }

  /**
   * DepartmentUser findFirst
   */
  export type DepartmentUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentUser to fetch.
     */
    where?: DepartmentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentUsers to fetch.
     */
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentUsers.
     */
    cursor?: DepartmentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentUsers.
     */
    distinct?: DepartmentUserScalarFieldEnum | DepartmentUserScalarFieldEnum[]
  }

  /**
   * DepartmentUser findFirstOrThrow
   */
  export type DepartmentUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentUser to fetch.
     */
    where?: DepartmentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentUsers to fetch.
     */
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentUsers.
     */
    cursor?: DepartmentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentUsers.
     */
    distinct?: DepartmentUserScalarFieldEnum | DepartmentUserScalarFieldEnum[]
  }

  /**
   * DepartmentUser findMany
   */
  export type DepartmentUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentUsers to fetch.
     */
    where?: DepartmentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentUsers to fetch.
     */
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentUsers.
     */
    cursor?: DepartmentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentUsers.
     */
    skip?: number
    distinct?: DepartmentUserScalarFieldEnum | DepartmentUserScalarFieldEnum[]
  }

  /**
   * DepartmentUser create
   */
  export type DepartmentUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentUser.
     */
    data: XOR<DepartmentUserCreateInput, DepartmentUserUncheckedCreateInput>
  }

  /**
   * DepartmentUser createMany
   */
  export type DepartmentUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentUsers.
     */
    data: DepartmentUserCreateManyInput | DepartmentUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentUser createManyAndReturn
   */
  export type DepartmentUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * The data used to create many DepartmentUsers.
     */
    data: DepartmentUserCreateManyInput | DepartmentUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentUser update
   */
  export type DepartmentUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentUser.
     */
    data: XOR<DepartmentUserUpdateInput, DepartmentUserUncheckedUpdateInput>
    /**
     * Choose, which DepartmentUser to update.
     */
    where: DepartmentUserWhereUniqueInput
  }

  /**
   * DepartmentUser updateMany
   */
  export type DepartmentUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentUsers.
     */
    data: XOR<DepartmentUserUpdateManyMutationInput, DepartmentUserUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentUsers to update
     */
    where?: DepartmentUserWhereInput
  }

  /**
   * DepartmentUser upsert
   */
  export type DepartmentUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentUser to update in case it exists.
     */
    where: DepartmentUserWhereUniqueInput
    /**
     * In case the DepartmentUser found by the `where` argument doesn't exist, create a new DepartmentUser with this data.
     */
    create: XOR<DepartmentUserCreateInput, DepartmentUserUncheckedCreateInput>
    /**
     * In case the DepartmentUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUserUpdateInput, DepartmentUserUncheckedUpdateInput>
  }

  /**
   * DepartmentUser delete
   */
  export type DepartmentUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    /**
     * Filter which DepartmentUser to delete.
     */
    where: DepartmentUserWhereUniqueInput
  }

  /**
   * DepartmentUser deleteMany
   */
  export type DepartmentUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentUsers to delete
     */
    where?: DepartmentUserWhereInput
  }

  /**
   * DepartmentUser without action
   */
  export type DepartmentUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
  }


  /**
   * Model CompanyPatient
   */

  export type AggregateCompanyPatient = {
    _count: CompanyPatientCountAggregateOutputType | null
    _min: CompanyPatientMinAggregateOutputType | null
    _max: CompanyPatientMaxAggregateOutputType | null
  }

  export type CompanyPatientMinAggregateOutputType = {
    patientId: string | null
    companyId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
  }

  export type CompanyPatientMaxAggregateOutputType = {
    patientId: string | null
    companyId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
  }

  export type CompanyPatientCountAggregateOutputType = {
    patientId: number
    companyId: number
    externalId: number
    createdAt: number
    updatedAt: number
    contactId: number
    _all: number
  }


  export type CompanyPatientMinAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
  }

  export type CompanyPatientMaxAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
  }

  export type CompanyPatientCountAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
    _all?: true
  }

  export type CompanyPatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPatient to aggregate.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyPatients
    **/
    _count?: true | CompanyPatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyPatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyPatientMaxAggregateInputType
  }

  export type GetCompanyPatientAggregateType<T extends CompanyPatientAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyPatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyPatient[P]>
      : GetScalarType<T[P], AggregateCompanyPatient[P]>
  }




  export type CompanyPatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithAggregationInput | CompanyPatientOrderByWithAggregationInput[]
    by: CompanyPatientScalarFieldEnum[] | CompanyPatientScalarFieldEnum
    having?: CompanyPatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyPatientCountAggregateInputType | true
    _min?: CompanyPatientMinAggregateInputType
    _max?: CompanyPatientMaxAggregateInputType
  }

  export type CompanyPatientGroupByOutputType = {
    patientId: string
    companyId: string
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    contactId: string | null
    _count: CompanyPatientCountAggregateOutputType | null
    _min: CompanyPatientMinAggregateOutputType | null
    _max: CompanyPatientMaxAggregateOutputType | null
  }

  type GetCompanyPatientGroupByPayload<T extends CompanyPatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyPatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyPatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyPatientGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyPatientGroupByOutputType[P]>
        }
      >
    >


  export type CompanyPatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patientId?: boolean
    companyId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    contact?: boolean | CompanyPatient$contactArgs<ExtArgs>
  }, ExtArgs["result"]["companyPatient"]>

  export type CompanyPatientSelectScalar = {
    patientId?: boolean
    companyId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
  }


  export type CompanyPatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    contact?: boolean | CompanyPatient$contactArgs<ExtArgs>
  }


  export type $CompanyPatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyPatient"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      patientId: string
      companyId: string
      externalId: string | null
      createdAt: Date
      updatedAt: Date
      contactId: string | null
    }, ExtArgs["result"]["companyPatient"]>
    composites: {}
  }


  type CompanyPatientGetPayload<S extends boolean | null | undefined | CompanyPatientDefaultArgs> = $Result.GetResult<Prisma.$CompanyPatientPayload, S>

  type CompanyPatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyPatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyPatientCountAggregateInputType | true
    }

  export interface CompanyPatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyPatient'], meta: { name: 'CompanyPatient' } }
    /**
     * Find zero or one CompanyPatient that matches the filter.
     * @param {CompanyPatientFindUniqueArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyPatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyPatient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyPatientFindUniqueOrThrowArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyPatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyPatient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindFirstArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyPatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyPatient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindFirstOrThrowArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyPatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyPatients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyPatients
     * const companyPatients = await prisma.companyPatient.findMany()
     * 
     * // Get first 10 CompanyPatients
     * const companyPatients = await prisma.companyPatient.findMany({ take: 10 })
     * 
     * // Only select the `patientId`
     * const companyPatientWithPatientIdOnly = await prisma.companyPatient.findMany({ select: { patientId: true } })
     * 
    **/
    findMany<T extends CompanyPatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyPatient.
     * @param {CompanyPatientCreateArgs} args - Arguments to create a CompanyPatient.
     * @example
     * // Create one CompanyPatient
     * const CompanyPatient = await prisma.companyPatient.create({
     *   data: {
     *     // ... data to create a CompanyPatient
     *   }
     * })
     * 
    **/
    create<T extends CompanyPatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientCreateArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyPatients.
     * @param {CompanyPatientCreateManyArgs} args - Arguments to create many CompanyPatients.
     * @example
     * // Create many CompanyPatients
     * const companyPatient = await prisma.companyPatient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyPatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyPatients and returns the data saved in the database.
     * @param {CompanyPatientCreateManyAndReturnArgs} args - Arguments to create many CompanyPatients.
     * @example
     * // Create many CompanyPatients
     * const companyPatient = await prisma.companyPatient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyPatients and only return the `patientId`
     * const companyPatientWithPatientIdOnly = await prisma.companyPatient.createManyAndReturn({ 
     *   select: { patientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyPatientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyPatient.
     * @param {CompanyPatientDeleteArgs} args - Arguments to delete one CompanyPatient.
     * @example
     * // Delete one CompanyPatient
     * const CompanyPatient = await prisma.companyPatient.delete({
     *   where: {
     *     // ... filter to delete one CompanyPatient
     *   }
     * })
     * 
    **/
    delete<T extends CompanyPatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientDeleteArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyPatient.
     * @param {CompanyPatientUpdateArgs} args - Arguments to update one CompanyPatient.
     * @example
     * // Update one CompanyPatient
     * const companyPatient = await prisma.companyPatient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyPatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpdateArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyPatients.
     * @param {CompanyPatientDeleteManyArgs} args - Arguments to filter CompanyPatients to delete.
     * @example
     * // Delete a few CompanyPatients
     * const { count } = await prisma.companyPatient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyPatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyPatients
     * const companyPatient = await prisma.companyPatient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyPatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyPatient.
     * @param {CompanyPatientUpsertArgs} args - Arguments to update or create a CompanyPatient.
     * @example
     * // Update or create a CompanyPatient
     * const companyPatient = await prisma.companyPatient.upsert({
     *   create: {
     *     // ... data to create a CompanyPatient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyPatient we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyPatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpsertArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientCountArgs} args - Arguments to filter CompanyPatients to count.
     * @example
     * // Count the number of CompanyPatients
     * const count = await prisma.companyPatient.count({
     *   where: {
     *     // ... the filter for the CompanyPatients we want to count
     *   }
     * })
    **/
    count<T extends CompanyPatientCountArgs>(
      args?: Subset<T, CompanyPatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyPatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyPatientAggregateArgs>(args: Subset<T, CompanyPatientAggregateArgs>): Prisma.PrismaPromise<GetCompanyPatientAggregateType<T>>

    /**
     * Group by CompanyPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyPatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyPatientGroupByArgs['orderBy'] }
        : { orderBy?: CompanyPatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyPatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyPatient model
   */
  readonly fields: CompanyPatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyPatient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyPatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contact<T extends CompanyPatient$contactArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPatient$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyPatient model
   */ 
  interface CompanyPatientFieldRefs {
    readonly patientId: FieldRef<"CompanyPatient", 'String'>
    readonly companyId: FieldRef<"CompanyPatient", 'String'>
    readonly externalId: FieldRef<"CompanyPatient", 'String'>
    readonly createdAt: FieldRef<"CompanyPatient", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyPatient", 'DateTime'>
    readonly contactId: FieldRef<"CompanyPatient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyPatient findUnique
   */
  export type CompanyPatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient findUniqueOrThrow
   */
  export type CompanyPatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient findFirst
   */
  export type CompanyPatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPatients.
     */
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient findFirstOrThrow
   */
  export type CompanyPatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPatients.
     */
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient findMany
   */
  export type CompanyPatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatients to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient create
   */
  export type CompanyPatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyPatient.
     */
    data: XOR<CompanyPatientCreateInput, CompanyPatientUncheckedCreateInput>
  }

  /**
   * CompanyPatient createMany
   */
  export type CompanyPatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyPatients.
     */
    data: CompanyPatientCreateManyInput | CompanyPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPatient createManyAndReturn
   */
  export type CompanyPatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyPatients.
     */
    data: CompanyPatientCreateManyInput | CompanyPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPatient update
   */
  export type CompanyPatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyPatient.
     */
    data: XOR<CompanyPatientUpdateInput, CompanyPatientUncheckedUpdateInput>
    /**
     * Choose, which CompanyPatient to update.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient updateMany
   */
  export type CompanyPatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyPatients.
     */
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyInput>
    /**
     * Filter which CompanyPatients to update
     */
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyPatient upsert
   */
  export type CompanyPatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyPatient to update in case it exists.
     */
    where: CompanyPatientWhereUniqueInput
    /**
     * In case the CompanyPatient found by the `where` argument doesn't exist, create a new CompanyPatient with this data.
     */
    create: XOR<CompanyPatientCreateInput, CompanyPatientUncheckedCreateInput>
    /**
     * In case the CompanyPatient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyPatientUpdateInput, CompanyPatientUncheckedUpdateInput>
  }

  /**
   * CompanyPatient delete
   */
  export type CompanyPatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter which CompanyPatient to delete.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient deleteMany
   */
  export type CompanyPatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPatients to delete
     */
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyPatient.contact
   */
  export type CompanyPatient$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * CompanyPatient without action
   */
  export type CompanyPatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
  }


  /**
   * Model FacilityPatient
   */

  export type AggregateFacilityPatient = {
    _count: FacilityPatientCountAggregateOutputType | null
    _min: FacilityPatientMinAggregateOutputType | null
    _max: FacilityPatientMaxAggregateOutputType | null
  }

  export type FacilityPatientMinAggregateOutputType = {
    patientId: string | null
    facilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityPatientMaxAggregateOutputType = {
    patientId: string | null
    facilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityPatientCountAggregateOutputType = {
    patientId: number
    facilityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityPatientMinAggregateInputType = {
    patientId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityPatientMaxAggregateInputType = {
    patientId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityPatientCountAggregateInputType = {
    patientId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityPatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityPatient to aggregate.
     */
    where?: FacilityPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityPatients to fetch.
     */
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityPatients
    **/
    _count?: true | FacilityPatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityPatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityPatientMaxAggregateInputType
  }

  export type GetFacilityPatientAggregateType<T extends FacilityPatientAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityPatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityPatient[P]>
      : GetScalarType<T[P], AggregateFacilityPatient[P]>
  }




  export type FacilityPatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityPatientWhereInput
    orderBy?: FacilityPatientOrderByWithAggregationInput | FacilityPatientOrderByWithAggregationInput[]
    by: FacilityPatientScalarFieldEnum[] | FacilityPatientScalarFieldEnum
    having?: FacilityPatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityPatientCountAggregateInputType | true
    _min?: FacilityPatientMinAggregateInputType
    _max?: FacilityPatientMaxAggregateInputType
  }

  export type FacilityPatientGroupByOutputType = {
    patientId: string
    facilityId: string
    createdAt: Date
    updatedAt: Date
    _count: FacilityPatientCountAggregateOutputType | null
    _min: FacilityPatientMinAggregateOutputType | null
    _max: FacilityPatientMaxAggregateOutputType | null
  }

  type GetFacilityPatientGroupByPayload<T extends FacilityPatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityPatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityPatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityPatientGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityPatientGroupByOutputType[P]>
        }
      >
    >


  export type FacilityPatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patientId?: boolean
    facilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityPatient"]>

  export type FacilityPatientSelectScalar = {
    patientId?: boolean
    facilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacilityPatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }


  export type $FacilityPatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityPatient"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      patientId: string
      facilityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facilityPatient"]>
    composites: {}
  }


  type FacilityPatientGetPayload<S extends boolean | null | undefined | FacilityPatientDefaultArgs> = $Result.GetResult<Prisma.$FacilityPatientPayload, S>

  type FacilityPatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityPatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityPatientCountAggregateInputType | true
    }

  export interface FacilityPatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityPatient'], meta: { name: 'FacilityPatient' } }
    /**
     * Find zero or one FacilityPatient that matches the filter.
     * @param {FacilityPatientFindUniqueArgs} args - Arguments to find a FacilityPatient
     * @example
     * // Get one FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityPatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FacilityPatient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityPatientFindUniqueOrThrowArgs} args - Arguments to find a FacilityPatient
     * @example
     * // Get one FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacilityPatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FacilityPatient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientFindFirstArgs} args - Arguments to find a FacilityPatient
     * @example
     * // Get one FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityPatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FacilityPatient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientFindFirstOrThrowArgs} args - Arguments to find a FacilityPatient
     * @example
     * // Get one FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacilityPatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FacilityPatients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityPatients
     * const facilityPatients = await prisma.facilityPatient.findMany()
     * 
     * // Get first 10 FacilityPatients
     * const facilityPatients = await prisma.facilityPatient.findMany({ take: 10 })
     * 
     * // Only select the `patientId`
     * const facilityPatientWithPatientIdOnly = await prisma.facilityPatient.findMany({ select: { patientId: true } })
     * 
    **/
    findMany<T extends FacilityPatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FacilityPatient.
     * @param {FacilityPatientCreateArgs} args - Arguments to create a FacilityPatient.
     * @example
     * // Create one FacilityPatient
     * const FacilityPatient = await prisma.facilityPatient.create({
     *   data: {
     *     // ... data to create a FacilityPatient
     *   }
     * })
     * 
    **/
    create<T extends FacilityPatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientCreateArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FacilityPatients.
     * @param {FacilityPatientCreateManyArgs} args - Arguments to create many FacilityPatients.
     * @example
     * // Create many FacilityPatients
     * const facilityPatient = await prisma.facilityPatient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FacilityPatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityPatients and returns the data saved in the database.
     * @param {FacilityPatientCreateManyAndReturnArgs} args - Arguments to create many FacilityPatients.
     * @example
     * // Create many FacilityPatients
     * const facilityPatient = await prisma.facilityPatient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityPatients and only return the `patientId`
     * const facilityPatientWithPatientIdOnly = await prisma.facilityPatient.createManyAndReturn({ 
     *   select: { patientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FacilityPatientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FacilityPatient.
     * @param {FacilityPatientDeleteArgs} args - Arguments to delete one FacilityPatient.
     * @example
     * // Delete one FacilityPatient
     * const FacilityPatient = await prisma.facilityPatient.delete({
     *   where: {
     *     // ... filter to delete one FacilityPatient
     *   }
     * })
     * 
    **/
    delete<T extends FacilityPatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientDeleteArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FacilityPatient.
     * @param {FacilityPatientUpdateArgs} args - Arguments to update one FacilityPatient.
     * @example
     * // Update one FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityPatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientUpdateArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FacilityPatients.
     * @param {FacilityPatientDeleteManyArgs} args - Arguments to filter FacilityPatients to delete.
     * @example
     * // Delete a few FacilityPatients
     * const { count } = await prisma.facilityPatient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityPatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityPatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityPatients
     * const facilityPatient = await prisma.facilityPatient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityPatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacilityPatient.
     * @param {FacilityPatientUpsertArgs} args - Arguments to update or create a FacilityPatient.
     * @example
     * // Update or create a FacilityPatient
     * const facilityPatient = await prisma.facilityPatient.upsert({
     *   create: {
     *     // ... data to create a FacilityPatient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityPatient we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityPatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityPatientUpsertArgs<ExtArgs>>
    ): Prisma__FacilityPatientClient<$Result.GetResult<Prisma.$FacilityPatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FacilityPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientCountArgs} args - Arguments to filter FacilityPatients to count.
     * @example
     * // Count the number of FacilityPatients
     * const count = await prisma.facilityPatient.count({
     *   where: {
     *     // ... the filter for the FacilityPatients we want to count
     *   }
     * })
    **/
    count<T extends FacilityPatientCountArgs>(
      args?: Subset<T, FacilityPatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityPatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityPatientAggregateArgs>(args: Subset<T, FacilityPatientAggregateArgs>): Prisma.PrismaPromise<GetFacilityPatientAggregateType<T>>

    /**
     * Group by FacilityPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityPatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityPatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityPatientGroupByArgs['orderBy'] }
        : { orderBy?: FacilityPatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityPatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityPatient model
   */
  readonly fields: FacilityPatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityPatient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityPatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FacilityPatient model
   */ 
  interface FacilityPatientFieldRefs {
    readonly patientId: FieldRef<"FacilityPatient", 'String'>
    readonly facilityId: FieldRef<"FacilityPatient", 'String'>
    readonly createdAt: FieldRef<"FacilityPatient", 'DateTime'>
    readonly updatedAt: FieldRef<"FacilityPatient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacilityPatient findUnique
   */
  export type FacilityPatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter, which FacilityPatient to fetch.
     */
    where: FacilityPatientWhereUniqueInput
  }

  /**
   * FacilityPatient findUniqueOrThrow
   */
  export type FacilityPatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter, which FacilityPatient to fetch.
     */
    where: FacilityPatientWhereUniqueInput
  }

  /**
   * FacilityPatient findFirst
   */
  export type FacilityPatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter, which FacilityPatient to fetch.
     */
    where?: FacilityPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityPatients to fetch.
     */
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityPatients.
     */
    cursor?: FacilityPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityPatients.
     */
    distinct?: FacilityPatientScalarFieldEnum | FacilityPatientScalarFieldEnum[]
  }

  /**
   * FacilityPatient findFirstOrThrow
   */
  export type FacilityPatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter, which FacilityPatient to fetch.
     */
    where?: FacilityPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityPatients to fetch.
     */
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityPatients.
     */
    cursor?: FacilityPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityPatients.
     */
    distinct?: FacilityPatientScalarFieldEnum | FacilityPatientScalarFieldEnum[]
  }

  /**
   * FacilityPatient findMany
   */
  export type FacilityPatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter, which FacilityPatients to fetch.
     */
    where?: FacilityPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityPatients to fetch.
     */
    orderBy?: FacilityPatientOrderByWithRelationInput | FacilityPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityPatients.
     */
    cursor?: FacilityPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityPatients.
     */
    skip?: number
    distinct?: FacilityPatientScalarFieldEnum | FacilityPatientScalarFieldEnum[]
  }

  /**
   * FacilityPatient create
   */
  export type FacilityPatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityPatient.
     */
    data: XOR<FacilityPatientCreateInput, FacilityPatientUncheckedCreateInput>
  }

  /**
   * FacilityPatient createMany
   */
  export type FacilityPatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityPatients.
     */
    data: FacilityPatientCreateManyInput | FacilityPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityPatient createManyAndReturn
   */
  export type FacilityPatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * The data used to create many FacilityPatients.
     */
    data: FacilityPatientCreateManyInput | FacilityPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityPatient update
   */
  export type FacilityPatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityPatient.
     */
    data: XOR<FacilityPatientUpdateInput, FacilityPatientUncheckedUpdateInput>
    /**
     * Choose, which FacilityPatient to update.
     */
    where: FacilityPatientWhereUniqueInput
  }

  /**
   * FacilityPatient updateMany
   */
  export type FacilityPatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityPatients.
     */
    data: XOR<FacilityPatientUpdateManyMutationInput, FacilityPatientUncheckedUpdateManyInput>
    /**
     * Filter which FacilityPatients to update
     */
    where?: FacilityPatientWhereInput
  }

  /**
   * FacilityPatient upsert
   */
  export type FacilityPatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityPatient to update in case it exists.
     */
    where: FacilityPatientWhereUniqueInput
    /**
     * In case the FacilityPatient found by the `where` argument doesn't exist, create a new FacilityPatient with this data.
     */
    create: XOR<FacilityPatientCreateInput, FacilityPatientUncheckedCreateInput>
    /**
     * In case the FacilityPatient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityPatientUpdateInput, FacilityPatientUncheckedUpdateInput>
  }

  /**
   * FacilityPatient delete
   */
  export type FacilityPatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
    /**
     * Filter which FacilityPatient to delete.
     */
    where: FacilityPatientWhereUniqueInput
  }

  /**
   * FacilityPatient deleteMany
   */
  export type FacilityPatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityPatients to delete
     */
    where?: FacilityPatientWhereInput
  }

  /**
   * FacilityPatient without action
   */
  export type FacilityPatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityPatient
     */
    select?: FacilityPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityPatientInclude<ExtArgs> | null
  }


  /**
   * Model StripeProduct
   */

  export type AggregateStripeProduct = {
    _count: StripeProductCountAggregateOutputType | null
    _avg: StripeProductAvgAggregateOutputType | null
    _sum: StripeProductSumAggregateOutputType | null
    _min: StripeProductMinAggregateOutputType | null
    _max: StripeProductMaxAggregateOutputType | null
  }

  export type StripeProductAvgAggregateOutputType = {
    amount: number | null
  }

  export type StripeProductSumAggregateOutputType = {
    amount: number | null
  }

  export type StripeProductMinAggregateOutputType = {
    id: string | null
    type: $Enums.StripeProductType | null
    stripeEntityId: string | null
    stripeProductId: string | null
    stripePriceId: string | null
    stripeCouponId: string | null
    frequency: $Enums.StripeBillingFrequency | null
    amount: number | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeProductMaxAggregateOutputType = {
    id: string | null
    type: $Enums.StripeProductType | null
    stripeEntityId: string | null
    stripeProductId: string | null
    stripePriceId: string | null
    stripeCouponId: string | null
    frequency: $Enums.StripeBillingFrequency | null
    amount: number | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeProductCountAggregateOutputType = {
    id: number
    type: number
    stripeEntityId: number
    stripeProductId: number
    stripePriceId: number
    stripeCouponId: number
    frequency: number
    amount: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeProductAvgAggregateInputType = {
    amount?: true
  }

  export type StripeProductSumAggregateInputType = {
    amount?: true
  }

  export type StripeProductMinAggregateInputType = {
    id?: true
    type?: true
    stripeEntityId?: true
    stripeProductId?: true
    stripePriceId?: true
    stripeCouponId?: true
    frequency?: true
    amount?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeProductMaxAggregateInputType = {
    id?: true
    type?: true
    stripeEntityId?: true
    stripeProductId?: true
    stripePriceId?: true
    stripeCouponId?: true
    frequency?: true
    amount?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeProductCountAggregateInputType = {
    id?: true
    type?: true
    stripeEntityId?: true
    stripeProductId?: true
    stripePriceId?: true
    stripeCouponId?: true
    frequency?: true
    amount?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeProduct to aggregate.
     */
    where?: StripeProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeProducts to fetch.
     */
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeProducts
    **/
    _count?: true | StripeProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StripeProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StripeProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeProductMaxAggregateInputType
  }

  export type GetStripeProductAggregateType<T extends StripeProductAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeProduct[P]>
      : GetScalarType<T[P], AggregateStripeProduct[P]>
  }




  export type StripeProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeProductWhereInput
    orderBy?: StripeProductOrderByWithAggregationInput | StripeProductOrderByWithAggregationInput[]
    by: StripeProductScalarFieldEnum[] | StripeProductScalarFieldEnum
    having?: StripeProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeProductCountAggregateInputType | true
    _avg?: StripeProductAvgAggregateInputType
    _sum?: StripeProductSumAggregateInputType
    _min?: StripeProductMinAggregateInputType
    _max?: StripeProductMaxAggregateInputType
  }

  export type StripeProductGroupByOutputType = {
    id: string
    type: $Enums.StripeProductType
    stripeEntityId: string | null
    stripeProductId: string
    stripePriceId: string | null
    stripeCouponId: string | null
    frequency: $Enums.StripeBillingFrequency | null
    amount: number | null
    description: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: StripeProductCountAggregateOutputType | null
    _avg: StripeProductAvgAggregateOutputType | null
    _sum: StripeProductSumAggregateOutputType | null
    _min: StripeProductMinAggregateOutputType | null
    _max: StripeProductMaxAggregateOutputType | null
  }

  type GetStripeProductGroupByPayload<T extends StripeProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeProductGroupByOutputType[P]>
            : GetScalarType<T[P], StripeProductGroupByOutputType[P]>
        }
      >
    >


  export type StripeProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    stripeEntityId?: boolean
    stripeProductId?: boolean
    stripePriceId?: boolean
    stripeCouponId?: boolean
    frequency?: boolean
    amount?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeEntity?: boolean | StripeProduct$stripeEntityArgs<ExtArgs>
    stripeInvoices?: boolean | StripeProduct$stripeInvoicesArgs<ExtArgs>
    stripeSubscriptions?: boolean | StripeProduct$stripeSubscriptionsArgs<ExtArgs>
    _count?: boolean | StripeProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeProduct"]>

  export type StripeProductSelectScalar = {
    id?: boolean
    type?: boolean
    stripeEntityId?: boolean
    stripeProductId?: boolean
    stripePriceId?: boolean
    stripeCouponId?: boolean
    frequency?: boolean
    amount?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type StripeProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeEntity?: boolean | StripeProduct$stripeEntityArgs<ExtArgs>
    stripeInvoices?: boolean | StripeProduct$stripeInvoicesArgs<ExtArgs>
    stripeSubscriptions?: boolean | StripeProduct$stripeSubscriptionsArgs<ExtArgs>
    _count?: boolean | StripeProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StripeProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeProduct"
    objects: {
      stripeEntity: Prisma.$StripeEntityPayload<ExtArgs> | null
      stripeInvoices: Prisma.$StripeInvoicePayload<ExtArgs>[]
      stripeSubscriptions: Prisma.$StripeSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.StripeProductType
      stripeEntityId: string | null
      stripeProductId: string
      stripePriceId: string | null
      stripeCouponId: string | null
      frequency: $Enums.StripeBillingFrequency | null
      amount: number | null
      description: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeProduct"]>
    composites: {}
  }


  type StripeProductGetPayload<S extends boolean | null | undefined | StripeProductDefaultArgs> = $Result.GetResult<Prisma.$StripeProductPayload, S>

  type StripeProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StripeProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StripeProductCountAggregateInputType | true
    }

  export interface StripeProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeProduct'], meta: { name: 'StripeProduct' } }
    /**
     * Find zero or one StripeProduct that matches the filter.
     * @param {StripeProductFindUniqueArgs} args - Arguments to find a StripeProduct
     * @example
     * // Get one StripeProduct
     * const stripeProduct = await prisma.stripeProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StripeProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductFindUniqueArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StripeProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StripeProductFindUniqueOrThrowArgs} args - Arguments to find a StripeProduct
     * @example
     * // Get one StripeProduct
     * const stripeProduct = await prisma.stripeProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StripeProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StripeProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductFindFirstArgs} args - Arguments to find a StripeProduct
     * @example
     * // Get one StripeProduct
     * const stripeProduct = await prisma.stripeProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StripeProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductFindFirstArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StripeProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductFindFirstOrThrowArgs} args - Arguments to find a StripeProduct
     * @example
     * // Get one StripeProduct
     * const stripeProduct = await prisma.stripeProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StripeProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StripeProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeProducts
     * const stripeProducts = await prisma.stripeProduct.findMany()
     * 
     * // Get first 10 StripeProducts
     * const stripeProducts = await prisma.stripeProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeProductWithIdOnly = await prisma.stripeProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StripeProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StripeProduct.
     * @param {StripeProductCreateArgs} args - Arguments to create a StripeProduct.
     * @example
     * // Create one StripeProduct
     * const StripeProduct = await prisma.stripeProduct.create({
     *   data: {
     *     // ... data to create a StripeProduct
     *   }
     * })
     * 
    **/
    create<T extends StripeProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductCreateArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StripeProducts.
     * @param {StripeProductCreateManyArgs} args - Arguments to create many StripeProducts.
     * @example
     * // Create many StripeProducts
     * const stripeProduct = await prisma.stripeProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StripeProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeProducts and returns the data saved in the database.
     * @param {StripeProductCreateManyAndReturnArgs} args - Arguments to create many StripeProducts.
     * @example
     * // Create many StripeProducts
     * const stripeProduct = await prisma.stripeProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeProducts and only return the `id`
     * const stripeProductWithIdOnly = await prisma.stripeProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends StripeProductCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a StripeProduct.
     * @param {StripeProductDeleteArgs} args - Arguments to delete one StripeProduct.
     * @example
     * // Delete one StripeProduct
     * const StripeProduct = await prisma.stripeProduct.delete({
     *   where: {
     *     // ... filter to delete one StripeProduct
     *   }
     * })
     * 
    **/
    delete<T extends StripeProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductDeleteArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StripeProduct.
     * @param {StripeProductUpdateArgs} args - Arguments to update one StripeProduct.
     * @example
     * // Update one StripeProduct
     * const stripeProduct = await prisma.stripeProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StripeProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductUpdateArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StripeProducts.
     * @param {StripeProductDeleteManyArgs} args - Arguments to filter StripeProducts to delete.
     * @example
     * // Delete a few StripeProducts
     * const { count } = await prisma.stripeProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StripeProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeProducts
     * const stripeProduct = await prisma.stripeProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StripeProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeProduct.
     * @param {StripeProductUpsertArgs} args - Arguments to update or create a StripeProduct.
     * @example
     * // Update or create a StripeProduct
     * const stripeProduct = await prisma.stripeProduct.upsert({
     *   create: {
     *     // ... data to create a StripeProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeProduct we want to update
     *   }
     * })
    **/
    upsert<T extends StripeProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StripeProductUpsertArgs<ExtArgs>>
    ): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StripeProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductCountArgs} args - Arguments to filter StripeProducts to count.
     * @example
     * // Count the number of StripeProducts
     * const count = await prisma.stripeProduct.count({
     *   where: {
     *     // ... the filter for the StripeProducts we want to count
     *   }
     * })
    **/
    count<T extends StripeProductCountArgs>(
      args?: Subset<T, StripeProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeProductAggregateArgs>(args: Subset<T, StripeProductAggregateArgs>): Prisma.PrismaPromise<GetStripeProductAggregateType<T>>

    /**
     * Group by StripeProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeProductGroupByArgs['orderBy'] }
        : { orderBy?: StripeProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeProduct model
   */
  readonly fields: StripeProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stripeEntity<T extends StripeProduct$stripeEntityArgs<ExtArgs> = {}>(args?: Subset<T, StripeProduct$stripeEntityArgs<ExtArgs>>): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    stripeInvoices<T extends StripeProduct$stripeInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, StripeProduct$stripeInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeSubscriptions<T extends StripeProduct$stripeSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, StripeProduct$stripeSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StripeProduct model
   */ 
  interface StripeProductFieldRefs {
    readonly id: FieldRef<"StripeProduct", 'String'>
    readonly type: FieldRef<"StripeProduct", 'StripeProductType'>
    readonly stripeEntityId: FieldRef<"StripeProduct", 'String'>
    readonly stripeProductId: FieldRef<"StripeProduct", 'String'>
    readonly stripePriceId: FieldRef<"StripeProduct", 'String'>
    readonly stripeCouponId: FieldRef<"StripeProduct", 'String'>
    readonly frequency: FieldRef<"StripeProduct", 'StripeBillingFrequency'>
    readonly amount: FieldRef<"StripeProduct", 'Float'>
    readonly description: FieldRef<"StripeProduct", 'String'>
    readonly active: FieldRef<"StripeProduct", 'Boolean'>
    readonly createdAt: FieldRef<"StripeProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeProduct findUnique
   */
  export type StripeProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter, which StripeProduct to fetch.
     */
    where: StripeProductWhereUniqueInput
  }

  /**
   * StripeProduct findUniqueOrThrow
   */
  export type StripeProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter, which StripeProduct to fetch.
     */
    where: StripeProductWhereUniqueInput
  }

  /**
   * StripeProduct findFirst
   */
  export type StripeProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter, which StripeProduct to fetch.
     */
    where?: StripeProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeProducts to fetch.
     */
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeProducts.
     */
    cursor?: StripeProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeProducts.
     */
    distinct?: StripeProductScalarFieldEnum | StripeProductScalarFieldEnum[]
  }

  /**
   * StripeProduct findFirstOrThrow
   */
  export type StripeProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter, which StripeProduct to fetch.
     */
    where?: StripeProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeProducts to fetch.
     */
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeProducts.
     */
    cursor?: StripeProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeProducts.
     */
    distinct?: StripeProductScalarFieldEnum | StripeProductScalarFieldEnum[]
  }

  /**
   * StripeProduct findMany
   */
  export type StripeProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter, which StripeProducts to fetch.
     */
    where?: StripeProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeProducts to fetch.
     */
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeProducts.
     */
    cursor?: StripeProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeProducts.
     */
    skip?: number
    distinct?: StripeProductScalarFieldEnum | StripeProductScalarFieldEnum[]
  }

  /**
   * StripeProduct create
   */
  export type StripeProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeProduct.
     */
    data: XOR<StripeProductCreateInput, StripeProductUncheckedCreateInput>
  }

  /**
   * StripeProduct createMany
   */
  export type StripeProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeProducts.
     */
    data: StripeProductCreateManyInput | StripeProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeProduct createManyAndReturn
   */
  export type StripeProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * The data used to create many StripeProducts.
     */
    data: StripeProductCreateManyInput | StripeProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeProduct update
   */
  export type StripeProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeProduct.
     */
    data: XOR<StripeProductUpdateInput, StripeProductUncheckedUpdateInput>
    /**
     * Choose, which StripeProduct to update.
     */
    where: StripeProductWhereUniqueInput
  }

  /**
   * StripeProduct updateMany
   */
  export type StripeProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeProducts.
     */
    data: XOR<StripeProductUpdateManyMutationInput, StripeProductUncheckedUpdateManyInput>
    /**
     * Filter which StripeProducts to update
     */
    where?: StripeProductWhereInput
  }

  /**
   * StripeProduct upsert
   */
  export type StripeProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeProduct to update in case it exists.
     */
    where: StripeProductWhereUniqueInput
    /**
     * In case the StripeProduct found by the `where` argument doesn't exist, create a new StripeProduct with this data.
     */
    create: XOR<StripeProductCreateInput, StripeProductUncheckedCreateInput>
    /**
     * In case the StripeProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeProductUpdateInput, StripeProductUncheckedUpdateInput>
  }

  /**
   * StripeProduct delete
   */
  export type StripeProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    /**
     * Filter which StripeProduct to delete.
     */
    where: StripeProductWhereUniqueInput
  }

  /**
   * StripeProduct deleteMany
   */
  export type StripeProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeProducts to delete
     */
    where?: StripeProductWhereInput
  }

  /**
   * StripeProduct.stripeEntity
   */
  export type StripeProduct$stripeEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    where?: StripeEntityWhereInput
  }

  /**
   * StripeProduct.stripeInvoices
   */
  export type StripeProduct$stripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    cursor?: StripeInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeProduct.stripeSubscriptions
   */
  export type StripeProduct$stripeSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    where?: StripeSubscriptionWhereInput
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    cursor?: StripeSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeProduct without action
   */
  export type StripeProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
  }


  /**
   * Model StripeInvoice
   */

  export type AggregateStripeInvoice = {
    _count: StripeInvoiceCountAggregateOutputType | null
    _avg: StripeInvoiceAvgAggregateOutputType | null
    _sum: StripeInvoiceSumAggregateOutputType | null
    _min: StripeInvoiceMinAggregateOutputType | null
    _max: StripeInvoiceMaxAggregateOutputType | null
  }

  export type StripeInvoiceAvgAggregateOutputType = {
    price: number | null
  }

  export type StripeInvoiceSumAggregateOutputType = {
    price: number | null
  }

  export type StripeInvoiceMinAggregateOutputType = {
    id: string | null
    stripeInvoiceId: string | null
    price: number | null
    type: $Enums.StripeInvoiceType | null
    status: $Enums.StripeInvoiceStatus | null
    lastWebhookId: string | null
    subscriptionId: string | null
    combinedInvoiceId: string | null
    stripeEntityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeInvoiceMaxAggregateOutputType = {
    id: string | null
    stripeInvoiceId: string | null
    price: number | null
    type: $Enums.StripeInvoiceType | null
    status: $Enums.StripeInvoiceStatus | null
    lastWebhookId: string | null
    subscriptionId: string | null
    combinedInvoiceId: string | null
    stripeEntityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeInvoiceCountAggregateOutputType = {
    id: number
    stripeInvoiceId: number
    price: number
    type: number
    status: number
    lastWebhookId: number
    metadata: number
    subscriptionId: number
    combinedInvoiceId: number
    stripeEntityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeInvoiceAvgAggregateInputType = {
    price?: true
  }

  export type StripeInvoiceSumAggregateInputType = {
    price?: true
  }

  export type StripeInvoiceMinAggregateInputType = {
    id?: true
    stripeInvoiceId?: true
    price?: true
    type?: true
    status?: true
    lastWebhookId?: true
    subscriptionId?: true
    combinedInvoiceId?: true
    stripeEntityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeInvoiceMaxAggregateInputType = {
    id?: true
    stripeInvoiceId?: true
    price?: true
    type?: true
    status?: true
    lastWebhookId?: true
    subscriptionId?: true
    combinedInvoiceId?: true
    stripeEntityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeInvoiceCountAggregateInputType = {
    id?: true
    stripeInvoiceId?: true
    price?: true
    type?: true
    status?: true
    lastWebhookId?: true
    metadata?: true
    subscriptionId?: true
    combinedInvoiceId?: true
    stripeEntityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeInvoice to aggregate.
     */
    where?: StripeInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeInvoices to fetch.
     */
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeInvoices
    **/
    _count?: true | StripeInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StripeInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StripeInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeInvoiceMaxAggregateInputType
  }

  export type GetStripeInvoiceAggregateType<T extends StripeInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeInvoice[P]>
      : GetScalarType<T[P], AggregateStripeInvoice[P]>
  }




  export type StripeInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeInvoiceWhereInput
    orderBy?: StripeInvoiceOrderByWithAggregationInput | StripeInvoiceOrderByWithAggregationInput[]
    by: StripeInvoiceScalarFieldEnum[] | StripeInvoiceScalarFieldEnum
    having?: StripeInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeInvoiceCountAggregateInputType | true
    _avg?: StripeInvoiceAvgAggregateInputType
    _sum?: StripeInvoiceSumAggregateInputType
    _min?: StripeInvoiceMinAggregateInputType
    _max?: StripeInvoiceMaxAggregateInputType
  }

  export type StripeInvoiceGroupByOutputType = {
    id: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId: string | null
    metadata: JsonValue | null
    subscriptionId: string | null
    combinedInvoiceId: string | null
    stripeEntityId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StripeInvoiceCountAggregateOutputType | null
    _avg: StripeInvoiceAvgAggregateOutputType | null
    _sum: StripeInvoiceSumAggregateOutputType | null
    _min: StripeInvoiceMinAggregateOutputType | null
    _max: StripeInvoiceMaxAggregateOutputType | null
  }

  type GetStripeInvoiceGroupByPayload<T extends StripeInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], StripeInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type StripeInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeInvoiceId?: boolean
    price?: boolean
    type?: boolean
    status?: boolean
    lastWebhookId?: boolean
    metadata?: boolean
    subscriptionId?: boolean
    combinedInvoiceId?: boolean
    stripeEntityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeProducts?: boolean | StripeInvoice$stripeProductsArgs<ExtArgs>
    combinedInvoice?: boolean | StripeInvoice$combinedInvoiceArgs<ExtArgs>
    combinedInvoices?: boolean | StripeInvoice$combinedInvoicesArgs<ExtArgs>
    stripeSubscription?: boolean | StripeInvoice$stripeSubscriptionArgs<ExtArgs>
    stripeEntity?: boolean | StripeInvoice$stripeEntityArgs<ExtArgs>
    employerEvaluations?: boolean | StripeInvoice$employerEvaluationsArgs<ExtArgs>
    checkoutEvaluations?: boolean | StripeInvoice$checkoutEvaluationsArgs<ExtArgs>
    _count?: boolean | StripeInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeInvoice"]>

  export type StripeInvoiceSelectScalar = {
    id?: boolean
    stripeInvoiceId?: boolean
    price?: boolean
    type?: boolean
    status?: boolean
    lastWebhookId?: boolean
    metadata?: boolean
    subscriptionId?: boolean
    combinedInvoiceId?: boolean
    stripeEntityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type StripeInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeProducts?: boolean | StripeInvoice$stripeProductsArgs<ExtArgs>
    combinedInvoice?: boolean | StripeInvoice$combinedInvoiceArgs<ExtArgs>
    combinedInvoices?: boolean | StripeInvoice$combinedInvoicesArgs<ExtArgs>
    stripeSubscription?: boolean | StripeInvoice$stripeSubscriptionArgs<ExtArgs>
    stripeEntity?: boolean | StripeInvoice$stripeEntityArgs<ExtArgs>
    employerEvaluations?: boolean | StripeInvoice$employerEvaluationsArgs<ExtArgs>
    checkoutEvaluations?: boolean | StripeInvoice$checkoutEvaluationsArgs<ExtArgs>
    _count?: boolean | StripeInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StripeInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeInvoice"
    objects: {
      stripeProducts: Prisma.$StripeProductPayload<ExtArgs>[]
      combinedInvoice: Prisma.$StripeInvoicePayload<ExtArgs> | null
      combinedInvoices: Prisma.$StripeInvoicePayload<ExtArgs>[]
      stripeSubscription: Prisma.$StripeSubscriptionPayload<ExtArgs> | null
      stripeEntity: Prisma.$StripeEntityPayload<ExtArgs> | null
      employerEvaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      checkoutEvaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripeInvoiceId: string
      price: number
      type: $Enums.StripeInvoiceType
      status: $Enums.StripeInvoiceStatus
      lastWebhookId: string | null
      metadata: Prisma.JsonValue | null
      subscriptionId: string | null
      combinedInvoiceId: string | null
      stripeEntityId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeInvoice"]>
    composites: {}
  }


  type StripeInvoiceGetPayload<S extends boolean | null | undefined | StripeInvoiceDefaultArgs> = $Result.GetResult<Prisma.$StripeInvoicePayload, S>

  type StripeInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StripeInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StripeInvoiceCountAggregateInputType | true
    }

  export interface StripeInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeInvoice'], meta: { name: 'StripeInvoice' } }
    /**
     * Find zero or one StripeInvoice that matches the filter.
     * @param {StripeInvoiceFindUniqueArgs} args - Arguments to find a StripeInvoice
     * @example
     * // Get one StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StripeInvoiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StripeInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StripeInvoiceFindUniqueOrThrowArgs} args - Arguments to find a StripeInvoice
     * @example
     * // Get one StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StripeInvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StripeInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceFindFirstArgs} args - Arguments to find a StripeInvoice
     * @example
     * // Get one StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StripeInvoiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StripeInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceFindFirstOrThrowArgs} args - Arguments to find a StripeInvoice
     * @example
     * // Get one StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StripeInvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StripeInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeInvoices
     * const stripeInvoices = await prisma.stripeInvoice.findMany()
     * 
     * // Get first 10 StripeInvoices
     * const stripeInvoices = await prisma.stripeInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeInvoiceWithIdOnly = await prisma.stripeInvoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StripeInvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StripeInvoice.
     * @param {StripeInvoiceCreateArgs} args - Arguments to create a StripeInvoice.
     * @example
     * // Create one StripeInvoice
     * const StripeInvoice = await prisma.stripeInvoice.create({
     *   data: {
     *     // ... data to create a StripeInvoice
     *   }
     * })
     * 
    **/
    create<T extends StripeInvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceCreateArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StripeInvoices.
     * @param {StripeInvoiceCreateManyArgs} args - Arguments to create many StripeInvoices.
     * @example
     * // Create many StripeInvoices
     * const stripeInvoice = await prisma.stripeInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StripeInvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeInvoices and returns the data saved in the database.
     * @param {StripeInvoiceCreateManyAndReturnArgs} args - Arguments to create many StripeInvoices.
     * @example
     * // Create many StripeInvoices
     * const stripeInvoice = await prisma.stripeInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeInvoices and only return the `id`
     * const stripeInvoiceWithIdOnly = await prisma.stripeInvoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends StripeInvoiceCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a StripeInvoice.
     * @param {StripeInvoiceDeleteArgs} args - Arguments to delete one StripeInvoice.
     * @example
     * // Delete one StripeInvoice
     * const StripeInvoice = await prisma.stripeInvoice.delete({
     *   where: {
     *     // ... filter to delete one StripeInvoice
     *   }
     * })
     * 
    **/
    delete<T extends StripeInvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceDeleteArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StripeInvoice.
     * @param {StripeInvoiceUpdateArgs} args - Arguments to update one StripeInvoice.
     * @example
     * // Update one StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StripeInvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceUpdateArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StripeInvoices.
     * @param {StripeInvoiceDeleteManyArgs} args - Arguments to filter StripeInvoices to delete.
     * @example
     * // Delete a few StripeInvoices
     * const { count } = await prisma.stripeInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StripeInvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeInvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeInvoices
     * const stripeInvoice = await prisma.stripeInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StripeInvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeInvoice.
     * @param {StripeInvoiceUpsertArgs} args - Arguments to update or create a StripeInvoice.
     * @example
     * // Update or create a StripeInvoice
     * const stripeInvoice = await prisma.stripeInvoice.upsert({
     *   create: {
     *     // ... data to create a StripeInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeInvoice we want to update
     *   }
     * })
    **/
    upsert<T extends StripeInvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StripeInvoiceUpsertArgs<ExtArgs>>
    ): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StripeInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceCountArgs} args - Arguments to filter StripeInvoices to count.
     * @example
     * // Count the number of StripeInvoices
     * const count = await prisma.stripeInvoice.count({
     *   where: {
     *     // ... the filter for the StripeInvoices we want to count
     *   }
     * })
    **/
    count<T extends StripeInvoiceCountArgs>(
      args?: Subset<T, StripeInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeInvoiceAggregateArgs>(args: Subset<T, StripeInvoiceAggregateArgs>): Prisma.PrismaPromise<GetStripeInvoiceAggregateType<T>>

    /**
     * Group by StripeInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: StripeInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeInvoice model
   */
  readonly fields: StripeInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stripeProducts<T extends StripeInvoice$stripeProductsArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$stripeProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    combinedInvoice<T extends StripeInvoice$combinedInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$combinedInvoiceArgs<ExtArgs>>): Prisma__StripeInvoiceClient<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    combinedInvoices<T extends StripeInvoice$combinedInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$combinedInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeSubscription<T extends StripeInvoice$stripeSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$stripeSubscriptionArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    stripeEntity<T extends StripeInvoice$stripeEntityArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$stripeEntityArgs<ExtArgs>>): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    employerEvaluations<T extends StripeInvoice$employerEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$employerEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    checkoutEvaluations<T extends StripeInvoice$checkoutEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, StripeInvoice$checkoutEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StripeInvoice model
   */ 
  interface StripeInvoiceFieldRefs {
    readonly id: FieldRef<"StripeInvoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"StripeInvoice", 'String'>
    readonly price: FieldRef<"StripeInvoice", 'Float'>
    readonly type: FieldRef<"StripeInvoice", 'StripeInvoiceType'>
    readonly status: FieldRef<"StripeInvoice", 'StripeInvoiceStatus'>
    readonly lastWebhookId: FieldRef<"StripeInvoice", 'String'>
    readonly metadata: FieldRef<"StripeInvoice", 'Json'>
    readonly subscriptionId: FieldRef<"StripeInvoice", 'String'>
    readonly combinedInvoiceId: FieldRef<"StripeInvoice", 'String'>
    readonly stripeEntityId: FieldRef<"StripeInvoice", 'String'>
    readonly createdAt: FieldRef<"StripeInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeInvoice findUnique
   */
  export type StripeInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which StripeInvoice to fetch.
     */
    where: StripeInvoiceWhereUniqueInput
  }

  /**
   * StripeInvoice findUniqueOrThrow
   */
  export type StripeInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which StripeInvoice to fetch.
     */
    where: StripeInvoiceWhereUniqueInput
  }

  /**
   * StripeInvoice findFirst
   */
  export type StripeInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which StripeInvoice to fetch.
     */
    where?: StripeInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeInvoices to fetch.
     */
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeInvoices.
     */
    cursor?: StripeInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeInvoices.
     */
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeInvoice findFirstOrThrow
   */
  export type StripeInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which StripeInvoice to fetch.
     */
    where?: StripeInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeInvoices to fetch.
     */
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeInvoices.
     */
    cursor?: StripeInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeInvoices.
     */
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeInvoice findMany
   */
  export type StripeInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which StripeInvoices to fetch.
     */
    where?: StripeInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeInvoices to fetch.
     */
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeInvoices.
     */
    cursor?: StripeInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeInvoices.
     */
    skip?: number
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeInvoice create
   */
  export type StripeInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeInvoice.
     */
    data: XOR<StripeInvoiceCreateInput, StripeInvoiceUncheckedCreateInput>
  }

  /**
   * StripeInvoice createMany
   */
  export type StripeInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeInvoices.
     */
    data: StripeInvoiceCreateManyInput | StripeInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeInvoice createManyAndReturn
   */
  export type StripeInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * The data used to create many StripeInvoices.
     */
    data: StripeInvoiceCreateManyInput | StripeInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeInvoice update
   */
  export type StripeInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeInvoice.
     */
    data: XOR<StripeInvoiceUpdateInput, StripeInvoiceUncheckedUpdateInput>
    /**
     * Choose, which StripeInvoice to update.
     */
    where: StripeInvoiceWhereUniqueInput
  }

  /**
   * StripeInvoice updateMany
   */
  export type StripeInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeInvoices.
     */
    data: XOR<StripeInvoiceUpdateManyMutationInput, StripeInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which StripeInvoices to update
     */
    where?: StripeInvoiceWhereInput
  }

  /**
   * StripeInvoice upsert
   */
  export type StripeInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeInvoice to update in case it exists.
     */
    where: StripeInvoiceWhereUniqueInput
    /**
     * In case the StripeInvoice found by the `where` argument doesn't exist, create a new StripeInvoice with this data.
     */
    create: XOR<StripeInvoiceCreateInput, StripeInvoiceUncheckedCreateInput>
    /**
     * In case the StripeInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeInvoiceUpdateInput, StripeInvoiceUncheckedUpdateInput>
  }

  /**
   * StripeInvoice delete
   */
  export type StripeInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    /**
     * Filter which StripeInvoice to delete.
     */
    where: StripeInvoiceWhereUniqueInput
  }

  /**
   * StripeInvoice deleteMany
   */
  export type StripeInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeInvoices to delete
     */
    where?: StripeInvoiceWhereInput
  }

  /**
   * StripeInvoice.stripeProducts
   */
  export type StripeInvoice$stripeProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    where?: StripeProductWhereInput
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    cursor?: StripeProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeProductScalarFieldEnum | StripeProductScalarFieldEnum[]
  }

  /**
   * StripeInvoice.combinedInvoice
   */
  export type StripeInvoice$combinedInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
  }

  /**
   * StripeInvoice.combinedInvoices
   */
  export type StripeInvoice$combinedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    cursor?: StripeInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeInvoice.stripeSubscription
   */
  export type StripeInvoice$stripeSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    where?: StripeSubscriptionWhereInput
  }

  /**
   * StripeInvoice.stripeEntity
   */
  export type StripeInvoice$stripeEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    where?: StripeEntityWhereInput
  }

  /**
   * StripeInvoice.employerEvaluations
   */
  export type StripeInvoice$employerEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * StripeInvoice.checkoutEvaluations
   */
  export type StripeInvoice$checkoutEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * StripeInvoice without action
   */
  export type StripeInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model StripeEntity
   */

  export type AggregateStripeEntity = {
    _count: StripeEntityCountAggregateOutputType | null
    _min: StripeEntityMinAggregateOutputType | null
    _max: StripeEntityMaxAggregateOutputType | null
  }

  export type StripeEntityMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    entityId: string | null
    stripeCustomerId: string | null
    autoAdvance: boolean | null
    autoAdvanceCombined: boolean | null
    collectionSendInvoice: boolean | null
    active: boolean | null
    entityParentId: string | null
    stripeEntityType: $Enums.StripeEntityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeEntityMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    entityId: string | null
    stripeCustomerId: string | null
    autoAdvance: boolean | null
    autoAdvanceCombined: boolean | null
    collectionSendInvoice: boolean | null
    active: boolean | null
    entityParentId: string | null
    stripeEntityType: $Enums.StripeEntityType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeEntityCountAggregateOutputType = {
    id: number
    companyId: number
    entityId: number
    stripeCustomerId: number
    billingPreferences: number
    autoAdvance: number
    autoAdvanceCombined: number
    collectionSendInvoice: number
    active: number
    entityParentId: number
    stripeEntityType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeEntityMinAggregateInputType = {
    id?: true
    companyId?: true
    entityId?: true
    stripeCustomerId?: true
    autoAdvance?: true
    autoAdvanceCombined?: true
    collectionSendInvoice?: true
    active?: true
    entityParentId?: true
    stripeEntityType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeEntityMaxAggregateInputType = {
    id?: true
    companyId?: true
    entityId?: true
    stripeCustomerId?: true
    autoAdvance?: true
    autoAdvanceCombined?: true
    collectionSendInvoice?: true
    active?: true
    entityParentId?: true
    stripeEntityType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeEntityCountAggregateInputType = {
    id?: true
    companyId?: true
    entityId?: true
    stripeCustomerId?: true
    billingPreferences?: true
    autoAdvance?: true
    autoAdvanceCombined?: true
    collectionSendInvoice?: true
    active?: true
    entityParentId?: true
    stripeEntityType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeEntity to aggregate.
     */
    where?: StripeEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeEntities to fetch.
     */
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeEntities
    **/
    _count?: true | StripeEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeEntityMaxAggregateInputType
  }

  export type GetStripeEntityAggregateType<T extends StripeEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeEntity[P]>
      : GetScalarType<T[P], AggregateStripeEntity[P]>
  }




  export type StripeEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeEntityWhereInput
    orderBy?: StripeEntityOrderByWithAggregationInput | StripeEntityOrderByWithAggregationInput[]
    by: StripeEntityScalarFieldEnum[] | StripeEntityScalarFieldEnum
    having?: StripeEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeEntityCountAggregateInputType | true
    _min?: StripeEntityMinAggregateInputType
    _max?: StripeEntityMaxAggregateInputType
  }

  export type StripeEntityGroupByOutputType = {
    id: string
    companyId: string
    entityId: string
    stripeCustomerId: string | null
    billingPreferences: JsonValue | null
    autoAdvance: boolean
    autoAdvanceCombined: boolean
    collectionSendInvoice: boolean
    active: boolean
    entityParentId: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt: Date
    updatedAt: Date
    _count: StripeEntityCountAggregateOutputType | null
    _min: StripeEntityMinAggregateOutputType | null
    _max: StripeEntityMaxAggregateOutputType | null
  }

  type GetStripeEntityGroupByPayload<T extends StripeEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeEntityGroupByOutputType[P]>
            : GetScalarType<T[P], StripeEntityGroupByOutputType[P]>
        }
      >
    >


  export type StripeEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    entityId?: boolean
    stripeCustomerId?: boolean
    billingPreferences?: boolean
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: boolean
    stripeEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentEntity?: boolean | StripeEntity$parentEntityArgs<ExtArgs>
    childEntities?: boolean | StripeEntity$childEntitiesArgs<ExtArgs>
    stripeProducts?: boolean | StripeEntity$stripeProductsArgs<ExtArgs>
    stripeSubscriptions?: boolean | StripeEntity$stripeSubscriptionsArgs<ExtArgs>
    stripeInvoices?: boolean | StripeEntity$stripeInvoicesArgs<ExtArgs>
    _count?: boolean | StripeEntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeEntity"]>

  export type StripeEntitySelectScalar = {
    id?: boolean
    companyId?: boolean
    entityId?: boolean
    stripeCustomerId?: boolean
    billingPreferences?: boolean
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: boolean
    stripeEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type StripeEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentEntity?: boolean | StripeEntity$parentEntityArgs<ExtArgs>
    childEntities?: boolean | StripeEntity$childEntitiesArgs<ExtArgs>
    stripeProducts?: boolean | StripeEntity$stripeProductsArgs<ExtArgs>
    stripeSubscriptions?: boolean | StripeEntity$stripeSubscriptionsArgs<ExtArgs>
    stripeInvoices?: boolean | StripeEntity$stripeInvoicesArgs<ExtArgs>
    _count?: boolean | StripeEntityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StripeEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeEntity"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      parentEntity: Prisma.$StripeEntityPayload<ExtArgs> | null
      childEntities: Prisma.$StripeEntityPayload<ExtArgs>[]
      stripeProducts: Prisma.$StripeProductPayload<ExtArgs>[]
      stripeSubscriptions: Prisma.$StripeSubscriptionPayload<ExtArgs>[]
      stripeInvoices: Prisma.$StripeInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      entityId: string
      stripeCustomerId: string | null
      billingPreferences: Prisma.JsonValue | null
      autoAdvance: boolean
      autoAdvanceCombined: boolean
      collectionSendInvoice: boolean
      active: boolean
      entityParentId: string | null
      stripeEntityType: $Enums.StripeEntityType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeEntity"]>
    composites: {}
  }


  type StripeEntityGetPayload<S extends boolean | null | undefined | StripeEntityDefaultArgs> = $Result.GetResult<Prisma.$StripeEntityPayload, S>

  type StripeEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StripeEntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StripeEntityCountAggregateInputType | true
    }

  export interface StripeEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeEntity'], meta: { name: 'StripeEntity' } }
    /**
     * Find zero or one StripeEntity that matches the filter.
     * @param {StripeEntityFindUniqueArgs} args - Arguments to find a StripeEntity
     * @example
     * // Get one StripeEntity
     * const stripeEntity = await prisma.stripeEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StripeEntityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityFindUniqueArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StripeEntity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StripeEntityFindUniqueOrThrowArgs} args - Arguments to find a StripeEntity
     * @example
     * // Get one StripeEntity
     * const stripeEntity = await prisma.stripeEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StripeEntityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StripeEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityFindFirstArgs} args - Arguments to find a StripeEntity
     * @example
     * // Get one StripeEntity
     * const stripeEntity = await prisma.stripeEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StripeEntityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityFindFirstArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StripeEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityFindFirstOrThrowArgs} args - Arguments to find a StripeEntity
     * @example
     * // Get one StripeEntity
     * const stripeEntity = await prisma.stripeEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StripeEntityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StripeEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeEntities
     * const stripeEntities = await prisma.stripeEntity.findMany()
     * 
     * // Get first 10 StripeEntities
     * const stripeEntities = await prisma.stripeEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeEntityWithIdOnly = await prisma.stripeEntity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StripeEntityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StripeEntity.
     * @param {StripeEntityCreateArgs} args - Arguments to create a StripeEntity.
     * @example
     * // Create one StripeEntity
     * const StripeEntity = await prisma.stripeEntity.create({
     *   data: {
     *     // ... data to create a StripeEntity
     *   }
     * })
     * 
    **/
    create<T extends StripeEntityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityCreateArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StripeEntities.
     * @param {StripeEntityCreateManyArgs} args - Arguments to create many StripeEntities.
     * @example
     * // Create many StripeEntities
     * const stripeEntity = await prisma.stripeEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StripeEntityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeEntities and returns the data saved in the database.
     * @param {StripeEntityCreateManyAndReturnArgs} args - Arguments to create many StripeEntities.
     * @example
     * // Create many StripeEntities
     * const stripeEntity = await prisma.stripeEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeEntities and only return the `id`
     * const stripeEntityWithIdOnly = await prisma.stripeEntity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends StripeEntityCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a StripeEntity.
     * @param {StripeEntityDeleteArgs} args - Arguments to delete one StripeEntity.
     * @example
     * // Delete one StripeEntity
     * const StripeEntity = await prisma.stripeEntity.delete({
     *   where: {
     *     // ... filter to delete one StripeEntity
     *   }
     * })
     * 
    **/
    delete<T extends StripeEntityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityDeleteArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StripeEntity.
     * @param {StripeEntityUpdateArgs} args - Arguments to update one StripeEntity.
     * @example
     * // Update one StripeEntity
     * const stripeEntity = await prisma.stripeEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StripeEntityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityUpdateArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StripeEntities.
     * @param {StripeEntityDeleteManyArgs} args - Arguments to filter StripeEntities to delete.
     * @example
     * // Delete a few StripeEntities
     * const { count } = await prisma.stripeEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StripeEntityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeEntityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeEntities
     * const stripeEntity = await prisma.stripeEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StripeEntityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeEntity.
     * @param {StripeEntityUpsertArgs} args - Arguments to update or create a StripeEntity.
     * @example
     * // Update or create a StripeEntity
     * const stripeEntity = await prisma.stripeEntity.upsert({
     *   create: {
     *     // ... data to create a StripeEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeEntity we want to update
     *   }
     * })
    **/
    upsert<T extends StripeEntityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StripeEntityUpsertArgs<ExtArgs>>
    ): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StripeEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityCountArgs} args - Arguments to filter StripeEntities to count.
     * @example
     * // Count the number of StripeEntities
     * const count = await prisma.stripeEntity.count({
     *   where: {
     *     // ... the filter for the StripeEntities we want to count
     *   }
     * })
    **/
    count<T extends StripeEntityCountArgs>(
      args?: Subset<T, StripeEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeEntityAggregateArgs>(args: Subset<T, StripeEntityAggregateArgs>): Prisma.PrismaPromise<GetStripeEntityAggregateType<T>>

    /**
     * Group by StripeEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeEntityGroupByArgs['orderBy'] }
        : { orderBy?: StripeEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeEntity model
   */
  readonly fields: StripeEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parentEntity<T extends StripeEntity$parentEntityArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntity$parentEntityArgs<ExtArgs>>): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    childEntities<T extends StripeEntity$childEntitiesArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntity$childEntitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeProducts<T extends StripeEntity$stripeProductsArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntity$stripeProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeSubscriptions<T extends StripeEntity$stripeSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntity$stripeSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeInvoices<T extends StripeEntity$stripeInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntity$stripeInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StripeEntity model
   */ 
  interface StripeEntityFieldRefs {
    readonly id: FieldRef<"StripeEntity", 'String'>
    readonly companyId: FieldRef<"StripeEntity", 'String'>
    readonly entityId: FieldRef<"StripeEntity", 'String'>
    readonly stripeCustomerId: FieldRef<"StripeEntity", 'String'>
    readonly billingPreferences: FieldRef<"StripeEntity", 'Json'>
    readonly autoAdvance: FieldRef<"StripeEntity", 'Boolean'>
    readonly autoAdvanceCombined: FieldRef<"StripeEntity", 'Boolean'>
    readonly collectionSendInvoice: FieldRef<"StripeEntity", 'Boolean'>
    readonly active: FieldRef<"StripeEntity", 'Boolean'>
    readonly entityParentId: FieldRef<"StripeEntity", 'String'>
    readonly stripeEntityType: FieldRef<"StripeEntity", 'StripeEntityType'>
    readonly createdAt: FieldRef<"StripeEntity", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeEntity findUnique
   */
  export type StripeEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter, which StripeEntity to fetch.
     */
    where: StripeEntityWhereUniqueInput
  }

  /**
   * StripeEntity findUniqueOrThrow
   */
  export type StripeEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter, which StripeEntity to fetch.
     */
    where: StripeEntityWhereUniqueInput
  }

  /**
   * StripeEntity findFirst
   */
  export type StripeEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter, which StripeEntity to fetch.
     */
    where?: StripeEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeEntities to fetch.
     */
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeEntities.
     */
    cursor?: StripeEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeEntities.
     */
    distinct?: StripeEntityScalarFieldEnum | StripeEntityScalarFieldEnum[]
  }

  /**
   * StripeEntity findFirstOrThrow
   */
  export type StripeEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter, which StripeEntity to fetch.
     */
    where?: StripeEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeEntities to fetch.
     */
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeEntities.
     */
    cursor?: StripeEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeEntities.
     */
    distinct?: StripeEntityScalarFieldEnum | StripeEntityScalarFieldEnum[]
  }

  /**
   * StripeEntity findMany
   */
  export type StripeEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter, which StripeEntities to fetch.
     */
    where?: StripeEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeEntities to fetch.
     */
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeEntities.
     */
    cursor?: StripeEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeEntities.
     */
    skip?: number
    distinct?: StripeEntityScalarFieldEnum | StripeEntityScalarFieldEnum[]
  }

  /**
   * StripeEntity create
   */
  export type StripeEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeEntity.
     */
    data: XOR<StripeEntityCreateInput, StripeEntityUncheckedCreateInput>
  }

  /**
   * StripeEntity createMany
   */
  export type StripeEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeEntities.
     */
    data: StripeEntityCreateManyInput | StripeEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeEntity createManyAndReturn
   */
  export type StripeEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * The data used to create many StripeEntities.
     */
    data: StripeEntityCreateManyInput | StripeEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeEntity update
   */
  export type StripeEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeEntity.
     */
    data: XOR<StripeEntityUpdateInput, StripeEntityUncheckedUpdateInput>
    /**
     * Choose, which StripeEntity to update.
     */
    where: StripeEntityWhereUniqueInput
  }

  /**
   * StripeEntity updateMany
   */
  export type StripeEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeEntities.
     */
    data: XOR<StripeEntityUpdateManyMutationInput, StripeEntityUncheckedUpdateManyInput>
    /**
     * Filter which StripeEntities to update
     */
    where?: StripeEntityWhereInput
  }

  /**
   * StripeEntity upsert
   */
  export type StripeEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeEntity to update in case it exists.
     */
    where: StripeEntityWhereUniqueInput
    /**
     * In case the StripeEntity found by the `where` argument doesn't exist, create a new StripeEntity with this data.
     */
    create: XOR<StripeEntityCreateInput, StripeEntityUncheckedCreateInput>
    /**
     * In case the StripeEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeEntityUpdateInput, StripeEntityUncheckedUpdateInput>
  }

  /**
   * StripeEntity delete
   */
  export type StripeEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    /**
     * Filter which StripeEntity to delete.
     */
    where: StripeEntityWhereUniqueInput
  }

  /**
   * StripeEntity deleteMany
   */
  export type StripeEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeEntities to delete
     */
    where?: StripeEntityWhereInput
  }

  /**
   * StripeEntity.parentEntity
   */
  export type StripeEntity$parentEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    where?: StripeEntityWhereInput
  }

  /**
   * StripeEntity.childEntities
   */
  export type StripeEntity$childEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
    where?: StripeEntityWhereInput
    orderBy?: StripeEntityOrderByWithRelationInput | StripeEntityOrderByWithRelationInput[]
    cursor?: StripeEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeEntityScalarFieldEnum | StripeEntityScalarFieldEnum[]
  }

  /**
   * StripeEntity.stripeProducts
   */
  export type StripeEntity$stripeProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeProduct
     */
    select?: StripeProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeProductInclude<ExtArgs> | null
    where?: StripeProductWhereInput
    orderBy?: StripeProductOrderByWithRelationInput | StripeProductOrderByWithRelationInput[]
    cursor?: StripeProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeProductScalarFieldEnum | StripeProductScalarFieldEnum[]
  }

  /**
   * StripeEntity.stripeSubscriptions
   */
  export type StripeEntity$stripeSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    where?: StripeSubscriptionWhereInput
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    cursor?: StripeSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeEntity.stripeInvoices
   */
  export type StripeEntity$stripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    cursor?: StripeInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeEntity without action
   */
  export type StripeEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeEntity
     */
    select?: StripeEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeEntityInclude<ExtArgs> | null
  }


  /**
   * Model StripeSubscription
   */

  export type AggregateStripeSubscription = {
    _count: StripeSubscriptionCountAggregateOutputType | null
    _min: StripeSubscriptionMinAggregateOutputType | null
    _max: StripeSubscriptionMaxAggregateOutputType | null
  }

  export type StripeSubscriptionMinAggregateOutputType = {
    id: string | null
    stripeEntityId: string | null
    stripeSubscriptionId: string | null
    stripeProductId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeSubscriptionMaxAggregateOutputType = {
    id: string | null
    stripeEntityId: string | null
    stripeSubscriptionId: string | null
    stripeProductId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeSubscriptionCountAggregateOutputType = {
    id: number
    stripeEntityId: number
    stripeSubscriptionId: number
    stripeProductId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeSubscriptionMinAggregateInputType = {
    id?: true
    stripeEntityId?: true
    stripeSubscriptionId?: true
    stripeProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeSubscriptionMaxAggregateInputType = {
    id?: true
    stripeEntityId?: true
    stripeSubscriptionId?: true
    stripeProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeSubscriptionCountAggregateInputType = {
    id?: true
    stripeEntityId?: true
    stripeSubscriptionId?: true
    stripeProductId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeSubscription to aggregate.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeSubscriptions
    **/
    _count?: true | StripeSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeSubscriptionMaxAggregateInputType
  }

  export type GetStripeSubscriptionAggregateType<T extends StripeSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeSubscription[P]>
      : GetScalarType<T[P], AggregateStripeSubscription[P]>
  }




  export type StripeSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeSubscriptionWhereInput
    orderBy?: StripeSubscriptionOrderByWithAggregationInput | StripeSubscriptionOrderByWithAggregationInput[]
    by: StripeSubscriptionScalarFieldEnum[] | StripeSubscriptionScalarFieldEnum
    having?: StripeSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeSubscriptionCountAggregateInputType | true
    _min?: StripeSubscriptionMinAggregateInputType
    _max?: StripeSubscriptionMaxAggregateInputType
  }

  export type StripeSubscriptionGroupByOutputType = {
    id: string
    stripeEntityId: string
    stripeSubscriptionId: string
    stripeProductId: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: StripeSubscriptionCountAggregateOutputType | null
    _min: StripeSubscriptionMinAggregateOutputType | null
    _max: StripeSubscriptionMaxAggregateOutputType | null
  }

  type GetStripeSubscriptionGroupByPayload<T extends StripeSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], StripeSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type StripeSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeEntityId?: boolean
    stripeSubscriptionId?: boolean
    stripeProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeEntity?: boolean | StripeEntityDefaultArgs<ExtArgs>
    stripeInvoices?: boolean | StripeSubscription$stripeInvoicesArgs<ExtArgs>
    stripeProducts?: boolean | StripeProductDefaultArgs<ExtArgs>
    _count?: boolean | StripeSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeSubscription"]>

  export type StripeSubscriptionSelectScalar = {
    id?: boolean
    stripeEntityId?: boolean
    stripeSubscriptionId?: boolean
    stripeProductId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type StripeSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stripeEntity?: boolean | StripeEntityDefaultArgs<ExtArgs>
    stripeInvoices?: boolean | StripeSubscription$stripeInvoicesArgs<ExtArgs>
    stripeProducts?: boolean | StripeProductDefaultArgs<ExtArgs>
    _count?: boolean | StripeSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StripeSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeSubscription"
    objects: {
      stripeEntity: Prisma.$StripeEntityPayload<ExtArgs>
      stripeInvoices: Prisma.$StripeInvoicePayload<ExtArgs>[]
      stripeProducts: Prisma.$StripeProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripeEntityId: string
      stripeSubscriptionId: string
      stripeProductId: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeSubscription"]>
    composites: {}
  }


  type StripeSubscriptionGetPayload<S extends boolean | null | undefined | StripeSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$StripeSubscriptionPayload, S>

  type StripeSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StripeSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StripeSubscriptionCountAggregateInputType | true
    }

  export interface StripeSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeSubscription'], meta: { name: 'StripeSubscription' } }
    /**
     * Find zero or one StripeSubscription that matches the filter.
     * @param {StripeSubscriptionFindUniqueArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StripeSubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StripeSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StripeSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StripeSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindFirstArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StripeSubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StripeSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindFirstOrThrowArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StripeSubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StripeSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeSubscriptions
     * const stripeSubscriptions = await prisma.stripeSubscription.findMany()
     * 
     * // Get first 10 StripeSubscriptions
     * const stripeSubscriptions = await prisma.stripeSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeSubscriptionWithIdOnly = await prisma.stripeSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StripeSubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StripeSubscription.
     * @param {StripeSubscriptionCreateArgs} args - Arguments to create a StripeSubscription.
     * @example
     * // Create one StripeSubscription
     * const StripeSubscription = await prisma.stripeSubscription.create({
     *   data: {
     *     // ... data to create a StripeSubscription
     *   }
     * })
     * 
    **/
    create<T extends StripeSubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionCreateArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StripeSubscriptions.
     * @param {StripeSubscriptionCreateManyArgs} args - Arguments to create many StripeSubscriptions.
     * @example
     * // Create many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StripeSubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeSubscriptions and returns the data saved in the database.
     * @param {StripeSubscriptionCreateManyAndReturnArgs} args - Arguments to create many StripeSubscriptions.
     * @example
     * // Create many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeSubscriptions and only return the `id`
     * const stripeSubscriptionWithIdOnly = await prisma.stripeSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends StripeSubscriptionCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a StripeSubscription.
     * @param {StripeSubscriptionDeleteArgs} args - Arguments to delete one StripeSubscription.
     * @example
     * // Delete one StripeSubscription
     * const StripeSubscription = await prisma.stripeSubscription.delete({
     *   where: {
     *     // ... filter to delete one StripeSubscription
     *   }
     * })
     * 
    **/
    delete<T extends StripeSubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StripeSubscription.
     * @param {StripeSubscriptionUpdateArgs} args - Arguments to update one StripeSubscription.
     * @example
     * // Update one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StripeSubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StripeSubscriptions.
     * @param {StripeSubscriptionDeleteManyArgs} args - Arguments to filter StripeSubscriptions to delete.
     * @example
     * // Delete a few StripeSubscriptions
     * const { count } = await prisma.stripeSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StripeSubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripeSubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StripeSubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeSubscription.
     * @param {StripeSubscriptionUpsertArgs} args - Arguments to update or create a StripeSubscription.
     * @example
     * // Update or create a StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.upsert({
     *   create: {
     *     // ... data to create a StripeSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends StripeSubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StripeSubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StripeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionCountArgs} args - Arguments to filter StripeSubscriptions to count.
     * @example
     * // Count the number of StripeSubscriptions
     * const count = await prisma.stripeSubscription.count({
     *   where: {
     *     // ... the filter for the StripeSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends StripeSubscriptionCountArgs>(
      args?: Subset<T, StripeSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeSubscriptionAggregateArgs>(args: Subset<T, StripeSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetStripeSubscriptionAggregateType<T>>

    /**
     * Group by StripeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: StripeSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeSubscription model
   */
  readonly fields: StripeSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stripeEntity<T extends StripeEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StripeEntityDefaultArgs<ExtArgs>>): Prisma__StripeEntityClient<$Result.GetResult<Prisma.$StripeEntityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stripeInvoices<T extends StripeSubscription$stripeInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, StripeSubscription$stripeInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeInvoicePayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeProducts<T extends StripeProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StripeProductDefaultArgs<ExtArgs>>): Prisma__StripeProductClient<$Result.GetResult<Prisma.$StripeProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StripeSubscription model
   */ 
  interface StripeSubscriptionFieldRefs {
    readonly id: FieldRef<"StripeSubscription", 'String'>
    readonly stripeEntityId: FieldRef<"StripeSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"StripeSubscription", 'String'>
    readonly stripeProductId: FieldRef<"StripeSubscription", 'String'>
    readonly active: FieldRef<"StripeSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"StripeSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeSubscription findUnique
   */
  export type StripeSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription findUniqueOrThrow
   */
  export type StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription findFirst
   */
  export type StripeSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeSubscriptions.
     */
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription findFirstOrThrow
   */
  export type StripeSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeSubscriptions.
     */
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription findMany
   */
  export type StripeSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscriptions to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription create
   */
  export type StripeSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeSubscription.
     */
    data: XOR<StripeSubscriptionCreateInput, StripeSubscriptionUncheckedCreateInput>
  }

  /**
   * StripeSubscription createMany
   */
  export type StripeSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeSubscriptions.
     */
    data: StripeSubscriptionCreateManyInput | StripeSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeSubscription createManyAndReturn
   */
  export type StripeSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The data used to create many StripeSubscriptions.
     */
    data: StripeSubscriptionCreateManyInput | StripeSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeSubscription update
   */
  export type StripeSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeSubscription.
     */
    data: XOR<StripeSubscriptionUpdateInput, StripeSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which StripeSubscription to update.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription updateMany
   */
  export type StripeSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeSubscriptions.
     */
    data: XOR<StripeSubscriptionUpdateManyMutationInput, StripeSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which StripeSubscriptions to update
     */
    where?: StripeSubscriptionWhereInput
  }

  /**
   * StripeSubscription upsert
   */
  export type StripeSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeSubscription to update in case it exists.
     */
    where: StripeSubscriptionWhereUniqueInput
    /**
     * In case the StripeSubscription found by the `where` argument doesn't exist, create a new StripeSubscription with this data.
     */
    create: XOR<StripeSubscriptionCreateInput, StripeSubscriptionUncheckedCreateInput>
    /**
     * In case the StripeSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeSubscriptionUpdateInput, StripeSubscriptionUncheckedUpdateInput>
  }

  /**
   * StripeSubscription delete
   */
  export type StripeSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which StripeSubscription to delete.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription deleteMany
   */
  export type StripeSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeSubscriptions to delete
     */
    where?: StripeSubscriptionWhereInput
  }

  /**
   * StripeSubscription.stripeInvoices
   */
  export type StripeSubscription$stripeInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeInvoice
     */
    select?: StripeInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeInvoiceInclude<ExtArgs> | null
    where?: StripeInvoiceWhereInput
    orderBy?: StripeInvoiceOrderByWithRelationInput | StripeInvoiceOrderByWithRelationInput[]
    cursor?: StripeInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeInvoiceScalarFieldEnum | StripeInvoiceScalarFieldEnum[]
  }

  /**
   * StripeSubscription without action
   */
  export type StripeSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.NotificationType | null
    responseType: $Enums.NotificationResponseType | null
    publish: boolean | null
    startTime: Date | null
    endTime: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.NotificationType | null
    responseType: $Enums.NotificationResponseType | null
    publish: boolean | null
    startTime: Date | null
    endTime: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    responseType: number
    publish: number
    startTime: number
    endTime: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    responseType?: true
    publish?: true
    startTime?: true
    endTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    responseType?: true
    publish?: true
    startTime?: true
    endTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    responseType?: true
    publish?: true
    startTime?: true
    endTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.NotificationType
    responseType: $Enums.NotificationResponseType | null
    publish: boolean
    startTime: Date | null
    endTime: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    responseType?: boolean
    publish?: boolean
    startTime?: boolean
    endTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | Notification$messagesArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    responseType?: boolean
    publish?: boolean
    startTime?: boolean
    endTime?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Notification$messagesArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      messages: Prisma.$NotificationMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.NotificationType
      responseType: $Enums.NotificationResponseType | null
      publish: boolean
      startTime: Date | null
      endTime: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    messages<T extends Notification$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Notification$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly name: FieldRef<"Notification", 'String'>
    readonly description: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly responseType: FieldRef<"Notification", 'NotificationResponseType'>
    readonly publish: FieldRef<"Notification", 'Boolean'>
    readonly startTime: FieldRef<"Notification", 'DateTime'>
    readonly endTime: FieldRef<"Notification", 'DateTime'>
    readonly active: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.messages
   */
  export type Notification$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    where?: NotificationMessageWhereInput
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    cursor?: NotificationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationMessageScalarFieldEnum | NotificationMessageScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationMessage
   */

  export type AggregateNotificationMessage = {
    _count: NotificationMessageCountAggregateOutputType | null
    _avg: NotificationMessageAvgAggregateOutputType | null
    _sum: NotificationMessageSumAggregateOutputType | null
    _min: NotificationMessageMinAggregateOutputType | null
    _max: NotificationMessageMaxAggregateOutputType | null
  }

  export type NotificationMessageAvgAggregateOutputType = {
    sequence: number | null
    delayMinutes: number | null
    sequenceLimit: number | null
  }

  export type NotificationMessageSumAggregateOutputType = {
    sequence: number | null
    delayMinutes: number | null
    sequenceLimit: number | null
  }

  export type NotificationMessageMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    sequence: number | null
    delayMinutes: number | null
    recurrencePattern: string | null
    sequenceLimit: number | null
    content: string | null
    emailTemplateId: string | null
    channel: $Enums.CommunicationChannel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMessageMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    sequence: number | null
    delayMinutes: number | null
    recurrencePattern: string | null
    sequenceLimit: number | null
    content: string | null
    emailTemplateId: string | null
    channel: $Enums.CommunicationChannel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMessageCountAggregateOutputType = {
    id: number
    notificationId: number
    sequence: number
    delayMinutes: number
    recurrencePattern: number
    sequenceLimit: number
    content: number
    emailTemplateId: number
    channel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMessageAvgAggregateInputType = {
    sequence?: true
    delayMinutes?: true
    sequenceLimit?: true
  }

  export type NotificationMessageSumAggregateInputType = {
    sequence?: true
    delayMinutes?: true
    sequenceLimit?: true
  }

  export type NotificationMessageMinAggregateInputType = {
    id?: true
    notificationId?: true
    sequence?: true
    delayMinutes?: true
    recurrencePattern?: true
    sequenceLimit?: true
    content?: true
    emailTemplateId?: true
    channel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMessageMaxAggregateInputType = {
    id?: true
    notificationId?: true
    sequence?: true
    delayMinutes?: true
    recurrencePattern?: true
    sequenceLimit?: true
    content?: true
    emailTemplateId?: true
    channel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMessageCountAggregateInputType = {
    id?: true
    notificationId?: true
    sequence?: true
    delayMinutes?: true
    recurrencePattern?: true
    sequenceLimit?: true
    content?: true
    emailTemplateId?: true
    channel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationMessage to aggregate.
     */
    where?: NotificationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationMessages to fetch.
     */
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationMessages
    **/
    _count?: true | NotificationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMessageMaxAggregateInputType
  }

  export type GetNotificationMessageAggregateType<T extends NotificationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationMessage[P]>
      : GetScalarType<T[P], AggregateNotificationMessage[P]>
  }




  export type NotificationMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationMessageWhereInput
    orderBy?: NotificationMessageOrderByWithAggregationInput | NotificationMessageOrderByWithAggregationInput[]
    by: NotificationMessageScalarFieldEnum[] | NotificationMessageScalarFieldEnum
    having?: NotificationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationMessageCountAggregateInputType | true
    _avg?: NotificationMessageAvgAggregateInputType
    _sum?: NotificationMessageSumAggregateInputType
    _min?: NotificationMessageMinAggregateInputType
    _max?: NotificationMessageMaxAggregateInputType
  }

  export type NotificationMessageGroupByOutputType = {
    id: string
    notificationId: string
    sequence: number
    delayMinutes: number | null
    recurrencePattern: string | null
    sequenceLimit: number | null
    content: string
    emailTemplateId: string | null
    channel: $Enums.CommunicationChannel
    createdAt: Date
    updatedAt: Date
    _count: NotificationMessageCountAggregateOutputType | null
    _avg: NotificationMessageAvgAggregateOutputType | null
    _sum: NotificationMessageSumAggregateOutputType | null
    _min: NotificationMessageMinAggregateOutputType | null
    _max: NotificationMessageMaxAggregateOutputType | null
  }

  type GetNotificationMessageGroupByPayload<T extends NotificationMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationMessageGroupByOutputType[P]>
        }
      >
    >


  export type NotificationMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    sequence?: boolean
    delayMinutes?: boolean
    recurrencePattern?: boolean
    sequenceLimit?: boolean
    content?: boolean
    emailTemplateId?: boolean
    channel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    emailTemplate?: boolean | NotificationMessage$emailTemplateArgs<ExtArgs>
    notificationHistory?: boolean | NotificationMessage$notificationHistoryArgs<ExtArgs>
    _count?: boolean | NotificationMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationMessage"]>

  export type NotificationMessageSelectScalar = {
    id?: boolean
    notificationId?: boolean
    sequence?: boolean
    delayMinutes?: boolean
    recurrencePattern?: boolean
    sequenceLimit?: boolean
    content?: boolean
    emailTemplateId?: boolean
    channel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type NotificationMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    emailTemplate?: boolean | NotificationMessage$emailTemplateArgs<ExtArgs>
    notificationHistory?: boolean | NotificationMessage$notificationHistoryArgs<ExtArgs>
    _count?: boolean | NotificationMessageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NotificationMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationMessage"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      emailTemplate: Prisma.$EmailTemplatePayload<ExtArgs> | null
      notificationHistory: Prisma.$NotificationHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      sequence: number
      delayMinutes: number | null
      recurrencePattern: string | null
      sequenceLimit: number | null
      content: string
      emailTemplateId: string | null
      channel: $Enums.CommunicationChannel
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationMessage"]>
    composites: {}
  }


  type NotificationMessageGetPayload<S extends boolean | null | undefined | NotificationMessageDefaultArgs> = $Result.GetResult<Prisma.$NotificationMessagePayload, S>

  type NotificationMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationMessageCountAggregateInputType | true
    }

  export interface NotificationMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationMessage'], meta: { name: 'NotificationMessage' } }
    /**
     * Find zero or one NotificationMessage that matches the filter.
     * @param {NotificationMessageFindUniqueArgs} args - Arguments to find a NotificationMessage
     * @example
     * // Get one NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NotificationMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationMessageFindUniqueOrThrowArgs} args - Arguments to find a NotificationMessage
     * @example
     * // Get one NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NotificationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageFindFirstArgs} args - Arguments to find a NotificationMessage
     * @example
     * // Get one NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NotificationMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageFindFirstOrThrowArgs} args - Arguments to find a NotificationMessage
     * @example
     * // Get one NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NotificationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationMessages
     * const notificationMessages = await prisma.notificationMessage.findMany()
     * 
     * // Get first 10 NotificationMessages
     * const notificationMessages = await prisma.notificationMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationMessageWithIdOnly = await prisma.notificationMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NotificationMessage.
     * @param {NotificationMessageCreateArgs} args - Arguments to create a NotificationMessage.
     * @example
     * // Create one NotificationMessage
     * const NotificationMessage = await prisma.notificationMessage.create({
     *   data: {
     *     // ... data to create a NotificationMessage
     *   }
     * })
     * 
    **/
    create<T extends NotificationMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageCreateArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NotificationMessages.
     * @param {NotificationMessageCreateManyArgs} args - Arguments to create many NotificationMessages.
     * @example
     * // Create many NotificationMessages
     * const notificationMessage = await prisma.notificationMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationMessages and returns the data saved in the database.
     * @param {NotificationMessageCreateManyAndReturnArgs} args - Arguments to create many NotificationMessages.
     * @example
     * // Create many NotificationMessages
     * const notificationMessage = await prisma.notificationMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationMessages and only return the `id`
     * const notificationMessageWithIdOnly = await prisma.notificationMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends NotificationMessageCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a NotificationMessage.
     * @param {NotificationMessageDeleteArgs} args - Arguments to delete one NotificationMessage.
     * @example
     * // Delete one NotificationMessage
     * const NotificationMessage = await prisma.notificationMessage.delete({
     *   where: {
     *     // ... filter to delete one NotificationMessage
     *   }
     * })
     * 
    **/
    delete<T extends NotificationMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageDeleteArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NotificationMessage.
     * @param {NotificationMessageUpdateArgs} args - Arguments to update one NotificationMessage.
     * @example
     * // Update one NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageUpdateArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NotificationMessages.
     * @param {NotificationMessageDeleteManyArgs} args - Arguments to filter NotificationMessages to delete.
     * @example
     * // Delete a few NotificationMessages
     * const { count } = await prisma.notificationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationMessages
     * const notificationMessage = await prisma.notificationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationMessage.
     * @param {NotificationMessageUpsertArgs} args - Arguments to update or create a NotificationMessage.
     * @example
     * // Update or create a NotificationMessage
     * const notificationMessage = await prisma.notificationMessage.upsert({
     *   create: {
     *     // ... data to create a NotificationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationMessage we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationMessageUpsertArgs<ExtArgs>>
    ): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NotificationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageCountArgs} args - Arguments to filter NotificationMessages to count.
     * @example
     * // Count the number of NotificationMessages
     * const count = await prisma.notificationMessage.count({
     *   where: {
     *     // ... the filter for the NotificationMessages we want to count
     *   }
     * })
    **/
    count<T extends NotificationMessageCountArgs>(
      args?: Subset<T, NotificationMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationMessageAggregateArgs>(args: Subset<T, NotificationMessageAggregateArgs>): Prisma.PrismaPromise<GetNotificationMessageAggregateType<T>>

    /**
     * Group by NotificationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationMessageGroupByArgs['orderBy'] }
        : { orderBy?: NotificationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationMessage model
   */
  readonly fields: NotificationMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    emailTemplate<T extends NotificationMessage$emailTemplateArgs<ExtArgs> = {}>(args?: Subset<T, NotificationMessage$emailTemplateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notificationHistory<T extends NotificationMessage$notificationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, NotificationMessage$notificationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NotificationMessage model
   */ 
  interface NotificationMessageFieldRefs {
    readonly id: FieldRef<"NotificationMessage", 'String'>
    readonly notificationId: FieldRef<"NotificationMessage", 'String'>
    readonly sequence: FieldRef<"NotificationMessage", 'Float'>
    readonly delayMinutes: FieldRef<"NotificationMessage", 'Float'>
    readonly recurrencePattern: FieldRef<"NotificationMessage", 'String'>
    readonly sequenceLimit: FieldRef<"NotificationMessage", 'Float'>
    readonly content: FieldRef<"NotificationMessage", 'String'>
    readonly emailTemplateId: FieldRef<"NotificationMessage", 'String'>
    readonly channel: FieldRef<"NotificationMessage", 'CommunicationChannel'>
    readonly createdAt: FieldRef<"NotificationMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationMessage findUnique
   */
  export type NotificationMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter, which NotificationMessage to fetch.
     */
    where: NotificationMessageWhereUniqueInput
  }

  /**
   * NotificationMessage findUniqueOrThrow
   */
  export type NotificationMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter, which NotificationMessage to fetch.
     */
    where: NotificationMessageWhereUniqueInput
  }

  /**
   * NotificationMessage findFirst
   */
  export type NotificationMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter, which NotificationMessage to fetch.
     */
    where?: NotificationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationMessages to fetch.
     */
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationMessages.
     */
    cursor?: NotificationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationMessages.
     */
    distinct?: NotificationMessageScalarFieldEnum | NotificationMessageScalarFieldEnum[]
  }

  /**
   * NotificationMessage findFirstOrThrow
   */
  export type NotificationMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter, which NotificationMessage to fetch.
     */
    where?: NotificationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationMessages to fetch.
     */
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationMessages.
     */
    cursor?: NotificationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationMessages.
     */
    distinct?: NotificationMessageScalarFieldEnum | NotificationMessageScalarFieldEnum[]
  }

  /**
   * NotificationMessage findMany
   */
  export type NotificationMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter, which NotificationMessages to fetch.
     */
    where?: NotificationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationMessages to fetch.
     */
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationMessages.
     */
    cursor?: NotificationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationMessages.
     */
    skip?: number
    distinct?: NotificationMessageScalarFieldEnum | NotificationMessageScalarFieldEnum[]
  }

  /**
   * NotificationMessage create
   */
  export type NotificationMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationMessage.
     */
    data: XOR<NotificationMessageCreateInput, NotificationMessageUncheckedCreateInput>
  }

  /**
   * NotificationMessage createMany
   */
  export type NotificationMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationMessages.
     */
    data: NotificationMessageCreateManyInput | NotificationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationMessage createManyAndReturn
   */
  export type NotificationMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * The data used to create many NotificationMessages.
     */
    data: NotificationMessageCreateManyInput | NotificationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationMessage update
   */
  export type NotificationMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationMessage.
     */
    data: XOR<NotificationMessageUpdateInput, NotificationMessageUncheckedUpdateInput>
    /**
     * Choose, which NotificationMessage to update.
     */
    where: NotificationMessageWhereUniqueInput
  }

  /**
   * NotificationMessage updateMany
   */
  export type NotificationMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationMessages.
     */
    data: XOR<NotificationMessageUpdateManyMutationInput, NotificationMessageUncheckedUpdateManyInput>
    /**
     * Filter which NotificationMessages to update
     */
    where?: NotificationMessageWhereInput
  }

  /**
   * NotificationMessage upsert
   */
  export type NotificationMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationMessage to update in case it exists.
     */
    where: NotificationMessageWhereUniqueInput
    /**
     * In case the NotificationMessage found by the `where` argument doesn't exist, create a new NotificationMessage with this data.
     */
    create: XOR<NotificationMessageCreateInput, NotificationMessageUncheckedCreateInput>
    /**
     * In case the NotificationMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationMessageUpdateInput, NotificationMessageUncheckedUpdateInput>
  }

  /**
   * NotificationMessage delete
   */
  export type NotificationMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    /**
     * Filter which NotificationMessage to delete.
     */
    where: NotificationMessageWhereUniqueInput
  }

  /**
   * NotificationMessage deleteMany
   */
  export type NotificationMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationMessages to delete
     */
    where?: NotificationMessageWhereInput
  }

  /**
   * NotificationMessage.emailTemplate
   */
  export type NotificationMessage$emailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    where?: EmailTemplateWhereInput
  }

  /**
   * NotificationMessage.notificationHistory
   */
  export type NotificationMessage$notificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    where?: NotificationHistoryWhereInput
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    cursor?: NotificationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationHistoryScalarFieldEnum | NotificationHistoryScalarFieldEnum[]
  }

  /**
   * NotificationMessage without action
   */
  export type NotificationMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
  }


  /**
   * Model NotificationHistory
   */

  export type AggregateNotificationHistory = {
    _count: NotificationHistoryCountAggregateOutputType | null
    _min: NotificationHistoryMinAggregateOutputType | null
    _max: NotificationHistoryMaxAggregateOutputType | null
  }

  export type NotificationHistoryMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    messageId: string | null
    sentAt: Date | null
    response: string | null
    responseReceivedAt: Date | null
    removedAt: Date | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationHistoryMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    messageId: string | null
    sentAt: Date | null
    response: string | null
    responseReceivedAt: Date | null
    removedAt: Date | null
    jobId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationHistoryCountAggregateOutputType = {
    id: number
    patientId: number
    messageId: number
    sentAt: number
    response: number
    responseReceivedAt: number
    removedAt: number
    jobId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationHistoryMinAggregateInputType = {
    id?: true
    patientId?: true
    messageId?: true
    sentAt?: true
    response?: true
    responseReceivedAt?: true
    removedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationHistoryMaxAggregateInputType = {
    id?: true
    patientId?: true
    messageId?: true
    sentAt?: true
    response?: true
    responseReceivedAt?: true
    removedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationHistoryCountAggregateInputType = {
    id?: true
    patientId?: true
    messageId?: true
    sentAt?: true
    response?: true
    responseReceivedAt?: true
    removedAt?: true
    jobId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationHistory to aggregate.
     */
    where?: NotificationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationHistories to fetch.
     */
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationHistories
    **/
    _count?: true | NotificationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationHistoryMaxAggregateInputType
  }

  export type GetNotificationHistoryAggregateType<T extends NotificationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationHistory[P]>
      : GetScalarType<T[P], AggregateNotificationHistory[P]>
  }




  export type NotificationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationHistoryWhereInput
    orderBy?: NotificationHistoryOrderByWithAggregationInput | NotificationHistoryOrderByWithAggregationInput[]
    by: NotificationHistoryScalarFieldEnum[] | NotificationHistoryScalarFieldEnum
    having?: NotificationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationHistoryCountAggregateInputType | true
    _min?: NotificationHistoryMinAggregateInputType
    _max?: NotificationHistoryMaxAggregateInputType
  }

  export type NotificationHistoryGroupByOutputType = {
    id: string
    patientId: string
    messageId: string
    sentAt: Date | null
    response: string | null
    responseReceivedAt: Date | null
    removedAt: Date | null
    jobId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationHistoryCountAggregateOutputType | null
    _min: NotificationHistoryMinAggregateOutputType | null
    _max: NotificationHistoryMaxAggregateOutputType | null
  }

  type GetNotificationHistoryGroupByPayload<T extends NotificationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type NotificationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    messageId?: boolean
    sentAt?: boolean
    response?: boolean
    responseReceivedAt?: boolean
    removedAt?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    message?: boolean | NotificationMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationHistory"]>

  export type NotificationHistorySelectScalar = {
    id?: boolean
    patientId?: boolean
    messageId?: boolean
    sentAt?: boolean
    response?: boolean
    responseReceivedAt?: boolean
    removedAt?: boolean
    jobId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type NotificationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    message?: boolean | NotificationMessageDefaultArgs<ExtArgs>
  }


  export type $NotificationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationHistory"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      message: Prisma.$NotificationMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      messageId: string
      sentAt: Date | null
      response: string | null
      responseReceivedAt: Date | null
      removedAt: Date | null
      jobId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationHistory"]>
    composites: {}
  }


  type NotificationHistoryGetPayload<S extends boolean | null | undefined | NotificationHistoryDefaultArgs> = $Result.GetResult<Prisma.$NotificationHistoryPayload, S>

  type NotificationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationHistoryCountAggregateInputType | true
    }

  export interface NotificationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationHistory'], meta: { name: 'NotificationHistory' } }
    /**
     * Find zero or one NotificationHistory that matches the filter.
     * @param {NotificationHistoryFindUniqueArgs} args - Arguments to find a NotificationHistory
     * @example
     * // Get one NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NotificationHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationHistoryFindUniqueOrThrowArgs} args - Arguments to find a NotificationHistory
     * @example
     * // Get one NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NotificationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryFindFirstArgs} args - Arguments to find a NotificationHistory
     * @example
     * // Get one NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NotificationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryFindFirstOrThrowArgs} args - Arguments to find a NotificationHistory
     * @example
     * // Get one NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NotificationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationHistories
     * const notificationHistories = await prisma.notificationHistory.findMany()
     * 
     * // Get first 10 NotificationHistories
     * const notificationHistories = await prisma.notificationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationHistoryWithIdOnly = await prisma.notificationHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NotificationHistory.
     * @param {NotificationHistoryCreateArgs} args - Arguments to create a NotificationHistory.
     * @example
     * // Create one NotificationHistory
     * const NotificationHistory = await prisma.notificationHistory.create({
     *   data: {
     *     // ... data to create a NotificationHistory
     *   }
     * })
     * 
    **/
    create<T extends NotificationHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryCreateArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NotificationHistories.
     * @param {NotificationHistoryCreateManyArgs} args - Arguments to create many NotificationHistories.
     * @example
     * // Create many NotificationHistories
     * const notificationHistory = await prisma.notificationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationHistories and returns the data saved in the database.
     * @param {NotificationHistoryCreateManyAndReturnArgs} args - Arguments to create many NotificationHistories.
     * @example
     * // Create many NotificationHistories
     * const notificationHistory = await prisma.notificationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationHistories and only return the `id`
     * const notificationHistoryWithIdOnly = await prisma.notificationHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends NotificationHistoryCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a NotificationHistory.
     * @param {NotificationHistoryDeleteArgs} args - Arguments to delete one NotificationHistory.
     * @example
     * // Delete one NotificationHistory
     * const NotificationHistory = await prisma.notificationHistory.delete({
     *   where: {
     *     // ... filter to delete one NotificationHistory
     *   }
     * })
     * 
    **/
    delete<T extends NotificationHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryDeleteArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NotificationHistory.
     * @param {NotificationHistoryUpdateArgs} args - Arguments to update one NotificationHistory.
     * @example
     * // Update one NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryUpdateArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NotificationHistories.
     * @param {NotificationHistoryDeleteManyArgs} args - Arguments to filter NotificationHistories to delete.
     * @example
     * // Delete a few NotificationHistories
     * const { count } = await prisma.notificationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationHistories
     * const notificationHistory = await prisma.notificationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationHistory.
     * @param {NotificationHistoryUpsertArgs} args - Arguments to update or create a NotificationHistory.
     * @example
     * // Update or create a NotificationHistory
     * const notificationHistory = await prisma.notificationHistory.upsert({
     *   create: {
     *     // ... data to create a NotificationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationHistory we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationHistoryUpsertArgs<ExtArgs>>
    ): Prisma__NotificationHistoryClient<$Result.GetResult<Prisma.$NotificationHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NotificationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryCountArgs} args - Arguments to filter NotificationHistories to count.
     * @example
     * // Count the number of NotificationHistories
     * const count = await prisma.notificationHistory.count({
     *   where: {
     *     // ... the filter for the NotificationHistories we want to count
     *   }
     * })
    **/
    count<T extends NotificationHistoryCountArgs>(
      args?: Subset<T, NotificationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationHistoryAggregateArgs>(args: Subset<T, NotificationHistoryAggregateArgs>): Prisma.PrismaPromise<GetNotificationHistoryAggregateType<T>>

    /**
     * Group by NotificationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: NotificationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationHistory model
   */
  readonly fields: NotificationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    message<T extends NotificationMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationMessageDefaultArgs<ExtArgs>>): Prisma__NotificationMessageClient<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NotificationHistory model
   */ 
  interface NotificationHistoryFieldRefs {
    readonly id: FieldRef<"NotificationHistory", 'String'>
    readonly patientId: FieldRef<"NotificationHistory", 'String'>
    readonly messageId: FieldRef<"NotificationHistory", 'String'>
    readonly sentAt: FieldRef<"NotificationHistory", 'DateTime'>
    readonly response: FieldRef<"NotificationHistory", 'String'>
    readonly responseReceivedAt: FieldRef<"NotificationHistory", 'DateTime'>
    readonly removedAt: FieldRef<"NotificationHistory", 'DateTime'>
    readonly jobId: FieldRef<"NotificationHistory", 'String'>
    readonly createdAt: FieldRef<"NotificationHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationHistory findUnique
   */
  export type NotificationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationHistory to fetch.
     */
    where: NotificationHistoryWhereUniqueInput
  }

  /**
   * NotificationHistory findUniqueOrThrow
   */
  export type NotificationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationHistory to fetch.
     */
    where: NotificationHistoryWhereUniqueInput
  }

  /**
   * NotificationHistory findFirst
   */
  export type NotificationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationHistory to fetch.
     */
    where?: NotificationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationHistories to fetch.
     */
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationHistories.
     */
    cursor?: NotificationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationHistories.
     */
    distinct?: NotificationHistoryScalarFieldEnum | NotificationHistoryScalarFieldEnum[]
  }

  /**
   * NotificationHistory findFirstOrThrow
   */
  export type NotificationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationHistory to fetch.
     */
    where?: NotificationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationHistories to fetch.
     */
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationHistories.
     */
    cursor?: NotificationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationHistories.
     */
    distinct?: NotificationHistoryScalarFieldEnum | NotificationHistoryScalarFieldEnum[]
  }

  /**
   * NotificationHistory findMany
   */
  export type NotificationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationHistories to fetch.
     */
    where?: NotificationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationHistories to fetch.
     */
    orderBy?: NotificationHistoryOrderByWithRelationInput | NotificationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationHistories.
     */
    cursor?: NotificationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationHistories.
     */
    skip?: number
    distinct?: NotificationHistoryScalarFieldEnum | NotificationHistoryScalarFieldEnum[]
  }

  /**
   * NotificationHistory create
   */
  export type NotificationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationHistory.
     */
    data: XOR<NotificationHistoryCreateInput, NotificationHistoryUncheckedCreateInput>
  }

  /**
   * NotificationHistory createMany
   */
  export type NotificationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationHistories.
     */
    data: NotificationHistoryCreateManyInput | NotificationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationHistory createManyAndReturn
   */
  export type NotificationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * The data used to create many NotificationHistories.
     */
    data: NotificationHistoryCreateManyInput | NotificationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationHistory update
   */
  export type NotificationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationHistory.
     */
    data: XOR<NotificationHistoryUpdateInput, NotificationHistoryUncheckedUpdateInput>
    /**
     * Choose, which NotificationHistory to update.
     */
    where: NotificationHistoryWhereUniqueInput
  }

  /**
   * NotificationHistory updateMany
   */
  export type NotificationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationHistories.
     */
    data: XOR<NotificationHistoryUpdateManyMutationInput, NotificationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which NotificationHistories to update
     */
    where?: NotificationHistoryWhereInput
  }

  /**
   * NotificationHistory upsert
   */
  export type NotificationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationHistory to update in case it exists.
     */
    where: NotificationHistoryWhereUniqueInput
    /**
     * In case the NotificationHistory found by the `where` argument doesn't exist, create a new NotificationHistory with this data.
     */
    create: XOR<NotificationHistoryCreateInput, NotificationHistoryUncheckedCreateInput>
    /**
     * In case the NotificationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationHistoryUpdateInput, NotificationHistoryUncheckedUpdateInput>
  }

  /**
   * NotificationHistory delete
   */
  export type NotificationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
    /**
     * Filter which NotificationHistory to delete.
     */
    where: NotificationHistoryWhereUniqueInput
  }

  /**
   * NotificationHistory deleteMany
   */
  export type NotificationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationHistories to delete
     */
    where?: NotificationHistoryWhereInput
  }

  /**
   * NotificationHistory without action
   */
  export type NotificationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationHistory
     */
    select?: NotificationHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    title: string | null
    htmlContent: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    title: string | null
    htmlContent: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    title: number
    design: number
    htmlContent: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    title?: true
    htmlContent?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    title?: true
    htmlContent?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    title?: true
    design?: true
    htmlContent?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    title: string
    design: JsonValue
    htmlContent: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    design?: boolean
    htmlContent?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    NotificationMessages?: boolean | EmailTemplate$NotificationMessagesArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    title?: boolean
    design?: boolean
    htmlContent?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NotificationMessages?: boolean | EmailTemplate$NotificationMessagesArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      NotificationMessages: Prisma.$NotificationMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      design: Prisma.JsonValue
      htmlContent: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }


  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
    **/
    create<T extends EmailTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EmailTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
    **/
    delete<T extends EmailTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    NotificationMessages<T extends EmailTemplate$NotificationMessagesArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$NotificationMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly title: FieldRef<"EmailTemplate", 'String'>
    readonly design: FieldRef<"EmailTemplate", 'Json'>
    readonly htmlContent: FieldRef<"EmailTemplate", 'String'>
    readonly active: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate.NotificationMessages
   */
  export type EmailTemplate$NotificationMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationMessage
     */
    select?: NotificationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationMessageInclude<ExtArgs> | null
    where?: NotificationMessageWhereInput
    orderBy?: NotificationMessageOrderByWithRelationInput | NotificationMessageOrderByWithRelationInput[]
    cursor?: NotificationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationMessageScalarFieldEnum | NotificationMessageScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    password: number
    pin: number
    photoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    pin?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    departments?: boolean | User$departmentsArgs<ExtArgs>
    clinician?: boolean | User$clinicianArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    auditsLogs?: boolean | User$auditsLogsArgs<ExtArgs>
    agreements?: boolean | User$agreementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    pin?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    departments?: boolean | User$departmentsArgs<ExtArgs>
    clinician?: boolean | User$clinicianArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    auditsLogs?: boolean | User$auditsLogsArgs<ExtArgs>
    agreements?: boolean | User$agreementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      companies: Prisma.$CompanyUserPayload<ExtArgs>[]
      departments: Prisma.$DepartmentUserPayload<ExtArgs>[]
      clinician: Prisma.$ClinicianPayload<ExtArgs> | null
      notes: Prisma.$WorkbenchNotesPayload<ExtArgs>[]
      auditsLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      agreements: Prisma.$UserAgreementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      password: string | null
      pin: string | null
      photoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    departments<T extends User$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    clinician<T extends User$clinicianArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicianArgs<ExtArgs>>): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'> | Null>;

    auditsLogs<T extends User$auditsLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    agreements<T extends User$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, User$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly pin: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * User.departments
   */
  export type User$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentUser
     */
    select?: DepartmentUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentUserInclude<ExtArgs> | null
    where?: DepartmentUserWhereInput
    orderBy?: DepartmentUserOrderByWithRelationInput | DepartmentUserOrderByWithRelationInput[]
    cursor?: DepartmentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentUserScalarFieldEnum | DepartmentUserScalarFieldEnum[]
  }

  /**
   * User.clinician
   */
  export type User$clinicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    where?: ClinicianWhereInput
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    cursor?: WorkbenchNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * User.auditsLogs
   */
  export type User$auditsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.agreements
   */
  export type User$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    where?: UserAgreementWhereInput
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    cursor?: UserAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserAgreement
   */

  export type AggregateUserAgreement = {
    _count: UserAgreementCountAggregateOutputType | null
    _min: UserAgreementMinAggregateOutputType | null
    _max: UserAgreementMaxAggregateOutputType | null
  }

  export type UserAgreementMinAggregateOutputType = {
    userId: string | null
    agreementId: string | null
    status: $Enums.AgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAgreementMaxAggregateOutputType = {
    userId: string | null
    agreementId: string | null
    status: $Enums.AgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAgreementCountAggregateOutputType = {
    userId: number
    agreementId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAgreementMinAggregateInputType = {
    userId?: true
    agreementId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAgreementMaxAggregateInputType = {
    userId?: true
    agreementId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAgreementCountAggregateInputType = {
    userId?: true
    agreementId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAgreement to aggregate.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAgreements
    **/
    _count?: true | UserAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAgreementMaxAggregateInputType
  }

  export type GetUserAgreementAggregateType<T extends UserAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAgreement[P]>
      : GetScalarType<T[P], AggregateUserAgreement[P]>
  }




  export type UserAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAgreementWhereInput
    orderBy?: UserAgreementOrderByWithAggregationInput | UserAgreementOrderByWithAggregationInput[]
    by: UserAgreementScalarFieldEnum[] | UserAgreementScalarFieldEnum
    having?: UserAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAgreementCountAggregateInputType | true
    _min?: UserAgreementMinAggregateInputType
    _max?: UserAgreementMaxAggregateInputType
  }

  export type UserAgreementGroupByOutputType = {
    userId: string
    agreementId: string
    status: $Enums.AgreementStatus
    createdAt: Date
    updatedAt: Date
    _count: UserAgreementCountAggregateOutputType | null
    _min: UserAgreementMinAggregateOutputType | null
    _max: UserAgreementMaxAggregateOutputType | null
  }

  type GetUserAgreementGroupByPayload<T extends UserAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAgreementGroupByOutputType[P]>
        }
      >
    >


  export type UserAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    agreementId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAgreement"]>

  export type UserAgreementSelectScalar = {
    userId?: boolean
    agreementId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }


  export type $UserAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAgreement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      agreement: Prisma.$AgreementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      agreementId: string
      status: $Enums.AgreementStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAgreement"]>
    composites: {}
  }


  type UserAgreementGetPayload<S extends boolean | null | undefined | UserAgreementDefaultArgs> = $Result.GetResult<Prisma.$UserAgreementPayload, S>

  type UserAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAgreementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAgreementCountAggregateInputType | true
    }

  export interface UserAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAgreement'], meta: { name: 'UserAgreement' } }
    /**
     * Find zero or one UserAgreement that matches the filter.
     * @param {UserAgreementFindUniqueArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAgreementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserAgreement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAgreementFindUniqueOrThrowArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAgreementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindFirstArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAgreementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementFindFirstArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindFirstOrThrowArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAgreementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAgreements
     * const userAgreements = await prisma.userAgreement.findMany()
     * 
     * // Get first 10 UserAgreements
     * const userAgreements = await prisma.userAgreement.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userAgreementWithUserIdOnly = await prisma.userAgreement.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserAgreementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserAgreement.
     * @param {UserAgreementCreateArgs} args - Arguments to create a UserAgreement.
     * @example
     * // Create one UserAgreement
     * const UserAgreement = await prisma.userAgreement.create({
     *   data: {
     *     // ... data to create a UserAgreement
     *   }
     * })
     * 
    **/
    create<T extends UserAgreementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementCreateArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserAgreements.
     * @param {UserAgreementCreateManyArgs} args - Arguments to create many UserAgreements.
     * @example
     * // Create many UserAgreements
     * const userAgreement = await prisma.userAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserAgreementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAgreements and returns the data saved in the database.
     * @param {UserAgreementCreateManyAndReturnArgs} args - Arguments to create many UserAgreements.
     * @example
     * // Create many UserAgreements
     * const userAgreement = await prisma.userAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAgreements and only return the `userId`
     * const userAgreementWithUserIdOnly = await prisma.userAgreement.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserAgreementCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a UserAgreement.
     * @param {UserAgreementDeleteArgs} args - Arguments to delete one UserAgreement.
     * @example
     * // Delete one UserAgreement
     * const UserAgreement = await prisma.userAgreement.delete({
     *   where: {
     *     // ... filter to delete one UserAgreement
     *   }
     * })
     * 
    **/
    delete<T extends UserAgreementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementDeleteArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserAgreement.
     * @param {UserAgreementUpdateArgs} args - Arguments to update one UserAgreement.
     * @example
     * // Update one UserAgreement
     * const userAgreement = await prisma.userAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAgreementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementUpdateArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserAgreements.
     * @param {UserAgreementDeleteManyArgs} args - Arguments to filter UserAgreements to delete.
     * @example
     * // Delete a few UserAgreements
     * const { count } = await prisma.userAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAgreementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAgreementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAgreements
     * const userAgreement = await prisma.userAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAgreementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAgreement.
     * @param {UserAgreementUpsertArgs} args - Arguments to update or create a UserAgreement.
     * @example
     * // Update or create a UserAgreement
     * const userAgreement = await prisma.userAgreement.upsert({
     *   create: {
     *     // ... data to create a UserAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAgreement we want to update
     *   }
     * })
    **/
    upsert<T extends UserAgreementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAgreementUpsertArgs<ExtArgs>>
    ): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementCountArgs} args - Arguments to filter UserAgreements to count.
     * @example
     * // Count the number of UserAgreements
     * const count = await prisma.userAgreement.count({
     *   where: {
     *     // ... the filter for the UserAgreements we want to count
     *   }
     * })
    **/
    count<T extends UserAgreementCountArgs>(
      args?: Subset<T, UserAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAgreementAggregateArgs>(args: Subset<T, UserAgreementAggregateArgs>): Prisma.PrismaPromise<GetUserAgreementAggregateType<T>>

    /**
     * Group by UserAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAgreementGroupByArgs['orderBy'] }
        : { orderBy?: UserAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAgreement model
   */
  readonly fields: UserAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    agreement<T extends AgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgreementDefaultArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserAgreement model
   */ 
  interface UserAgreementFieldRefs {
    readonly userId: FieldRef<"UserAgreement", 'String'>
    readonly agreementId: FieldRef<"UserAgreement", 'String'>
    readonly status: FieldRef<"UserAgreement", 'AgreementStatus'>
    readonly createdAt: FieldRef<"UserAgreement", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAgreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAgreement findUnique
   */
  export type UserAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement findUniqueOrThrow
   */
  export type UserAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement findFirst
   */
  export type UserAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAgreements.
     */
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement findFirstOrThrow
   */
  export type UserAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAgreements.
     */
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement findMany
   */
  export type UserAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreements to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement create
   */
  export type UserAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAgreement.
     */
    data: XOR<UserAgreementCreateInput, UserAgreementUncheckedCreateInput>
  }

  /**
   * UserAgreement createMany
   */
  export type UserAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAgreements.
     */
    data: UserAgreementCreateManyInput | UserAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAgreement createManyAndReturn
   */
  export type UserAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The data used to create many UserAgreements.
     */
    data: UserAgreementCreateManyInput | UserAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAgreement update
   */
  export type UserAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAgreement.
     */
    data: XOR<UserAgreementUpdateInput, UserAgreementUncheckedUpdateInput>
    /**
     * Choose, which UserAgreement to update.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement updateMany
   */
  export type UserAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAgreements.
     */
    data: XOR<UserAgreementUpdateManyMutationInput, UserAgreementUncheckedUpdateManyInput>
    /**
     * Filter which UserAgreements to update
     */
    where?: UserAgreementWhereInput
  }

  /**
   * UserAgreement upsert
   */
  export type UserAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAgreement to update in case it exists.
     */
    where: UserAgreementWhereUniqueInput
    /**
     * In case the UserAgreement found by the `where` argument doesn't exist, create a new UserAgreement with this data.
     */
    create: XOR<UserAgreementCreateInput, UserAgreementUncheckedCreateInput>
    /**
     * In case the UserAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAgreementUpdateInput, UserAgreementUncheckedUpdateInput>
  }

  /**
   * UserAgreement delete
   */
  export type UserAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter which UserAgreement to delete.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement deleteMany
   */
  export type UserAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAgreements to delete
     */
    where?: UserAgreementWhereInput
  }

  /**
   * UserAgreement without action
   */
  export type UserAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
  }


  /**
   * Model Agreement
   */

  export type AggregateAgreement = {
    _count: AgreementCountAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  export type AgreementMinAggregateOutputType = {
    id: string | null
    type: $Enums.AgreementType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementMaxAggregateOutputType = {
    id: string | null
    type: $Enums.AgreementType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementCountAggregateOutputType = {
    id: number
    type: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgreementMinAggregateInputType = {
    id?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementMaxAggregateInputType = {
    id?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementCountAggregateInputType = {
    id?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreement to aggregate.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agreements
    **/
    _count?: true | AgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementMaxAggregateInputType
  }

  export type GetAgreementAggregateType<T extends AgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreement[P]>
      : GetScalarType<T[P], AggregateAgreement[P]>
  }




  export type AgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithAggregationInput | AgreementOrderByWithAggregationInput[]
    by: AgreementScalarFieldEnum[] | AgreementScalarFieldEnum
    having?: AgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementCountAggregateInputType | true
    _min?: AgreementMinAggregateInputType
    _max?: AgreementMaxAggregateInputType
  }

  export type AgreementGroupByOutputType = {
    id: string
    type: $Enums.AgreementType
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: AgreementCountAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  type GetAgreementGroupByPayload<T extends AgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementGroupByOutputType[P]>
        }
      >
    >


  export type AgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userAgreements?: boolean | Agreement$userAgreementsArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectScalar = {
    id?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAgreements?: boolean | Agreement$userAgreementsArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agreement"
    objects: {
      userAgreements: Prisma.$UserAgreementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.AgreementType
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agreement"]>
    composites: {}
  }


  type AgreementGetPayload<S extends boolean | null | undefined | AgreementDefaultArgs> = $Result.GetResult<Prisma.$AgreementPayload, S>

  type AgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgreementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgreementCountAggregateInputType | true
    }

  export interface AgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agreement'], meta: { name: 'Agreement' } }
    /**
     * Find zero or one Agreement that matches the filter.
     * @param {AgreementFindUniqueArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementFindUniqueArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Agreement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgreementFindUniqueOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Agreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindFirstArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Agreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Agreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agreements
     * const agreements = await prisma.agreement.findMany()
     * 
     * // Get first 10 Agreements
     * const agreements = await prisma.agreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementWithIdOnly = await prisma.agreement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgreementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Agreement.
     * @param {AgreementCreateArgs} args - Arguments to create a Agreement.
     * @example
     * // Create one Agreement
     * const Agreement = await prisma.agreement.create({
     *   data: {
     *     // ... data to create a Agreement
     *   }
     * })
     * 
    **/
    create<T extends AgreementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementCreateArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Agreements.
     * @param {AgreementCreateManyArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgreementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agreements and returns the data saved in the database.
     * @param {AgreementCreateManyAndReturnArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agreements and only return the `id`
     * const agreementWithIdOnly = await prisma.agreement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AgreementCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Agreement.
     * @param {AgreementDeleteArgs} args - Arguments to delete one Agreement.
     * @example
     * // Delete one Agreement
     * const Agreement = await prisma.agreement.delete({
     *   where: {
     *     // ... filter to delete one Agreement
     *   }
     * })
     * 
    **/
    delete<T extends AgreementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementDeleteArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Agreement.
     * @param {AgreementUpdateArgs} args - Arguments to update one Agreement.
     * @example
     * // Update one Agreement
     * const agreement = await prisma.agreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpdateArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Agreements.
     * @param {AgreementDeleteManyArgs} args - Arguments to filter Agreements to delete.
     * @example
     * // Delete a few Agreements
     * const { count } = await prisma.agreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agreements
     * const agreement = await prisma.agreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agreement.
     * @param {AgreementUpsertArgs} args - Arguments to update or create a Agreement.
     * @example
     * // Update or create a Agreement
     * const agreement = await prisma.agreement.upsert({
     *   create: {
     *     // ... data to create a Agreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agreement we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpsertArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementCountArgs} args - Arguments to filter Agreements to count.
     * @example
     * // Count the number of Agreements
     * const count = await prisma.agreement.count({
     *   where: {
     *     // ... the filter for the Agreements we want to count
     *   }
     * })
    **/
    count<T extends AgreementCountArgs>(
      args?: Subset<T, AgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAggregateArgs>(args: Subset<T, AgreementAggregateArgs>): Prisma.PrismaPromise<GetAgreementAggregateType<T>>

    /**
     * Group by Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementGroupByArgs['orderBy'] }
        : { orderBy?: AgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agreement model
   */
  readonly fields: AgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userAgreements<T extends Agreement$userAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$userAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Agreement model
   */ 
  interface AgreementFieldRefs {
    readonly id: FieldRef<"Agreement", 'String'>
    readonly type: FieldRef<"Agreement", 'AgreementType'>
    readonly active: FieldRef<"Agreement", 'Boolean'>
    readonly createdAt: FieldRef<"Agreement", 'DateTime'>
    readonly updatedAt: FieldRef<"Agreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agreement findUnique
   */
  export type AgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findUniqueOrThrow
   */
  export type AgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findFirst
   */
  export type AgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findFirstOrThrow
   */
  export type AgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findMany
   */
  export type AgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreements to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement create
   */
  export type AgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a Agreement.
     */
    data: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
  }

  /**
   * Agreement createMany
   */
  export type AgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agreement createManyAndReturn
   */
  export type AgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agreement update
   */
  export type AgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a Agreement.
     */
    data: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
    /**
     * Choose, which Agreement to update.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement updateMany
   */
  export type AgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agreements.
     */
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyInput>
    /**
     * Filter which Agreements to update
     */
    where?: AgreementWhereInput
  }

  /**
   * Agreement upsert
   */
  export type AgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the Agreement to update in case it exists.
     */
    where: AgreementWhereUniqueInput
    /**
     * In case the Agreement found by the `where` argument doesn't exist, create a new Agreement with this data.
     */
    create: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
    /**
     * In case the Agreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
  }

  /**
   * Agreement delete
   */
  export type AgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter which Agreement to delete.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement deleteMany
   */
  export type AgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreements to delete
     */
    where?: AgreementWhereInput
  }

  /**
   * Agreement.userAgreements
   */
  export type Agreement$userAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    where?: UserAgreementWhereInput
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    cursor?: UserAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * Agreement without action
   */
  export type AgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    userId: string | null
    profileId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    userId: string | null
    profileId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    userId: number
    profileId: number
    provider: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    userId: string
    profileId: string
    provider: string
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    profileId?: boolean
    provider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    userId?: boolean
    profileId?: boolean
    provider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      profileId: string
      provider: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", 'String'>
    readonly profileId: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountVerification
   */

  export type AggregateAccountVerification = {
    _count: AccountVerificationCountAggregateOutputType | null
    _min: AccountVerificationMinAggregateOutputType | null
    _max: AccountVerificationMaxAggregateOutputType | null
  }

  export type AccountVerificationMinAggregateOutputType = {
    token: string | null
    email: string | null
    type: $Enums.AccountRecoveryType | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountVerificationMaxAggregateOutputType = {
    token: string | null
    email: string | null
    type: $Enums.AccountRecoveryType | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountVerificationCountAggregateOutputType = {
    token: number
    email: number
    type: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountVerificationMinAggregateInputType = {
    token?: true
    email?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountVerificationMaxAggregateInputType = {
    token?: true
    email?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountVerificationCountAggregateInputType = {
    token?: true
    email?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountVerification to aggregate.
     */
    where?: AccountVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountVerifications to fetch.
     */
    orderBy?: AccountVerificationOrderByWithRelationInput | AccountVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountVerifications
    **/
    _count?: true | AccountVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountVerificationMaxAggregateInputType
  }

  export type GetAccountVerificationAggregateType<T extends AccountVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountVerification[P]>
      : GetScalarType<T[P], AggregateAccountVerification[P]>
  }




  export type AccountVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountVerificationWhereInput
    orderBy?: AccountVerificationOrderByWithAggregationInput | AccountVerificationOrderByWithAggregationInput[]
    by: AccountVerificationScalarFieldEnum[] | AccountVerificationScalarFieldEnum
    having?: AccountVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountVerificationCountAggregateInputType | true
    _min?: AccountVerificationMinAggregateInputType
    _max?: AccountVerificationMaxAggregateInputType
  }

  export type AccountVerificationGroupByOutputType = {
    token: string
    email: string
    type: $Enums.AccountRecoveryType
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AccountVerificationCountAggregateOutputType | null
    _min: AccountVerificationMinAggregateOutputType | null
    _max: AccountVerificationMaxAggregateOutputType | null
  }

  type GetAccountVerificationGroupByPayload<T extends AccountVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], AccountVerificationGroupByOutputType[P]>
        }
      >
    >


  export type AccountVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    email?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accountVerification"]>

  export type AccountVerificationSelectScalar = {
    token?: boolean
    email?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }



  export type $AccountVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountVerification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      token: string
      email: string
      type: $Enums.AccountRecoveryType
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accountVerification"]>
    composites: {}
  }


  type AccountVerificationGetPayload<S extends boolean | null | undefined | AccountVerificationDefaultArgs> = $Result.GetResult<Prisma.$AccountVerificationPayload, S>

  type AccountVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountVerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountVerificationCountAggregateInputType | true
    }

  export interface AccountVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountVerification'], meta: { name: 'AccountVerification' } }
    /**
     * Find zero or one AccountVerification that matches the filter.
     * @param {AccountVerificationFindUniqueArgs} args - Arguments to find a AccountVerification
     * @example
     * // Get one AccountVerification
     * const accountVerification = await prisma.accountVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountVerificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AccountVerification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountVerificationFindUniqueOrThrowArgs} args - Arguments to find a AccountVerification
     * @example
     * // Get one AccountVerification
     * const accountVerification = await prisma.accountVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountVerificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AccountVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationFindFirstArgs} args - Arguments to find a AccountVerification
     * @example
     * // Get one AccountVerification
     * const accountVerification = await prisma.accountVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountVerificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationFindFirstArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AccountVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationFindFirstOrThrowArgs} args - Arguments to find a AccountVerification
     * @example
     * // Get one AccountVerification
     * const accountVerification = await prisma.accountVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountVerificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AccountVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountVerifications
     * const accountVerifications = await prisma.accountVerification.findMany()
     * 
     * // Get first 10 AccountVerifications
     * const accountVerifications = await prisma.accountVerification.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const accountVerificationWithTokenOnly = await prisma.accountVerification.findMany({ select: { token: true } })
     * 
    **/
    findMany<T extends AccountVerificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AccountVerification.
     * @param {AccountVerificationCreateArgs} args - Arguments to create a AccountVerification.
     * @example
     * // Create one AccountVerification
     * const AccountVerification = await prisma.accountVerification.create({
     *   data: {
     *     // ... data to create a AccountVerification
     *   }
     * })
     * 
    **/
    create<T extends AccountVerificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationCreateArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AccountVerifications.
     * @param {AccountVerificationCreateManyArgs} args - Arguments to create many AccountVerifications.
     * @example
     * // Create many AccountVerifications
     * const accountVerification = await prisma.accountVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AccountVerificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountVerifications and returns the data saved in the database.
     * @param {AccountVerificationCreateManyAndReturnArgs} args - Arguments to create many AccountVerifications.
     * @example
     * // Create many AccountVerifications
     * const accountVerification = await prisma.accountVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountVerifications and only return the `token`
     * const accountVerificationWithTokenOnly = await prisma.accountVerification.createManyAndReturn({ 
     *   select: { token: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AccountVerificationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AccountVerification.
     * @param {AccountVerificationDeleteArgs} args - Arguments to delete one AccountVerification.
     * @example
     * // Delete one AccountVerification
     * const AccountVerification = await prisma.accountVerification.delete({
     *   where: {
     *     // ... filter to delete one AccountVerification
     *   }
     * })
     * 
    **/
    delete<T extends AccountVerificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationDeleteArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AccountVerification.
     * @param {AccountVerificationUpdateArgs} args - Arguments to update one AccountVerification.
     * @example
     * // Update one AccountVerification
     * const accountVerification = await prisma.accountVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountVerificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationUpdateArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AccountVerifications.
     * @param {AccountVerificationDeleteManyArgs} args - Arguments to filter AccountVerifications to delete.
     * @example
     * // Delete a few AccountVerifications
     * const { count } = await prisma.accountVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountVerificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountVerificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountVerifications
     * const accountVerification = await prisma.accountVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountVerificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountVerification.
     * @param {AccountVerificationUpsertArgs} args - Arguments to update or create a AccountVerification.
     * @example
     * // Update or create a AccountVerification
     * const accountVerification = await prisma.accountVerification.upsert({
     *   create: {
     *     // ... data to create a AccountVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountVerification we want to update
     *   }
     * })
    **/
    upsert<T extends AccountVerificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountVerificationUpsertArgs<ExtArgs>>
    ): Prisma__AccountVerificationClient<$Result.GetResult<Prisma.$AccountVerificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AccountVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationCountArgs} args - Arguments to filter AccountVerifications to count.
     * @example
     * // Count the number of AccountVerifications
     * const count = await prisma.accountVerification.count({
     *   where: {
     *     // ... the filter for the AccountVerifications we want to count
     *   }
     * })
    **/
    count<T extends AccountVerificationCountArgs>(
      args?: Subset<T, AccountVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountVerificationAggregateArgs>(args: Subset<T, AccountVerificationAggregateArgs>): Prisma.PrismaPromise<GetAccountVerificationAggregateType<T>>

    /**
     * Group by AccountVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountVerificationGroupByArgs['orderBy'] }
        : { orderBy?: AccountVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountVerification model
   */
  readonly fields: AccountVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AccountVerification model
   */ 
  interface AccountVerificationFieldRefs {
    readonly token: FieldRef<"AccountVerification", 'String'>
    readonly email: FieldRef<"AccountVerification", 'String'>
    readonly type: FieldRef<"AccountVerification", 'AccountRecoveryType'>
    readonly expiresAt: FieldRef<"AccountVerification", 'DateTime'>
    readonly createdAt: FieldRef<"AccountVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountVerification findUnique
   */
  export type AccountVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter, which AccountVerification to fetch.
     */
    where: AccountVerificationWhereUniqueInput
  }

  /**
   * AccountVerification findUniqueOrThrow
   */
  export type AccountVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter, which AccountVerification to fetch.
     */
    where: AccountVerificationWhereUniqueInput
  }

  /**
   * AccountVerification findFirst
   */
  export type AccountVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter, which AccountVerification to fetch.
     */
    where?: AccountVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountVerifications to fetch.
     */
    orderBy?: AccountVerificationOrderByWithRelationInput | AccountVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountVerifications.
     */
    cursor?: AccountVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountVerifications.
     */
    distinct?: AccountVerificationScalarFieldEnum | AccountVerificationScalarFieldEnum[]
  }

  /**
   * AccountVerification findFirstOrThrow
   */
  export type AccountVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter, which AccountVerification to fetch.
     */
    where?: AccountVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountVerifications to fetch.
     */
    orderBy?: AccountVerificationOrderByWithRelationInput | AccountVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountVerifications.
     */
    cursor?: AccountVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountVerifications.
     */
    distinct?: AccountVerificationScalarFieldEnum | AccountVerificationScalarFieldEnum[]
  }

  /**
   * AccountVerification findMany
   */
  export type AccountVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter, which AccountVerifications to fetch.
     */
    where?: AccountVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountVerifications to fetch.
     */
    orderBy?: AccountVerificationOrderByWithRelationInput | AccountVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountVerifications.
     */
    cursor?: AccountVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountVerifications.
     */
    skip?: number
    distinct?: AccountVerificationScalarFieldEnum | AccountVerificationScalarFieldEnum[]
  }

  /**
   * AccountVerification create
   */
  export type AccountVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a AccountVerification.
     */
    data: XOR<AccountVerificationCreateInput, AccountVerificationUncheckedCreateInput>
  }

  /**
   * AccountVerification createMany
   */
  export type AccountVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountVerifications.
     */
    data: AccountVerificationCreateManyInput | AccountVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountVerification createManyAndReturn
   */
  export type AccountVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * The data used to create many AccountVerifications.
     */
    data: AccountVerificationCreateManyInput | AccountVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountVerification update
   */
  export type AccountVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a AccountVerification.
     */
    data: XOR<AccountVerificationUpdateInput, AccountVerificationUncheckedUpdateInput>
    /**
     * Choose, which AccountVerification to update.
     */
    where: AccountVerificationWhereUniqueInput
  }

  /**
   * AccountVerification updateMany
   */
  export type AccountVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountVerifications.
     */
    data: XOR<AccountVerificationUpdateManyMutationInput, AccountVerificationUncheckedUpdateManyInput>
    /**
     * Filter which AccountVerifications to update
     */
    where?: AccountVerificationWhereInput
  }

  /**
   * AccountVerification upsert
   */
  export type AccountVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the AccountVerification to update in case it exists.
     */
    where: AccountVerificationWhereUniqueInput
    /**
     * In case the AccountVerification found by the `where` argument doesn't exist, create a new AccountVerification with this data.
     */
    create: XOR<AccountVerificationCreateInput, AccountVerificationUncheckedCreateInput>
    /**
     * In case the AccountVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountVerificationUpdateInput, AccountVerificationUncheckedUpdateInput>
  }

  /**
   * AccountVerification delete
   */
  export type AccountVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
    /**
     * Filter which AccountVerification to delete.
     */
    where: AccountVerificationWhereUniqueInput
  }

  /**
   * AccountVerification deleteMany
   */
  export type AccountVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountVerifications to delete
     */
    where?: AccountVerificationWhereInput
  }

  /**
   * AccountVerification without action
   */
  export type AccountVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountVerification
     */
    select?: AccountVerificationSelect<ExtArgs> | null
  }


  /**
   * Model CompanyInvitation
   */

  export type AggregateCompanyInvitation = {
    _count: CompanyInvitationCountAggregateOutputType | null
    _min: CompanyInvitationMinAggregateOutputType | null
    _max: CompanyInvitationMaxAggregateOutputType | null
  }

  export type CompanyInvitationMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    contact: string | null
    contactType: $Enums.ContactType | null
    role: $Enums.CompanyRole | null
    token: string | null
    verified: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvitationMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    contact: string | null
    contactType: $Enums.ContactType | null
    role: $Enums.CompanyRole | null
    token: string | null
    verified: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvitationCountAggregateOutputType = {
    id: number
    companyId: number
    contact: number
    contactType: number
    role: number
    token: number
    verified: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyInvitationMinAggregateInputType = {
    id?: true
    companyId?: true
    contact?: true
    contactType?: true
    role?: true
    token?: true
    verified?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvitationMaxAggregateInputType = {
    id?: true
    companyId?: true
    contact?: true
    contactType?: true
    role?: true
    token?: true
    verified?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvitationCountAggregateInputType = {
    id?: true
    companyId?: true
    contact?: true
    contactType?: true
    role?: true
    token?: true
    verified?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvitation to aggregate.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyInvitations
    **/
    _count?: true | CompanyInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyInvitationMaxAggregateInputType
  }

  export type GetCompanyInvitationAggregateType<T extends CompanyInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyInvitation[P]>
      : GetScalarType<T[P], AggregateCompanyInvitation[P]>
  }




  export type CompanyInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithAggregationInput | CompanyInvitationOrderByWithAggregationInput[]
    by: CompanyInvitationScalarFieldEnum[] | CompanyInvitationScalarFieldEnum
    having?: CompanyInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyInvitationCountAggregateInputType | true
    _min?: CompanyInvitationMinAggregateInputType
    _max?: CompanyInvitationMaxAggregateInputType
  }

  export type CompanyInvitationGroupByOutputType = {
    id: string
    companyId: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified: boolean
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CompanyInvitationCountAggregateOutputType | null
    _min: CompanyInvitationMinAggregateOutputType | null
    _max: CompanyInvitationMaxAggregateOutputType | null
  }

  type GetCompanyInvitationGroupByPayload<T extends CompanyInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyInvitationGroupByOutputType[P]>
        }
      >
    >


  export type CompanyInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    contact?: boolean
    contactType?: boolean
    role?: boolean
    token?: boolean
    verified?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvitation"]>

  export type CompanyInvitationSelectScalar = {
    id?: boolean
    companyId?: boolean
    contact?: boolean
    contactType?: boolean
    role?: boolean
    token?: boolean
    verified?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $CompanyInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyInvitation"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      contact: string
      contactType: $Enums.ContactType
      role: $Enums.CompanyRole
      token: string
      verified: boolean
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyInvitation"]>
    composites: {}
  }


  type CompanyInvitationGetPayload<S extends boolean | null | undefined | CompanyInvitationDefaultArgs> = $Result.GetResult<Prisma.$CompanyInvitationPayload, S>

  type CompanyInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyInvitationCountAggregateInputType | true
    }

  export interface CompanyInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyInvitation'], meta: { name: 'CompanyInvitation' } }
    /**
     * Find zero or one CompanyInvitation that matches the filter.
     * @param {CompanyInvitationFindUniqueArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyInvitationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyInvitationFindUniqueOrThrowArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyInvitationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindFirstArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyInvitationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindFirstOrThrowArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyInvitationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyInvitations
     * const companyInvitations = await prisma.companyInvitation.findMany()
     * 
     * // Get first 10 CompanyInvitations
     * const companyInvitations = await prisma.companyInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyInvitationWithIdOnly = await prisma.companyInvitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyInvitationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyInvitation.
     * @param {CompanyInvitationCreateArgs} args - Arguments to create a CompanyInvitation.
     * @example
     * // Create one CompanyInvitation
     * const CompanyInvitation = await prisma.companyInvitation.create({
     *   data: {
     *     // ... data to create a CompanyInvitation
     *   }
     * })
     * 
    **/
    create<T extends CompanyInvitationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationCreateArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyInvitations.
     * @param {CompanyInvitationCreateManyArgs} args - Arguments to create many CompanyInvitations.
     * @example
     * // Create many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyInvitationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyInvitations and returns the data saved in the database.
     * @param {CompanyInvitationCreateManyAndReturnArgs} args - Arguments to create many CompanyInvitations.
     * @example
     * // Create many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyInvitations and only return the `id`
     * const companyInvitationWithIdOnly = await prisma.companyInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyInvitationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyInvitation.
     * @param {CompanyInvitationDeleteArgs} args - Arguments to delete one CompanyInvitation.
     * @example
     * // Delete one CompanyInvitation
     * const CompanyInvitation = await prisma.companyInvitation.delete({
     *   where: {
     *     // ... filter to delete one CompanyInvitation
     *   }
     * })
     * 
    **/
    delete<T extends CompanyInvitationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationDeleteArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyInvitation.
     * @param {CompanyInvitationUpdateArgs} args - Arguments to update one CompanyInvitation.
     * @example
     * // Update one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyInvitationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationUpdateArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyInvitations.
     * @param {CompanyInvitationDeleteManyArgs} args - Arguments to filter CompanyInvitations to delete.
     * @example
     * // Delete a few CompanyInvitations
     * const { count } = await prisma.companyInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyInvitationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyInvitationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyInvitationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyInvitation.
     * @param {CompanyInvitationUpsertArgs} args - Arguments to update or create a CompanyInvitation.
     * @example
     * // Update or create a CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.upsert({
     *   create: {
     *     // ... data to create a CompanyInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyInvitation we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyInvitationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyInvitationUpsertArgs<ExtArgs>>
    ): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationCountArgs} args - Arguments to filter CompanyInvitations to count.
     * @example
     * // Count the number of CompanyInvitations
     * const count = await prisma.companyInvitation.count({
     *   where: {
     *     // ... the filter for the CompanyInvitations we want to count
     *   }
     * })
    **/
    count<T extends CompanyInvitationCountArgs>(
      args?: Subset<T, CompanyInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyInvitationAggregateArgs>(args: Subset<T, CompanyInvitationAggregateArgs>): Prisma.PrismaPromise<GetCompanyInvitationAggregateType<T>>

    /**
     * Group by CompanyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyInvitationGroupByArgs['orderBy'] }
        : { orderBy?: CompanyInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyInvitation model
   */
  readonly fields: CompanyInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyInvitation model
   */ 
  interface CompanyInvitationFieldRefs {
    readonly id: FieldRef<"CompanyInvitation", 'String'>
    readonly companyId: FieldRef<"CompanyInvitation", 'String'>
    readonly contact: FieldRef<"CompanyInvitation", 'String'>
    readonly contactType: FieldRef<"CompanyInvitation", 'ContactType'>
    readonly role: FieldRef<"CompanyInvitation", 'CompanyRole'>
    readonly token: FieldRef<"CompanyInvitation", 'String'>
    readonly verified: FieldRef<"CompanyInvitation", 'Boolean'>
    readonly expiresAt: FieldRef<"CompanyInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"CompanyInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyInvitation findUnique
   */
  export type CompanyInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation findUniqueOrThrow
   */
  export type CompanyInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation findFirst
   */
  export type CompanyInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvitations.
     */
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation findFirstOrThrow
   */
  export type CompanyInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvitations.
     */
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation findMany
   */
  export type CompanyInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitations to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation create
   */
  export type CompanyInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyInvitation.
     */
    data: XOR<CompanyInvitationCreateInput, CompanyInvitationUncheckedCreateInput>
  }

  /**
   * CompanyInvitation createMany
   */
  export type CompanyInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyInvitations.
     */
    data: CompanyInvitationCreateManyInput | CompanyInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyInvitation createManyAndReturn
   */
  export type CompanyInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyInvitations.
     */
    data: CompanyInvitationCreateManyInput | CompanyInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyInvitation update
   */
  export type CompanyInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyInvitation.
     */
    data: XOR<CompanyInvitationUpdateInput, CompanyInvitationUncheckedUpdateInput>
    /**
     * Choose, which CompanyInvitation to update.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation updateMany
   */
  export type CompanyInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyInvitations.
     */
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyInput>
    /**
     * Filter which CompanyInvitations to update
     */
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyInvitation upsert
   */
  export type CompanyInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyInvitation to update in case it exists.
     */
    where: CompanyInvitationWhereUniqueInput
    /**
     * In case the CompanyInvitation found by the `where` argument doesn't exist, create a new CompanyInvitation with this data.
     */
    create: XOR<CompanyInvitationCreateInput, CompanyInvitationUncheckedCreateInput>
    /**
     * In case the CompanyInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyInvitationUpdateInput, CompanyInvitationUncheckedUpdateInput>
  }

  /**
   * CompanyInvitation delete
   */
  export type CompanyInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter which CompanyInvitation to delete.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation deleteMany
   */
  export type CompanyInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvitations to delete
     */
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyInvitation without action
   */
  export type CompanyInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    key: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    key: string
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    key?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }


  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApiKeyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApiKeyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApiKeyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
    **/
    create<T extends ApiKeyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ApiKeyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
    **/
    delete<T extends ApiKeyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApiKeyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApiKeyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApiKeyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
    **/
    upsert<T extends ApiKeyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly companyId: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model ViewFlattenedWorkbench
   */

  export type AggregateViewFlattenedWorkbench = {
    _count: ViewFlattenedWorkbenchCountAggregateOutputType | null
    _avg: ViewFlattenedWorkbenchAvgAggregateOutputType | null
    _sum: ViewFlattenedWorkbenchSumAggregateOutputType | null
    _min: ViewFlattenedWorkbenchMinAggregateOutputType | null
    _max: ViewFlattenedWorkbenchMaxAggregateOutputType | null
  }

  export type ViewFlattenedWorkbenchAvgAggregateOutputType = {
    orderSide: number | null
  }

  export type ViewFlattenedWorkbenchSumAggregateOutputType = {
    orderSide: number | null
  }

  export type ViewFlattenedWorkbenchMinAggregateOutputType = {
    workbenchId: string | null
    companyId: string | null
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string | null
    patientId: string | null
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    workbenchCreatedAt: Date | null
    companySlug: string | null
    labelId: string | null
    trackingStatus: $Enums.ShippingTrackingStatus | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus: $Enums.OrderAuthorizationStatus | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    productType: $Enums.ProductType | null
    submittedAt: Date | null
    isReprint: boolean | null
    orderShoeSize: string | null
    orderShoeWidth: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    needsDevValidation: boolean | null
    isImpressionBox: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
  }

  export type ViewFlattenedWorkbenchMaxAggregateOutputType = {
    workbenchId: string | null
    companyId: string | null
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string | null
    patientId: string | null
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    workbenchCreatedAt: Date | null
    companySlug: string | null
    labelId: string | null
    trackingStatus: $Enums.ShippingTrackingStatus | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus: $Enums.OrderAuthorizationStatus | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    productType: $Enums.ProductType | null
    submittedAt: Date | null
    isReprint: boolean | null
    orderShoeSize: string | null
    orderShoeWidth: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    needsDevValidation: boolean | null
    isImpressionBox: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
  }

  export type ViewFlattenedWorkbenchCountAggregateOutputType = {
    workbenchId: number
    companyId: number
    workbenchStatus: number
    evaluationId: number
    patientId: number
    orderId: number
    orderStatus: number
    workbenchCreatedAt: number
    companySlug: number
    labelId: number
    trackingStatus: number
    createdReason: number
    orderAuthorizationStatus: number
    slicerProfile: number
    poNumber: number
    clinicianName: number
    clinicianId: number
    patientFirstName: number
    patientLastName: number
    orderCreatedAt: number
    authorizationUpdatedAt: number
    orderCompletedAt: number
    isDiabetic: number
    orderSide: number
    orderQuantity: number
    productType: number
    submittedAt: number
    isReprint: number
    orderShoeSize: number
    orderShoeWidth: number
    orderGender: number
    validatedAt: number
    printingStartedAt: number
    printingStartedBy: number
    grindingCompletedAt: number
    grindingCompletedBy: number
    gluingCompletedAt: number
    gluingCompletedBy: number
    finishingCompletedAt: number
    finishingCompletedBy: number
    shippingCompletedAt: number
    shippingCompletedBy: number
    printingCompletedAt: number
    printingCompletedBy: number
    addonCompletedAt: number
    addonCompletedBy: number
    validationStatus: number
    needsDevValidation: number
    isImpressionBox: number
    deviceTypeName: number
    taikaId: number
    taikaDevId: number
    externalId: number
    companyName: number
    _all: number
  }


  export type ViewFlattenedWorkbenchAvgAggregateInputType = {
    orderSide?: true
  }

  export type ViewFlattenedWorkbenchSumAggregateInputType = {
    orderSide?: true
  }

  export type ViewFlattenedWorkbenchMinAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    workbenchCreatedAt?: true
    companySlug?: true
    labelId?: true
    trackingStatus?: true
    createdReason?: true
    orderAuthorizationStatus?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    productType?: true
    submittedAt?: true
    isReprint?: true
    orderShoeSize?: true
    orderShoeWidth?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    needsDevValidation?: true
    isImpressionBox?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
  }

  export type ViewFlattenedWorkbenchMaxAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    workbenchCreatedAt?: true
    companySlug?: true
    labelId?: true
    trackingStatus?: true
    createdReason?: true
    orderAuthorizationStatus?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    productType?: true
    submittedAt?: true
    isReprint?: true
    orderShoeSize?: true
    orderShoeWidth?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    needsDevValidation?: true
    isImpressionBox?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
  }

  export type ViewFlattenedWorkbenchCountAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    workbenchCreatedAt?: true
    companySlug?: true
    labelId?: true
    trackingStatus?: true
    createdReason?: true
    orderAuthorizationStatus?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    productType?: true
    submittedAt?: true
    isReprint?: true
    orderShoeSize?: true
    orderShoeWidth?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    needsDevValidation?: true
    isImpressionBox?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
    _all?: true
  }

  export type ViewFlattenedWorkbenchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewFlattenedWorkbench to aggregate.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewFlattenedWorkbenches
    **/
    _count?: true | ViewFlattenedWorkbenchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewFlattenedWorkbenchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewFlattenedWorkbenchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewFlattenedWorkbenchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewFlattenedWorkbenchMaxAggregateInputType
  }

  export type GetViewFlattenedWorkbenchAggregateType<T extends ViewFlattenedWorkbenchAggregateArgs> = {
        [P in keyof T & keyof AggregateViewFlattenedWorkbench]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewFlattenedWorkbench[P]>
      : GetScalarType<T[P], AggregateViewFlattenedWorkbench[P]>
  }




  export type ViewFlattenedWorkbenchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewFlattenedWorkbenchWhereInput
    orderBy?: ViewFlattenedWorkbenchOrderByWithAggregationInput | ViewFlattenedWorkbenchOrderByWithAggregationInput[]
    by: ViewFlattenedWorkbenchScalarFieldEnum[] | ViewFlattenedWorkbenchScalarFieldEnum
    having?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewFlattenedWorkbenchCountAggregateInputType | true
    _avg?: ViewFlattenedWorkbenchAvgAggregateInputType
    _sum?: ViewFlattenedWorkbenchSumAggregateInputType
    _min?: ViewFlattenedWorkbenchMinAggregateInputType
    _max?: ViewFlattenedWorkbenchMaxAggregateInputType
  }

  export type ViewFlattenedWorkbenchGroupByOutputType = {
    workbenchId: string
    companyId: string
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    workbenchCreatedAt: Date | null
    companySlug: string | null
    labelId: string | null
    trackingStatus: $Enums.ShippingTrackingStatus | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus: $Enums.OrderAuthorizationStatus | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    productType: $Enums.ProductType | null
    submittedAt: Date | null
    isReprint: boolean | null
    orderShoeSize: string | null
    orderShoeWidth: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    needsDevValidation: boolean | null
    isImpressionBox: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
    _count: ViewFlattenedWorkbenchCountAggregateOutputType | null
    _avg: ViewFlattenedWorkbenchAvgAggregateOutputType | null
    _sum: ViewFlattenedWorkbenchSumAggregateOutputType | null
    _min: ViewFlattenedWorkbenchMinAggregateOutputType | null
    _max: ViewFlattenedWorkbenchMaxAggregateOutputType | null
  }

  type GetViewFlattenedWorkbenchGroupByPayload<T extends ViewFlattenedWorkbenchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewFlattenedWorkbenchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewFlattenedWorkbenchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewFlattenedWorkbenchGroupByOutputType[P]>
            : GetScalarType<T[P], ViewFlattenedWorkbenchGroupByOutputType[P]>
        }
      >
    >


  export type ViewFlattenedWorkbenchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workbenchId?: boolean
    companyId?: boolean
    workbenchStatus?: boolean
    evaluationId?: boolean
    patientId?: boolean
    orderId?: boolean
    orderStatus?: boolean
    workbenchCreatedAt?: boolean
    companySlug?: boolean
    labelId?: boolean
    trackingStatus?: boolean
    createdReason?: boolean
    orderAuthorizationStatus?: boolean
    slicerProfile?: boolean
    poNumber?: boolean
    clinicianName?: boolean
    clinicianId?: boolean
    patientFirstName?: boolean
    patientLastName?: boolean
    orderCreatedAt?: boolean
    authorizationUpdatedAt?: boolean
    orderCompletedAt?: boolean
    isDiabetic?: boolean
    orderSide?: boolean
    orderQuantity?: boolean
    productType?: boolean
    submittedAt?: boolean
    isReprint?: boolean
    orderShoeSize?: boolean
    orderShoeWidth?: boolean
    orderGender?: boolean
    validatedAt?: boolean
    printingStartedAt?: boolean
    printingStartedBy?: boolean
    grindingCompletedAt?: boolean
    grindingCompletedBy?: boolean
    gluingCompletedAt?: boolean
    gluingCompletedBy?: boolean
    finishingCompletedAt?: boolean
    finishingCompletedBy?: boolean
    shippingCompletedAt?: boolean
    shippingCompletedBy?: boolean
    printingCompletedAt?: boolean
    printingCompletedBy?: boolean
    addonCompletedAt?: boolean
    addonCompletedBy?: boolean
    validationStatus?: boolean
    needsDevValidation?: boolean
    isImpressionBox?: boolean
    deviceTypeName?: boolean
    taikaId?: boolean
    taikaDevId?: boolean
    externalId?: boolean
    companyName?: boolean
  }, ExtArgs["result"]["viewFlattenedWorkbench"]>

  export type ViewFlattenedWorkbenchSelectScalar = {
    workbenchId?: boolean
    companyId?: boolean
    workbenchStatus?: boolean
    evaluationId?: boolean
    patientId?: boolean
    orderId?: boolean
    orderStatus?: boolean
    workbenchCreatedAt?: boolean
    companySlug?: boolean
    labelId?: boolean
    trackingStatus?: boolean
    createdReason?: boolean
    orderAuthorizationStatus?: boolean
    slicerProfile?: boolean
    poNumber?: boolean
    clinicianName?: boolean
    clinicianId?: boolean
    patientFirstName?: boolean
    patientLastName?: boolean
    orderCreatedAt?: boolean
    authorizationUpdatedAt?: boolean
    orderCompletedAt?: boolean
    isDiabetic?: boolean
    orderSide?: boolean
    orderQuantity?: boolean
    productType?: boolean
    submittedAt?: boolean
    isReprint?: boolean
    orderShoeSize?: boolean
    orderShoeWidth?: boolean
    orderGender?: boolean
    validatedAt?: boolean
    printingStartedAt?: boolean
    printingStartedBy?: boolean
    grindingCompletedAt?: boolean
    grindingCompletedBy?: boolean
    gluingCompletedAt?: boolean
    gluingCompletedBy?: boolean
    finishingCompletedAt?: boolean
    finishingCompletedBy?: boolean
    shippingCompletedAt?: boolean
    shippingCompletedBy?: boolean
    printingCompletedAt?: boolean
    printingCompletedBy?: boolean
    addonCompletedAt?: boolean
    addonCompletedBy?: boolean
    validationStatus?: boolean
    needsDevValidation?: boolean
    isImpressionBox?: boolean
    deviceTypeName?: boolean
    taikaId?: boolean
    taikaDevId?: boolean
    externalId?: boolean
    companyName?: boolean
  }



  export type $ViewFlattenedWorkbenchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewFlattenedWorkbench"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      workbenchId: string
      companyId: string
      workbenchStatus: $Enums.WorkbenchStatus | null
      evaluationId: string
      patientId: string
      orderId: string | null
      orderStatus: $Enums.OrderStatus | null
      workbenchCreatedAt: Date | null
      companySlug: string | null
      labelId: string | null
      trackingStatus: $Enums.ShippingTrackingStatus | null
      createdReason: $Enums.WorkbenchCreatedReason | null
      orderAuthorizationStatus: $Enums.OrderAuthorizationStatus | null
      slicerProfile: string | null
      poNumber: string | null
      clinicianName: string | null
      clinicianId: string | null
      patientFirstName: string | null
      patientLastName: string | null
      orderCreatedAt: Date | null
      authorizationUpdatedAt: Date | null
      orderCompletedAt: Date | null
      isDiabetic: boolean | null
      orderSide: number | null
      orderQuantity: string | null
      productType: $Enums.ProductType | null
      submittedAt: Date | null
      isReprint: boolean | null
      orderShoeSize: string | null
      orderShoeWidth: string | null
      orderGender: string | null
      validatedAt: Date | null
      printingStartedAt: Date | null
      printingStartedBy: string | null
      grindingCompletedAt: Date | null
      grindingCompletedBy: string | null
      gluingCompletedAt: Date | null
      gluingCompletedBy: string | null
      finishingCompletedAt: Date | null
      finishingCompletedBy: string | null
      shippingCompletedAt: Date | null
      shippingCompletedBy: string | null
      printingCompletedAt: Date | null
      printingCompletedBy: string | null
      addonCompletedAt: Date | null
      addonCompletedBy: string | null
      validationStatus: boolean | null
      needsDevValidation: boolean | null
      isImpressionBox: boolean | null
      deviceTypeName: string | null
      taikaId: string | null
      taikaDevId: string | null
      externalId: string | null
      companyName: string | null
    }, ExtArgs["result"]["viewFlattenedWorkbench"]>
    composites: {}
  }


  type ViewFlattenedWorkbenchGetPayload<S extends boolean | null | undefined | ViewFlattenedWorkbenchDefaultArgs> = $Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload, S>

  type ViewFlattenedWorkbenchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViewFlattenedWorkbenchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViewFlattenedWorkbenchCountAggregateInputType | true
    }

  export interface ViewFlattenedWorkbenchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewFlattenedWorkbench'], meta: { name: 'ViewFlattenedWorkbench' } }
    /**
     * Find zero or one ViewFlattenedWorkbench that matches the filter.
     * @param {ViewFlattenedWorkbenchFindUniqueArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ViewFlattenedWorkbench that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViewFlattenedWorkbenchFindUniqueOrThrowArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ViewFlattenedWorkbench that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindFirstArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ViewFlattenedWorkbench that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindFirstOrThrowArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ViewFlattenedWorkbenches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewFlattenedWorkbenches
     * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany()
     * 
     * // Get first 10 ViewFlattenedWorkbenches
     * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany({ take: 10 })
     * 
     * // Only select the `workbenchId`
     * const viewFlattenedWorkbenchWithWorkbenchIdOnly = await prisma.viewFlattenedWorkbench.findMany({ select: { workbenchId: true } })
     * 
    **/
    findMany<T extends ViewFlattenedWorkbenchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchCreateArgs} args - Arguments to create a ViewFlattenedWorkbench.
     * @example
     * // Create one ViewFlattenedWorkbench
     * const ViewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.create({
     *   data: {
     *     // ... data to create a ViewFlattenedWorkbench
     *   }
     * })
     * 
    **/
    create<T extends ViewFlattenedWorkbenchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchCreateArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ViewFlattenedWorkbenches.
     * @param {ViewFlattenedWorkbenchCreateManyArgs} args - Arguments to create many ViewFlattenedWorkbenches.
     * @example
     * // Create many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewFlattenedWorkbenches and returns the data saved in the database.
     * @param {ViewFlattenedWorkbenchCreateManyAndReturnArgs} args - Arguments to create many ViewFlattenedWorkbenches.
     * @example
     * // Create many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewFlattenedWorkbenches and only return the `workbenchId`
     * const viewFlattenedWorkbenchWithWorkbenchIdOnly = await prisma.viewFlattenedWorkbench.createManyAndReturn({ 
     *   select: { workbenchId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchDeleteArgs} args - Arguments to delete one ViewFlattenedWorkbench.
     * @example
     * // Delete one ViewFlattenedWorkbench
     * const ViewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.delete({
     *   where: {
     *     // ... filter to delete one ViewFlattenedWorkbench
     *   }
     * })
     * 
    **/
    delete<T extends ViewFlattenedWorkbenchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchDeleteArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchUpdateArgs} args - Arguments to update one ViewFlattenedWorkbench.
     * @example
     * // Update one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ViewFlattenedWorkbenchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpdateArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ViewFlattenedWorkbenches.
     * @param {ViewFlattenedWorkbenchDeleteManyArgs} args - Arguments to filter ViewFlattenedWorkbenches to delete.
     * @example
     * // Delete a few ViewFlattenedWorkbenches
     * const { count } = await prisma.viewFlattenedWorkbench.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewFlattenedWorkbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchUpsertArgs} args - Arguments to update or create a ViewFlattenedWorkbench.
     * @example
     * // Update or create a ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.upsert({
     *   create: {
     *     // ... data to create a ViewFlattenedWorkbench
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewFlattenedWorkbench we want to update
     *   }
     * })
    **/
    upsert<T extends ViewFlattenedWorkbenchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpsertArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ViewFlattenedWorkbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchCountArgs} args - Arguments to filter ViewFlattenedWorkbenches to count.
     * @example
     * // Count the number of ViewFlattenedWorkbenches
     * const count = await prisma.viewFlattenedWorkbench.count({
     *   where: {
     *     // ... the filter for the ViewFlattenedWorkbenches we want to count
     *   }
     * })
    **/
    count<T extends ViewFlattenedWorkbenchCountArgs>(
      args?: Subset<T, ViewFlattenedWorkbenchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewFlattenedWorkbenchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewFlattenedWorkbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewFlattenedWorkbenchAggregateArgs>(args: Subset<T, ViewFlattenedWorkbenchAggregateArgs>): Prisma.PrismaPromise<GetViewFlattenedWorkbenchAggregateType<T>>

    /**
     * Group by ViewFlattenedWorkbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewFlattenedWorkbenchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewFlattenedWorkbenchGroupByArgs['orderBy'] }
        : { orderBy?: ViewFlattenedWorkbenchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewFlattenedWorkbenchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewFlattenedWorkbenchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewFlattenedWorkbench model
   */
  readonly fields: ViewFlattenedWorkbenchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewFlattenedWorkbench.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewFlattenedWorkbenchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ViewFlattenedWorkbench model
   */ 
  interface ViewFlattenedWorkbenchFieldRefs {
    readonly workbenchId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly companyId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly workbenchStatus: FieldRef<"ViewFlattenedWorkbench", 'WorkbenchStatus'>
    readonly evaluationId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderStatus: FieldRef<"ViewFlattenedWorkbench", 'OrderStatus'>
    readonly workbenchCreatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly companySlug: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly labelId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly trackingStatus: FieldRef<"ViewFlattenedWorkbench", 'ShippingTrackingStatus'>
    readonly createdReason: FieldRef<"ViewFlattenedWorkbench", 'WorkbenchCreatedReason'>
    readonly orderAuthorizationStatus: FieldRef<"ViewFlattenedWorkbench", 'OrderAuthorizationStatus'>
    readonly slicerProfile: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly poNumber: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly clinicianName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly clinicianId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientFirstName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientLastName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderCreatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly authorizationUpdatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly orderCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly isDiabetic: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly orderSide: FieldRef<"ViewFlattenedWorkbench", 'Int'>
    readonly orderQuantity: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly productType: FieldRef<"ViewFlattenedWorkbench", 'ProductType'>
    readonly submittedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly isReprint: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly orderShoeSize: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderShoeWidth: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderGender: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly validatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingStartedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingStartedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly grindingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly grindingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly gluingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly gluingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly finishingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly finishingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly shippingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly shippingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly printingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly addonCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly addonCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly validationStatus: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly needsDevValidation: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly isImpressionBox: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly deviceTypeName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly taikaId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly taikaDevId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly externalId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly companyName: FieldRef<"ViewFlattenedWorkbench", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViewFlattenedWorkbench findUnique
   */
  export type ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench findUniqueOrThrow
   */
  export type ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench findFirst
   */
  export type ViewFlattenedWorkbenchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewFlattenedWorkbenches.
     */
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench findFirstOrThrow
   */
  export type ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewFlattenedWorkbenches.
     */
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench findMany
   */
  export type ViewFlattenedWorkbenchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbenches to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench create
   */
  export type ViewFlattenedWorkbenchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data needed to create a ViewFlattenedWorkbench.
     */
    data: XOR<ViewFlattenedWorkbenchCreateInput, ViewFlattenedWorkbenchUncheckedCreateInput>
  }

  /**
   * ViewFlattenedWorkbench createMany
   */
  export type ViewFlattenedWorkbenchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewFlattenedWorkbenches.
     */
    data: ViewFlattenedWorkbenchCreateManyInput | ViewFlattenedWorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewFlattenedWorkbench createManyAndReturn
   */
  export type ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data used to create many ViewFlattenedWorkbenches.
     */
    data: ViewFlattenedWorkbenchCreateManyInput | ViewFlattenedWorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewFlattenedWorkbench update
   */
  export type ViewFlattenedWorkbenchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data needed to update a ViewFlattenedWorkbench.
     */
    data: XOR<ViewFlattenedWorkbenchUpdateInput, ViewFlattenedWorkbenchUncheckedUpdateInput>
    /**
     * Choose, which ViewFlattenedWorkbench to update.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench updateMany
   */
  export type ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewFlattenedWorkbenches.
     */
    data: XOR<ViewFlattenedWorkbenchUpdateManyMutationInput, ViewFlattenedWorkbenchUncheckedUpdateManyInput>
    /**
     * Filter which ViewFlattenedWorkbenches to update
     */
    where?: ViewFlattenedWorkbenchWhereInput
  }

  /**
   * ViewFlattenedWorkbench upsert
   */
  export type ViewFlattenedWorkbenchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The filter to search for the ViewFlattenedWorkbench to update in case it exists.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * In case the ViewFlattenedWorkbench found by the `where` argument doesn't exist, create a new ViewFlattenedWorkbench with this data.
     */
    create: XOR<ViewFlattenedWorkbenchCreateInput, ViewFlattenedWorkbenchUncheckedCreateInput>
    /**
     * In case the ViewFlattenedWorkbench was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewFlattenedWorkbenchUpdateInput, ViewFlattenedWorkbenchUncheckedUpdateInput>
  }

  /**
   * ViewFlattenedWorkbench delete
   */
  export type ViewFlattenedWorkbenchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter which ViewFlattenedWorkbench to delete.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench deleteMany
   */
  export type ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewFlattenedWorkbenches to delete
     */
    where?: ViewFlattenedWorkbenchWhereInput
  }

  /**
   * ViewFlattenedWorkbench without action
   */
  export type ViewFlattenedWorkbenchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    logoUrl: 'logoUrl',
    slug: 'slug',
    preferences: 'preferences',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    companyId: 'companyId',
    type: 'type',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    contactId: 'contactId'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    birthDate: 'birthDate',
    height: 'height',
    weight: 'weight',
    maritalStatus: 'maritalStatus',
    photoUrl: 'photoUrl',
    active: 'active',
    deceasedAt: 'deceasedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    primaryPhysicianId: 'primaryPhysicianId'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const ClinicianScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicianScalarFieldEnum = (typeof ClinicianScalarFieldEnum)[keyof typeof ClinicianScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    poNumber: 'poNumber',
    type: 'type',
    patientId: 'patientId',
    companyId: 'companyId',
    deviceTypeId: 'deviceTypeId',
    isDiabetic: 'isDiabetic',
    isVeteran: 'isVeteran',
    deviceSide: 'deviceSide',
    devicePosition: 'devicePosition',
    appointmentAt: 'appointmentAt',
    appointmentStatus: 'appointmentStatus',
    referringPhysicianId: 'referringPhysicianId',
    diagnosisId: 'diagnosisId',
    diagnosisedAt: 'diagnosisedAt',
    visitTypeId: 'visitTypeId',
    visitedAt: 'visitedAt',
    facilityId: 'facilityId',
    location: 'location',
    prescribedAt: 'prescribedAt',
    prescribedActive: 'prescribedActive',
    stripeInvoiceId: 'stripeInvoiceId',
    stripeCheckoutInvoiceId: 'stripeCheckoutInvoiceId',
    primaryInsurance: 'primaryInsurance',
    secondaryInsurance: 'secondaryInsurance',
    submittedAt: 'submittedAt',
    startedAt: 'startedAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const FootScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    workbenchId: 'workbenchId',
    side: 'side',
    shoeSize: 'shoeSize',
    shoeWidth: 'shoeWidth',
    shoeGender: 'shoeGender',
    shoeSystem: 'shoeSystem',
    shoeBrand: 'shoeBrand',
    shoeModel: 'shoeModel',
    questionnaire: 'questionnaire',
    inactiveReason: 'inactiveReason',
    isChild: 'isChild',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FootScalarFieldEnum = (typeof FootScalarFieldEnum)[keyof typeof FootScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    footId: 'footId',
    type: 'type',
    fileUrl: 'fileUrl',
    metadata: 'metadata',
    status: 'status',
    statusCheckpoints: 'statusCheckpoints',
    statusReason: 'statusReason',
    statusUpdatedAt: 'statusUpdatedAt',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const AssetAugmentScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    type: 'type',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetAugmentScalarFieldEnum = (typeof AssetAugmentScalarFieldEnum)[keyof typeof AssetAugmentScalarFieldEnum]


  export const AssetAugmentMediaScalarFieldEnum: {
    id: 'id',
    augmentId: 'augmentId',
    data: 'data',
    originalData: 'originalData',
    region: 'region',
    bucket: 'bucket',
    key: 'key',
    active: 'active',
    inactiveReason: 'inactiveReason',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetAugmentMediaScalarFieldEnum = (typeof AssetAugmentMediaScalarFieldEnum)[keyof typeof AssetAugmentMediaScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    sides: 'sides',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const WorkbenchScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    productId: 'productId',
    evaluationId: 'evaluationId',
    customization: 'customization',
    webhookUrl: 'webhookUrl',
    createdReason: 'createdReason',
    status: 'status',
    failedAt: 'failedAt',
    completedAt: 'completedAt',
    submittedAt: 'submittedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkbenchScalarFieldEnum = (typeof WorkbenchScalarFieldEnum)[keyof typeof WorkbenchScalarFieldEnum]


  export const WorkbenchNotesScalarFieldEnum: {
    id: 'id',
    workbenchId: 'workbenchId',
    title: 'title',
    content: 'content',
    tags: 'tags',
    blocks: 'blocks',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WorkbenchNotesScalarFieldEnum = (typeof WorkbenchNotesScalarFieldEnum)[keyof typeof WorkbenchNotesScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    workbenchId: 'workbenchId',
    status: 'status',
    statusUpdatedAt: 'statusUpdatedAt',
    committedDeliveryAt: 'committedDeliveryAt',
    parcelId: 'parcelId',
    active: 'active',
    authorizationStatus: 'authorizationStatus',
    shippingLabelId: 'shippingLabelId',
    authorizationUpdatedAt: 'authorizationUpdatedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    stateOrProvince: 'stateOrProvince',
    postalCode: 'postalCode',
    countryCode: 'countryCode',
    shippingAccountId: 'shippingAccountId',
    phoneNumber: 'phoneNumber',
    shippingAccountCarrier: 'shippingAccountCarrier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ShippingPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weight: 'weight',
    weightUnit: 'weightUnit',
    length: 'length',
    width: 'width',
    height: 'height',
    dimensionUnit: 'dimensionUnit',
    insoleCapacity: 'insoleCapacity',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingPackageScalarFieldEnum = (typeof ShippingPackageScalarFieldEnum)[keyof typeof ShippingPackageScalarFieldEnum]


  export const ShippingLabelScalarFieldEnum: {
    id: 'id',
    addressName: 'addressName',
    facilityId: 'facilityId',
    labelId: 'labelId',
    trackingNumber: 'trackingNumber',
    trackingStatus: 'trackingStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingLabelScalarFieldEnum = (typeof ShippingLabelScalarFieldEnum)[keyof typeof ShippingLabelScalarFieldEnum]


  export const PhysicianScalarFieldEnum: {
    id: 'id',
    name: 'name',
    npi: 'npi',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhysicianScalarFieldEnum = (typeof PhysicianScalarFieldEnum)[keyof typeof PhysicianScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    diabetic: 'diabetic',
    standard: 'standard',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const BillingCodeScalarFieldEnum: {
    id: 'id',
    summary: 'summary',
    description: 'description',
    justifications: 'justifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingCodeScalarFieldEnum = (typeof BillingCodeScalarFieldEnum)[keyof typeof BillingCodeScalarFieldEnum]


  export const DeviceTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    diabetic: 'diabetic',
    custom: 'custom'
  };

  export type DeviceTypeScalarFieldEnum = (typeof DeviceTypeScalarFieldEnum)[keyof typeof DeviceTypeScalarFieldEnum]


  export const VisitTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type VisitTypeScalarFieldEnum = (typeof VisitTypeScalarFieldEnum)[keyof typeof VisitTypeScalarFieldEnum]


  export const FormSchemaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormSchemaScalarFieldEnum = (typeof FormSchemaScalarFieldEnum)[keyof typeof FormSchemaScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    workbenchId: 'workbenchId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const FormTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormTemplateScalarFieldEnum = (typeof FormTemplateScalarFieldEnum)[keyof typeof FormTemplateScalarFieldEnum]


  export const CatalogProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    price: 'price',
    active: 'active',
    favorite: 'favorite',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductScalarFieldEnum = (typeof CatalogProductScalarFieldEnum)[keyof typeof CatalogProductScalarFieldEnum]


  export const CatalogProductAttributeScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    value: 'value',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductAttributeScalarFieldEnum = (typeof CatalogProductAttributeScalarFieldEnum)[keyof typeof CatalogProductAttributeScalarFieldEnum]


  export const CatalogProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    description: 'description',
    caption: 'caption',
    barcode: 'barcode',
    price: 'price',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductVariantScalarFieldEnum = (typeof CatalogProductVariantScalarFieldEnum)[keyof typeof CatalogProductVariantScalarFieldEnum]


  export const CatalogCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogCategoryScalarFieldEnum = (typeof CatalogCategoryScalarFieldEnum)[keyof typeof CatalogCategoryScalarFieldEnum]


  export const CatalogVendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogVendorScalarFieldEnum = (typeof CatalogVendorScalarFieldEnum)[keyof typeof CatalogVendorScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    entityId: 'entityId',
    entityType: 'entityType',
    action: 'action',
    context: 'context',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const PrinterScalarFieldEnum: {
    id: 'id',
    printerIdentifier: 'printerIdentifier',
    tailScaleIP: 'tailScaleIP',
    portNumber: 'portNumber',
    privateIPAddress: 'privateIPAddress'
  };

  export type PrinterScalarFieldEnum = (typeof PrinterScalarFieldEnum)[keyof typeof PrinterScalarFieldEnum]


  export const CompanyUserScalarFieldEnum: {
    userId: 'userId',
    companyId: 'companyId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyUserScalarFieldEnum = (typeof CompanyUserScalarFieldEnum)[keyof typeof CompanyUserScalarFieldEnum]


  export const DepartmentUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    department: 'department',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentUserScalarFieldEnum = (typeof DepartmentUserScalarFieldEnum)[keyof typeof DepartmentUserScalarFieldEnum]


  export const CompanyPatientScalarFieldEnum: {
    patientId: 'patientId',
    companyId: 'companyId',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactId: 'contactId'
  };

  export type CompanyPatientScalarFieldEnum = (typeof CompanyPatientScalarFieldEnum)[keyof typeof CompanyPatientScalarFieldEnum]


  export const FacilityPatientScalarFieldEnum: {
    patientId: 'patientId',
    facilityId: 'facilityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityPatientScalarFieldEnum = (typeof FacilityPatientScalarFieldEnum)[keyof typeof FacilityPatientScalarFieldEnum]


  export const StripeProductScalarFieldEnum: {
    id: 'id',
    type: 'type',
    stripeEntityId: 'stripeEntityId',
    stripeProductId: 'stripeProductId',
    stripePriceId: 'stripePriceId',
    stripeCouponId: 'stripeCouponId',
    frequency: 'frequency',
    amount: 'amount',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeProductScalarFieldEnum = (typeof StripeProductScalarFieldEnum)[keyof typeof StripeProductScalarFieldEnum]


  export const StripeInvoiceScalarFieldEnum: {
    id: 'id',
    stripeInvoiceId: 'stripeInvoiceId',
    price: 'price',
    type: 'type',
    status: 'status',
    lastWebhookId: 'lastWebhookId',
    metadata: 'metadata',
    subscriptionId: 'subscriptionId',
    combinedInvoiceId: 'combinedInvoiceId',
    stripeEntityId: 'stripeEntityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeInvoiceScalarFieldEnum = (typeof StripeInvoiceScalarFieldEnum)[keyof typeof StripeInvoiceScalarFieldEnum]


  export const StripeEntityScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    entityId: 'entityId',
    stripeCustomerId: 'stripeCustomerId',
    billingPreferences: 'billingPreferences',
    autoAdvance: 'autoAdvance',
    autoAdvanceCombined: 'autoAdvanceCombined',
    collectionSendInvoice: 'collectionSendInvoice',
    active: 'active',
    entityParentId: 'entityParentId',
    stripeEntityType: 'stripeEntityType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeEntityScalarFieldEnum = (typeof StripeEntityScalarFieldEnum)[keyof typeof StripeEntityScalarFieldEnum]


  export const StripeSubscriptionScalarFieldEnum: {
    id: 'id',
    stripeEntityId: 'stripeEntityId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeProductId: 'stripeProductId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeSubscriptionScalarFieldEnum = (typeof StripeSubscriptionScalarFieldEnum)[keyof typeof StripeSubscriptionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    responseType: 'responseType',
    publish: 'publish',
    startTime: 'startTime',
    endTime: 'endTime',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationMessageScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    sequence: 'sequence',
    delayMinutes: 'delayMinutes',
    recurrencePattern: 'recurrencePattern',
    sequenceLimit: 'sequenceLimit',
    content: 'content',
    emailTemplateId: 'emailTemplateId',
    channel: 'channel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationMessageScalarFieldEnum = (typeof NotificationMessageScalarFieldEnum)[keyof typeof NotificationMessageScalarFieldEnum]


  export const NotificationHistoryScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    messageId: 'messageId',
    sentAt: 'sentAt',
    response: 'response',
    responseReceivedAt: 'responseReceivedAt',
    removedAt: 'removedAt',
    jobId: 'jobId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationHistoryScalarFieldEnum = (typeof NotificationHistoryScalarFieldEnum)[keyof typeof NotificationHistoryScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    title: 'title',
    design: 'design',
    htmlContent: 'htmlContent',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    password: 'password',
    pin: 'pin',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserAgreementScalarFieldEnum: {
    userId: 'userId',
    agreementId: 'agreementId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAgreementScalarFieldEnum = (typeof UserAgreementScalarFieldEnum)[keyof typeof UserAgreementScalarFieldEnum]


  export const AgreementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgreementScalarFieldEnum = (typeof AgreementScalarFieldEnum)[keyof typeof AgreementScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    userId: 'userId',
    profileId: 'profileId',
    provider: 'provider',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountVerificationScalarFieldEnum: {
    token: 'token',
    email: 'email',
    type: 'type',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountVerificationScalarFieldEnum = (typeof AccountVerificationScalarFieldEnum)[keyof typeof AccountVerificationScalarFieldEnum]


  export const CompanyInvitationScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    contact: 'contact',
    contactType: 'contactType',
    role: 'role',
    token: 'token',
    verified: 'verified',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyInvitationScalarFieldEnum = (typeof CompanyInvitationScalarFieldEnum)[keyof typeof CompanyInvitationScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ViewFlattenedWorkbenchScalarFieldEnum: {
    workbenchId: 'workbenchId',
    companyId: 'companyId',
    workbenchStatus: 'workbenchStatus',
    evaluationId: 'evaluationId',
    patientId: 'patientId',
    orderId: 'orderId',
    orderStatus: 'orderStatus',
    workbenchCreatedAt: 'workbenchCreatedAt',
    companySlug: 'companySlug',
    labelId: 'labelId',
    trackingStatus: 'trackingStatus',
    createdReason: 'createdReason',
    orderAuthorizationStatus: 'orderAuthorizationStatus',
    slicerProfile: 'slicerProfile',
    poNumber: 'poNumber',
    clinicianName: 'clinicianName',
    clinicianId: 'clinicianId',
    patientFirstName: 'patientFirstName',
    patientLastName: 'patientLastName',
    orderCreatedAt: 'orderCreatedAt',
    authorizationUpdatedAt: 'authorizationUpdatedAt',
    orderCompletedAt: 'orderCompletedAt',
    isDiabetic: 'isDiabetic',
    orderSide: 'orderSide',
    orderQuantity: 'orderQuantity',
    productType: 'productType',
    submittedAt: 'submittedAt',
    isReprint: 'isReprint',
    orderShoeSize: 'orderShoeSize',
    orderShoeWidth: 'orderShoeWidth',
    orderGender: 'orderGender',
    validatedAt: 'validatedAt',
    printingStartedAt: 'printingStartedAt',
    printingStartedBy: 'printingStartedBy',
    grindingCompletedAt: 'grindingCompletedAt',
    grindingCompletedBy: 'grindingCompletedBy',
    gluingCompletedAt: 'gluingCompletedAt',
    gluingCompletedBy: 'gluingCompletedBy',
    finishingCompletedAt: 'finishingCompletedAt',
    finishingCompletedBy: 'finishingCompletedBy',
    shippingCompletedAt: 'shippingCompletedAt',
    shippingCompletedBy: 'shippingCompletedBy',
    printingCompletedAt: 'printingCompletedAt',
    printingCompletedBy: 'printingCompletedBy',
    addonCompletedAt: 'addonCompletedAt',
    addonCompletedBy: 'addonCompletedBy',
    validationStatus: 'validationStatus',
    needsDevValidation: 'needsDevValidation',
    isImpressionBox: 'isImpressionBox',
    deviceTypeName: 'deviceTypeName',
    taikaId: 'taikaId',
    taikaDevId: 'taikaDevId',
    externalId: 'externalId',
    companyName: 'companyName'
  };

  export type ViewFlattenedWorkbenchScalarFieldEnum = (typeof ViewFlattenedWorkbenchScalarFieldEnum)[keyof typeof ViewFlattenedWorkbenchScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FacilityType'
   */
  export type EnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType'>
    


  /**
   * Reference to a field of type 'FacilityType[]'
   */
  export type ListEnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'CareType'
   */
  export type EnumCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareType'>
    


  /**
   * Reference to a field of type 'CareType[]'
   */
  export type ListEnumCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareType[]'>
    


  /**
   * Reference to a field of type 'Side'
   */
  export type EnumSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Side'>
    


  /**
   * Reference to a field of type 'Side[]'
   */
  export type ListEnumSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Side[]'>
    


  /**
   * Reference to a field of type 'VerticalPosition'
   */
  export type EnumVerticalPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerticalPosition'>
    


  /**
   * Reference to a field of type 'VerticalPosition[]'
   */
  export type ListEnumVerticalPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerticalPosition[]'>
    


  /**
   * Reference to a field of type 'ShoeWidth'
   */
  export type EnumShoeWidthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeWidth'>
    


  /**
   * Reference to a field of type 'ShoeWidth[]'
   */
  export type ListEnumShoeWidthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeWidth[]'>
    


  /**
   * Reference to a field of type 'ShoeSystem'
   */
  export type EnumShoeSystemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeSystem'>
    


  /**
   * Reference to a field of type 'ShoeSystem[]'
   */
  export type ListEnumShoeSystemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeSystem[]'>
    


  /**
   * Reference to a field of type 'InactiveFootReason'
   */
  export type EnumInactiveFootReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InactiveFootReason'>
    


  /**
   * Reference to a field of type 'InactiveFootReason[]'
   */
  export type ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InactiveFootReason[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'AssetStatus[]'
   */
  export type ListEnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus[]'>
    


  /**
   * Reference to a field of type 'AssetAugmentType'
   */
  export type EnumAssetAugmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetAugmentType'>
    


  /**
   * Reference to a field of type 'AssetAugmentType[]'
   */
  export type ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetAugmentType[]'>
    


  /**
   * Reference to a field of type 'WorkbenchCreatedReason'
   */
  export type EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchCreatedReason'>
    


  /**
   * Reference to a field of type 'WorkbenchCreatedReason[]'
   */
  export type ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchCreatedReason[]'>
    


  /**
   * Reference to a field of type 'WorkbenchStatus'
   */
  export type EnumWorkbenchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchStatus'>
    


  /**
   * Reference to a field of type 'WorkbenchStatus[]'
   */
  export type ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'OrderAuthorizationStatus'
   */
  export type EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAuthorizationStatus'>
    


  /**
   * Reference to a field of type 'OrderAuthorizationStatus[]'
   */
  export type ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAuthorizationStatus[]'>
    


  /**
   * Reference to a field of type 'Carrier'
   */
  export type EnumCarrierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Carrier'>
    


  /**
   * Reference to a field of type 'Carrier[]'
   */
  export type ListEnumCarrierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Carrier[]'>
    


  /**
   * Reference to a field of type 'WeightUnit'
   */
  export type EnumWeightUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeightUnit'>
    


  /**
   * Reference to a field of type 'WeightUnit[]'
   */
  export type ListEnumWeightUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeightUnit[]'>
    


  /**
   * Reference to a field of type 'DimensionUnit'
   */
  export type EnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit'>
    


  /**
   * Reference to a field of type 'DimensionUnit[]'
   */
  export type ListEnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ShippingTrackingStatus'
   */
  export type EnumShippingTrackingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingTrackingStatus'>
    


  /**
   * Reference to a field of type 'ShippingTrackingStatus[]'
   */
  export type ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingTrackingStatus[]'>
    


  /**
   * Reference to a field of type 'DiagnosisStandard'
   */
  export type EnumDiagnosisStandardFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiagnosisStandard'>
    


  /**
   * Reference to a field of type 'DiagnosisStandard[]'
   */
  export type ListEnumDiagnosisStandardFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiagnosisStandard[]'>
    


  /**
   * Reference to a field of type 'FormSchemaType'
   */
  export type EnumFormSchemaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormSchemaType'>
    


  /**
   * Reference to a field of type 'FormSchemaType[]'
   */
  export type ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormSchemaType[]'>
    


  /**
   * Reference to a field of type 'ProductAttributeType'
   */
  export type EnumProductAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAttributeType'>
    


  /**
   * Reference to a field of type 'ProductAttributeType[]'
   */
  export type ListEnumProductAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAttributeType[]'>
    


  /**
   * Reference to a field of type 'CompanyRole'
   */
  export type EnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole'>
    


  /**
   * Reference to a field of type 'CompanyRole[]'
   */
  export type ListEnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole[]'>
    


  /**
   * Reference to a field of type 'CompanyDepartment'
   */
  export type EnumCompanyDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyDepartment'>
    


  /**
   * Reference to a field of type 'CompanyDepartment[]'
   */
  export type ListEnumCompanyDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyDepartment[]'>
    


  /**
   * Reference to a field of type 'StripeProductType'
   */
  export type EnumStripeProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeProductType'>
    


  /**
   * Reference to a field of type 'StripeProductType[]'
   */
  export type ListEnumStripeProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeProductType[]'>
    


  /**
   * Reference to a field of type 'StripeBillingFrequency'
   */
  export type EnumStripeBillingFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeBillingFrequency'>
    


  /**
   * Reference to a field of type 'StripeBillingFrequency[]'
   */
  export type ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeBillingFrequency[]'>
    


  /**
   * Reference to a field of type 'StripeInvoiceType'
   */
  export type EnumStripeInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeInvoiceType'>
    


  /**
   * Reference to a field of type 'StripeInvoiceType[]'
   */
  export type ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeInvoiceType[]'>
    


  /**
   * Reference to a field of type 'StripeInvoiceStatus'
   */
  export type EnumStripeInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeInvoiceStatus'>
    


  /**
   * Reference to a field of type 'StripeInvoiceStatus[]'
   */
  export type ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeInvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'StripeEntityType'
   */
  export type EnumStripeEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeEntityType'>
    


  /**
   * Reference to a field of type 'StripeEntityType[]'
   */
  export type ListEnumStripeEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StripeEntityType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationResponseType'
   */
  export type EnumNotificationResponseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationResponseType'>
    


  /**
   * Reference to a field of type 'NotificationResponseType[]'
   */
  export type ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationResponseType[]'>
    


  /**
   * Reference to a field of type 'CommunicationChannel'
   */
  export type EnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel'>
    


  /**
   * Reference to a field of type 'CommunicationChannel[]'
   */
  export type ListEnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel[]'>
    


  /**
   * Reference to a field of type 'AgreementStatus'
   */
  export type EnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus'>
    


  /**
   * Reference to a field of type 'AgreementStatus[]'
   */
  export type ListEnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus[]'>
    


  /**
   * Reference to a field of type 'AgreementType'
   */
  export type EnumAgreementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementType'>
    


  /**
   * Reference to a field of type 'AgreementType[]'
   */
  export type ListEnumAgreementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementType[]'>
    


  /**
   * Reference to a field of type 'AccountRecoveryType'
   */
  export type EnumAccountRecoveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountRecoveryType'>
    


  /**
   * Reference to a field of type 'AccountRecoveryType[]'
   */
  export type ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountRecoveryType[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    url?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    slug?: StringFilter<"Company"> | string
    preferences?: JsonNullableFilter<"Company">
    active?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    facilities?: FacilityListRelationFilter
    evaluations?: EvaluationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    packages?: ShippingPackageListRelationFilter
    users?: CompanyUserListRelationFilter
    departments?: DepartmentUserListRelationFilter
    patients?: CompanyPatientListRelationFilter
    invitations?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    stripeEntities?: StripeEntityListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    slug?: SortOrder
    preferences?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilities?: FacilityOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    packages?: ShippingPackageOrderByRelationAggregateInput
    users?: CompanyUserOrderByRelationAggregateInput
    departments?: DepartmentUserOrderByRelationAggregateInput
    patients?: CompanyPatientOrderByRelationAggregateInput
    invitations?: CompanyInvitationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    stripeEntities?: StripeEntityOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    url?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    preferences?: JsonNullableFilter<"Company">
    active?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    facilities?: FacilityListRelationFilter
    evaluations?: EvaluationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    packages?: ShippingPackageListRelationFilter
    users?: CompanyUserListRelationFilter
    departments?: DepartmentUserListRelationFilter
    patients?: CompanyPatientListRelationFilter
    invitations?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    stripeEntities?: StripeEntityListRelationFilter
  }, "id" | "slug">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    slug?: SortOrder
    preferences?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    url?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    slug?: StringWithAggregatesFilter<"Company"> | string
    preferences?: JsonNullableWithAggregatesFilter<"Company">
    active?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    parentId?: StringNullableFilter<"Facility"> | string | null
    contactId?: StringNullableFilter<"Facility"> | string | null
    parent?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    children?: FacilityListRelationFilter
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patients?: FacilityPatientListRelationFilter
    evaluations?: EvaluationListRelationFilter
    shippingLabels?: ShippingLabelListRelationFilter
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    parent?: FacilityOrderByWithRelationInput
    children?: FacilityOrderByRelationAggregateInput
    contact?: ContactOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    patients?: FacilityPatientOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    shippingLabels?: ShippingLabelOrderByRelationAggregateInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    parentId?: StringNullableFilter<"Facility"> | string | null
    contactId?: StringNullableFilter<"Facility"> | string | null
    parent?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    children?: FacilityListRelationFilter
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patients?: FacilityPatientListRelationFilter
    evaluations?: EvaluationListRelationFilter
    shippingLabels?: ShippingLabelListRelationFilter
  }, "id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facility"> | string
    name?: StringWithAggregatesFilter<"Facility"> | string
    companyId?: StringWithAggregatesFilter<"Facility"> | string
    type?: EnumFacilityTypeWithAggregatesFilter<"Facility"> | $Enums.FacilityType
    active?: BoolWithAggregatesFilter<"Facility"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Facility"> | string | null
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
    primaryPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    feet?: FootListRelationFilter
    evaluations?: EvaluationListRelationFilter
    workbenches?: WorkbenchListRelationFilter
    companies?: CompanyPatientListRelationFilter
    notificationHistory?: NotificationHistoryListRelationFilter
    facilities?: FacilityPatientListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    deceasedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrderInput | SortOrder
    primaryPhysician?: PhysicianOrderByWithRelationInput
    feet?: FootOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
    companies?: CompanyPatientOrderByRelationAggregateInput
    notificationHistory?: NotificationHistoryOrderByRelationAggregateInput
    facilities?: FacilityPatientOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
    primaryPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    feet?: FootListRelationFilter
    evaluations?: EvaluationListRelationFilter
    workbenches?: WorkbenchListRelationFilter
    companies?: CompanyPatientListRelationFilter
    notificationHistory?: NotificationHistoryListRelationFilter
    facilities?: FacilityPatientListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    deceasedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    height?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    active?: BoolWithAggregatesFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
  }

  export type ClinicianWhereInput = {
    AND?: ClinicianWhereInput | ClinicianWhereInput[]
    OR?: ClinicianWhereInput[]
    NOT?: ClinicianWhereInput | ClinicianWhereInput[]
    id?: StringFilter<"Clinician"> | string
    name?: StringFilter<"Clinician"> | string
    userId?: StringNullableFilter<"Clinician"> | string | null
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    evaluations?: EvaluationListRelationFilter
  }

  export type ClinicianOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type ClinicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClinicianWhereInput | ClinicianWhereInput[]
    OR?: ClinicianWhereInput[]
    NOT?: ClinicianWhereInput | ClinicianWhereInput[]
    name?: StringFilter<"Clinician"> | string
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    evaluations?: EvaluationListRelationFilter
  }, "id" | "userId">

  export type ClinicianOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicianCountOrderByAggregateInput
    _max?: ClinicianMaxOrderByAggregateInput
    _min?: ClinicianMinOrderByAggregateInput
  }

  export type ClinicianScalarWhereWithAggregatesInput = {
    AND?: ClinicianScalarWhereWithAggregatesInput | ClinicianScalarWhereWithAggregatesInput[]
    OR?: ClinicianScalarWhereWithAggregatesInput[]
    NOT?: ClinicianScalarWhereWithAggregatesInput | ClinicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinician"> | string
    name?: StringWithAggregatesFilter<"Clinician"> | string
    userId?: StringNullableWithAggregatesFilter<"Clinician"> | string | null
    active?: BoolWithAggregatesFilter<"Clinician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinician"> | Date | string
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    stripeInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    stripeCheckoutInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deviceType?: XOR<DeviceTypeNullableRelationFilter, DeviceTypeWhereInput> | null
    visitType?: XOR<VisitTypeNullableRelationFilter, VisitTypeWhereInput> | null
    referringPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    diagnosis?: XOR<DiagnosisNullableRelationFilter, DiagnosisWhereInput> | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    stripeInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    stripeCheckoutInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    clinicians?: ClinicianListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrderInput | SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrderInput | SortOrder
    devicePosition?: SortOrderInput | SortOrder
    appointmentAt?: SortOrderInput | SortOrder
    appointmentStatus?: SortOrderInput | SortOrder
    referringPhysicianId?: SortOrderInput | SortOrder
    diagnosisId?: SortOrderInput | SortOrder
    diagnosisedAt?: SortOrderInput | SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitedAt?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    prescribedAt?: SortOrderInput | SortOrder
    prescribedActive?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    stripeCheckoutInvoiceId?: SortOrderInput | SortOrder
    primaryInsurance?: SortOrderInput | SortOrder
    secondaryInsurance?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    deviceType?: DeviceTypeOrderByWithRelationInput
    visitType?: VisitTypeOrderByWithRelationInput
    referringPhysician?: PhysicianOrderByWithRelationInput
    diagnosis?: DiagnosisOrderByWithRelationInput
    facility?: FacilityOrderByWithRelationInput
    stripeInvoice?: StripeInvoiceOrderByWithRelationInput
    stripeCheckoutInvoice?: StripeInvoiceOrderByWithRelationInput
    clinicians?: ClinicianOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_companyId?: EvaluationIdCompanyIdCompoundUniqueInput
    externalId_companyId?: EvaluationExternalIdCompanyIdCompoundUniqueInput
    poNumber_companyId?: EvaluationPoNumberCompanyIdCompoundUniqueInput
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    stripeInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    stripeCheckoutInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deviceType?: XOR<DeviceTypeNullableRelationFilter, DeviceTypeWhereInput> | null
    visitType?: XOR<VisitTypeNullableRelationFilter, VisitTypeWhereInput> | null
    referringPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    diagnosis?: XOR<DiagnosisNullableRelationFilter, DiagnosisWhereInput> | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    stripeInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    stripeCheckoutInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    clinicians?: ClinicianListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }, "id" | "id_companyId" | "externalId_companyId" | "poNumber_companyId">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrderInput | SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrderInput | SortOrder
    devicePosition?: SortOrderInput | SortOrder
    appointmentAt?: SortOrderInput | SortOrder
    appointmentStatus?: SortOrderInput | SortOrder
    referringPhysicianId?: SortOrderInput | SortOrder
    diagnosisId?: SortOrderInput | SortOrder
    diagnosisedAt?: SortOrderInput | SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitedAt?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    prescribedAt?: SortOrderInput | SortOrder
    prescribedActive?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    stripeCheckoutInvoiceId?: SortOrderInput | SortOrder
    primaryInsurance?: SortOrderInput | SortOrder
    secondaryInsurance?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evaluation"> | string
    externalId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    poNumber?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    type?: EnumCareTypeWithAggregatesFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringWithAggregatesFilter<"Evaluation"> | string
    companyId?: StringWithAggregatesFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    isDiabetic?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    isVeteran?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableWithAggregatesFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableWithAggregatesFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    location?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    stripeCheckoutInvoiceId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    primaryInsurance?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
  }

  export type FootWhereInput = {
    AND?: FootWhereInput | FootWhereInput[]
    OR?: FootWhereInput[]
    NOT?: FootWhereInput | FootWhereInput[]
    id?: StringFilter<"Foot"> | string
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthNullableFilter<"Foot"> | $Enums.ShoeWidth | null
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    assets?: AssetListRelationFilter
  }

  export type FootOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrderInput | SortOrder
    shoeWidth?: SortOrderInput | SortOrder
    shoeGender?: SortOrderInput | SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrderInput | SortOrder
    shoeModel?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    workbench?: WorkbenchOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type FootWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FootWhereInput | FootWhereInput[]
    OR?: FootWhereInput[]
    NOT?: FootWhereInput | FootWhereInput[]
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthNullableFilter<"Foot"> | $Enums.ShoeWidth | null
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    assets?: AssetListRelationFilter
  }, "id">

  export type FootOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrderInput | SortOrder
    shoeWidth?: SortOrderInput | SortOrder
    shoeGender?: SortOrderInput | SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrderInput | SortOrder
    shoeModel?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FootCountOrderByAggregateInput
    _avg?: FootAvgOrderByAggregateInput
    _max?: FootMaxOrderByAggregateInput
    _min?: FootMinOrderByAggregateInput
    _sum?: FootSumOrderByAggregateInput
  }

  export type FootScalarWhereWithAggregatesInput = {
    AND?: FootScalarWhereWithAggregatesInput | FootScalarWhereWithAggregatesInput[]
    OR?: FootScalarWhereWithAggregatesInput[]
    NOT?: FootScalarWhereWithAggregatesInput | FootScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Foot"> | string
    patientId?: StringWithAggregatesFilter<"Foot"> | string
    workbenchId?: StringWithAggregatesFilter<"Foot"> | string
    side?: EnumSideWithAggregatesFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableWithAggregatesFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthNullableWithAggregatesFilter<"Foot"> | $Enums.ShoeWidth | null
    shoeGender?: EnumGenderNullableWithAggregatesFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemWithAggregatesFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableWithAggregatesFilter<"Foot"> | string | null
    shoeModel?: StringNullableWithAggregatesFilter<"Foot"> | string | null
    questionnaire?: JsonNullableWithAggregatesFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableWithAggregatesFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolWithAggregatesFilter<"Foot"> | boolean
    active?: BoolWithAggregatesFilter<"Foot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Foot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Foot"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    foot?: XOR<FootRelationFilter, FootWhereInput>
    workbenches?: WorkbenchListRelationFilter
    augments?: AssetAugmentListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foot?: FootOrderByWithRelationInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
    augments?: AssetAugmentOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    foot?: XOR<FootRelationFilter, FootWhereInput>
    workbenches?: WorkbenchListRelationFilter
    augments?: AssetAugmentListRelationFilter
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    footId?: StringWithAggregatesFilter<"Asset"> | string
    type?: EnumProductTypeWithAggregatesFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Asset">
    status?: EnumAssetStatusWithAggregatesFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Asset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type AssetAugmentWhereInput = {
    AND?: AssetAugmentWhereInput | AssetAugmentWhereInput[]
    OR?: AssetAugmentWhereInput[]
    NOT?: AssetAugmentWhereInput | AssetAugmentWhereInput[]
    id?: StringFilter<"AssetAugment"> | string
    assetId?: StringFilter<"AssetAugment"> | string
    type?: EnumAssetAugmentTypeFilter<"AssetAugment"> | $Enums.AssetAugmentType
    data?: JsonNullableFilter<"AssetAugment">
    createdAt?: DateTimeFilter<"AssetAugment"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugment"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    media?: AssetAugmentMediaListRelationFilter
  }

  export type AssetAugmentOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    asset?: AssetOrderByWithRelationInput
    media?: AssetAugmentMediaOrderByRelationAggregateInput
  }

  export type AssetAugmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetAugmentWhereInput | AssetAugmentWhereInput[]
    OR?: AssetAugmentWhereInput[]
    NOT?: AssetAugmentWhereInput | AssetAugmentWhereInput[]
    assetId?: StringFilter<"AssetAugment"> | string
    type?: EnumAssetAugmentTypeFilter<"AssetAugment"> | $Enums.AssetAugmentType
    data?: JsonNullableFilter<"AssetAugment">
    createdAt?: DateTimeFilter<"AssetAugment"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugment"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    media?: AssetAugmentMediaListRelationFilter
  }, "id">

  export type AssetAugmentOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetAugmentCountOrderByAggregateInput
    _max?: AssetAugmentMaxOrderByAggregateInput
    _min?: AssetAugmentMinOrderByAggregateInput
  }

  export type AssetAugmentScalarWhereWithAggregatesInput = {
    AND?: AssetAugmentScalarWhereWithAggregatesInput | AssetAugmentScalarWhereWithAggregatesInput[]
    OR?: AssetAugmentScalarWhereWithAggregatesInput[]
    NOT?: AssetAugmentScalarWhereWithAggregatesInput | AssetAugmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetAugment"> | string
    assetId?: StringWithAggregatesFilter<"AssetAugment"> | string
    type?: EnumAssetAugmentTypeWithAggregatesFilter<"AssetAugment"> | $Enums.AssetAugmentType
    data?: JsonNullableWithAggregatesFilter<"AssetAugment">
    createdAt?: DateTimeWithAggregatesFilter<"AssetAugment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssetAugment"> | Date | string
  }

  export type AssetAugmentMediaWhereInput = {
    AND?: AssetAugmentMediaWhereInput | AssetAugmentMediaWhereInput[]
    OR?: AssetAugmentMediaWhereInput[]
    NOT?: AssetAugmentMediaWhereInput | AssetAugmentMediaWhereInput[]
    id?: StringFilter<"AssetAugmentMedia"> | string
    augmentId?: StringFilter<"AssetAugmentMedia"> | string
    data?: JsonNullableFilter<"AssetAugmentMedia">
    originalData?: JsonNullableFilter<"AssetAugmentMedia">
    region?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    bucket?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    key?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    active?: BoolFilter<"AssetAugmentMedia"> | boolean
    inactiveReason?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssetAugmentMedia"> | Date | string | null
    createdAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
    augment?: XOR<AssetAugmentRelationFilter, AssetAugmentWhereInput>
  }

  export type AssetAugmentMediaOrderByWithRelationInput = {
    id?: SortOrder
    augmentId?: SortOrder
    data?: SortOrderInput | SortOrder
    originalData?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    active?: SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    augment?: AssetAugmentOrderByWithRelationInput
  }

  export type AssetAugmentMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetAugmentMediaWhereInput | AssetAugmentMediaWhereInput[]
    OR?: AssetAugmentMediaWhereInput[]
    NOT?: AssetAugmentMediaWhereInput | AssetAugmentMediaWhereInput[]
    augmentId?: StringFilter<"AssetAugmentMedia"> | string
    data?: JsonNullableFilter<"AssetAugmentMedia">
    originalData?: JsonNullableFilter<"AssetAugmentMedia">
    region?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    bucket?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    key?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    active?: BoolFilter<"AssetAugmentMedia"> | boolean
    inactiveReason?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssetAugmentMedia"> | Date | string | null
    createdAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
    augment?: XOR<AssetAugmentRelationFilter, AssetAugmentWhereInput>
  }, "id">

  export type AssetAugmentMediaOrderByWithAggregationInput = {
    id?: SortOrder
    augmentId?: SortOrder
    data?: SortOrderInput | SortOrder
    originalData?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    active?: SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetAugmentMediaCountOrderByAggregateInput
    _max?: AssetAugmentMediaMaxOrderByAggregateInput
    _min?: AssetAugmentMediaMinOrderByAggregateInput
  }

  export type AssetAugmentMediaScalarWhereWithAggregatesInput = {
    AND?: AssetAugmentMediaScalarWhereWithAggregatesInput | AssetAugmentMediaScalarWhereWithAggregatesInput[]
    OR?: AssetAugmentMediaScalarWhereWithAggregatesInput[]
    NOT?: AssetAugmentMediaScalarWhereWithAggregatesInput | AssetAugmentMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetAugmentMedia"> | string
    augmentId?: StringWithAggregatesFilter<"AssetAugmentMedia"> | string
    data?: JsonNullableWithAggregatesFilter<"AssetAugmentMedia">
    originalData?: JsonNullableWithAggregatesFilter<"AssetAugmentMedia">
    region?: StringNullableWithAggregatesFilter<"AssetAugmentMedia"> | string | null
    bucket?: StringNullableWithAggregatesFilter<"AssetAugmentMedia"> | string | null
    key?: StringNullableWithAggregatesFilter<"AssetAugmentMedia"> | string | null
    active?: BoolWithAggregatesFilter<"AssetAugmentMedia"> | boolean
    inactiveReason?: StringNullableWithAggregatesFilter<"AssetAugmentMedia"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"AssetAugmentMedia"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssetAugmentMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssetAugmentMedia"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    buildingBlocks?: ProductListRelationFilter
    usedByProducts?: ProductListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingBlocks?: ProductOrderByRelationAggregateInput
    usedByProducts?: ProductOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    buildingBlocks?: ProductListRelationFilter
    usedByProducts?: ProductListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type WorkbenchWhereInput = {
    AND?: WorkbenchWhereInput | WorkbenchWhereInput[]
    OR?: WorkbenchWhereInput[]
    NOT?: WorkbenchWhereInput | WorkbenchWhereInput[]
    id?: StringFilter<"Workbench"> | string
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
    assets?: AssetListRelationFilter
    orders?: OrderListRelationFilter
    feet?: FootListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    notes?: WorkbenchNotesListRelationFilter
  }

  export type WorkbenchOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    evaluation?: EvaluationOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    feet?: FootOrderByRelationAggregateInput
    formSubmissions?: FormSubmissionOrderByRelationAggregateInput
    notes?: WorkbenchNotesOrderByRelationAggregateInput
  }

  export type WorkbenchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkbenchWhereInput | WorkbenchWhereInput[]
    OR?: WorkbenchWhereInput[]
    NOT?: WorkbenchWhereInput | WorkbenchWhereInput[]
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
    assets?: AssetListRelationFilter
    orders?: OrderListRelationFilter
    feet?: FootListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    notes?: WorkbenchNotesListRelationFilter
  }, "id">

  export type WorkbenchOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkbenchCountOrderByAggregateInput
    _max?: WorkbenchMaxOrderByAggregateInput
    _min?: WorkbenchMinOrderByAggregateInput
  }

  export type WorkbenchScalarWhereWithAggregatesInput = {
    AND?: WorkbenchScalarWhereWithAggregatesInput | WorkbenchScalarWhereWithAggregatesInput[]
    OR?: WorkbenchScalarWhereWithAggregatesInput[]
    NOT?: WorkbenchScalarWhereWithAggregatesInput | WorkbenchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workbench"> | string
    patientId?: StringWithAggregatesFilter<"Workbench"> | string
    productId?: StringWithAggregatesFilter<"Workbench"> | string
    evaluationId?: StringWithAggregatesFilter<"Workbench"> | string
    customization?: JsonNullableWithAggregatesFilter<"Workbench">
    webhookUrl?: StringNullableWithAggregatesFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableWithAggregatesFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusWithAggregatesFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workbench"> | Date | string
  }

  export type WorkbenchNotesWhereInput = {
    AND?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    OR?: WorkbenchNotesWhereInput[]
    NOT?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    id?: StringFilter<"WorkbenchNotes"> | string
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type WorkbenchNotesOrderByWithRelationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    blocks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workbench?: WorkbenchOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type WorkbenchNotesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    OR?: WorkbenchNotesWhereInput[]
    NOT?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type WorkbenchNotesOrderByWithAggregationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    blocks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkbenchNotesCountOrderByAggregateInput
    _max?: WorkbenchNotesMaxOrderByAggregateInput
    _min?: WorkbenchNotesMinOrderByAggregateInput
  }

  export type WorkbenchNotesScalarWhereWithAggregatesInput = {
    AND?: WorkbenchNotesScalarWhereWithAggregatesInput | WorkbenchNotesScalarWhereWithAggregatesInput[]
    OR?: WorkbenchNotesScalarWhereWithAggregatesInput[]
    NOT?: WorkbenchNotesScalarWhereWithAggregatesInput | WorkbenchNotesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkbenchNotes"> | string
    workbenchId?: StringWithAggregatesFilter<"WorkbenchNotes"> | string
    title?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableWithAggregatesFilter<"WorkbenchNotes">
    createdAt?: DateTimeWithAggregatesFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WorkbenchNotes"> | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    shippingLabelId?: StringNullableFilter<"Order"> | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    shippingLabel?: XOR<ShippingLabelNullableRelationFilter, ShippingLabelWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    committedDeliveryAt?: SortOrderInput | SortOrder
    parcelId?: SortOrderInput | SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    shippingLabelId?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workbench?: WorkbenchOrderByWithRelationInput
    shippingLabel?: ShippingLabelOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    shippingLabelId?: StringNullableFilter<"Order"> | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    shippingLabel?: XOR<ShippingLabelNullableRelationFilter, ShippingLabelWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    committedDeliveryAt?: SortOrderInput | SortOrder
    parcelId?: SortOrderInput | SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    shippingLabelId?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    workbenchId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    parcelId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    active?: BoolWithAggregatesFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusWithAggregatesFilter<"Order"> | $Enums.OrderAuthorizationStatus
    shippingLabelId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    authorizationUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    addressLine1?: StringFilter<"Contact"> | string
    addressLine2?: StringNullableFilter<"Contact"> | string | null
    city?: StringFilter<"Contact"> | string
    stateOrProvince?: StringFilter<"Contact"> | string
    postalCode?: StringFilter<"Contact"> | string
    countryCode?: StringFilter<"Contact"> | string
    shippingAccountId?: StringNullableFilter<"Contact"> | string | null
    phoneNumber?: StringNullableFilter<"Contact"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableFilter<"Contact"> | $Enums.Carrier | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    facilities?: FacilityListRelationFilter
    patients?: CompanyPatientListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    shippingAccountCarrier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilities?: FacilityOrderByRelationAggregateInput
    patients?: CompanyPatientOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringNullableFilter<"Contact"> | string | null
    addressLine1?: StringFilter<"Contact"> | string
    addressLine2?: StringNullableFilter<"Contact"> | string | null
    city?: StringFilter<"Contact"> | string
    stateOrProvince?: StringFilter<"Contact"> | string
    postalCode?: StringFilter<"Contact"> | string
    countryCode?: StringFilter<"Contact"> | string
    shippingAccountId?: StringNullableFilter<"Contact"> | string | null
    phoneNumber?: StringNullableFilter<"Contact"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableFilter<"Contact"> | $Enums.Carrier | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    facilities?: FacilityListRelationFilter
    patients?: CompanyPatientListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    shippingAccountCarrier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    addressLine1?: StringWithAggregatesFilter<"Contact"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    city?: StringWithAggregatesFilter<"Contact"> | string
    stateOrProvince?: StringWithAggregatesFilter<"Contact"> | string
    postalCode?: StringWithAggregatesFilter<"Contact"> | string
    countryCode?: StringWithAggregatesFilter<"Contact"> | string
    shippingAccountId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableWithAggregatesFilter<"Contact"> | $Enums.Carrier | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ShippingPackageWhereInput = {
    AND?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    OR?: ShippingPackageWhereInput[]
    NOT?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    id?: StringFilter<"ShippingPackage"> | string
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ShippingPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ShippingPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    OR?: ShippingPackageWhereInput[]
    NOT?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type ShippingPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingPackageCountOrderByAggregateInput
    _avg?: ShippingPackageAvgOrderByAggregateInput
    _max?: ShippingPackageMaxOrderByAggregateInput
    _min?: ShippingPackageMinOrderByAggregateInput
    _sum?: ShippingPackageSumOrderByAggregateInput
  }

  export type ShippingPackageScalarWhereWithAggregatesInput = {
    AND?: ShippingPackageScalarWhereWithAggregatesInput | ShippingPackageScalarWhereWithAggregatesInput[]
    OR?: ShippingPackageScalarWhereWithAggregatesInput[]
    NOT?: ShippingPackageScalarWhereWithAggregatesInput | ShippingPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingPackage"> | string
    name?: StringWithAggregatesFilter<"ShippingPackage"> | string
    weight?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitWithAggregatesFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    width?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    height?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitWithAggregatesFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntWithAggregatesFilter<"ShippingPackage"> | number
    companyId?: StringWithAggregatesFilter<"ShippingPackage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingPackage"> | Date | string
  }

  export type ShippingLabelWhereInput = {
    AND?: ShippingLabelWhereInput | ShippingLabelWhereInput[]
    OR?: ShippingLabelWhereInput[]
    NOT?: ShippingLabelWhereInput | ShippingLabelWhereInput[]
    id?: StringFilter<"ShippingLabel"> | string
    addressName?: StringFilter<"ShippingLabel"> | string
    facilityId?: StringNullableFilter<"ShippingLabel"> | string | null
    labelId?: StringFilter<"ShippingLabel"> | string
    trackingNumber?: StringFilter<"ShippingLabel"> | string
    trackingStatus?: EnumShippingTrackingStatusFilter<"ShippingLabel"> | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFilter<"ShippingLabel"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingLabel"> | Date | string
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    orders?: OrderListRelationFilter
  }

  export type ShippingLabelOrderByWithRelationInput = {
    id?: SortOrder
    addressName?: SortOrder
    facilityId?: SortOrderInput | SortOrder
    labelId?: SortOrder
    trackingNumber?: SortOrder
    trackingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ShippingLabelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingNumber?: string
    AND?: ShippingLabelWhereInput | ShippingLabelWhereInput[]
    OR?: ShippingLabelWhereInput[]
    NOT?: ShippingLabelWhereInput | ShippingLabelWhereInput[]
    addressName?: StringFilter<"ShippingLabel"> | string
    facilityId?: StringNullableFilter<"ShippingLabel"> | string | null
    labelId?: StringFilter<"ShippingLabel"> | string
    trackingStatus?: EnumShippingTrackingStatusFilter<"ShippingLabel"> | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFilter<"ShippingLabel"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingLabel"> | Date | string
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    orders?: OrderListRelationFilter
  }, "id" | "trackingNumber">

  export type ShippingLabelOrderByWithAggregationInput = {
    id?: SortOrder
    addressName?: SortOrder
    facilityId?: SortOrderInput | SortOrder
    labelId?: SortOrder
    trackingNumber?: SortOrder
    trackingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingLabelCountOrderByAggregateInput
    _max?: ShippingLabelMaxOrderByAggregateInput
    _min?: ShippingLabelMinOrderByAggregateInput
  }

  export type ShippingLabelScalarWhereWithAggregatesInput = {
    AND?: ShippingLabelScalarWhereWithAggregatesInput | ShippingLabelScalarWhereWithAggregatesInput[]
    OR?: ShippingLabelScalarWhereWithAggregatesInput[]
    NOT?: ShippingLabelScalarWhereWithAggregatesInput | ShippingLabelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingLabel"> | string
    addressName?: StringWithAggregatesFilter<"ShippingLabel"> | string
    facilityId?: StringNullableWithAggregatesFilter<"ShippingLabel"> | string | null
    labelId?: StringWithAggregatesFilter<"ShippingLabel"> | string
    trackingNumber?: StringWithAggregatesFilter<"ShippingLabel"> | string
    trackingStatus?: EnumShippingTrackingStatusWithAggregatesFilter<"ShippingLabel"> | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeWithAggregatesFilter<"ShippingLabel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingLabel"> | Date | string
  }

  export type PhysicianWhereInput = {
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    id?: StringFilter<"Physician"> | string
    name?: StringFilter<"Physician"> | string
    npi?: StringNullableFilter<"Physician"> | string | null
    active?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    evaluations?: EvaluationListRelationFilter
    patient?: PatientListRelationFilter
  }

  export type PhysicianOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
    patient?: PatientOrderByRelationAggregateInput
  }

  export type PhysicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    npi?: string
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    name?: StringFilter<"Physician"> | string
    active?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    evaluations?: EvaluationListRelationFilter
    patient?: PatientListRelationFilter
  }, "id" | "npi">

  export type PhysicianOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhysicianCountOrderByAggregateInput
    _max?: PhysicianMaxOrderByAggregateInput
    _min?: PhysicianMinOrderByAggregateInput
  }

  export type PhysicianScalarWhereWithAggregatesInput = {
    AND?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    OR?: PhysicianScalarWhereWithAggregatesInput[]
    NOT?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Physician"> | string
    name?: StringWithAggregatesFilter<"Physician"> | string
    npi?: StringNullableWithAggregatesFilter<"Physician"> | string | null
    active?: BoolWithAggregatesFilter<"Physician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: StringFilter<"Diagnosis"> | string
    code?: StringFilter<"Diagnosis"> | string
    description?: StringFilter<"Diagnosis"> | string
    diabetic?: BoolFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    evaluations?: EvaluationListRelationFilter
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    description?: StringFilter<"Diagnosis"> | string
    diabetic?: BoolFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    evaluations?: EvaluationListRelationFilter
  }, "id" | "code">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Diagnosis"> | string
    code?: StringWithAggregatesFilter<"Diagnosis"> | string
    description?: StringWithAggregatesFilter<"Diagnosis"> | string
    diabetic?: BoolWithAggregatesFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardWithAggregatesFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type BillingCodeWhereInput = {
    AND?: BillingCodeWhereInput | BillingCodeWhereInput[]
    OR?: BillingCodeWhereInput[]
    NOT?: BillingCodeWhereInput | BillingCodeWhereInput[]
    id?: StringFilter<"BillingCode"> | string
    summary?: StringNullableFilter<"BillingCode"> | string | null
    description?: StringFilter<"BillingCode"> | string
    justifications?: JsonNullableFilter<"BillingCode">
    createdAt?: DateTimeFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeFilter<"BillingCode"> | Date | string
  }

  export type BillingCodeOrderByWithRelationInput = {
    id?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrder
    justifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingCodeWhereInput | BillingCodeWhereInput[]
    OR?: BillingCodeWhereInput[]
    NOT?: BillingCodeWhereInput | BillingCodeWhereInput[]
    summary?: StringNullableFilter<"BillingCode"> | string | null
    description?: StringFilter<"BillingCode"> | string
    justifications?: JsonNullableFilter<"BillingCode">
    createdAt?: DateTimeFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeFilter<"BillingCode"> | Date | string
  }, "id">

  export type BillingCodeOrderByWithAggregationInput = {
    id?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrder
    justifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingCodeCountOrderByAggregateInput
    _max?: BillingCodeMaxOrderByAggregateInput
    _min?: BillingCodeMinOrderByAggregateInput
  }

  export type BillingCodeScalarWhereWithAggregatesInput = {
    AND?: BillingCodeScalarWhereWithAggregatesInput | BillingCodeScalarWhereWithAggregatesInput[]
    OR?: BillingCodeScalarWhereWithAggregatesInput[]
    NOT?: BillingCodeScalarWhereWithAggregatesInput | BillingCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingCode"> | string
    summary?: StringNullableWithAggregatesFilter<"BillingCode"> | string | null
    description?: StringWithAggregatesFilter<"BillingCode"> | string
    justifications?: JsonNullableWithAggregatesFilter<"BillingCode">
    createdAt?: DateTimeWithAggregatesFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingCode"> | Date | string
  }

  export type DeviceTypeWhereInput = {
    AND?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    OR?: DeviceTypeWhereInput[]
    NOT?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    id?: StringFilter<"DeviceType"> | string
    name?: StringFilter<"DeviceType"> | string
    diabetic?: BoolFilter<"DeviceType"> | boolean
    custom?: BoolNullableFilter<"DeviceType"> | boolean | null
    evaluations?: EvaluationListRelationFilter
  }

  export type DeviceTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrderInput | SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type DeviceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    OR?: DeviceTypeWhereInput[]
    NOT?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    diabetic?: BoolFilter<"DeviceType"> | boolean
    custom?: BoolNullableFilter<"DeviceType"> | boolean | null
    evaluations?: EvaluationListRelationFilter
  }, "id" | "name">

  export type DeviceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrderInput | SortOrder
    _count?: DeviceTypeCountOrderByAggregateInput
    _max?: DeviceTypeMaxOrderByAggregateInput
    _min?: DeviceTypeMinOrderByAggregateInput
  }

  export type DeviceTypeScalarWhereWithAggregatesInput = {
    AND?: DeviceTypeScalarWhereWithAggregatesInput | DeviceTypeScalarWhereWithAggregatesInput[]
    OR?: DeviceTypeScalarWhereWithAggregatesInput[]
    NOT?: DeviceTypeScalarWhereWithAggregatesInput | DeviceTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceType"> | string
    name?: StringWithAggregatesFilter<"DeviceType"> | string
    diabetic?: BoolWithAggregatesFilter<"DeviceType"> | boolean
    custom?: BoolNullableWithAggregatesFilter<"DeviceType"> | boolean | null
  }

  export type VisitTypeWhereInput = {
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    id?: StringFilter<"VisitType"> | string
    name?: StringFilter<"VisitType"> | string
    evaluations?: EvaluationListRelationFilter
  }

  export type VisitTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type VisitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    evaluations?: EvaluationListRelationFilter
  }, "id" | "name">

  export type VisitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: VisitTypeCountOrderByAggregateInput
    _max?: VisitTypeMaxOrderByAggregateInput
    _min?: VisitTypeMinOrderByAggregateInput
  }

  export type VisitTypeScalarWhereWithAggregatesInput = {
    AND?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    OR?: VisitTypeScalarWhereWithAggregatesInput[]
    NOT?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitType"> | string
    name?: StringWithAggregatesFilter<"VisitType"> | string
  }

  export type FormSchemaWhereInput = {
    AND?: FormSchemaWhereInput | FormSchemaWhereInput[]
    OR?: FormSchemaWhereInput[]
    NOT?: FormSchemaWhereInput | FormSchemaWhereInput[]
    id?: StringFilter<"FormSchema"> | string
    title?: StringFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonFilter<"FormSchema">
    createdAt?: DateTimeFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeFilter<"FormSchema"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormSchemaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormSchemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormSchemaWhereInput | FormSchemaWhereInput[]
    OR?: FormSchemaWhereInput[]
    NOT?: FormSchemaWhereInput | FormSchemaWhereInput[]
    title?: StringFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonFilter<"FormSchema">
    createdAt?: DateTimeFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeFilter<"FormSchema"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }, "id">

  export type FormSchemaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormSchemaCountOrderByAggregateInput
    _max?: FormSchemaMaxOrderByAggregateInput
    _min?: FormSchemaMinOrderByAggregateInput
  }

  export type FormSchemaScalarWhereWithAggregatesInput = {
    AND?: FormSchemaScalarWhereWithAggregatesInput | FormSchemaScalarWhereWithAggregatesInput[]
    OR?: FormSchemaScalarWhereWithAggregatesInput[]
    NOT?: FormSchemaScalarWhereWithAggregatesInput | FormSchemaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSchema"> | string
    title?: StringWithAggregatesFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableWithAggregatesFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonWithAggregatesFilter<"FormSchema">
    createdAt?: DateTimeWithAggregatesFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSchema"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    schema?: XOR<FormSchemaRelationFilter, FormSchemaWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schema?: FormSchemaOrderByWithRelationInput
    workbench?: WorkbenchOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workbenchId_schemaId?: FormSubmissionWorkbenchIdSchemaIdCompoundUniqueInput
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    schema?: XOR<FormSchemaRelationFilter, FormSchemaWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }, "id" | "workbenchId_schemaId">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    schemaId?: StringWithAggregatesFilter<"FormSubmission"> | string
    workbenchId?: StringWithAggregatesFilter<"FormSubmission"> | string
    data?: JsonWithAggregatesFilter<"FormSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type FormTemplateWhereInput = {
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    id?: StringFilter<"FormTemplate"> | string
    userId?: StringFilter<"FormTemplate"> | string
    title?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    data?: JsonFilter<"FormTemplate">
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
  }

  export type FormTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    userId?: StringFilter<"FormTemplate"> | string
    title?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    data?: JsonFilter<"FormTemplate">
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
  }, "id">

  export type FormTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormTemplateCountOrderByAggregateInput
    _max?: FormTemplateMaxOrderByAggregateInput
    _min?: FormTemplateMinOrderByAggregateInput
  }

  export type FormTemplateScalarWhereWithAggregatesInput = {
    AND?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    OR?: FormTemplateScalarWhereWithAggregatesInput[]
    NOT?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormTemplate"> | string
    userId?: StringWithAggregatesFilter<"FormTemplate"> | string
    title?: StringWithAggregatesFilter<"FormTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"FormTemplate"> | string | null
    data?: JsonWithAggregatesFilter<"FormTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
  }

  export type CatalogProductWhereInput = {
    AND?: CatalogProductWhereInput | CatalogProductWhereInput[]
    OR?: CatalogProductWhereInput[]
    NOT?: CatalogProductWhereInput | CatalogProductWhereInput[]
    id?: StringFilter<"CatalogProduct"> | string
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    favorite?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    attributes?: CatalogProductAttributeListRelationFilter
    variants?: CatalogProductVariantListRelationFilter
    categories?: CatalogCategoryListRelationFilter
    vendors?: CatalogVendorListRelationFilter
  }

  export type CatalogProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    favorite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attributes?: CatalogProductAttributeOrderByRelationAggregateInput
    variants?: CatalogProductVariantOrderByRelationAggregateInput
    categories?: CatalogCategoryOrderByRelationAggregateInput
    vendors?: CatalogVendorOrderByRelationAggregateInput
  }

  export type CatalogProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogProductWhereInput | CatalogProductWhereInput[]
    OR?: CatalogProductWhereInput[]
    NOT?: CatalogProductWhereInput | CatalogProductWhereInput[]
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    favorite?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    attributes?: CatalogProductAttributeListRelationFilter
    variants?: CatalogProductVariantListRelationFilter
    categories?: CatalogCategoryListRelationFilter
    vendors?: CatalogVendorListRelationFilter
  }, "id">

  export type CatalogProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    favorite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductCountOrderByAggregateInput
    _avg?: CatalogProductAvgOrderByAggregateInput
    _max?: CatalogProductMaxOrderByAggregateInput
    _min?: CatalogProductMinOrderByAggregateInput
    _sum?: CatalogProductSumOrderByAggregateInput
  }

  export type CatalogProductScalarWhereWithAggregatesInput = {
    AND?: CatalogProductScalarWhereWithAggregatesInput | CatalogProductScalarWhereWithAggregatesInput[]
    OR?: CatalogProductScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductScalarWhereWithAggregatesInput | CatalogProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProduct"> | string
    name?: StringWithAggregatesFilter<"CatalogProduct"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProduct"> | string | null
    image?: StringNullableWithAggregatesFilter<"CatalogProduct"> | string | null
    price?: FloatNullableWithAggregatesFilter<"CatalogProduct"> | number | null
    active?: BoolWithAggregatesFilter<"CatalogProduct"> | boolean
    favorite?: BoolWithAggregatesFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProduct"> | Date | string
  }

  export type CatalogProductAttributeWhereInput = {
    AND?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    OR?: CatalogProductAttributeWhereInput[]
    NOT?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    id?: StringFilter<"CatalogProductAttribute"> | string
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }

  export type CatalogProductAttributeOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: CatalogProductOrderByWithRelationInput
  }

  export type CatalogProductAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    OR?: CatalogProductAttributeWhereInput[]
    NOT?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }, "id">

  export type CatalogProductAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductAttributeCountOrderByAggregateInput
    _max?: CatalogProductAttributeMaxOrderByAggregateInput
    _min?: CatalogProductAttributeMinOrderByAggregateInput
  }

  export type CatalogProductAttributeScalarWhereWithAggregatesInput = {
    AND?: CatalogProductAttributeScalarWhereWithAggregatesInput | CatalogProductAttributeScalarWhereWithAggregatesInput[]
    OR?: CatalogProductAttributeScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductAttributeScalarWhereWithAggregatesInput | CatalogProductAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    productId?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeWithAggregatesFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProductAttribute"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProductAttribute"> | Date | string
  }

  export type CatalogProductVariantWhereInput = {
    AND?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    OR?: CatalogProductVariantWhereInput[]
    NOT?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    id?: StringFilter<"CatalogProductVariant"> | string
    productId?: StringFilter<"CatalogProductVariant"> | string
    sku?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }

  export type CatalogProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: CatalogProductOrderByWithRelationInput
  }

  export type CatalogProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    OR?: CatalogProductVariantWhereInput[]
    NOT?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    productId?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }, "id" | "sku">

  export type CatalogProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductVariantCountOrderByAggregateInput
    _avg?: CatalogProductVariantAvgOrderByAggregateInput
    _max?: CatalogProductVariantMaxOrderByAggregateInput
    _min?: CatalogProductVariantMinOrderByAggregateInput
    _sum?: CatalogProductVariantSumOrderByAggregateInput
  }

  export type CatalogProductVariantScalarWhereWithAggregatesInput = {
    AND?: CatalogProductVariantScalarWhereWithAggregatesInput | CatalogProductVariantScalarWhereWithAggregatesInput[]
    OR?: CatalogProductVariantScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductVariantScalarWhereWithAggregatesInput | CatalogProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    productId?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    sku?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    name?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableWithAggregatesFilter<"CatalogProductVariant"> | number | null
    active?: BoolWithAggregatesFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProductVariant"> | Date | string
  }

  export type CatalogCategoryWhereInput = {
    AND?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    OR?: CatalogCategoryWhereInput[]
    NOT?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    id?: StringFilter<"CatalogCategory"> | string
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    products?: CatalogProductListRelationFilter
  }

  export type CatalogCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: CatalogProductOrderByRelationAggregateInput
  }

  export type CatalogCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    OR?: CatalogCategoryWhereInput[]
    NOT?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    products?: CatalogProductListRelationFilter
  }, "id">

  export type CatalogCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogCategoryCountOrderByAggregateInput
    _max?: CatalogCategoryMaxOrderByAggregateInput
    _min?: CatalogCategoryMinOrderByAggregateInput
  }

  export type CatalogCategoryScalarWhereWithAggregatesInput = {
    AND?: CatalogCategoryScalarWhereWithAggregatesInput | CatalogCategoryScalarWhereWithAggregatesInput[]
    OR?: CatalogCategoryScalarWhereWithAggregatesInput[]
    NOT?: CatalogCategoryScalarWhereWithAggregatesInput | CatalogCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogCategory"> | string
    name?: StringWithAggregatesFilter<"CatalogCategory"> | string
    parentId?: StringNullableWithAggregatesFilter<"CatalogCategory"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogCategory"> | Date | string
  }

  export type CatalogVendorWhereInput = {
    AND?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    OR?: CatalogVendorWhereInput[]
    NOT?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    id?: StringFilter<"CatalogVendor"> | string
    name?: StringFilter<"CatalogVendor"> | string
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    products?: CatalogProductListRelationFilter
  }

  export type CatalogVendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: CatalogProductOrderByRelationAggregateInput
  }

  export type CatalogVendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    OR?: CatalogVendorWhereInput[]
    NOT?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    products?: CatalogProductListRelationFilter
  }, "id" | "name">

  export type CatalogVendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogVendorCountOrderByAggregateInput
    _max?: CatalogVendorMaxOrderByAggregateInput
    _min?: CatalogVendorMinOrderByAggregateInput
  }

  export type CatalogVendorScalarWhereWithAggregatesInput = {
    AND?: CatalogVendorScalarWhereWithAggregatesInput | CatalogVendorScalarWhereWithAggregatesInput[]
    OR?: CatalogVendorScalarWhereWithAggregatesInput[]
    NOT?: CatalogVendorScalarWhereWithAggregatesInput | CatalogVendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogVendor"> | string
    name?: StringWithAggregatesFilter<"CatalogVendor"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogVendor"> | string | null
    image?: StringNullableWithAggregatesFilter<"CatalogVendor"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogVendor"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    companyId?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    context?: JsonNullableWithAggregatesFilter<"AuditLog">
    comment?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type PrinterWhereInput = {
    AND?: PrinterWhereInput | PrinterWhereInput[]
    OR?: PrinterWhereInput[]
    NOT?: PrinterWhereInput | PrinterWhereInput[]
    id?: StringFilter<"Printer"> | string
    printerIdentifier?: StringFilter<"Printer"> | string
    tailScaleIP?: StringFilter<"Printer"> | string
    portNumber?: StringFilter<"Printer"> | string
    privateIPAddress?: StringFilter<"Printer"> | string
  }

  export type PrinterOrderByWithRelationInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    printerIdentifier?: string
    tailScaleIP?: string
    portNumber?: string
    privateIPAddress?: string
    AND?: PrinterWhereInput | PrinterWhereInput[]
    OR?: PrinterWhereInput[]
    NOT?: PrinterWhereInput | PrinterWhereInput[]
  }, "id" | "printerIdentifier" | "tailScaleIP" | "portNumber" | "privateIPAddress">

  export type PrinterOrderByWithAggregationInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
    _count?: PrinterCountOrderByAggregateInput
    _max?: PrinterMaxOrderByAggregateInput
    _min?: PrinterMinOrderByAggregateInput
  }

  export type PrinterScalarWhereWithAggregatesInput = {
    AND?: PrinterScalarWhereWithAggregatesInput | PrinterScalarWhereWithAggregatesInput[]
    OR?: PrinterScalarWhereWithAggregatesInput[]
    NOT?: PrinterScalarWhereWithAggregatesInput | PrinterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Printer"> | string
    printerIdentifier?: StringWithAggregatesFilter<"Printer"> | string
    tailScaleIP?: StringWithAggregatesFilter<"Printer"> | string
    portNumber?: StringWithAggregatesFilter<"Printer"> | string
    privateIPAddress?: StringWithAggregatesFilter<"Printer"> | string
  }

  export type CompanyUserWhereInput = {
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CompanyUserOrderByWithRelationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CompanyUserWhereUniqueInput = Prisma.AtLeast<{
    userId_companyId?: CompanyUserUserIdCompanyIdCompoundUniqueInput
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_companyId">

  export type CompanyUserOrderByWithAggregationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyUserCountOrderByAggregateInput
    _max?: CompanyUserMaxOrderByAggregateInput
    _min?: CompanyUserMinOrderByAggregateInput
  }

  export type CompanyUserScalarWhereWithAggregatesInput = {
    AND?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    OR?: CompanyUserScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"CompanyUser"> | string
    companyId?: StringWithAggregatesFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleWithAggregatesFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
  }

  export type DepartmentUserWhereInput = {
    AND?: DepartmentUserWhereInput | DepartmentUserWhereInput[]
    OR?: DepartmentUserWhereInput[]
    NOT?: DepartmentUserWhereInput | DepartmentUserWhereInput[]
    id?: StringFilter<"DepartmentUser"> | string
    userId?: StringFilter<"DepartmentUser"> | string
    companyId?: StringFilter<"DepartmentUser"> | string
    department?: EnumCompanyDepartmentFilter<"DepartmentUser"> | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFilter<"DepartmentUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"DepartmentUser"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type DepartmentUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    department?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DepartmentUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_companyId_department?: DepartmentUserUserIdCompanyIdDepartmentCompoundUniqueInput
    AND?: DepartmentUserWhereInput | DepartmentUserWhereInput[]
    OR?: DepartmentUserWhereInput[]
    NOT?: DepartmentUserWhereInput | DepartmentUserWhereInput[]
    userId?: StringFilter<"DepartmentUser"> | string
    companyId?: StringFilter<"DepartmentUser"> | string
    department?: EnumCompanyDepartmentFilter<"DepartmentUser"> | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFilter<"DepartmentUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"DepartmentUser"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "userId_companyId_department">

  export type DepartmentUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    department?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentUserCountOrderByAggregateInput
    _max?: DepartmentUserMaxOrderByAggregateInput
    _min?: DepartmentUserMinOrderByAggregateInput
  }

  export type DepartmentUserScalarWhereWithAggregatesInput = {
    AND?: DepartmentUserScalarWhereWithAggregatesInput | DepartmentUserScalarWhereWithAggregatesInput[]
    OR?: DepartmentUserScalarWhereWithAggregatesInput[]
    NOT?: DepartmentUserScalarWhereWithAggregatesInput | DepartmentUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentUser"> | string
    userId?: StringWithAggregatesFilter<"DepartmentUser"> | string
    companyId?: StringWithAggregatesFilter<"DepartmentUser"> | string
    department?: EnumCompanyDepartmentWithAggregatesFilter<"DepartmentUser"> | $Enums.CompanyDepartment
    role?: EnumCompanyRoleWithAggregatesFilter<"DepartmentUser"> | $Enums.CompanyRole
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentUser"> | Date | string
  }

  export type CompanyPatientWhereInput = {
    AND?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    OR?: CompanyPatientWhereInput[]
    NOT?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    contactId?: StringNullableFilter<"CompanyPatient"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }

  export type CompanyPatientOrderByWithRelationInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type CompanyPatientWhereUniqueInput = Prisma.AtLeast<{
    externalId_companyId?: CompanyPatientExternalIdCompanyIdCompoundUniqueInput
    patientId_companyId?: CompanyPatientPatientIdCompanyIdCompoundUniqueInput
    AND?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    OR?: CompanyPatientWhereInput[]
    NOT?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    contactId?: StringNullableFilter<"CompanyPatient"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
  }, "patientId_companyId" | "externalId_companyId">

  export type CompanyPatientOrderByWithAggregationInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: CompanyPatientCountOrderByAggregateInput
    _max?: CompanyPatientMaxOrderByAggregateInput
    _min?: CompanyPatientMinOrderByAggregateInput
  }

  export type CompanyPatientScalarWhereWithAggregatesInput = {
    AND?: CompanyPatientScalarWhereWithAggregatesInput | CompanyPatientScalarWhereWithAggregatesInput[]
    OR?: CompanyPatientScalarWhereWithAggregatesInput[]
    NOT?: CompanyPatientScalarWhereWithAggregatesInput | CompanyPatientScalarWhereWithAggregatesInput[]
    patientId?: StringWithAggregatesFilter<"CompanyPatient"> | string
    companyId?: StringWithAggregatesFilter<"CompanyPatient"> | string
    externalId?: StringNullableWithAggregatesFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyPatient"> | Date | string
    contactId?: StringNullableWithAggregatesFilter<"CompanyPatient"> | string | null
  }

  export type FacilityPatientWhereInput = {
    AND?: FacilityPatientWhereInput | FacilityPatientWhereInput[]
    OR?: FacilityPatientWhereInput[]
    NOT?: FacilityPatientWhereInput | FacilityPatientWhereInput[]
    patientId?: StringFilter<"FacilityPatient"> | string
    facilityId?: StringFilter<"FacilityPatient"> | string
    createdAt?: DateTimeFilter<"FacilityPatient"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityPatient"> | Date | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type FacilityPatientOrderByWithRelationInput = {
    patientId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type FacilityPatientWhereUniqueInput = Prisma.AtLeast<{
    patientId_facilityId?: FacilityPatientPatientIdFacilityIdCompoundUniqueInput
    AND?: FacilityPatientWhereInput | FacilityPatientWhereInput[]
    OR?: FacilityPatientWhereInput[]
    NOT?: FacilityPatientWhereInput | FacilityPatientWhereInput[]
    patientId?: StringFilter<"FacilityPatient"> | string
    facilityId?: StringFilter<"FacilityPatient"> | string
    createdAt?: DateTimeFilter<"FacilityPatient"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityPatient"> | Date | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "patientId_facilityId">

  export type FacilityPatientOrderByWithAggregationInput = {
    patientId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityPatientCountOrderByAggregateInput
    _max?: FacilityPatientMaxOrderByAggregateInput
    _min?: FacilityPatientMinOrderByAggregateInput
  }

  export type FacilityPatientScalarWhereWithAggregatesInput = {
    AND?: FacilityPatientScalarWhereWithAggregatesInput | FacilityPatientScalarWhereWithAggregatesInput[]
    OR?: FacilityPatientScalarWhereWithAggregatesInput[]
    NOT?: FacilityPatientScalarWhereWithAggregatesInput | FacilityPatientScalarWhereWithAggregatesInput[]
    patientId?: StringWithAggregatesFilter<"FacilityPatient"> | string
    facilityId?: StringWithAggregatesFilter<"FacilityPatient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FacilityPatient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacilityPatient"> | Date | string
  }

  export type StripeProductWhereInput = {
    AND?: StripeProductWhereInput | StripeProductWhereInput[]
    OR?: StripeProductWhereInput[]
    NOT?: StripeProductWhereInput | StripeProductWhereInput[]
    id?: StringFilter<"StripeProduct"> | string
    type?: EnumStripeProductTypeFilter<"StripeProduct"> | $Enums.StripeProductType
    stripeEntityId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeProductId?: StringFilter<"StripeProduct"> | string
    stripePriceId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeCouponId?: StringNullableFilter<"StripeProduct"> | string | null
    frequency?: EnumStripeBillingFrequencyNullableFilter<"StripeProduct"> | $Enums.StripeBillingFrequency | null
    amount?: FloatNullableFilter<"StripeProduct"> | number | null
    description?: StringNullableFilter<"StripeProduct"> | string | null
    active?: BoolFilter<"StripeProduct"> | boolean
    createdAt?: DateTimeFilter<"StripeProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StripeProduct"> | Date | string
    stripeEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    stripeInvoices?: StripeInvoiceListRelationFilter
    stripeSubscriptions?: StripeSubscriptionListRelationFilter
  }

  export type StripeProductOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    stripeEntityId?: SortOrderInput | SortOrder
    stripeProductId?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeCouponId?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeEntity?: StripeEntityOrderByWithRelationInput
    stripeInvoices?: StripeInvoiceOrderByRelationAggregateInput
    stripeSubscriptions?: StripeSubscriptionOrderByRelationAggregateInput
  }

  export type StripeProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeProductWhereInput | StripeProductWhereInput[]
    OR?: StripeProductWhereInput[]
    NOT?: StripeProductWhereInput | StripeProductWhereInput[]
    type?: EnumStripeProductTypeFilter<"StripeProduct"> | $Enums.StripeProductType
    stripeEntityId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeProductId?: StringFilter<"StripeProduct"> | string
    stripePriceId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeCouponId?: StringNullableFilter<"StripeProduct"> | string | null
    frequency?: EnumStripeBillingFrequencyNullableFilter<"StripeProduct"> | $Enums.StripeBillingFrequency | null
    amount?: FloatNullableFilter<"StripeProduct"> | number | null
    description?: StringNullableFilter<"StripeProduct"> | string | null
    active?: BoolFilter<"StripeProduct"> | boolean
    createdAt?: DateTimeFilter<"StripeProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StripeProduct"> | Date | string
    stripeEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    stripeInvoices?: StripeInvoiceListRelationFilter
    stripeSubscriptions?: StripeSubscriptionListRelationFilter
  }, "id">

  export type StripeProductOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    stripeEntityId?: SortOrderInput | SortOrder
    stripeProductId?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeCouponId?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeProductCountOrderByAggregateInput
    _avg?: StripeProductAvgOrderByAggregateInput
    _max?: StripeProductMaxOrderByAggregateInput
    _min?: StripeProductMinOrderByAggregateInput
    _sum?: StripeProductSumOrderByAggregateInput
  }

  export type StripeProductScalarWhereWithAggregatesInput = {
    AND?: StripeProductScalarWhereWithAggregatesInput | StripeProductScalarWhereWithAggregatesInput[]
    OR?: StripeProductScalarWhereWithAggregatesInput[]
    NOT?: StripeProductScalarWhereWithAggregatesInput | StripeProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeProduct"> | string
    type?: EnumStripeProductTypeWithAggregatesFilter<"StripeProduct"> | $Enums.StripeProductType
    stripeEntityId?: StringNullableWithAggregatesFilter<"StripeProduct"> | string | null
    stripeProductId?: StringWithAggregatesFilter<"StripeProduct"> | string
    stripePriceId?: StringNullableWithAggregatesFilter<"StripeProduct"> | string | null
    stripeCouponId?: StringNullableWithAggregatesFilter<"StripeProduct"> | string | null
    frequency?: EnumStripeBillingFrequencyNullableWithAggregatesFilter<"StripeProduct"> | $Enums.StripeBillingFrequency | null
    amount?: FloatNullableWithAggregatesFilter<"StripeProduct"> | number | null
    description?: StringNullableWithAggregatesFilter<"StripeProduct"> | string | null
    active?: BoolWithAggregatesFilter<"StripeProduct"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StripeProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeProduct"> | Date | string
  }

  export type StripeInvoiceWhereInput = {
    AND?: StripeInvoiceWhereInput | StripeInvoiceWhereInput[]
    OR?: StripeInvoiceWhereInput[]
    NOT?: StripeInvoiceWhereInput | StripeInvoiceWhereInput[]
    id?: StringFilter<"StripeInvoice"> | string
    stripeInvoiceId?: StringFilter<"StripeInvoice"> | string
    price?: FloatFilter<"StripeInvoice"> | number
    type?: EnumStripeInvoiceTypeFilter<"StripeInvoice"> | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFilter<"StripeInvoice"> | $Enums.StripeInvoiceStatus
    lastWebhookId?: StringNullableFilter<"StripeInvoice"> | string | null
    metadata?: JsonNullableFilter<"StripeInvoice">
    subscriptionId?: StringNullableFilter<"StripeInvoice"> | string | null
    combinedInvoiceId?: StringNullableFilter<"StripeInvoice"> | string | null
    stripeEntityId?: StringNullableFilter<"StripeInvoice"> | string | null
    createdAt?: DateTimeFilter<"StripeInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"StripeInvoice"> | Date | string
    stripeProducts?: StripeProductListRelationFilter
    combinedInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    combinedInvoices?: StripeInvoiceListRelationFilter
    stripeSubscription?: XOR<StripeSubscriptionNullableRelationFilter, StripeSubscriptionWhereInput> | null
    stripeEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    employerEvaluations?: EvaluationListRelationFilter
    checkoutEvaluations?: EvaluationListRelationFilter
  }

  export type StripeInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    stripeInvoiceId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastWebhookId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    combinedInvoiceId?: SortOrderInput | SortOrder
    stripeEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeProducts?: StripeProductOrderByRelationAggregateInput
    combinedInvoice?: StripeInvoiceOrderByWithRelationInput
    combinedInvoices?: StripeInvoiceOrderByRelationAggregateInput
    stripeSubscription?: StripeSubscriptionOrderByWithRelationInput
    stripeEntity?: StripeEntityOrderByWithRelationInput
    employerEvaluations?: EvaluationOrderByRelationAggregateInput
    checkoutEvaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type StripeInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    AND?: StripeInvoiceWhereInput | StripeInvoiceWhereInput[]
    OR?: StripeInvoiceWhereInput[]
    NOT?: StripeInvoiceWhereInput | StripeInvoiceWhereInput[]
    price?: FloatFilter<"StripeInvoice"> | number
    type?: EnumStripeInvoiceTypeFilter<"StripeInvoice"> | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFilter<"StripeInvoice"> | $Enums.StripeInvoiceStatus
    lastWebhookId?: StringNullableFilter<"StripeInvoice"> | string | null
    metadata?: JsonNullableFilter<"StripeInvoice">
    subscriptionId?: StringNullableFilter<"StripeInvoice"> | string | null
    combinedInvoiceId?: StringNullableFilter<"StripeInvoice"> | string | null
    stripeEntityId?: StringNullableFilter<"StripeInvoice"> | string | null
    createdAt?: DateTimeFilter<"StripeInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"StripeInvoice"> | Date | string
    stripeProducts?: StripeProductListRelationFilter
    combinedInvoice?: XOR<StripeInvoiceNullableRelationFilter, StripeInvoiceWhereInput> | null
    combinedInvoices?: StripeInvoiceListRelationFilter
    stripeSubscription?: XOR<StripeSubscriptionNullableRelationFilter, StripeSubscriptionWhereInput> | null
    stripeEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    employerEvaluations?: EvaluationListRelationFilter
    checkoutEvaluations?: EvaluationListRelationFilter
  }, "id" | "stripeInvoiceId">

  export type StripeInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    stripeInvoiceId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastWebhookId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    combinedInvoiceId?: SortOrderInput | SortOrder
    stripeEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeInvoiceCountOrderByAggregateInput
    _avg?: StripeInvoiceAvgOrderByAggregateInput
    _max?: StripeInvoiceMaxOrderByAggregateInput
    _min?: StripeInvoiceMinOrderByAggregateInput
    _sum?: StripeInvoiceSumOrderByAggregateInput
  }

  export type StripeInvoiceScalarWhereWithAggregatesInput = {
    AND?: StripeInvoiceScalarWhereWithAggregatesInput | StripeInvoiceScalarWhereWithAggregatesInput[]
    OR?: StripeInvoiceScalarWhereWithAggregatesInput[]
    NOT?: StripeInvoiceScalarWhereWithAggregatesInput | StripeInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeInvoice"> | string
    stripeInvoiceId?: StringWithAggregatesFilter<"StripeInvoice"> | string
    price?: FloatWithAggregatesFilter<"StripeInvoice"> | number
    type?: EnumStripeInvoiceTypeWithAggregatesFilter<"StripeInvoice"> | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusWithAggregatesFilter<"StripeInvoice"> | $Enums.StripeInvoiceStatus
    lastWebhookId?: StringNullableWithAggregatesFilter<"StripeInvoice"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"StripeInvoice">
    subscriptionId?: StringNullableWithAggregatesFilter<"StripeInvoice"> | string | null
    combinedInvoiceId?: StringNullableWithAggregatesFilter<"StripeInvoice"> | string | null
    stripeEntityId?: StringNullableWithAggregatesFilter<"StripeInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StripeInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeInvoice"> | Date | string
  }

  export type StripeEntityWhereInput = {
    AND?: StripeEntityWhereInput | StripeEntityWhereInput[]
    OR?: StripeEntityWhereInput[]
    NOT?: StripeEntityWhereInput | StripeEntityWhereInput[]
    id?: StringFilter<"StripeEntity"> | string
    companyId?: StringFilter<"StripeEntity"> | string
    entityId?: StringFilter<"StripeEntity"> | string
    stripeCustomerId?: StringNullableFilter<"StripeEntity"> | string | null
    billingPreferences?: JsonNullableFilter<"StripeEntity">
    autoAdvance?: BoolFilter<"StripeEntity"> | boolean
    autoAdvanceCombined?: BoolFilter<"StripeEntity"> | boolean
    collectionSendInvoice?: BoolFilter<"StripeEntity"> | boolean
    active?: BoolFilter<"StripeEntity"> | boolean
    entityParentId?: StringNullableFilter<"StripeEntity"> | string | null
    stripeEntityType?: EnumStripeEntityTypeFilter<"StripeEntity"> | $Enums.StripeEntityType
    createdAt?: DateTimeFilter<"StripeEntity"> | Date | string
    updatedAt?: DateTimeFilter<"StripeEntity"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    parentEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    childEntities?: StripeEntityListRelationFilter
    stripeProducts?: StripeProductListRelationFilter
    stripeSubscriptions?: StripeSubscriptionListRelationFilter
    stripeInvoices?: StripeInvoiceListRelationFilter
  }

  export type StripeEntityOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    billingPreferences?: SortOrderInput | SortOrder
    autoAdvance?: SortOrder
    autoAdvanceCombined?: SortOrder
    collectionSendInvoice?: SortOrder
    active?: SortOrder
    entityParentId?: SortOrderInput | SortOrder
    stripeEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    parentEntity?: StripeEntityOrderByWithRelationInput
    childEntities?: StripeEntityOrderByRelationAggregateInput
    stripeProducts?: StripeProductOrderByRelationAggregateInput
    stripeSubscriptions?: StripeSubscriptionOrderByRelationAggregateInput
    stripeInvoices?: StripeInvoiceOrderByRelationAggregateInput
  }

  export type StripeEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeEntityWhereInput | StripeEntityWhereInput[]
    OR?: StripeEntityWhereInput[]
    NOT?: StripeEntityWhereInput | StripeEntityWhereInput[]
    companyId?: StringFilter<"StripeEntity"> | string
    entityId?: StringFilter<"StripeEntity"> | string
    stripeCustomerId?: StringNullableFilter<"StripeEntity"> | string | null
    billingPreferences?: JsonNullableFilter<"StripeEntity">
    autoAdvance?: BoolFilter<"StripeEntity"> | boolean
    autoAdvanceCombined?: BoolFilter<"StripeEntity"> | boolean
    collectionSendInvoice?: BoolFilter<"StripeEntity"> | boolean
    active?: BoolFilter<"StripeEntity"> | boolean
    entityParentId?: StringNullableFilter<"StripeEntity"> | string | null
    stripeEntityType?: EnumStripeEntityTypeFilter<"StripeEntity"> | $Enums.StripeEntityType
    createdAt?: DateTimeFilter<"StripeEntity"> | Date | string
    updatedAt?: DateTimeFilter<"StripeEntity"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    parentEntity?: XOR<StripeEntityNullableRelationFilter, StripeEntityWhereInput> | null
    childEntities?: StripeEntityListRelationFilter
    stripeProducts?: StripeProductListRelationFilter
    stripeSubscriptions?: StripeSubscriptionListRelationFilter
    stripeInvoices?: StripeInvoiceListRelationFilter
  }, "id">

  export type StripeEntityOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    billingPreferences?: SortOrderInput | SortOrder
    autoAdvance?: SortOrder
    autoAdvanceCombined?: SortOrder
    collectionSendInvoice?: SortOrder
    active?: SortOrder
    entityParentId?: SortOrderInput | SortOrder
    stripeEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeEntityCountOrderByAggregateInput
    _max?: StripeEntityMaxOrderByAggregateInput
    _min?: StripeEntityMinOrderByAggregateInput
  }

  export type StripeEntityScalarWhereWithAggregatesInput = {
    AND?: StripeEntityScalarWhereWithAggregatesInput | StripeEntityScalarWhereWithAggregatesInput[]
    OR?: StripeEntityScalarWhereWithAggregatesInput[]
    NOT?: StripeEntityScalarWhereWithAggregatesInput | StripeEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeEntity"> | string
    companyId?: StringWithAggregatesFilter<"StripeEntity"> | string
    entityId?: StringWithAggregatesFilter<"StripeEntity"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"StripeEntity"> | string | null
    billingPreferences?: JsonNullableWithAggregatesFilter<"StripeEntity">
    autoAdvance?: BoolWithAggregatesFilter<"StripeEntity"> | boolean
    autoAdvanceCombined?: BoolWithAggregatesFilter<"StripeEntity"> | boolean
    collectionSendInvoice?: BoolWithAggregatesFilter<"StripeEntity"> | boolean
    active?: BoolWithAggregatesFilter<"StripeEntity"> | boolean
    entityParentId?: StringNullableWithAggregatesFilter<"StripeEntity"> | string | null
    stripeEntityType?: EnumStripeEntityTypeWithAggregatesFilter<"StripeEntity"> | $Enums.StripeEntityType
    createdAt?: DateTimeWithAggregatesFilter<"StripeEntity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeEntity"> | Date | string
  }

  export type StripeSubscriptionWhereInput = {
    AND?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    OR?: StripeSubscriptionWhereInput[]
    NOT?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    id?: StringFilter<"StripeSubscription"> | string
    stripeEntityId?: StringFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringFilter<"StripeSubscription"> | string
    stripeProductId?: StringFilter<"StripeSubscription"> | string
    active?: BoolFilter<"StripeSubscription"> | boolean
    createdAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    stripeEntity?: XOR<StripeEntityRelationFilter, StripeEntityWhereInput>
    stripeInvoices?: StripeInvoiceListRelationFilter
    stripeProducts?: XOR<StripeProductRelationFilter, StripeProductWhereInput>
  }

  export type StripeSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    stripeEntityId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeEntity?: StripeEntityOrderByWithRelationInput
    stripeInvoices?: StripeInvoiceOrderByRelationAggregateInput
    stripeProducts?: StripeProductOrderByWithRelationInput
  }

  export type StripeSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    OR?: StripeSubscriptionWhereInput[]
    NOT?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    stripeEntityId?: StringFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringFilter<"StripeSubscription"> | string
    stripeProductId?: StringFilter<"StripeSubscription"> | string
    active?: BoolFilter<"StripeSubscription"> | boolean
    createdAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    stripeEntity?: XOR<StripeEntityRelationFilter, StripeEntityWhereInput>
    stripeInvoices?: StripeInvoiceListRelationFilter
    stripeProducts?: XOR<StripeProductRelationFilter, StripeProductWhereInput>
  }, "id">

  export type StripeSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    stripeEntityId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeSubscriptionCountOrderByAggregateInput
    _max?: StripeSubscriptionMaxOrderByAggregateInput
    _min?: StripeSubscriptionMinOrderByAggregateInput
  }

  export type StripeSubscriptionScalarWhereWithAggregatesInput = {
    AND?: StripeSubscriptionScalarWhereWithAggregatesInput | StripeSubscriptionScalarWhereWithAggregatesInput[]
    OR?: StripeSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: StripeSubscriptionScalarWhereWithAggregatesInput | StripeSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeSubscription"> | string
    stripeEntityId?: StringWithAggregatesFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringWithAggregatesFilter<"StripeSubscription"> | string
    stripeProductId?: StringWithAggregatesFilter<"StripeSubscription"> | string
    active?: BoolWithAggregatesFilter<"StripeSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeSubscription"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    name?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    responseType?: EnumNotificationResponseTypeNullableFilter<"Notification"> | $Enums.NotificationResponseType | null
    publish?: BoolFilter<"Notification"> | boolean
    startTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    active?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    messages?: NotificationMessageListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    responseType?: SortOrderInput | SortOrder
    publish?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: NotificationMessageOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    name?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    responseType?: EnumNotificationResponseTypeNullableFilter<"Notification"> | $Enums.NotificationResponseType | null
    publish?: BoolFilter<"Notification"> | boolean
    startTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Notification"> | Date | string | null
    active?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    messages?: NotificationMessageListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    responseType?: SortOrderInput | SortOrder
    publish?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    name?: StringWithAggregatesFilter<"Notification"> | string
    description?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    responseType?: EnumNotificationResponseTypeNullableWithAggregatesFilter<"Notification"> | $Enums.NotificationResponseType | null
    publish?: BoolWithAggregatesFilter<"Notification"> | boolean
    startTime?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationMessageWhereInput = {
    AND?: NotificationMessageWhereInput | NotificationMessageWhereInput[]
    OR?: NotificationMessageWhereInput[]
    NOT?: NotificationMessageWhereInput | NotificationMessageWhereInput[]
    id?: StringFilter<"NotificationMessage"> | string
    notificationId?: StringFilter<"NotificationMessage"> | string
    sequence?: FloatFilter<"NotificationMessage"> | number
    delayMinutes?: FloatNullableFilter<"NotificationMessage"> | number | null
    recurrencePattern?: StringNullableFilter<"NotificationMessage"> | string | null
    sequenceLimit?: FloatNullableFilter<"NotificationMessage"> | number | null
    content?: StringFilter<"NotificationMessage"> | string
    emailTemplateId?: StringNullableFilter<"NotificationMessage"> | string | null
    channel?: EnumCommunicationChannelFilter<"NotificationMessage"> | $Enums.CommunicationChannel
    createdAt?: DateTimeFilter<"NotificationMessage"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationMessage"> | Date | string
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    emailTemplate?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
    notificationHistory?: NotificationHistoryListRelationFilter
  }

  export type NotificationMessageOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    sequence?: SortOrder
    delayMinutes?: SortOrderInput | SortOrder
    recurrencePattern?: SortOrderInput | SortOrder
    sequenceLimit?: SortOrderInput | SortOrder
    content?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    emailTemplate?: EmailTemplateOrderByWithRelationInput
    notificationHistory?: NotificationHistoryOrderByRelationAggregateInput
  }

  export type NotificationMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    notificationId_sequence?: NotificationMessageNotificationIdSequenceCompoundUniqueInput
    AND?: NotificationMessageWhereInput | NotificationMessageWhereInput[]
    OR?: NotificationMessageWhereInput[]
    NOT?: NotificationMessageWhereInput | NotificationMessageWhereInput[]
    notificationId?: StringFilter<"NotificationMessage"> | string
    sequence?: FloatFilter<"NotificationMessage"> | number
    delayMinutes?: FloatNullableFilter<"NotificationMessage"> | number | null
    recurrencePattern?: StringNullableFilter<"NotificationMessage"> | string | null
    sequenceLimit?: FloatNullableFilter<"NotificationMessage"> | number | null
    content?: StringFilter<"NotificationMessage"> | string
    emailTemplateId?: StringNullableFilter<"NotificationMessage"> | string | null
    channel?: EnumCommunicationChannelFilter<"NotificationMessage"> | $Enums.CommunicationChannel
    createdAt?: DateTimeFilter<"NotificationMessage"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationMessage"> | Date | string
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    emailTemplate?: XOR<EmailTemplateNullableRelationFilter, EmailTemplateWhereInput> | null
    notificationHistory?: NotificationHistoryListRelationFilter
  }, "id" | "notificationId_sequence">

  export type NotificationMessageOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    sequence?: SortOrder
    delayMinutes?: SortOrderInput | SortOrder
    recurrencePattern?: SortOrderInput | SortOrder
    sequenceLimit?: SortOrderInput | SortOrder
    content?: SortOrder
    emailTemplateId?: SortOrderInput | SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationMessageCountOrderByAggregateInput
    _avg?: NotificationMessageAvgOrderByAggregateInput
    _max?: NotificationMessageMaxOrderByAggregateInput
    _min?: NotificationMessageMinOrderByAggregateInput
    _sum?: NotificationMessageSumOrderByAggregateInput
  }

  export type NotificationMessageScalarWhereWithAggregatesInput = {
    AND?: NotificationMessageScalarWhereWithAggregatesInput | NotificationMessageScalarWhereWithAggregatesInput[]
    OR?: NotificationMessageScalarWhereWithAggregatesInput[]
    NOT?: NotificationMessageScalarWhereWithAggregatesInput | NotificationMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationMessage"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationMessage"> | string
    sequence?: FloatWithAggregatesFilter<"NotificationMessage"> | number
    delayMinutes?: FloatNullableWithAggregatesFilter<"NotificationMessage"> | number | null
    recurrencePattern?: StringNullableWithAggregatesFilter<"NotificationMessage"> | string | null
    sequenceLimit?: FloatNullableWithAggregatesFilter<"NotificationMessage"> | number | null
    content?: StringWithAggregatesFilter<"NotificationMessage"> | string
    emailTemplateId?: StringNullableWithAggregatesFilter<"NotificationMessage"> | string | null
    channel?: EnumCommunicationChannelWithAggregatesFilter<"NotificationMessage"> | $Enums.CommunicationChannel
    createdAt?: DateTimeWithAggregatesFilter<"NotificationMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationMessage"> | Date | string
  }

  export type NotificationHistoryWhereInput = {
    AND?: NotificationHistoryWhereInput | NotificationHistoryWhereInput[]
    OR?: NotificationHistoryWhereInput[]
    NOT?: NotificationHistoryWhereInput | NotificationHistoryWhereInput[]
    id?: StringFilter<"NotificationHistory"> | string
    patientId?: StringFilter<"NotificationHistory"> | string
    messageId?: StringFilter<"NotificationHistory"> | string
    sentAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    response?: StringNullableFilter<"NotificationHistory"> | string | null
    responseReceivedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    jobId?: StringNullableFilter<"NotificationHistory"> | string | null
    createdAt?: DateTimeFilter<"NotificationHistory"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationHistory"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    message?: XOR<NotificationMessageRelationFilter, NotificationMessageWhereInput>
  }

  export type NotificationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    messageId?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    responseReceivedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    message?: NotificationMessageOrderByWithRelationInput
  }

  export type NotificationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationHistoryWhereInput | NotificationHistoryWhereInput[]
    OR?: NotificationHistoryWhereInput[]
    NOT?: NotificationHistoryWhereInput | NotificationHistoryWhereInput[]
    patientId?: StringFilter<"NotificationHistory"> | string
    messageId?: StringFilter<"NotificationHistory"> | string
    sentAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    response?: StringNullableFilter<"NotificationHistory"> | string | null
    responseReceivedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    jobId?: StringNullableFilter<"NotificationHistory"> | string | null
    createdAt?: DateTimeFilter<"NotificationHistory"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationHistory"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    message?: XOR<NotificationMessageRelationFilter, NotificationMessageWhereInput>
  }, "id">

  export type NotificationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    messageId?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    responseReceivedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationHistoryCountOrderByAggregateInput
    _max?: NotificationHistoryMaxOrderByAggregateInput
    _min?: NotificationHistoryMinOrderByAggregateInput
  }

  export type NotificationHistoryScalarWhereWithAggregatesInput = {
    AND?: NotificationHistoryScalarWhereWithAggregatesInput | NotificationHistoryScalarWhereWithAggregatesInput[]
    OR?: NotificationHistoryScalarWhereWithAggregatesInput[]
    NOT?: NotificationHistoryScalarWhereWithAggregatesInput | NotificationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationHistory"> | string
    patientId?: StringWithAggregatesFilter<"NotificationHistory"> | string
    messageId?: StringWithAggregatesFilter<"NotificationHistory"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"NotificationHistory"> | Date | string | null
    response?: StringNullableWithAggregatesFilter<"NotificationHistory"> | string | null
    responseReceivedAt?: DateTimeNullableWithAggregatesFilter<"NotificationHistory"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"NotificationHistory"> | Date | string | null
    jobId?: StringNullableWithAggregatesFilter<"NotificationHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationHistory"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    title?: StringFilter<"EmailTemplate"> | string
    design?: JsonFilter<"EmailTemplate">
    htmlContent?: StringFilter<"EmailTemplate"> | string
    active?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    NotificationMessages?: NotificationMessageListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    design?: SortOrder
    htmlContent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    NotificationMessages?: NotificationMessageOrderByRelationAggregateInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    title?: StringFilter<"EmailTemplate"> | string
    design?: JsonFilter<"EmailTemplate">
    htmlContent?: StringFilter<"EmailTemplate"> | string
    active?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    NotificationMessages?: NotificationMessageListRelationFilter
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    design?: SortOrder
    htmlContent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    title?: StringWithAggregatesFilter<"EmailTemplate"> | string
    design?: JsonWithAggregatesFilter<"EmailTemplate">
    htmlContent?: StringWithAggregatesFilter<"EmailTemplate"> | string
    active?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    companies?: CompanyUserListRelationFilter
    departments?: DepartmentUserListRelationFilter
    clinician?: XOR<ClinicianNullableRelationFilter, ClinicianWhereInput> | null
    notes?: WorkbenchNotesListRelationFilter
    auditsLogs?: AuditLogListRelationFilter
    agreements?: UserAgreementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    companies?: CompanyUserOrderByRelationAggregateInput
    departments?: DepartmentUserOrderByRelationAggregateInput
    clinician?: ClinicianOrderByWithRelationInput
    notes?: WorkbenchNotesOrderByRelationAggregateInput
    auditsLogs?: AuditLogOrderByRelationAggregateInput
    agreements?: UserAgreementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    companies?: CompanyUserListRelationFilter
    departments?: DepartmentUserListRelationFilter
    clinician?: XOR<ClinicianNullableRelationFilter, ClinicianWhereInput> | null
    notes?: WorkbenchNotesListRelationFilter
    auditsLogs?: AuditLogListRelationFilter
    agreements?: UserAgreementListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    pin?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserAgreementWhereInput = {
    AND?: UserAgreementWhereInput | UserAgreementWhereInput[]
    OR?: UserAgreementWhereInput[]
    NOT?: UserAgreementWhereInput | UserAgreementWhereInput[]
    userId?: StringFilter<"UserAgreement"> | string
    agreementId?: StringFilter<"UserAgreement"> | string
    status?: EnumAgreementStatusFilter<"UserAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"UserAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAgreement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    agreement?: XOR<AgreementRelationFilter, AgreementWhereInput>
  }

  export type UserAgreementOrderByWithRelationInput = {
    userId?: SortOrder
    agreementId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    agreement?: AgreementOrderByWithRelationInput
  }

  export type UserAgreementWhereUniqueInput = Prisma.AtLeast<{
    userId_agreementId?: UserAgreementUserIdAgreementIdCompoundUniqueInput
    AND?: UserAgreementWhereInput | UserAgreementWhereInput[]
    OR?: UserAgreementWhereInput[]
    NOT?: UserAgreementWhereInput | UserAgreementWhereInput[]
    userId?: StringFilter<"UserAgreement"> | string
    agreementId?: StringFilter<"UserAgreement"> | string
    status?: EnumAgreementStatusFilter<"UserAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"UserAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAgreement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    agreement?: XOR<AgreementRelationFilter, AgreementWhereInput>
  }, "userId_agreementId">

  export type UserAgreementOrderByWithAggregationInput = {
    userId?: SortOrder
    agreementId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAgreementCountOrderByAggregateInput
    _max?: UserAgreementMaxOrderByAggregateInput
    _min?: UserAgreementMinOrderByAggregateInput
  }

  export type UserAgreementScalarWhereWithAggregatesInput = {
    AND?: UserAgreementScalarWhereWithAggregatesInput | UserAgreementScalarWhereWithAggregatesInput[]
    OR?: UserAgreementScalarWhereWithAggregatesInput[]
    NOT?: UserAgreementScalarWhereWithAggregatesInput | UserAgreementScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserAgreement"> | string
    agreementId?: StringWithAggregatesFilter<"UserAgreement"> | string
    status?: EnumAgreementStatusWithAggregatesFilter<"UserAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeWithAggregatesFilter<"UserAgreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAgreement"> | Date | string
  }

  export type AgreementWhereInput = {
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    id?: StringFilter<"Agreement"> | string
    type?: EnumAgreementTypeFilter<"Agreement"> | $Enums.AgreementType
    active?: BoolFilter<"Agreement"> | boolean
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    userAgreements?: UserAgreementListRelationFilter
  }

  export type AgreementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userAgreements?: UserAgreementOrderByRelationAggregateInput
  }

  export type AgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    type?: EnumAgreementTypeFilter<"Agreement"> | $Enums.AgreementType
    active?: BoolFilter<"Agreement"> | boolean
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    userAgreements?: UserAgreementListRelationFilter
  }, "id">

  export type AgreementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgreementCountOrderByAggregateInput
    _max?: AgreementMaxOrderByAggregateInput
    _min?: AgreementMinOrderByAggregateInput
  }

  export type AgreementScalarWhereWithAggregatesInput = {
    AND?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    OR?: AgreementScalarWhereWithAggregatesInput[]
    NOT?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agreement"> | string
    type?: EnumAgreementTypeWithAggregatesFilter<"Agreement"> | $Enums.AgreementType
    active?: BoolWithAggregatesFilter<"Agreement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    profileId_provider?: AccountProfileIdProviderCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "profileId_provider">

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Account"> | string
    profileId?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type AccountVerificationWhereInput = {
    AND?: AccountVerificationWhereInput | AccountVerificationWhereInput[]
    OR?: AccountVerificationWhereInput[]
    NOT?: AccountVerificationWhereInput | AccountVerificationWhereInput[]
    token?: StringFilter<"AccountVerification"> | string
    email?: StringFilter<"AccountVerification"> | string
    type?: EnumAccountRecoveryTypeFilter<"AccountVerification"> | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFilter<"AccountVerification"> | Date | string
    createdAt?: DateTimeFilter<"AccountVerification"> | Date | string
    updatedAt?: DateTimeFilter<"AccountVerification"> | Date | string
  }

  export type AccountVerificationOrderByWithRelationInput = {
    token?: SortOrder
    email?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountVerificationWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    email?: string
    AND?: AccountVerificationWhereInput | AccountVerificationWhereInput[]
    OR?: AccountVerificationWhereInput[]
    NOT?: AccountVerificationWhereInput | AccountVerificationWhereInput[]
    type?: EnumAccountRecoveryTypeFilter<"AccountVerification"> | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFilter<"AccountVerification"> | Date | string
    createdAt?: DateTimeFilter<"AccountVerification"> | Date | string
    updatedAt?: DateTimeFilter<"AccountVerification"> | Date | string
  }, "token" | "email">

  export type AccountVerificationOrderByWithAggregationInput = {
    token?: SortOrder
    email?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountVerificationCountOrderByAggregateInput
    _max?: AccountVerificationMaxOrderByAggregateInput
    _min?: AccountVerificationMinOrderByAggregateInput
  }

  export type AccountVerificationScalarWhereWithAggregatesInput = {
    AND?: AccountVerificationScalarWhereWithAggregatesInput | AccountVerificationScalarWhereWithAggregatesInput[]
    OR?: AccountVerificationScalarWhereWithAggregatesInput[]
    NOT?: AccountVerificationScalarWhereWithAggregatesInput | AccountVerificationScalarWhereWithAggregatesInput[]
    token?: StringWithAggregatesFilter<"AccountVerification"> | string
    email?: StringWithAggregatesFilter<"AccountVerification"> | string
    type?: EnumAccountRecoveryTypeWithAggregatesFilter<"AccountVerification"> | $Enums.AccountRecoveryType
    expiresAt?: DateTimeWithAggregatesFilter<"AccountVerification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AccountVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccountVerification"> | Date | string
  }

  export type CompanyInvitationWhereInput = {
    AND?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    OR?: CompanyInvitationWhereInput[]
    NOT?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    id?: StringFilter<"CompanyInvitation"> | string
    companyId?: StringFilter<"CompanyInvitation"> | string
    contact?: StringFilter<"CompanyInvitation"> | string
    contactType?: EnumContactTypeFilter<"CompanyInvitation"> | $Enums.ContactType
    role?: EnumCompanyRoleFilter<"CompanyInvitation"> | $Enums.CompanyRole
    token?: StringFilter<"CompanyInvitation"> | string
    verified?: BoolFilter<"CompanyInvitation"> | boolean
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CompanyInvitationOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contact?: SortOrder
    contactType?: SortOrder
    role?: SortOrder
    token?: SortOrder
    verified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    contact_companyId?: CompanyInvitationContactCompanyIdCompoundUniqueInput
    AND?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    OR?: CompanyInvitationWhereInput[]
    NOT?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    companyId?: StringFilter<"CompanyInvitation"> | string
    contact?: StringFilter<"CompanyInvitation"> | string
    contactType?: EnumContactTypeFilter<"CompanyInvitation"> | $Enums.ContactType
    role?: EnumCompanyRoleFilter<"CompanyInvitation"> | $Enums.CompanyRole
    verified?: BoolFilter<"CompanyInvitation"> | boolean
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "token" | "contact_companyId">

  export type CompanyInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    contact?: SortOrder
    contactType?: SortOrder
    role?: SortOrder
    token?: SortOrder
    verified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyInvitationCountOrderByAggregateInput
    _max?: CompanyInvitationMaxOrderByAggregateInput
    _min?: CompanyInvitationMinOrderByAggregateInput
  }

  export type CompanyInvitationScalarWhereWithAggregatesInput = {
    AND?: CompanyInvitationScalarWhereWithAggregatesInput | CompanyInvitationScalarWhereWithAggregatesInput[]
    OR?: CompanyInvitationScalarWhereWithAggregatesInput[]
    NOT?: CompanyInvitationScalarWhereWithAggregatesInput | CompanyInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyInvitation"> | string
    companyId?: StringWithAggregatesFilter<"CompanyInvitation"> | string
    contact?: StringWithAggregatesFilter<"CompanyInvitation"> | string
    contactType?: EnumContactTypeWithAggregatesFilter<"CompanyInvitation"> | $Enums.ContactType
    role?: EnumCompanyRoleWithAggregatesFilter<"CompanyInvitation"> | $Enums.CompanyRole
    token?: StringWithAggregatesFilter<"CompanyInvitation"> | string
    verified?: BoolWithAggregatesFilter<"CompanyInvitation"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    id_companyId?: ApiKeyIdCompanyIdCompoundUniqueInput
    key_companyId?: ApiKeyKeyCompanyIdCompoundUniqueInput
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "key" | "id_companyId" | "key_companyId">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    companyId?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type ViewFlattenedWorkbenchWhereInput = {
    AND?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    OR?: ViewFlattenedWorkbenchWhereInput[]
    NOT?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    workbenchId?: StringFilter<"ViewFlattenedWorkbench"> | string
    companyId?: StringFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    workbenchCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    companySlug?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    labelId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    trackingStatus?: EnumShippingTrackingStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.ShippingTrackingStatus | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: EnumOrderAuthorizationStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    productType?: EnumProductTypeNullableFilter<"ViewFlattenedWorkbench"> | $Enums.ProductType | null
    submittedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isReprint?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderShoeSize?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeWidth?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    needsDevValidation?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    isImpressionBox?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
  }

  export type ViewFlattenedWorkbenchOrderByWithRelationInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrderInput | SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderStatus?: SortOrderInput | SortOrder
    workbenchCreatedAt?: SortOrderInput | SortOrder
    companySlug?: SortOrderInput | SortOrder
    labelId?: SortOrderInput | SortOrder
    trackingStatus?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    orderAuthorizationStatus?: SortOrderInput | SortOrder
    slicerProfile?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    clinicianName?: SortOrderInput | SortOrder
    clinicianId?: SortOrderInput | SortOrder
    patientFirstName?: SortOrderInput | SortOrder
    patientLastName?: SortOrderInput | SortOrder
    orderCreatedAt?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    orderCompletedAt?: SortOrderInput | SortOrder
    isDiabetic?: SortOrderInput | SortOrder
    orderSide?: SortOrderInput | SortOrder
    orderQuantity?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    isReprint?: SortOrderInput | SortOrder
    orderShoeSize?: SortOrderInput | SortOrder
    orderShoeWidth?: SortOrderInput | SortOrder
    orderGender?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    printingStartedAt?: SortOrderInput | SortOrder
    printingStartedBy?: SortOrderInput | SortOrder
    grindingCompletedAt?: SortOrderInput | SortOrder
    grindingCompletedBy?: SortOrderInput | SortOrder
    gluingCompletedAt?: SortOrderInput | SortOrder
    gluingCompletedBy?: SortOrderInput | SortOrder
    finishingCompletedAt?: SortOrderInput | SortOrder
    finishingCompletedBy?: SortOrderInput | SortOrder
    shippingCompletedAt?: SortOrderInput | SortOrder
    shippingCompletedBy?: SortOrderInput | SortOrder
    printingCompletedAt?: SortOrderInput | SortOrder
    printingCompletedBy?: SortOrderInput | SortOrder
    addonCompletedAt?: SortOrderInput | SortOrder
    addonCompletedBy?: SortOrderInput | SortOrder
    validationStatus?: SortOrderInput | SortOrder
    needsDevValidation?: SortOrderInput | SortOrder
    isImpressionBox?: SortOrderInput | SortOrder
    deviceTypeName?: SortOrderInput | SortOrder
    taikaId?: SortOrderInput | SortOrder
    taikaDevId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
  }

  export type ViewFlattenedWorkbenchWhereUniqueInput = Prisma.AtLeast<{
    workbenchId?: string
    AND?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    OR?: ViewFlattenedWorkbenchWhereInput[]
    NOT?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    companyId?: StringFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    workbenchCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    companySlug?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    labelId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    trackingStatus?: EnumShippingTrackingStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.ShippingTrackingStatus | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: EnumOrderAuthorizationStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    productType?: EnumProductTypeNullableFilter<"ViewFlattenedWorkbench"> | $Enums.ProductType | null
    submittedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isReprint?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderShoeSize?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeWidth?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    needsDevValidation?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    isImpressionBox?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
  }, "workbenchId">

  export type ViewFlattenedWorkbenchOrderByWithAggregationInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrderInput | SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderStatus?: SortOrderInput | SortOrder
    workbenchCreatedAt?: SortOrderInput | SortOrder
    companySlug?: SortOrderInput | SortOrder
    labelId?: SortOrderInput | SortOrder
    trackingStatus?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    orderAuthorizationStatus?: SortOrderInput | SortOrder
    slicerProfile?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    clinicianName?: SortOrderInput | SortOrder
    clinicianId?: SortOrderInput | SortOrder
    patientFirstName?: SortOrderInput | SortOrder
    patientLastName?: SortOrderInput | SortOrder
    orderCreatedAt?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    orderCompletedAt?: SortOrderInput | SortOrder
    isDiabetic?: SortOrderInput | SortOrder
    orderSide?: SortOrderInput | SortOrder
    orderQuantity?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    isReprint?: SortOrderInput | SortOrder
    orderShoeSize?: SortOrderInput | SortOrder
    orderShoeWidth?: SortOrderInput | SortOrder
    orderGender?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    printingStartedAt?: SortOrderInput | SortOrder
    printingStartedBy?: SortOrderInput | SortOrder
    grindingCompletedAt?: SortOrderInput | SortOrder
    grindingCompletedBy?: SortOrderInput | SortOrder
    gluingCompletedAt?: SortOrderInput | SortOrder
    gluingCompletedBy?: SortOrderInput | SortOrder
    finishingCompletedAt?: SortOrderInput | SortOrder
    finishingCompletedBy?: SortOrderInput | SortOrder
    shippingCompletedAt?: SortOrderInput | SortOrder
    shippingCompletedBy?: SortOrderInput | SortOrder
    printingCompletedAt?: SortOrderInput | SortOrder
    printingCompletedBy?: SortOrderInput | SortOrder
    addonCompletedAt?: SortOrderInput | SortOrder
    addonCompletedBy?: SortOrderInput | SortOrder
    validationStatus?: SortOrderInput | SortOrder
    needsDevValidation?: SortOrderInput | SortOrder
    isImpressionBox?: SortOrderInput | SortOrder
    deviceTypeName?: SortOrderInput | SortOrder
    taikaId?: SortOrderInput | SortOrder
    taikaDevId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    _count?: ViewFlattenedWorkbenchCountOrderByAggregateInput
    _avg?: ViewFlattenedWorkbenchAvgOrderByAggregateInput
    _max?: ViewFlattenedWorkbenchMaxOrderByAggregateInput
    _min?: ViewFlattenedWorkbenchMinOrderByAggregateInput
    _sum?: ViewFlattenedWorkbenchSumOrderByAggregateInput
  }

  export type ViewFlattenedWorkbenchScalarWhereWithAggregatesInput = {
    AND?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput | ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    OR?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    NOT?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput | ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    workbenchId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    companyId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    workbenchCreatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    companySlug?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    labelId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    trackingStatus?: EnumShippingTrackingStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.ShippingTrackingStatus | null
    createdReason?: EnumWorkbenchCreatedReasonNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: EnumOrderAuthorizationStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    productType?: EnumProductTypeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.ProductType | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isReprint?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderShoeSize?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeWidth?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    needsDevValidation?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    isImpressionBox?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
  }

  export type FacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicianCreateInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutClinicianInput
    evaluations?: EvaluationCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUncheckedCreateInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutClinicianNestedInput
    evaluations?: EvaluationUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianCreateManyInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateManyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootCreateInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootCreateManyInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    foot: FootCreateNestedOneWithoutAssetsInput
    workbenches?: WorkbenchCreateNestedManyWithoutAssetsInput
    augments?: AssetAugmentCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutAssetsInput
    augments?: AssetAugmentUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foot?: FootUpdateOneRequiredWithoutAssetsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutAssetsNestedInput
    augments?: AssetAugmentUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput
    augments?: AssetAugmentUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentCreateInput = {
    id?: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    asset: AssetCreateNestedOneWithoutAugmentsInput
    media?: AssetAugmentMediaCreateNestedManyWithoutAugmentInput
  }

  export type AssetAugmentUncheckedCreateInput = {
    id?: string
    assetId: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: AssetAugmentMediaUncheckedCreateNestedManyWithoutAugmentInput
  }

  export type AssetAugmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutAugmentsNestedInput
    media?: AssetAugmentMediaUpdateManyWithoutAugmentNestedInput
  }

  export type AssetAugmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: AssetAugmentMediaUncheckedUpdateManyWithoutAugmentNestedInput
  }

  export type AssetAugmentCreateManyInput = {
    id?: string
    assetId: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaCreateInput = {
    id?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    augment: AssetAugmentCreateNestedOneWithoutMediaInput
  }

  export type AssetAugmentMediaUncheckedCreateInput = {
    id?: string
    augmentId: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    augment?: AssetAugmentUpdateOneRequiredWithoutMediaNestedInput
  }

  export type AssetAugmentMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    augmentId?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaCreateManyInput = {
    id?: string
    augmentId: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    augmentId?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchCreateManyInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesCreateInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workbench: WorkbenchCreateNestedOneWithoutNotesInput
    createdByUser?: UserCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workbench?: WorkbenchUpdateOneRequiredWithoutNotesNestedInput
    createdByUser?: UserUpdateOneWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesCreateManyInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutOrdersInput
    shippingLabel?: ShippingLabelCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    shippingLabelId?: string | null
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutOrdersNestedInput
    shippingLabel?: ShippingLabelUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    shippingLabelId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    shippingLabelId?: string | null
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    shippingLabelId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutContactInput
    patients?: CompanyPatientCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutContactInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutContactNestedInput
    patients?: CompanyPatientUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutContactNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageCreateInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackagesInput
  }

  export type ShippingPackageUncheckedCreateInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type ShippingPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageCreateManyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingLabelCreateInput = {
    id?: string
    addressName: string
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    facility?: FacilityCreateNestedOneWithoutShippingLabelsInput
    orders?: OrderCreateNestedManyWithoutShippingLabelInput
  }

  export type ShippingLabelUncheckedCreateInput = {
    id?: string
    addressName: string
    facilityId?: string | null
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutShippingLabelInput
  }

  export type ShippingLabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneWithoutShippingLabelsNestedInput
    orders?: OrderUpdateManyWithoutShippingLabelNestedInput
  }

  export type ShippingLabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutShippingLabelNestedInput
  }

  export type ShippingLabelCreateManyInput = {
    id?: string
    addressName: string
    facilityId?: string | null
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingLabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingLabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicianCreateInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutReferringPhysicianInput
    patient?: PatientCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUncheckedCreateInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput
    patient?: PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutReferringPhysicianNestedInput
    patient?: PatientUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput
    patient?: PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianCreateManyInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisCreateManyInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeCreateInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUncheckedCreateInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeCreateManyInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTypeCreateInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
    evaluations?: EvaluationCreateNestedManyWithoutDeviceTypeInput
  }

  export type DeviceTypeUncheckedCreateInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDeviceTypeInput
  }

  export type DeviceTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
    evaluations?: EvaluationUpdateManyWithoutDeviceTypeNestedInput
  }

  export type DeviceTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutDeviceTypeNestedInput
  }

  export type DeviceTypeCreateManyInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VisitTypeCreateInput = {
    id?: string
    name: string
    evaluations?: EvaluationCreateNestedManyWithoutVisitTypeInput
  }

  export type VisitTypeUncheckedCreateInput = {
    id?: string
    name: string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutVisitTypeInput
  }

  export type VisitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    evaluations?: EvaluationUpdateManyWithoutVisitTypeNestedInput
  }

  export type VisitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutVisitTypeNestedInput
  }

  export type VisitTypeCreateManyInput = {
    id?: string
    name: string
  }

  export type VisitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VisitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FormSchemaCreateInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionCreateNestedManyWithoutSchemaInput
  }

  export type FormSchemaUncheckedCreateInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type FormSchemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUpdateManyWithoutSchemaNestedInput
  }

  export type FormSchemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type FormSchemaCreateManyInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSchemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: FormSchemaCreateNestedOneWithoutSubmissionsInput
    workbench: WorkbenchCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    schemaId: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    schemaId: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: CatalogProductCreateNestedOneWithoutAttributesInput
  }

  export type CatalogProductAttributeUncheckedCreateInput = {
    id?: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CatalogProductUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type CatalogProductAttributeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateManyInput = {
    id?: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: CatalogProductCreateNestedOneWithoutVariantsInput
  }

  export type CatalogProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CatalogProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type CatalogProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantCreateManyInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductCreateNestedManyWithoutCategoriesInput
  }

  export type CatalogCategoryUncheckedCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CatalogCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CatalogCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CatalogCategoryCreateManyInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductCreateNestedManyWithoutVendorsInput
  }

  export type CatalogVendorUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type CatalogVendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUpdateManyWithoutVendorsNestedInput
  }

  export type CatalogVendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type CatalogVendorCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsLogsInput
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsLogsNestedInput
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrinterCreateInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUncheckedCreateInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterCreateManyInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserCreateInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateInput = {
    userId: string
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserUpdateInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateManyInput = {
    userId: string
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserUpdateManyMutationInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserCreateInput = {
    id?: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepartmentsInput
    company: CompanyCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUserUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepartmentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientCreateInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPatientsInput
    patient: PatientCreateNestedOneWithoutCompaniesInput
    contact?: ContactCreateNestedOneWithoutPatientsInput
  }

  export type CompanyPatientUncheckedCreateInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type CompanyPatientUpdateInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPatientsNestedInput
    patient?: PatientUpdateOneRequiredWithoutCompaniesNestedInput
    contact?: ContactUpdateOneWithoutPatientsNestedInput
  }

  export type CompanyPatientUncheckedUpdateInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyPatientCreateManyInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type CompanyPatientUpdateManyMutationInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUncheckedUpdateManyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityPatientCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutPatientsInput
    patient: PatientCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityPatientUncheckedCreateInput = {
    patientId: string
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityPatientUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutPatientsNestedInput
    patient?: PatientUpdateOneRequiredWithoutFacilitiesNestedInput
  }

  export type FacilityPatientUncheckedUpdateInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityPatientCreateManyInput = {
    patientId: string
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityPatientUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityPatientUncheckedUpdateManyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeProductCreateInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeProductsInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeProductsInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductUncheckedCreateInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeEntityId?: string | null
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeProductsInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneWithoutStripeProductsNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeProductsNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeProductsNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductCreateManyInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeEntityId?: string | null
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceCreateInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceCreateManyInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeEntityCreateInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityCreateManyInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionCreateInput = {
    id?: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity: StripeEntityCreateNestedOneWithoutStripeSubscriptionsInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeSubscriptionInput
    stripeProducts: StripeProductCreateNestedOneWithoutStripeSubscriptionsInput
  }

  export type StripeSubscriptionUncheckedCreateInput = {
    id?: string
    stripeEntityId: string
    stripeSubscriptionId: string
    stripeProductId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeSubscriptionInput
  }

  export type StripeSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeSubscriptionNestedInput
    stripeProducts?: StripeProductUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEntityId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripeProductId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionNestedInput
  }

  export type StripeSubscriptionCreateManyInput = {
    id?: string
    stripeEntityId: string
    stripeSubscriptionId: string
    stripeProductId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEntityId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripeProductId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    responseType?: $Enums.NotificationResponseType | null
    publish?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: NotificationMessageCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    responseType?: $Enums.NotificationResponseType | null
    publish?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: NotificationMessageUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: NotificationMessageUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: NotificationMessageUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    responseType?: $Enums.NotificationResponseType | null
    publish?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationMessageCreateInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutMessagesInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutNotificationMessagesInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageUncheckedCreateInput = {
    id?: string
    notificationId: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    emailTemplateId?: string | null
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutMessagesNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutNotificationMessagesNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageCreateManyInput = {
    id?: string
    notificationId: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    emailTemplateId?: string | null
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryCreateInput = {
    id?: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutNotificationHistoryInput
    message: NotificationMessageCreateNestedOneWithoutNotificationHistoryInput
  }

  export type NotificationHistoryUncheckedCreateInput = {
    id?: string
    patientId: string
    messageId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutNotificationHistoryNestedInput
    message?: NotificationMessageUpdateOneRequiredWithoutNotificationHistoryNestedInput
  }

  export type NotificationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryCreateManyInput = {
    id?: string
    patientId: string
    messageId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    title: string
    design: JsonNullValueInput | InputJsonValue
    htmlContent: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    NotificationMessages?: NotificationMessageCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    title: string
    design: JsonNullValueInput | InputJsonValue
    htmlContent: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    NotificationMessages?: NotificationMessageUncheckedCreateNestedManyWithoutEmailTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationMessages?: NotificationMessageUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationMessages?: NotificationMessageUncheckedUpdateManyWithoutEmailTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    title: string
    design: JsonNullValueInput | InputJsonValue
    htmlContent: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateInput = {
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgreementsInput
    agreement: AgreementCreateNestedOneWithoutUserAgreementsInput
  }

  export type UserAgreementUncheckedCreateInput = {
    userId: string
    agreementId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAgreementUpdateInput = {
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgreementsNestedInput
    agreement?: AgreementUpdateOneRequiredWithoutUserAgreementsNestedInput
  }

  export type UserAgreementUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateManyInput = {
    userId: string
    agreementId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAgreementUpdateManyMutationInput = {
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementCreateInput = {
    id?: string
    type: $Enums.AgreementType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userAgreements?: UserAgreementCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUncheckedCreateInput = {
    id?: string
    type: $Enums.AgreementType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userAgreements?: UserAgreementUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgreements?: UserAgreementUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgreements?: UserAgreementUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementCreateManyInput = {
    id?: string
    type: $Enums.AgreementType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    userId: string
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    userId: string
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountVerificationCreateInput = {
    token: string
    email: string
    type: $Enums.AccountRecoveryType
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountVerificationUncheckedCreateInput = {
    token: string
    email: string
    type: $Enums.AccountRecoveryType
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountVerificationUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountRecoveryTypeFieldUpdateOperationsInput | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountVerificationUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountRecoveryTypeFieldUpdateOperationsInput | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountVerificationCreateManyInput = {
    token: string
    email: string
    type: $Enums.AccountRecoveryType
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountVerificationUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountRecoveryTypeFieldUpdateOperationsInput | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountVerificationUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountRecoveryTypeFieldUpdateOperationsInput | $Enums.AccountRecoveryType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationCreateInput = {
    id?: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvitationsInput
  }

  export type CompanyInvitationUncheckedCreateInput = {
    id?: string
    companyId: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type CompanyInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationCreateManyInput = {
    id?: string
    companyId: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    key: string
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    key: string
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewFlattenedWorkbenchCreateInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    workbenchCreatedAt?: Date | string | null
    companySlug?: string | null
    labelId?: string | null
    trackingStatus?: $Enums.ShippingTrackingStatus | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: $Enums.OrderAuthorizationStatus | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    productType?: $Enums.ProductType | null
    submittedAt?: Date | string | null
    isReprint?: boolean | null
    orderShoeSize?: string | null
    orderShoeWidth?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    needsDevValidation?: boolean | null
    isImpressionBox?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUncheckedCreateInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    workbenchCreatedAt?: Date | string | null
    companySlug?: string | null
    labelId?: string | null
    trackingStatus?: $Enums.ShippingTrackingStatus | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: $Enums.OrderAuthorizationStatus | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    productType?: $Enums.ProductType | null
    submittedAt?: Date | string | null
    isReprint?: boolean | null
    orderShoeSize?: string | null
    orderShoeWidth?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    needsDevValidation?: boolean | null
    isImpressionBox?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUpdateInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    workbenchCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingStatus?: NullableEnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: NullableEnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableEnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isReprint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeWidth?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needsDevValidation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isImpressionBox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchUncheckedUpdateInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    workbenchCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingStatus?: NullableEnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: NullableEnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableEnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isReprint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeWidth?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needsDevValidation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isImpressionBox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchCreateManyInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    workbenchCreatedAt?: Date | string | null
    companySlug?: string | null
    labelId?: string | null
    trackingStatus?: $Enums.ShippingTrackingStatus | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: $Enums.OrderAuthorizationStatus | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    productType?: $Enums.ProductType | null
    submittedAt?: Date | string | null
    isReprint?: boolean | null
    orderShoeSize?: string | null
    orderShoeWidth?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    needsDevValidation?: boolean | null
    isImpressionBox?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUpdateManyMutationInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    workbenchCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingStatus?: NullableEnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: NullableEnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableEnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isReprint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeWidth?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needsDevValidation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isImpressionBox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchUncheckedUpdateManyInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    workbenchCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    trackingStatus?: NullableEnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    orderAuthorizationStatus?: NullableEnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableEnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isReprint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeWidth?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needsDevValidation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isImpressionBox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FacilityListRelationFilter = {
    every?: FacilityWhereInput
    some?: FacilityWhereInput
    none?: FacilityWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ShippingPackageListRelationFilter = {
    every?: ShippingPackageWhereInput
    some?: ShippingPackageWhereInput
    none?: ShippingPackageWhereInput
  }

  export type CompanyUserListRelationFilter = {
    every?: CompanyUserWhereInput
    some?: CompanyUserWhereInput
    none?: CompanyUserWhereInput
  }

  export type DepartmentUserListRelationFilter = {
    every?: DepartmentUserWhereInput
    some?: DepartmentUserWhereInput
    none?: DepartmentUserWhereInput
  }

  export type CompanyPatientListRelationFilter = {
    every?: CompanyPatientWhereInput
    some?: CompanyPatientWhereInput
    none?: CompanyPatientWhereInput
  }

  export type CompanyInvitationListRelationFilter = {
    every?: CompanyInvitationWhereInput
    some?: CompanyInvitationWhereInput
    none?: CompanyInvitationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type StripeEntityListRelationFilter = {
    every?: StripeEntityWhereInput
    some?: StripeEntityWhereInput
    none?: StripeEntityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FacilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingPackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyPatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StripeEntityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    preferences?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type FacilityNullableRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type FacilityPatientListRelationFilter = {
    every?: FacilityPatientWhereInput
    some?: FacilityPatientWhereInput
    none?: FacilityPatientWhereInput
  }

  export type ShippingLabelListRelationFilter = {
    every?: ShippingLabelWhereInput
    some?: ShippingLabelWhereInput
    none?: ShippingLabelWhereInput
  }

  export type FacilityPatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    contactId?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    contactId?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    contactId?: SortOrder
  }

  export type EnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type PhysicianNullableRelationFilter = {
    is?: PhysicianWhereInput | null
    isNot?: PhysicianWhereInput | null
  }

  export type FootListRelationFilter = {
    every?: FootWhereInput
    some?: FootWhereInput
    none?: FootWhereInput
  }

  export type WorkbenchListRelationFilter = {
    every?: WorkbenchWhereInput
    some?: WorkbenchWhereInput
    none?: WorkbenchWhereInput
  }

  export type NotificationHistoryListRelationFilter = {
    every?: NotificationHistoryWhereInput
    some?: NotificationHistoryWhereInput
    none?: NotificationHistoryWhereInput
  }

  export type FootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClinicianCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicianMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicianMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeFilter<$PrismaModel> | $Enums.CareType
  }

  export type EnumSideNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableFilter<$PrismaModel> | $Enums.Side | null
  }

  export type EnumVerticalPositionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableFilter<$PrismaModel> | $Enums.VerticalPosition | null
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type DeviceTypeNullableRelationFilter = {
    is?: DeviceTypeWhereInput | null
    isNot?: DeviceTypeWhereInput | null
  }

  export type VisitTypeNullableRelationFilter = {
    is?: VisitTypeWhereInput | null
    isNot?: VisitTypeWhereInput | null
  }

  export type DiagnosisNullableRelationFilter = {
    is?: DiagnosisWhereInput | null
    isNot?: DiagnosisWhereInput | null
  }

  export type StripeInvoiceNullableRelationFilter = {
    is?: StripeInvoiceWhereInput | null
    isNot?: StripeInvoiceWhereInput | null
  }

  export type ClinicianListRelationFilter = {
    every?: ClinicianWhereInput
    some?: ClinicianWhereInput
    none?: ClinicianWhereInput
  }

  export type ClinicianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationIdCompanyIdCompoundUniqueInput = {
    id: string
    companyId: string
  }

  export type EvaluationExternalIdCompanyIdCompoundUniqueInput = {
    externalId: string
    companyId: string
  }

  export type EvaluationPoNumberCompanyIdCompoundUniqueInput = {
    poNumber: string
    companyId: string
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    stripeInvoiceId?: SortOrder
    stripeCheckoutInvoiceId?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    stripeInvoiceId?: SortOrder
    stripeCheckoutInvoiceId?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    stripeInvoiceId?: SortOrder
    stripeCheckoutInvoiceId?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTypeFilter<$PrismaModel>
  }

  export type EnumSideNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableWithAggregatesFilter<$PrismaModel> | $Enums.Side | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSideNullableFilter<$PrismaModel>
    _max?: NestedEnumSideNullableFilter<$PrismaModel>
  }

  export type EnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerticalPosition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
    _max?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
  }

  export type EnumSideFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideFilter<$PrismaModel> | $Enums.Side
  }

  export type EnumShoeWidthNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShoeWidthNullableFilter<$PrismaModel> | $Enums.ShoeWidth | null
  }

  export type EnumShoeSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemFilter<$PrismaModel> | $Enums.ShoeSystem
  }

  export type EnumInactiveFootReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel> | $Enums.InactiveFootReason | null
  }

  export type WorkbenchRelationFilter = {
    is?: WorkbenchWhereInput
    isNot?: WorkbenchWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FootCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    questionnaire?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootAvgOrderByAggregateInput = {
    shoeSize?: SortOrder
  }

  export type FootMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootSumOrderByAggregateInput = {
    shoeSize?: SortOrder
  }

  export type EnumSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideWithAggregatesFilter<$PrismaModel> | $Enums.Side
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSideFilter<$PrismaModel>
    _max?: NestedEnumSideFilter<$PrismaModel>
  }

  export type EnumShoeWidthNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShoeWidthNullableWithAggregatesFilter<$PrismaModel> | $Enums.ShoeWidth | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumShoeWidthNullableFilter<$PrismaModel>
    _max?: NestedEnumShoeWidthNullableFilter<$PrismaModel>
  }

  export type EnumShoeSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel> | $Enums.ShoeSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeSystemFilter<$PrismaModel>
    _max?: NestedEnumShoeSystemFilter<$PrismaModel>
  }

  export type EnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.InactiveFootReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type EnumAssetStatusNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel> | null
    has?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    hasSome?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FootRelationFilter = {
    is?: FootWhereInput
    isNot?: FootWhereInput
  }

  export type AssetAugmentListRelationFilter = {
    every?: AssetAugmentWhereInput
    some?: AssetAugmentWhereInput
    none?: AssetAugmentWhereInput
  }

  export type AssetAugmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type EnumAssetAugmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetAugmentType | EnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetAugmentTypeFilter<$PrismaModel> | $Enums.AssetAugmentType
  }

  export type AssetRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type AssetAugmentMediaListRelationFilter = {
    every?: AssetAugmentMediaWhereInput
    some?: AssetAugmentMediaWhereInput
    none?: AssetAugmentMediaWhereInput
  }

  export type AssetAugmentMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetAugmentCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAugmentMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAugmentMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssetAugmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetAugmentType | EnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetAugmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetAugmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetAugmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetAugmentTypeFilter<$PrismaModel>
  }

  export type AssetAugmentRelationFilter = {
    is?: AssetAugmentWhereInput
    isNot?: AssetAugmentWhereInput
  }

  export type AssetAugmentMediaCountOrderByAggregateInput = {
    id?: SortOrder
    augmentId?: SortOrder
    data?: SortOrder
    originalData?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    active?: SortOrder
    inactiveReason?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAugmentMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    augmentId?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    active?: SortOrder
    inactiveReason?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAugmentMediaMinOrderByAggregateInput = {
    id?: SortOrder
    augmentId?: SortOrder
    region?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    active?: SortOrder
    inactiveReason?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSideNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    has?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchCreatedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
  }

  export type EnumWorkbenchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusFilter<$PrismaModel> | $Enums.WorkbenchStatus
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type EvaluationRelationFilter = {
    is?: EvaluationWhereInput
    isNot?: EvaluationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type WorkbenchNotesListRelationFilter = {
    every?: WorkbenchNotesWhereInput
    some?: WorkbenchNotesWhereInput
    none?: WorkbenchNotesWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchNotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkbenchMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkbenchMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
  }

  export type EnumWorkbenchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WorkbenchNotesCountOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    blocks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkbenchNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkbenchNotesMinOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumOrderAuthorizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
  }

  export type ShippingLabelNullableRelationFilter = {
    is?: ShippingLabelWhereInput | null
    isNot?: ShippingLabelWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    shippingLabelId?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    shippingLabelId?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    shippingLabelId?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
  }

  export type EnumCarrierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableFilter<$PrismaModel> | $Enums.Carrier | null
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    phoneNumber?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    phoneNumber?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    phoneNumber?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCarrierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel> | $Enums.Carrier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCarrierNullableFilter<$PrismaModel>
    _max?: NestedEnumCarrierNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumWeightUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitFilter<$PrismaModel> | $Enums.WeightUnit
  }

  export type EnumDimensionUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitFilter<$PrismaModel> | $Enums.DimensionUnit
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ShippingPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageAvgOrderByAggregateInput = {
    weight?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    insoleCapacity?: SortOrder
  }

  export type ShippingPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageSumOrderByAggregateInput = {
    weight?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    insoleCapacity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumWeightUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel> | $Enums.WeightUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeightUnitFilter<$PrismaModel>
    _max?: NestedEnumWeightUnitFilter<$PrismaModel>
  }

  export type EnumDimensionUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumShippingTrackingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTrackingStatusFilter<$PrismaModel> | $Enums.ShippingTrackingStatus
  }

  export type ShippingLabelCountOrderByAggregateInput = {
    id?: SortOrder
    addressName?: SortOrder
    facilityId?: SortOrder
    labelId?: SortOrder
    trackingNumber?: SortOrder
    trackingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingLabelMaxOrderByAggregateInput = {
    id?: SortOrder
    addressName?: SortOrder
    facilityId?: SortOrder
    labelId?: SortOrder
    trackingNumber?: SortOrder
    trackingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingLabelMinOrderByAggregateInput = {
    id?: SortOrder
    addressName?: SortOrder
    facilityId?: SortOrder
    labelId?: SortOrder
    trackingNumber?: SortOrder
    trackingStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumShippingTrackingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTrackingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShippingTrackingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingTrackingStatusFilter<$PrismaModel>
    _max?: NestedEnumShippingTrackingStatusFilter<$PrismaModel>
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhysicianCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicianMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicianMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDiagnosisStandardFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardFilter<$PrismaModel> | $Enums.DiagnosisStandard
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDiagnosisStandardWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel> | $Enums.DiagnosisStandard
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
    _max?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
  }

  export type BillingCodeCountOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    justifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeMinOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DeviceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type DeviceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type DeviceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type VisitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VisitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VisitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumFormSchemaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel> | $Enums.FormSchemaType | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FormSchemaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSchemaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSchemaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FormSchemaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FormSchemaRelationFilter = {
    is?: FormSchemaWhereInput
    isNot?: FormSchemaWhereInput
  }

  export type FormSubmissionWorkbenchIdSchemaIdCompoundUniqueInput = {
    workbenchId: string
    schemaId: string
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeListRelationFilter = {
    every?: CatalogProductAttributeWhereInput
    some?: CatalogProductAttributeWhereInput
    none?: CatalogProductAttributeWhereInput
  }

  export type CatalogProductVariantListRelationFilter = {
    every?: CatalogProductVariantWhereInput
    some?: CatalogProductVariantWhereInput
    none?: CatalogProductVariantWhereInput
  }

  export type CatalogCategoryListRelationFilter = {
    every?: CatalogCategoryWhereInput
    some?: CatalogCategoryWhereInput
    none?: CatalogCategoryWhereInput
  }

  export type CatalogVendorListRelationFilter = {
    every?: CatalogVendorWhereInput
    some?: CatalogVendorWhereInput
    none?: CatalogVendorWhereInput
  }

  export type CatalogProductAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogVendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    favorite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    favorite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    favorite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumProductAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeFilter<$PrismaModel> | $Enums.ProductAttributeType
  }

  export type CatalogProductRelationFilter = {
    is?: CatalogProductWhereInput
    isNot?: CatalogProductWhereInput
  }

  export type CatalogProductAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
  }

  export type CatalogProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductListRelationFilter = {
    every?: CatalogProductWhereInput
    some?: CatalogProductWhereInput
    none?: CatalogProductWhereInput
  }

  export type CatalogProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    context?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type PrinterCountOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterMaxOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterMinOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type EnumCompanyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleFilter<$PrismaModel> | $Enums.CompanyRole
  }

  export type CompanyUserUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type CompanyUserCountOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserMinOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyRoleFilter<$PrismaModel>
    _max?: NestedEnumCompanyRoleFilter<$PrismaModel>
  }

  export type EnumCompanyDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyDepartment | EnumCompanyDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyDepartmentFilter<$PrismaModel> | $Enums.CompanyDepartment
  }

  export type DepartmentUserUserIdCompanyIdDepartmentCompoundUniqueInput = {
    userId: string
    companyId: string
    department: $Enums.CompanyDepartment
  }

  export type DepartmentUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    department?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    department?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    department?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanyDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyDepartment | EnumCompanyDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.CompanyDepartment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyDepartmentFilter<$PrismaModel>
    _max?: NestedEnumCompanyDepartmentFilter<$PrismaModel>
  }

  export type CompanyPatientExternalIdCompanyIdCompoundUniqueInput = {
    externalId: string
    companyId: string
  }

  export type CompanyPatientPatientIdCompanyIdCompoundUniqueInput = {
    patientId: string
    companyId: string
  }

  export type CompanyPatientCountOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type CompanyPatientMaxOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type CompanyPatientMinOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type FacilityRelationFilter = {
    is?: FacilityWhereInput
    isNot?: FacilityWhereInput
  }

  export type FacilityPatientPatientIdFacilityIdCompoundUniqueInput = {
    patientId: string
    facilityId: string
  }

  export type FacilityPatientCountOrderByAggregateInput = {
    patientId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityPatientMaxOrderByAggregateInput = {
    patientId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityPatientMinOrderByAggregateInput = {
    patientId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStripeProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeProductType | EnumStripeProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeProductTypeFilter<$PrismaModel> | $Enums.StripeProductType
  }

  export type EnumStripeBillingFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeBillingFrequency | EnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel> | $Enums.StripeBillingFrequency | null
  }

  export type StripeEntityNullableRelationFilter = {
    is?: StripeEntityWhereInput | null
    isNot?: StripeEntityWhereInput | null
  }

  export type StripeInvoiceListRelationFilter = {
    every?: StripeInvoiceWhereInput
    some?: StripeInvoiceWhereInput
    none?: StripeInvoiceWhereInput
  }

  export type StripeSubscriptionListRelationFilter = {
    every?: StripeSubscriptionWhereInput
    some?: StripeSubscriptionWhereInput
    none?: StripeSubscriptionWhereInput
  }

  export type StripeInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StripeSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StripeProductCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stripeEntityId?: SortOrder
    stripeProductId?: SortOrder
    stripePriceId?: SortOrder
    stripeCouponId?: SortOrder
    frequency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeProductAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StripeProductMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stripeEntityId?: SortOrder
    stripeProductId?: SortOrder
    stripePriceId?: SortOrder
    stripeCouponId?: SortOrder
    frequency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeProductMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stripeEntityId?: SortOrder
    stripeProductId?: SortOrder
    stripePriceId?: SortOrder
    stripeCouponId?: SortOrder
    frequency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeProductSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumStripeProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeProductType | EnumStripeProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeProductTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeProductTypeFilter<$PrismaModel>
  }

  export type EnumStripeBillingFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeBillingFrequency | EnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStripeBillingFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.StripeBillingFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel>
  }

  export type EnumStripeInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceType | EnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel> | $Enums.StripeInvoiceType
  }

  export type EnumStripeInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceStatus | EnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel> | $Enums.StripeInvoiceStatus
  }

  export type StripeProductListRelationFilter = {
    every?: StripeProductWhereInput
    some?: StripeProductWhereInput
    none?: StripeProductWhereInput
  }

  export type StripeSubscriptionNullableRelationFilter = {
    is?: StripeSubscriptionWhereInput | null
    isNot?: StripeSubscriptionWhereInput | null
  }

  export type StripeProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StripeInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    stripeInvoiceId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastWebhookId?: SortOrder
    metadata?: SortOrder
    subscriptionId?: SortOrder
    combinedInvoiceId?: SortOrder
    stripeEntityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeInvoiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type StripeInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeInvoiceId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastWebhookId?: SortOrder
    subscriptionId?: SortOrder
    combinedInvoiceId?: SortOrder
    stripeEntityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    stripeInvoiceId?: SortOrder
    price?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastWebhookId?: SortOrder
    subscriptionId?: SortOrder
    combinedInvoiceId?: SortOrder
    stripeEntityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeInvoiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumStripeInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceType | EnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeInvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumStripeInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceStatus | EnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.StripeInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumStripeEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeEntityType | EnumStripeEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeEntityTypeFilter<$PrismaModel> | $Enums.StripeEntityType
  }

  export type StripeEntityCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    stripeCustomerId?: SortOrder
    billingPreferences?: SortOrder
    autoAdvance?: SortOrder
    autoAdvanceCombined?: SortOrder
    collectionSendInvoice?: SortOrder
    active?: SortOrder
    entityParentId?: SortOrder
    stripeEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    stripeCustomerId?: SortOrder
    autoAdvance?: SortOrder
    autoAdvanceCombined?: SortOrder
    collectionSendInvoice?: SortOrder
    active?: SortOrder
    entityParentId?: SortOrder
    stripeEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeEntityMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    stripeCustomerId?: SortOrder
    autoAdvance?: SortOrder
    autoAdvanceCombined?: SortOrder
    collectionSendInvoice?: SortOrder
    active?: SortOrder
    entityParentId?: SortOrder
    stripeEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStripeEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeEntityType | EnumStripeEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeEntityTypeFilter<$PrismaModel>
  }

  export type StripeEntityRelationFilter = {
    is?: StripeEntityWhereInput
    isNot?: StripeEntityWhereInput
  }

  export type StripeProductRelationFilter = {
    is?: StripeProductWhereInput
    isNot?: StripeProductWhereInput
  }

  export type StripeSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    stripeEntityId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeEntityId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    stripeEntityId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeProductId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationResponseTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationResponseType | EnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel> | $Enums.NotificationResponseType | null
  }

  export type NotificationMessageListRelationFilter = {
    every?: NotificationMessageWhereInput
    some?: NotificationMessageWhereInput
    none?: NotificationMessageWhereInput
  }

  export type NotificationMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    publish?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    publish?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    publish?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationResponseTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationResponseType | EnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationResponseTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationResponseType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel>
  }

  export type EnumCommunicationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelFilter<$PrismaModel> | $Enums.CommunicationChannel
  }

  export type NotificationRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type EmailTemplateNullableRelationFilter = {
    is?: EmailTemplateWhereInput | null
    isNot?: EmailTemplateWhereInput | null
  }

  export type NotificationMessageNotificationIdSequenceCompoundUniqueInput = {
    notificationId: string
    sequence: number
  }

  export type NotificationMessageCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    sequence?: SortOrder
    delayMinutes?: SortOrder
    recurrencePattern?: SortOrder
    sequenceLimit?: SortOrder
    content?: SortOrder
    emailTemplateId?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMessageAvgOrderByAggregateInput = {
    sequence?: SortOrder
    delayMinutes?: SortOrder
    sequenceLimit?: SortOrder
  }

  export type NotificationMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    sequence?: SortOrder
    delayMinutes?: SortOrder
    recurrencePattern?: SortOrder
    sequenceLimit?: SortOrder
    content?: SortOrder
    emailTemplateId?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMessageMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    sequence?: SortOrder
    delayMinutes?: SortOrder
    recurrencePattern?: SortOrder
    sequenceLimit?: SortOrder
    content?: SortOrder
    emailTemplateId?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMessageSumOrderByAggregateInput = {
    sequence?: SortOrder
    delayMinutes?: SortOrder
    sequenceLimit?: SortOrder
  }

  export type EnumCommunicationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationChannelFilter<$PrismaModel>
    _max?: NestedEnumCommunicationChannelFilter<$PrismaModel>
  }

  export type NotificationMessageRelationFilter = {
    is?: NotificationMessageWhereInput
    isNot?: NotificationMessageWhereInput
  }

  export type NotificationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    messageId?: SortOrder
    sentAt?: SortOrder
    response?: SortOrder
    responseReceivedAt?: SortOrder
    removedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    messageId?: SortOrder
    sentAt?: SortOrder
    response?: SortOrder
    responseReceivedAt?: SortOrder
    removedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    messageId?: SortOrder
    sentAt?: SortOrder
    response?: SortOrder
    responseReceivedAt?: SortOrder
    removedAt?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    design?: SortOrder
    htmlContent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    htmlContent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    htmlContent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ClinicianNullableRelationFilter = {
    is?: ClinicianWhereInput | null
    isNot?: ClinicianWhereInput | null
  }

  export type UserAgreementListRelationFilter = {
    every?: UserAgreementWhereInput
    some?: UserAgreementWhereInput
    none?: UserAgreementWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type AgreementRelationFilter = {
    is?: AgreementWhereInput
    isNot?: AgreementWhereInput
  }

  export type UserAgreementUserIdAgreementIdCompoundUniqueInput = {
    userId: string
    agreementId: string
  }

  export type UserAgreementCountOrderByAggregateInput = {
    userId?: SortOrder
    agreementId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAgreementMaxOrderByAggregateInput = {
    userId?: SortOrder
    agreementId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAgreementMinOrderByAggregateInput = {
    userId?: SortOrder
    agreementId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type EnumAgreementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementType | EnumAgreementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementTypeFilter<$PrismaModel> | $Enums.AgreementType
  }

  export type AgreementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgreementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementType | EnumAgreementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgreementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementTypeFilter<$PrismaModel>
    _max?: NestedEnumAgreementTypeFilter<$PrismaModel>
  }

  export type AccountProfileIdProviderCompoundUniqueInput = {
    profileId: string
    provider: string
  }

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountRecoveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountRecoveryType | EnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel> | $Enums.AccountRecoveryType
  }

  export type AccountVerificationCountOrderByAggregateInput = {
    token?: SortOrder
    email?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountVerificationMaxOrderByAggregateInput = {
    token?: SortOrder
    email?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountVerificationMinOrderByAggregateInput = {
    token?: SortOrder
    email?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountRecoveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountRecoveryType | EnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountRecoveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountRecoveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type CompanyInvitationContactCompanyIdCompoundUniqueInput = {
    contact: string
    companyId: string
  }

  export type CompanyInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contact?: SortOrder
    contactType?: SortOrder
    role?: SortOrder
    token?: SortOrder
    verified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contact?: SortOrder
    contactType?: SortOrder
    role?: SortOrder
    token?: SortOrder
    verified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contact?: SortOrder
    contactType?: SortOrder
    role?: SortOrder
    token?: SortOrder
    verified?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type ApiKeyIdCompanyIdCompoundUniqueInput = {
    id: string
    companyId: string
  }

  export type ApiKeyKeyCompanyIdCompoundUniqueInput = {
    key: string
    companyId: string
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
  }

  export type EnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type EnumShippingTrackingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel> | $Enums.ShippingTrackingStatus | null
  }

  export type EnumOrderAuthorizationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProductTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductTypeNullableFilter<$PrismaModel> | $Enums.ProductType | null
  }

  export type ViewFlattenedWorkbenchCountOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    workbenchCreatedAt?: SortOrder
    companySlug?: SortOrder
    labelId?: SortOrder
    trackingStatus?: SortOrder
    createdReason?: SortOrder
    orderAuthorizationStatus?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    productType?: SortOrder
    submittedAt?: SortOrder
    isReprint?: SortOrder
    orderShoeSize?: SortOrder
    orderShoeWidth?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    needsDevValidation?: SortOrder
    isImpressionBox?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchAvgOrderByAggregateInput = {
    orderSide?: SortOrder
  }

  export type ViewFlattenedWorkbenchMaxOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    workbenchCreatedAt?: SortOrder
    companySlug?: SortOrder
    labelId?: SortOrder
    trackingStatus?: SortOrder
    createdReason?: SortOrder
    orderAuthorizationStatus?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    productType?: SortOrder
    submittedAt?: SortOrder
    isReprint?: SortOrder
    orderShoeSize?: SortOrder
    orderShoeWidth?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    needsDevValidation?: SortOrder
    isImpressionBox?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchMinOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    workbenchCreatedAt?: SortOrder
    companySlug?: SortOrder
    labelId?: SortOrder
    trackingStatus?: SortOrder
    createdReason?: SortOrder
    orderAuthorizationStatus?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    productType?: SortOrder
    submittedAt?: SortOrder
    isReprint?: SortOrder
    orderShoeSize?: SortOrder
    orderShoeWidth?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    needsDevValidation?: SortOrder
    isImpressionBox?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchSumOrderByAggregateInput = {
    orderSide?: SortOrder
  }

  export type EnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type EnumShippingTrackingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShippingTrackingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ShippingTrackingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel>
  }

  export type EnumOrderAuthorizationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderAuthorizationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProductTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProductType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProductTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumProductTypeNullableFilter<$PrismaModel>
  }

  export type FacilityCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ShippingPackageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DepartmentUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput> | DepartmentUserCreateWithoutCompanyInput[] | DepartmentUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutCompanyInput | DepartmentUserCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentUserCreateManyCompanyInputEnvelope
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
  }

  export type CompanyPatientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type CompanyInvitationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StripeEntityCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput> | StripeEntityCreateWithoutCompanyInput[] | StripeEntityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutCompanyInput | StripeEntityCreateOrConnectWithoutCompanyInput[]
    createMany?: StripeEntityCreateManyCompanyInputEnvelope
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput> | DepartmentUserCreateWithoutCompanyInput[] | DepartmentUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutCompanyInput | DepartmentUserCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentUserCreateManyCompanyInputEnvelope
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
  }

  export type CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StripeEntityUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput> | StripeEntityCreateWithoutCompanyInput[] | StripeEntityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutCompanyInput | StripeEntityCreateOrConnectWithoutCompanyInput[]
    createMany?: StripeEntityCreateManyCompanyInputEnvelope
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FacilityUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutCompanyInput | FacilityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutCompanyInput | FacilityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutCompanyInput | FacilityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCompanyInput | EvaluationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCompanyInput | EvaluationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCompanyInput | EvaluationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutCompanyInput | ApiKeyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutCompanyInput | ApiKeyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutCompanyInput | ApiKeyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ShippingPackageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    upsert?: ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput | ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    set?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    disconnect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    delete?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    update?: ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput | ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShippingPackageUpdateManyWithWhereWithoutCompanyInput | ShippingPackageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DepartmentUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput> | DepartmentUserCreateWithoutCompanyInput[] | DepartmentUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutCompanyInput | DepartmentUserCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUserUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentUserCreateManyCompanyInputEnvelope
    set?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    disconnect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    delete?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    update?: DepartmentUserUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUserUpdateManyWithWhereWithoutCompanyInput | DepartmentUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
  }

  export type CompanyPatientUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput | CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput | CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutCompanyInput | CompanyPatientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type CompanyInvitationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutCompanyInput | CompanyInvitationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StripeEntityUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput> | StripeEntityCreateWithoutCompanyInput[] | StripeEntityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutCompanyInput | StripeEntityCreateOrConnectWithoutCompanyInput[]
    upsert?: StripeEntityUpsertWithWhereUniqueWithoutCompanyInput | StripeEntityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StripeEntityCreateManyCompanyInputEnvelope
    set?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    disconnect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    delete?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    update?: StripeEntityUpdateWithWhereUniqueWithoutCompanyInput | StripeEntityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StripeEntityUpdateManyWithWhereWithoutCompanyInput | StripeEntityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutCompanyInput | FacilityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutCompanyInput | FacilityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutCompanyInput | FacilityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCompanyInput | EvaluationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCompanyInput | EvaluationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCompanyInput | EvaluationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutCompanyInput | ApiKeyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutCompanyInput | ApiKeyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutCompanyInput | ApiKeyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    upsert?: ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput | ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    set?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    disconnect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    delete?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    update?: ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput | ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShippingPackageUpdateManyWithWhereWithoutCompanyInput | ShippingPackageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput> | DepartmentUserCreateWithoutCompanyInput[] | DepartmentUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutCompanyInput | DepartmentUserCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUserUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentUserCreateManyCompanyInputEnvelope
    set?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    disconnect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    delete?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    update?: DepartmentUserUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUserUpdateManyWithWhereWithoutCompanyInput | DepartmentUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
  }

  export type CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput | CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput | CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutCompanyInput | CompanyPatientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutCompanyInput | CompanyInvitationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput> | StripeEntityCreateWithoutCompanyInput[] | StripeEntityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutCompanyInput | StripeEntityCreateOrConnectWithoutCompanyInput[]
    upsert?: StripeEntityUpsertWithWhereUniqueWithoutCompanyInput | StripeEntityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StripeEntityCreateManyCompanyInputEnvelope
    set?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    disconnect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    delete?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    update?: StripeEntityUpdateWithWhereUniqueWithoutCompanyInput | StripeEntityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StripeEntityUpdateManyWithWhereWithoutCompanyInput | StripeEntityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
  }

  export type FacilityCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FacilityCreateWithoutChildrenInput, FacilityUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutChildrenInput
    connect?: FacilityWhereUniqueInput
  }

  export type FacilityCreateNestedManyWithoutParentInput = {
    create?: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput> | FacilityCreateWithoutParentInput[] | FacilityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutParentInput | FacilityCreateOrConnectWithoutParentInput[]
    createMany?: FacilityCreateManyParentInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type ContactCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<ContactCreateWithoutFacilitiesInput, ContactUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFacilitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFacilitiesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FacilityPatientCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput> | FacilityPatientCreateWithoutFacilityInput[] | FacilityPatientUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutFacilityInput | FacilityPatientCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityPatientCreateManyFacilityInputEnvelope
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ShippingLabelCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput> | ShippingLabelCreateWithoutFacilityInput[] | ShippingLabelUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutFacilityInput | ShippingLabelCreateOrConnectWithoutFacilityInput[]
    createMany?: ShippingLabelCreateManyFacilityInputEnvelope
    connect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput> | FacilityCreateWithoutParentInput[] | FacilityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutParentInput | FacilityCreateOrConnectWithoutParentInput[]
    createMany?: FacilityCreateManyParentInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput> | FacilityPatientCreateWithoutFacilityInput[] | FacilityPatientUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutFacilityInput | FacilityPatientCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityPatientCreateManyFacilityInputEnvelope
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput> | ShippingLabelCreateWithoutFacilityInput[] | ShippingLabelUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutFacilityInput | ShippingLabelCreateOrConnectWithoutFacilityInput[]
    createMany?: ShippingLabelCreateManyFacilityInputEnvelope
    connect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
  }

  export type EnumFacilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.FacilityType
  }

  export type FacilityUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FacilityCreateWithoutChildrenInput, FacilityUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutChildrenInput
    upsert?: FacilityUpsertWithoutChildrenInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutChildrenInput, FacilityUpdateWithoutChildrenInput>, FacilityUncheckedUpdateWithoutChildrenInput>
  }

  export type FacilityUpdateManyWithoutParentNestedInput = {
    create?: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput> | FacilityCreateWithoutParentInput[] | FacilityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutParentInput | FacilityCreateOrConnectWithoutParentInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutParentInput | FacilityUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FacilityCreateManyParentInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutParentInput | FacilityUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutParentInput | FacilityUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type ContactUpdateOneWithoutFacilitiesNestedInput = {
    create?: XOR<ContactCreateWithoutFacilitiesInput, ContactUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFacilitiesInput
    upsert?: ContactUpsertWithoutFacilitiesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutFacilitiesInput, ContactUpdateWithoutFacilitiesInput>, ContactUncheckedUpdateWithoutFacilitiesInput>
  }

  export type CompanyUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFacilitiesInput
    upsert?: CompanyUpsertWithoutFacilitiesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFacilitiesInput, CompanyUpdateWithoutFacilitiesInput>, CompanyUncheckedUpdateWithoutFacilitiesInput>
  }

  export type FacilityPatientUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput> | FacilityPatientCreateWithoutFacilityInput[] | FacilityPatientUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutFacilityInput | FacilityPatientCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityPatientUpsertWithWhereUniqueWithoutFacilityInput | FacilityPatientUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityPatientCreateManyFacilityInputEnvelope
    set?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    disconnect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    delete?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    update?: FacilityPatientUpdateWithWhereUniqueWithoutFacilityInput | FacilityPatientUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityPatientUpdateManyWithWhereWithoutFacilityInput | FacilityPatientUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutFacilityInput | EvaluationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutFacilityInput | EvaluationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutFacilityInput | EvaluationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ShippingLabelUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput> | ShippingLabelCreateWithoutFacilityInput[] | ShippingLabelUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutFacilityInput | ShippingLabelCreateOrConnectWithoutFacilityInput[]
    upsert?: ShippingLabelUpsertWithWhereUniqueWithoutFacilityInput | ShippingLabelUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ShippingLabelCreateManyFacilityInputEnvelope
    set?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    disconnect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    delete?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    connect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    update?: ShippingLabelUpdateWithWhereUniqueWithoutFacilityInput | ShippingLabelUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ShippingLabelUpdateManyWithWhereWithoutFacilityInput | ShippingLabelUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ShippingLabelScalarWhereInput | ShippingLabelScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput> | FacilityCreateWithoutParentInput[] | FacilityUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutParentInput | FacilityCreateOrConnectWithoutParentInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutParentInput | FacilityUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FacilityCreateManyParentInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutParentInput | FacilityUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutParentInput | FacilityUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput> | FacilityPatientCreateWithoutFacilityInput[] | FacilityPatientUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutFacilityInput | FacilityPatientCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityPatientUpsertWithWhereUniqueWithoutFacilityInput | FacilityPatientUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityPatientCreateManyFacilityInputEnvelope
    set?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    disconnect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    delete?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    update?: FacilityPatientUpdateWithWhereUniqueWithoutFacilityInput | FacilityPatientUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityPatientUpdateManyWithWhereWithoutFacilityInput | FacilityPatientUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutFacilityInput | EvaluationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutFacilityInput | EvaluationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutFacilityInput | EvaluationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput> | ShippingLabelCreateWithoutFacilityInput[] | ShippingLabelUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutFacilityInput | ShippingLabelCreateOrConnectWithoutFacilityInput[]
    upsert?: ShippingLabelUpsertWithWhereUniqueWithoutFacilityInput | ShippingLabelUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ShippingLabelCreateManyFacilityInputEnvelope
    set?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    disconnect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    delete?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    connect?: ShippingLabelWhereUniqueInput | ShippingLabelWhereUniqueInput[]
    update?: ShippingLabelUpdateWithWhereUniqueWithoutFacilityInput | ShippingLabelUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ShippingLabelUpdateManyWithWhereWithoutFacilityInput | ShippingLabelUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ShippingLabelScalarWhereInput | ShippingLabelScalarWhereInput[]
  }

  export type PhysicianCreateNestedOneWithoutPatientInput = {
    create?: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPatientInput
    connect?: PhysicianWhereUniqueInput
  }

  export type FootCreateNestedManyWithoutPatientInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutPatientInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutPatientInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type CompanyPatientCreateNestedManyWithoutPatientInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type NotificationHistoryCreateNestedManyWithoutPatientInput = {
    create?: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput> | NotificationHistoryCreateWithoutPatientInput[] | NotificationHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutPatientInput | NotificationHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: NotificationHistoryCreateManyPatientInputEnvelope
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
  }

  export type FacilityPatientCreateNestedManyWithoutPatientInput = {
    create?: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput> | FacilityPatientCreateWithoutPatientInput[] | FacilityPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutPatientInput | FacilityPatientCreateOrConnectWithoutPatientInput[]
    createMany?: FacilityPatientCreateManyPatientInputEnvelope
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
  }

  export type FootUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type CompanyPatientUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput> | NotificationHistoryCreateWithoutPatientInput[] | NotificationHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutPatientInput | NotificationHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: NotificationHistoryCreateManyPatientInputEnvelope
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
  }

  export type FacilityPatientUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput> | FacilityPatientCreateWithoutPatientInput[] | FacilityPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutPatientInput | FacilityPatientCreateOrConnectWithoutPatientInput[]
    createMany?: FacilityPatientCreateManyPatientInputEnvelope
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type PhysicianUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPatientInput
    upsert?: PhysicianUpsertWithoutPatientInput
    disconnect?: PhysicianWhereInput | boolean
    delete?: PhysicianWhereInput | boolean
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutPatientInput, PhysicianUpdateWithoutPatientInput>, PhysicianUncheckedUpdateWithoutPatientInput>
  }

  export type FootUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutPatientInput | FootUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutPatientInput | FootUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FootUpdateManyWithWhereWithoutPatientInput | FootUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPatientInput | EvaluationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPatientInput | EvaluationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPatientInput | EvaluationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutPatientNestedInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutPatientInput | WorkbenchUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutPatientInput | WorkbenchUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutPatientInput | WorkbenchUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type CompanyPatientUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutPatientInput | CompanyPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutPatientInput | CompanyPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutPatientInput | CompanyPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type NotificationHistoryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput> | NotificationHistoryCreateWithoutPatientInput[] | NotificationHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutPatientInput | NotificationHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: NotificationHistoryUpsertWithWhereUniqueWithoutPatientInput | NotificationHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: NotificationHistoryCreateManyPatientInputEnvelope
    set?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    disconnect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    delete?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    update?: NotificationHistoryUpdateWithWhereUniqueWithoutPatientInput | NotificationHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: NotificationHistoryUpdateManyWithWhereWithoutPatientInput | NotificationHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
  }

  export type FacilityPatientUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput> | FacilityPatientCreateWithoutPatientInput[] | FacilityPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutPatientInput | FacilityPatientCreateOrConnectWithoutPatientInput[]
    upsert?: FacilityPatientUpsertWithWhereUniqueWithoutPatientInput | FacilityPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FacilityPatientCreateManyPatientInputEnvelope
    set?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    disconnect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    delete?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    update?: FacilityPatientUpdateWithWhereUniqueWithoutPatientInput | FacilityPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FacilityPatientUpdateManyWithWhereWithoutPatientInput | FacilityPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
  }

  export type FootUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutPatientInput | FootUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutPatientInput | FootUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FootUpdateManyWithWhereWithoutPatientInput | FootUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPatientInput | EvaluationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPatientInput | EvaluationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPatientInput | EvaluationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutPatientInput | WorkbenchUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutPatientInput | WorkbenchUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutPatientInput | WorkbenchUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutPatientInput | CompanyPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutPatientInput | CompanyPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutPatientInput | CompanyPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput> | NotificationHistoryCreateWithoutPatientInput[] | NotificationHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutPatientInput | NotificationHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: NotificationHistoryUpsertWithWhereUniqueWithoutPatientInput | NotificationHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: NotificationHistoryCreateManyPatientInputEnvelope
    set?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    disconnect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    delete?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    update?: NotificationHistoryUpdateWithWhereUniqueWithoutPatientInput | NotificationHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: NotificationHistoryUpdateManyWithWhereWithoutPatientInput | NotificationHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
  }

  export type FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput> | FacilityPatientCreateWithoutPatientInput[] | FacilityPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FacilityPatientCreateOrConnectWithoutPatientInput | FacilityPatientCreateOrConnectWithoutPatientInput[]
    upsert?: FacilityPatientUpsertWithWhereUniqueWithoutPatientInput | FacilityPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FacilityPatientCreateManyPatientInputEnvelope
    set?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    disconnect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    delete?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    connect?: FacilityPatientWhereUniqueInput | FacilityPatientWhereUniqueInput[]
    update?: FacilityPatientUpdateWithWhereUniqueWithoutPatientInput | FacilityPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FacilityPatientUpdateManyWithWhereWithoutPatientInput | FacilityPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClinicianInput = {
    create?: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicianInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutCliniciansInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutCliniciansInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutClinicianNestedInput = {
    create?: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicianInput
    upsert?: UserUpsertWithoutClinicianInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinicianInput, UserUpdateWithoutClinicianInput>, UserUncheckedUpdateWithoutClinicianInput>
  }

  export type EvaluationUpdateManyWithoutCliniciansNestedInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCliniciansInput | EvaluationUpsertWithWhereUniqueWithoutCliniciansInput[]
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCliniciansInput | EvaluationUpdateWithWhereUniqueWithoutCliniciansInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCliniciansInput | EvaluationUpdateManyWithWhereWithoutCliniciansInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCliniciansInput | EvaluationUpsertWithWhereUniqueWithoutCliniciansInput[]
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCliniciansInput | EvaluationUpdateWithWhereUniqueWithoutCliniciansInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCliniciansInput | EvaluationUpdateManyWithWhereWithoutCliniciansInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEvaluationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DeviceTypeCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DeviceTypeCreateOrConnectWithoutEvaluationsInput
    connect?: DeviceTypeWhereUniqueInput
  }

  export type VisitTypeCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutEvaluationsInput
    connect?: VisitTypeWhereUniqueInput
  }

  export type PhysicianCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutEvaluationsInput
    connect?: PhysicianWhereUniqueInput
  }

  export type DiagnosisCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEvaluationsInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type FacilityCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEvaluationsInput
    connect?: FacilityWhereUniqueInput
  }

  export type StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput = {
    create?: XOR<StripeInvoiceCreateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedCreateWithoutEmployerEvaluationsInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutEmployerEvaluationsInput
    connect?: StripeInvoiceWhereUniqueInput
  }

  export type StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput = {
    create?: XOR<StripeInvoiceCreateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedCreateWithoutCheckoutEvaluationsInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCheckoutEvaluationsInput
    connect?: StripeInvoiceWhereUniqueInput
  }

  export type ClinicianCreateNestedManyWithoutEvaluationsInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type EnumCareTypeFieldUpdateOperationsInput = {
    set?: $Enums.CareType
  }

  export type NullableEnumSideFieldUpdateOperationsInput = {
    set?: $Enums.Side | null
  }

  export type NullableEnumVerticalPositionFieldUpdateOperationsInput = {
    set?: $Enums.VerticalPosition | null
  }

  export type PatientUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    upsert?: PatientUpsertWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEvaluationsInput, PatientUpdateWithoutEvaluationsInput>, PatientUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CompanyUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEvaluationsInput
    upsert?: CompanyUpsertWithoutEvaluationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEvaluationsInput, CompanyUpdateWithoutEvaluationsInput>, CompanyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DeviceTypeUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DeviceTypeCreateOrConnectWithoutEvaluationsInput
    upsert?: DeviceTypeUpsertWithoutEvaluationsInput
    disconnect?: DeviceTypeWhereInput | boolean
    delete?: DeviceTypeWhereInput | boolean
    connect?: DeviceTypeWhereUniqueInput
    update?: XOR<XOR<DeviceTypeUpdateToOneWithWhereWithoutEvaluationsInput, DeviceTypeUpdateWithoutEvaluationsInput>, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type VisitTypeUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutEvaluationsInput
    upsert?: VisitTypeUpsertWithoutEvaluationsInput
    disconnect?: VisitTypeWhereInput | boolean
    delete?: VisitTypeWhereInput | boolean
    connect?: VisitTypeWhereUniqueInput
    update?: XOR<XOR<VisitTypeUpdateToOneWithWhereWithoutEvaluationsInput, VisitTypeUpdateWithoutEvaluationsInput>, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PhysicianUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutEvaluationsInput
    upsert?: PhysicianUpsertWithoutEvaluationsInput
    disconnect?: PhysicianWhereInput | boolean
    delete?: PhysicianWhereInput | boolean
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutEvaluationsInput, PhysicianUpdateWithoutEvaluationsInput>, PhysicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DiagnosisUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEvaluationsInput
    upsert?: DiagnosisUpsertWithoutEvaluationsInput
    disconnect?: DiagnosisWhereInput | boolean
    delete?: DiagnosisWhereInput | boolean
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutEvaluationsInput, DiagnosisUpdateWithoutEvaluationsInput>, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
  }

  export type FacilityUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEvaluationsInput
    upsert?: FacilityUpsertWithoutEvaluationsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutEvaluationsInput, FacilityUpdateWithoutEvaluationsInput>, FacilityUncheckedUpdateWithoutEvaluationsInput>
  }

  export type StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedCreateWithoutEmployerEvaluationsInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutEmployerEvaluationsInput
    upsert?: StripeInvoiceUpsertWithoutEmployerEvaluationsInput
    disconnect?: StripeInvoiceWhereInput | boolean
    delete?: StripeInvoiceWhereInput | boolean
    connect?: StripeInvoiceWhereUniqueInput
    update?: XOR<XOR<StripeInvoiceUpdateToOneWithWhereWithoutEmployerEvaluationsInput, StripeInvoiceUpdateWithoutEmployerEvaluationsInput>, StripeInvoiceUncheckedUpdateWithoutEmployerEvaluationsInput>
  }

  export type StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedCreateWithoutCheckoutEvaluationsInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCheckoutEvaluationsInput
    upsert?: StripeInvoiceUpsertWithoutCheckoutEvaluationsInput
    disconnect?: StripeInvoiceWhereInput | boolean
    delete?: StripeInvoiceWhereInput | boolean
    connect?: StripeInvoiceWhereUniqueInput
    update?: XOR<XOR<StripeInvoiceUpdateToOneWithWhereWithoutCheckoutEvaluationsInput, StripeInvoiceUpdateWithoutCheckoutEvaluationsInput>, StripeInvoiceUncheckedUpdateWithoutCheckoutEvaluationsInput>
  }

  export type ClinicianUpdateManyWithoutEvaluationsNestedInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    upsert?: ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput | ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput[]
    set?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    disconnect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    delete?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    update?: ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput | ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput[]
    updateMany?: ClinicianUpdateManyWithWhereWithoutEvaluationsInput | ClinicianUpdateManyWithWhereWithoutEvaluationsInput[]
    deleteMany?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput | WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput | WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutEvaluationInput | WorkbenchUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    upsert?: ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput | ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput[]
    set?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    disconnect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    delete?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    update?: ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput | ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput[]
    updateMany?: ClinicianUpdateManyWithWhereWithoutEvaluationsInput | ClinicianUpdateManyWithWhereWithoutEvaluationsInput[]
    deleteMany?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput | WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput | WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutEvaluationInput | WorkbenchUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutFeetInput = {
    create?: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFeetInput
    connect?: PatientWhereUniqueInput
  }

  export type WorkbenchCreateNestedOneWithoutFeetInput = {
    create?: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFeetInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutFootInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutFootInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type EnumSideFieldUpdateOperationsInput = {
    set?: $Enums.Side
  }

  export type NullableEnumShoeWidthFieldUpdateOperationsInput = {
    set?: $Enums.ShoeWidth | null
  }

  export type EnumShoeSystemFieldUpdateOperationsInput = {
    set?: $Enums.ShoeSystem
  }

  export type NullableEnumInactiveFootReasonFieldUpdateOperationsInput = {
    set?: $Enums.InactiveFootReason | null
  }

  export type PatientUpdateOneRequiredWithoutFeetNestedInput = {
    create?: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFeetInput
    upsert?: PatientUpsertWithoutFeetInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutFeetInput, PatientUpdateWithoutFeetInput>, PatientUncheckedUpdateWithoutFeetInput>
  }

  export type WorkbenchUpdateOneRequiredWithoutFeetNestedInput = {
    create?: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFeetInput
    upsert?: WorkbenchUpsertWithoutFeetInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutFeetInput, WorkbenchUpdateWithoutFeetInput>, WorkbenchUncheckedUpdateWithoutFeetInput>
  }

  export type AssetUpdateManyWithoutFootNestedInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutFootInput | AssetUpsertWithWhereUniqueWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutFootInput | AssetUpdateWithWhereUniqueWithoutFootInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutFootInput | AssetUpdateManyWithWhereWithoutFootInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutFootNestedInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutFootInput | AssetUpsertWithWhereUniqueWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutFootInput | AssetUpdateWithWhereUniqueWithoutFootInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutFootInput | AssetUpdateManyWithWhereWithoutFootInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCreatestatusCheckpointsInput = {
    set: $Enums.AssetStatus[]
  }

  export type FootCreateNestedOneWithoutAssetsInput = {
    create?: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: FootCreateOrConnectWithoutAssetsInput
    connect?: FootWhereUniqueInput
  }

  export type WorkbenchCreateNestedManyWithoutAssetsInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type AssetAugmentCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput> | AssetAugmentCreateWithoutAssetInput[] | AssetAugmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutAssetInput | AssetAugmentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAugmentCreateManyAssetInputEnvelope
    connect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type AssetAugmentUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput> | AssetAugmentCreateWithoutAssetInput[] | AssetAugmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutAssetInput | AssetAugmentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAugmentCreateManyAssetInputEnvelope
    connect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type AssetUpdatestatusCheckpointsInput = {
    set?: $Enums.AssetStatus[]
    push?: $Enums.AssetStatus | $Enums.AssetStatus[]
  }

  export type FootUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: FootCreateOrConnectWithoutAssetsInput
    upsert?: FootUpsertWithoutAssetsInput
    connect?: FootWhereUniqueInput
    update?: XOR<XOR<FootUpdateToOneWithWhereWithoutAssetsInput, FootUpdateWithoutAssetsInput>, FootUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkbenchUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutAssetsInput | WorkbenchUpsertWithWhereUniqueWithoutAssetsInput[]
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutAssetsInput | WorkbenchUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutAssetsInput | WorkbenchUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type AssetAugmentUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput> | AssetAugmentCreateWithoutAssetInput[] | AssetAugmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutAssetInput | AssetAugmentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAugmentUpsertWithWhereUniqueWithoutAssetInput | AssetAugmentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAugmentCreateManyAssetInputEnvelope
    set?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    disconnect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    delete?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    connect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    update?: AssetAugmentUpdateWithWhereUniqueWithoutAssetInput | AssetAugmentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAugmentUpdateManyWithWhereWithoutAssetInput | AssetAugmentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAugmentScalarWhereInput | AssetAugmentScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutAssetsInput | WorkbenchUpsertWithWhereUniqueWithoutAssetsInput[]
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutAssetsInput | WorkbenchUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutAssetsInput | WorkbenchUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type AssetAugmentUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput> | AssetAugmentCreateWithoutAssetInput[] | AssetAugmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutAssetInput | AssetAugmentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAugmentUpsertWithWhereUniqueWithoutAssetInput | AssetAugmentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAugmentCreateManyAssetInputEnvelope
    set?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    disconnect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    delete?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    connect?: AssetAugmentWhereUniqueInput | AssetAugmentWhereUniqueInput[]
    update?: AssetAugmentUpdateWithWhereUniqueWithoutAssetInput | AssetAugmentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAugmentUpdateManyWithWhereWithoutAssetInput | AssetAugmentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAugmentScalarWhereInput | AssetAugmentScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAugmentsInput = {
    create?: XOR<AssetCreateWithoutAugmentsInput, AssetUncheckedCreateWithoutAugmentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAugmentsInput
    connect?: AssetWhereUniqueInput
  }

  export type AssetAugmentMediaCreateNestedManyWithoutAugmentInput = {
    create?: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput> | AssetAugmentMediaCreateWithoutAugmentInput[] | AssetAugmentMediaUncheckedCreateWithoutAugmentInput[]
    connectOrCreate?: AssetAugmentMediaCreateOrConnectWithoutAugmentInput | AssetAugmentMediaCreateOrConnectWithoutAugmentInput[]
    createMany?: AssetAugmentMediaCreateManyAugmentInputEnvelope
    connect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
  }

  export type AssetAugmentMediaUncheckedCreateNestedManyWithoutAugmentInput = {
    create?: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput> | AssetAugmentMediaCreateWithoutAugmentInput[] | AssetAugmentMediaUncheckedCreateWithoutAugmentInput[]
    connectOrCreate?: AssetAugmentMediaCreateOrConnectWithoutAugmentInput | AssetAugmentMediaCreateOrConnectWithoutAugmentInput[]
    createMany?: AssetAugmentMediaCreateManyAugmentInputEnvelope
    connect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
  }

  export type EnumAssetAugmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssetAugmentType
  }

  export type AssetUpdateOneRequiredWithoutAugmentsNestedInput = {
    create?: XOR<AssetCreateWithoutAugmentsInput, AssetUncheckedCreateWithoutAugmentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAugmentsInput
    upsert?: AssetUpsertWithoutAugmentsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAugmentsInput, AssetUpdateWithoutAugmentsInput>, AssetUncheckedUpdateWithoutAugmentsInput>
  }

  export type AssetAugmentMediaUpdateManyWithoutAugmentNestedInput = {
    create?: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput> | AssetAugmentMediaCreateWithoutAugmentInput[] | AssetAugmentMediaUncheckedCreateWithoutAugmentInput[]
    connectOrCreate?: AssetAugmentMediaCreateOrConnectWithoutAugmentInput | AssetAugmentMediaCreateOrConnectWithoutAugmentInput[]
    upsert?: AssetAugmentMediaUpsertWithWhereUniqueWithoutAugmentInput | AssetAugmentMediaUpsertWithWhereUniqueWithoutAugmentInput[]
    createMany?: AssetAugmentMediaCreateManyAugmentInputEnvelope
    set?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    disconnect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    delete?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    connect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    update?: AssetAugmentMediaUpdateWithWhereUniqueWithoutAugmentInput | AssetAugmentMediaUpdateWithWhereUniqueWithoutAugmentInput[]
    updateMany?: AssetAugmentMediaUpdateManyWithWhereWithoutAugmentInput | AssetAugmentMediaUpdateManyWithWhereWithoutAugmentInput[]
    deleteMany?: AssetAugmentMediaScalarWhereInput | AssetAugmentMediaScalarWhereInput[]
  }

  export type AssetAugmentMediaUncheckedUpdateManyWithoutAugmentNestedInput = {
    create?: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput> | AssetAugmentMediaCreateWithoutAugmentInput[] | AssetAugmentMediaUncheckedCreateWithoutAugmentInput[]
    connectOrCreate?: AssetAugmentMediaCreateOrConnectWithoutAugmentInput | AssetAugmentMediaCreateOrConnectWithoutAugmentInput[]
    upsert?: AssetAugmentMediaUpsertWithWhereUniqueWithoutAugmentInput | AssetAugmentMediaUpsertWithWhereUniqueWithoutAugmentInput[]
    createMany?: AssetAugmentMediaCreateManyAugmentInputEnvelope
    set?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    disconnect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    delete?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    connect?: AssetAugmentMediaWhereUniqueInput | AssetAugmentMediaWhereUniqueInput[]
    update?: AssetAugmentMediaUpdateWithWhereUniqueWithoutAugmentInput | AssetAugmentMediaUpdateWithWhereUniqueWithoutAugmentInput[]
    updateMany?: AssetAugmentMediaUpdateManyWithWhereWithoutAugmentInput | AssetAugmentMediaUpdateManyWithWhereWithoutAugmentInput[]
    deleteMany?: AssetAugmentMediaScalarWhereInput | AssetAugmentMediaScalarWhereInput[]
  }

  export type AssetAugmentCreateNestedOneWithoutMediaInput = {
    create?: XOR<AssetAugmentCreateWithoutMediaInput, AssetAugmentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutMediaInput
    connect?: AssetAugmentWhereUniqueInput
  }

  export type AssetAugmentUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<AssetAugmentCreateWithoutMediaInput, AssetAugmentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: AssetAugmentCreateOrConnectWithoutMediaInput
    upsert?: AssetAugmentUpsertWithoutMediaInput
    connect?: AssetAugmentWhereUniqueInput
    update?: XOR<XOR<AssetAugmentUpdateToOneWithWhereWithoutMediaInput, AssetAugmentUpdateWithoutMediaInput>, AssetAugmentUncheckedUpdateWithoutMediaInput>
  }

  export type ProductCreatesidesInput = {
    set: $Enums.Side[]
  }

  export type ProductCreateNestedManyWithoutUsedByProductsInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBuildingBlocksInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUsedByProductsInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ProductUpdatesidesInput = {
    set?: $Enums.Side[]
    push?: $Enums.Side | $Enums.Side[]
  }

  export type ProductUpdateManyWithoutUsedByProductsNestedInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUsedByProductsInput | ProductUpsertWithWhereUniqueWithoutUsedByProductsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUsedByProductsInput | ProductUpdateWithWhereUniqueWithoutUsedByProductsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUsedByProductsInput | ProductUpdateManyWithWhereWithoutUsedByProductsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBuildingBlocksNestedInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput | ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput | ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBuildingBlocksInput | ProductUpdateManyWithWhereWithoutBuildingBlocksInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutProductInput | WorkbenchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutProductInput | WorkbenchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutProductInput | WorkbenchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUsedByProductsInput | ProductUpsertWithWhereUniqueWithoutUsedByProductsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUsedByProductsInput | ProductUpdateWithWhereUniqueWithoutUsedByProductsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUsedByProductsInput | ProductUpdateManyWithWhereWithoutUsedByProductsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput | ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput | ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBuildingBlocksInput | ProductUpdateManyWithWhereWithoutBuildingBlocksInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutProductInput | WorkbenchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutProductInput | WorkbenchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutProductInput | WorkbenchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutWorkbenchesInput
    connect?: PatientWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWorkbenchesInput
    connect?: ProductWhereUniqueInput
  }

  export type EvaluationCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutWorkbenchesInput
    connect?: EvaluationWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutWorkbenchesInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FootCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type WorkbenchNotesCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutWorkbenchesInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FootUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchCreatedReason | null
  }

  export type EnumWorkbenchStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchStatus
  }

  export type PatientUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutWorkbenchesInput
    upsert?: PatientUpsertWithoutWorkbenchesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutWorkbenchesInput, PatientUpdateWithoutWorkbenchesInput>, PatientUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type ProductUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWorkbenchesInput
    upsert?: ProductUpsertWithoutWorkbenchesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWorkbenchesInput, ProductUpdateWithoutWorkbenchesInput>, ProductUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutWorkbenchesInput
    upsert?: EvaluationUpsertWithoutWorkbenchesInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutWorkbenchesInput, EvaluationUpdateWithoutWorkbenchesInput>, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type AssetUpdateManyWithoutWorkbenchesNestedInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkbenchesInput | AssetUpsertWithWhereUniqueWithoutWorkbenchesInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkbenchesInput | AssetUpdateWithWhereUniqueWithoutWorkbenchesInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkbenchesInput | AssetUpdateManyWithWhereWithoutWorkbenchesInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkbenchInput | OrderUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkbenchInput | OrderUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkbenchInput | OrderUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FootUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutWorkbenchInput | FootUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutWorkbenchInput | FootUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FootUpdateManyWithWhereWithoutWorkbenchInput | FootUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput | FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput | WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkbenchesInput | AssetUpsertWithWhereUniqueWithoutWorkbenchesInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkbenchesInput | AssetUpdateWithWhereUniqueWithoutWorkbenchesInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkbenchesInput | AssetUpdateManyWithWhereWithoutWorkbenchesInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkbenchInput | OrderUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkbenchInput | OrderUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkbenchInput | OrderUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FootUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutWorkbenchInput | FootUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutWorkbenchInput | FootUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FootUpdateManyWithWhereWithoutWorkbenchInput | FootUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput | FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput | WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type WorkbenchNotesCreatetagsInput = {
    set: string[]
  }

  export type WorkbenchCreateNestedOneWithoutNotesInput = {
    create?: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutNotesInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkbenchNotesUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkbenchUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutNotesInput
    upsert?: WorkbenchUpsertWithoutNotesInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutNotesInput, WorkbenchUpdateWithoutNotesInput>, WorkbenchUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type WorkbenchCreateNestedOneWithoutOrdersInput = {
    create?: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutOrdersInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type ShippingLabelCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ShippingLabelCreateWithoutOrdersInput, ShippingLabelUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutOrdersInput
    connect?: ShippingLabelWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumOrderAuthorizationStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderAuthorizationStatus
  }

  export type WorkbenchUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutOrdersInput
    upsert?: WorkbenchUpsertWithoutOrdersInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutOrdersInput, WorkbenchUpdateWithoutOrdersInput>, WorkbenchUncheckedUpdateWithoutOrdersInput>
  }

  export type ShippingLabelUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ShippingLabelCreateWithoutOrdersInput, ShippingLabelUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShippingLabelCreateOrConnectWithoutOrdersInput
    upsert?: ShippingLabelUpsertWithoutOrdersInput
    disconnect?: ShippingLabelWhereInput | boolean
    delete?: ShippingLabelWhereInput | boolean
    connect?: ShippingLabelWhereUniqueInput
    update?: XOR<XOR<ShippingLabelUpdateToOneWithWhereWithoutOrdersInput, ShippingLabelUpdateWithoutOrdersInput>, ShippingLabelUncheckedUpdateWithoutOrdersInput>
  }

  export type FacilityCreateNestedManyWithoutContactInput = {
    create?: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput> | FacilityCreateWithoutContactInput[] | FacilityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutContactInput | FacilityCreateOrConnectWithoutContactInput[]
    createMany?: FacilityCreateManyContactInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type CompanyPatientCreateNestedManyWithoutContactInput = {
    create?: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput> | CompanyPatientCreateWithoutContactInput[] | CompanyPatientUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutContactInput | CompanyPatientCreateOrConnectWithoutContactInput[]
    createMany?: CompanyPatientCreateManyContactInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput> | FacilityCreateWithoutContactInput[] | FacilityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutContactInput | FacilityCreateOrConnectWithoutContactInput[]
    createMany?: FacilityCreateManyContactInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type CompanyPatientUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput> | CompanyPatientCreateWithoutContactInput[] | CompanyPatientUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutContactInput | CompanyPatientCreateOrConnectWithoutContactInput[]
    createMany?: CompanyPatientCreateManyContactInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type NullableEnumCarrierFieldUpdateOperationsInput = {
    set?: $Enums.Carrier | null
  }

  export type FacilityUpdateManyWithoutContactNestedInput = {
    create?: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput> | FacilityCreateWithoutContactInput[] | FacilityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutContactInput | FacilityCreateOrConnectWithoutContactInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutContactInput | FacilityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: FacilityCreateManyContactInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutContactInput | FacilityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutContactInput | FacilityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type CompanyPatientUpdateManyWithoutContactNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput> | CompanyPatientCreateWithoutContactInput[] | CompanyPatientUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutContactInput | CompanyPatientCreateOrConnectWithoutContactInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutContactInput | CompanyPatientUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CompanyPatientCreateManyContactInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutContactInput | CompanyPatientUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutContactInput | CompanyPatientUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput> | FacilityCreateWithoutContactInput[] | FacilityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutContactInput | FacilityCreateOrConnectWithoutContactInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutContactInput | FacilityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: FacilityCreateManyContactInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutContactInput | FacilityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutContactInput | FacilityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type CompanyPatientUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput> | CompanyPatientCreateWithoutContactInput[] | CompanyPatientUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutContactInput | CompanyPatientCreateOrConnectWithoutContactInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutContactInput | CompanyPatientUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CompanyPatientCreateManyContactInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutContactInput | CompanyPatientUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutContactInput | CompanyPatientUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPackagesInput = {
    create?: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackagesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumWeightUnitFieldUpdateOperationsInput = {
    set?: $Enums.WeightUnit
  }

  export type EnumDimensionUnitFieldUpdateOperationsInput = {
    set?: $Enums.DimensionUnit
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackagesInput
    upsert?: CompanyUpsertWithoutPackagesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPackagesInput, CompanyUpdateWithoutPackagesInput>, CompanyUncheckedUpdateWithoutPackagesInput>
  }

  export type FacilityCreateNestedOneWithoutShippingLabelsInput = {
    create?: XOR<FacilityCreateWithoutShippingLabelsInput, FacilityUncheckedCreateWithoutShippingLabelsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutShippingLabelsInput
    connect?: FacilityWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutShippingLabelInput = {
    create?: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput> | OrderCreateWithoutShippingLabelInput[] | OrderUncheckedCreateWithoutShippingLabelInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShippingLabelInput | OrderCreateOrConnectWithoutShippingLabelInput[]
    createMany?: OrderCreateManyShippingLabelInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutShippingLabelInput = {
    create?: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput> | OrderCreateWithoutShippingLabelInput[] | OrderUncheckedCreateWithoutShippingLabelInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShippingLabelInput | OrderCreateOrConnectWithoutShippingLabelInput[]
    createMany?: OrderCreateManyShippingLabelInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnumShippingTrackingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShippingTrackingStatus
  }

  export type FacilityUpdateOneWithoutShippingLabelsNestedInput = {
    create?: XOR<FacilityCreateWithoutShippingLabelsInput, FacilityUncheckedCreateWithoutShippingLabelsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutShippingLabelsInput
    upsert?: FacilityUpsertWithoutShippingLabelsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutShippingLabelsInput, FacilityUpdateWithoutShippingLabelsInput>, FacilityUncheckedUpdateWithoutShippingLabelsInput>
  }

  export type OrderUpdateManyWithoutShippingLabelNestedInput = {
    create?: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput> | OrderCreateWithoutShippingLabelInput[] | OrderUncheckedCreateWithoutShippingLabelInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShippingLabelInput | OrderCreateOrConnectWithoutShippingLabelInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShippingLabelInput | OrderUpsertWithWhereUniqueWithoutShippingLabelInput[]
    createMany?: OrderCreateManyShippingLabelInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShippingLabelInput | OrderUpdateWithWhereUniqueWithoutShippingLabelInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShippingLabelInput | OrderUpdateManyWithWhereWithoutShippingLabelInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutShippingLabelNestedInput = {
    create?: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput> | OrderCreateWithoutShippingLabelInput[] | OrderUncheckedCreateWithoutShippingLabelInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShippingLabelInput | OrderCreateOrConnectWithoutShippingLabelInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShippingLabelInput | OrderUpsertWithWhereUniqueWithoutShippingLabelInput[]
    createMany?: OrderCreateManyShippingLabelInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShippingLabelInput | OrderUpdateWithWhereUniqueWithoutShippingLabelInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShippingLabelInput | OrderUpdateManyWithWhereWithoutShippingLabelInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutReferringPhysicianInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutPrimaryPhysicianInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type EvaluationUpdateManyWithoutReferringPhysicianNestedInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput | EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutPrimaryPhysicianNestedInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput | PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput | EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput | PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EnumDiagnosisStandardFieldUpdateOperationsInput = {
    set?: $Enums.DiagnosisStandard
  }

  export type EvaluationUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput | EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput | EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDiagnosisInput | EvaluationUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput | EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput | EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDiagnosisInput | EvaluationUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutDeviceTypeInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutDeviceTypeInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EvaluationUpdateManyWithoutDeviceTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDeviceTypeInput | EvaluationUpdateManyWithWhereWithoutDeviceTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutDeviceTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDeviceTypeInput | EvaluationUpdateManyWithWhereWithoutDeviceTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutVisitTypeInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutVisitTypeInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUpdateManyWithoutVisitTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput | EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput | EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutVisitTypeInput | EvaluationUpdateManyWithWhereWithoutVisitTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutVisitTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput | EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput | EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutVisitTypeInput | EvaluationUpdateManyWithWhereWithoutVisitTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutSchemaInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutSchemaInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type NullableEnumFormSchemaTypeFieldUpdateOperationsInput = {
    set?: $Enums.FormSchemaType | null
  }

  export type FormSubmissionUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput | FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput | FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSchemaInput | FormSubmissionUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput | FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput | FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSchemaInput | FormSubmissionUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormSchemaCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormSchemaCreateOrConnectWithoutSubmissionsInput
    connect?: FormSchemaWhereUniqueInput
  }

  export type WorkbenchCreateNestedOneWithoutFormSubmissionsInput = {
    create?: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFormSubmissionsInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormSchemaCreateOrConnectWithoutSubmissionsInput
    upsert?: FormSchemaUpsertWithoutSubmissionsInput
    connect?: FormSchemaWhereUniqueInput
    update?: XOR<XOR<FormSchemaUpdateToOneWithWhereWithoutSubmissionsInput, FormSchemaUpdateWithoutSubmissionsInput>, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
  }

  export type WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFormSubmissionsInput
    upsert?: WorkbenchUpsertWithoutFormSubmissionsInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutFormSubmissionsInput, WorkbenchUpdateWithoutFormSubmissionsInput>, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type CatalogProductAttributeCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
  }

  export type CatalogProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
  }

  export type CatalogCategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
  }

  export type CatalogVendorCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
  }

  export type CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
  }

  export type CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
  }

  export type CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
  }

  export type CatalogVendorUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
  }

  export type CatalogProductAttributeUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    set?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    disconnect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    delete?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    update?: CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductAttributeUpdateManyWithWhereWithoutProductInput | CatalogProductAttributeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
  }

  export type CatalogProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput | CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    set?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    disconnect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    delete?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    update?: CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput | CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductVariantUpdateManyWithWhereWithoutProductInput | CatalogProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
  }

  export type CatalogCategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput | CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    disconnect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    delete?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    update?: CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput | CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogCategoryUpdateManyWithWhereWithoutProductsInput | CatalogCategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
  }

  export type CatalogVendorUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogVendorUpsertWithWhereUniqueWithoutProductsInput | CatalogVendorUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    disconnect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    delete?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    update?: CatalogVendorUpdateWithWhereUniqueWithoutProductsInput | CatalogVendorUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogVendorUpdateManyWithWhereWithoutProductsInput | CatalogVendorUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
  }

  export type CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    set?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    disconnect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    delete?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    update?: CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductAttributeUpdateManyWithWhereWithoutProductInput | CatalogProductAttributeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
  }

  export type CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput | CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    set?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    disconnect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    delete?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    update?: CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput | CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductVariantUpdateManyWithWhereWithoutProductInput | CatalogProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
  }

  export type CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput | CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    disconnect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    delete?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    update?: CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput | CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogCategoryUpdateManyWithWhereWithoutProductsInput | CatalogCategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
  }

  export type CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogVendorUpsertWithWhereUniqueWithoutProductsInput | CatalogVendorUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    disconnect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    delete?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    update?: CatalogVendorUpdateWithWhereUniqueWithoutProductsInput | CatalogVendorUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogVendorUpdateManyWithWhereWithoutProductsInput | CatalogVendorUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
  }

  export type CatalogProductCreateNestedOneWithoutAttributesInput = {
    create?: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutAttributesInput
    connect?: CatalogProductWhereUniqueInput
  }

  export type EnumProductAttributeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductAttributeType
  }

  export type CatalogProductUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutAttributesInput
    upsert?: CatalogProductUpsertWithoutAttributesInput
    connect?: CatalogProductWhereUniqueInput
    update?: XOR<XOR<CatalogProductUpdateToOneWithWhereWithoutAttributesInput, CatalogProductUpdateWithoutAttributesInput>, CatalogProductUncheckedUpdateWithoutAttributesInput>
  }

  export type CatalogProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVariantsInput
    connect?: CatalogProductWhereUniqueInput
  }

  export type CatalogProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVariantsInput
    upsert?: CatalogProductUpsertWithoutVariantsInput
    connect?: CatalogProductWhereUniqueInput
    update?: XOR<XOR<CatalogProductUpdateToOneWithWhereWithoutVariantsInput, CatalogProductUpdateWithoutVariantsInput>, CatalogProductUncheckedUpdateWithoutVariantsInput>
  }

  export type CatalogProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput | CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput | CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutCategoriesInput | CatalogProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput | CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput | CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutCategoriesInput | CatalogProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductCreateNestedManyWithoutVendorsInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutVendorsInput | CatalogProductUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutVendorsInput | CatalogProductUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutVendorsInput | CatalogProductUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutVendorsInput | CatalogProductUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutVendorsInput | CatalogProductUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutVendorsInput | CatalogProductUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditsLogsInput = {
    create?: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditsLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsLogsInput
    upsert?: UserUpsertWithoutAuditsLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsLogsInput, UserUpdateWithoutAuditsLogsInput>, UserUncheckedUpdateWithoutAuditsLogsInput>
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCompanyRoleFieldUpdateOperationsInput = {
    set?: $Enums.CompanyRole
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumCompanyDepartmentFieldUpdateOperationsInput = {
    set?: $Enums.CompanyDepartment
  }

  export type UserUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsInput
    upsert?: UserUpsertWithoutDepartmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepartmentsInput, UserUpdateWithoutDepartmentsInput>, UserUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    upsert?: CompanyUpsertWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDepartmentsInput, CompanyUpdateWithoutDepartmentsInput>, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyCreateNestedOneWithoutPatientsInput = {
    create?: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPatientsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCompaniesInput
    connect?: PatientWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutPatientsInput = {
    create?: XOR<ContactCreateWithoutPatientsInput, ContactUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPatientsInput
    connect?: ContactWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPatientsInput
    upsert?: CompanyUpsertWithoutPatientsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPatientsInput, CompanyUpdateWithoutPatientsInput>, CompanyUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCompaniesInput
    upsert?: PatientUpsertWithoutCompaniesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutCompaniesInput, PatientUpdateWithoutCompaniesInput>, PatientUncheckedUpdateWithoutCompaniesInput>
  }

  export type ContactUpdateOneWithoutPatientsNestedInput = {
    create?: XOR<ContactCreateWithoutPatientsInput, ContactUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPatientsInput
    upsert?: ContactUpsertWithoutPatientsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPatientsInput, ContactUpdateWithoutPatientsInput>, ContactUncheckedUpdateWithoutPatientsInput>
  }

  export type FacilityCreateNestedOneWithoutPatientsInput = {
    create?: XOR<FacilityCreateWithoutPatientsInput, FacilityUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutPatientsInput
    connect?: FacilityWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<PatientCreateWithoutFacilitiesInput, PatientUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFacilitiesInput
    connect?: PatientWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<FacilityCreateWithoutPatientsInput, FacilityUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutPatientsInput
    upsert?: FacilityUpsertWithoutPatientsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutPatientsInput, FacilityUpdateWithoutPatientsInput>, FacilityUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<PatientCreateWithoutFacilitiesInput, PatientUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFacilitiesInput
    upsert?: PatientUpsertWithoutFacilitiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutFacilitiesInput, PatientUpdateWithoutFacilitiesInput>, PatientUncheckedUpdateWithoutFacilitiesInput>
  }

  export type StripeEntityCreateNestedOneWithoutStripeProductsInput = {
    create?: XOR<StripeEntityCreateWithoutStripeProductsInput, StripeEntityUncheckedCreateWithoutStripeProductsInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeProductsInput
    connect?: StripeEntityWhereUniqueInput
  }

  export type StripeInvoiceCreateNestedManyWithoutStripeProductsInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput> | StripeInvoiceCreateWithoutStripeProductsInput[] | StripeInvoiceUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeProductsInput | StripeInvoiceCreateOrConnectWithoutStripeProductsInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeSubscriptionCreateNestedManyWithoutStripeProductsInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput> | StripeSubscriptionCreateWithoutStripeProductsInput[] | StripeSubscriptionUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeProductsInput | StripeSubscriptionCreateOrConnectWithoutStripeProductsInput[]
    createMany?: StripeSubscriptionCreateManyStripeProductsInputEnvelope
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
  }

  export type StripeInvoiceUncheckedCreateNestedManyWithoutStripeProductsInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput> | StripeInvoiceCreateWithoutStripeProductsInput[] | StripeInvoiceUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeProductsInput | StripeInvoiceCreateOrConnectWithoutStripeProductsInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeSubscriptionUncheckedCreateNestedManyWithoutStripeProductsInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput> | StripeSubscriptionCreateWithoutStripeProductsInput[] | StripeSubscriptionUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeProductsInput | StripeSubscriptionCreateOrConnectWithoutStripeProductsInput[]
    createMany?: StripeSubscriptionCreateManyStripeProductsInputEnvelope
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
  }

  export type EnumStripeProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.StripeProductType
  }

  export type NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.StripeBillingFrequency | null
  }

  export type StripeEntityUpdateOneWithoutStripeProductsNestedInput = {
    create?: XOR<StripeEntityCreateWithoutStripeProductsInput, StripeEntityUncheckedCreateWithoutStripeProductsInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeProductsInput
    upsert?: StripeEntityUpsertWithoutStripeProductsInput
    disconnect?: StripeEntityWhereInput | boolean
    delete?: StripeEntityWhereInput | boolean
    connect?: StripeEntityWhereUniqueInput
    update?: XOR<XOR<StripeEntityUpdateToOneWithWhereWithoutStripeProductsInput, StripeEntityUpdateWithoutStripeProductsInput>, StripeEntityUncheckedUpdateWithoutStripeProductsInput>
  }

  export type StripeInvoiceUpdateManyWithoutStripeProductsNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput> | StripeInvoiceCreateWithoutStripeProductsInput[] | StripeInvoiceUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeProductsInput | StripeInvoiceCreateOrConnectWithoutStripeProductsInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeProductsInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeProductsInput[]
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeProductsInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeProductsInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeProductsInput | StripeInvoiceUpdateManyWithWhereWithoutStripeProductsInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeSubscriptionUpdateManyWithoutStripeProductsNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput> | StripeSubscriptionCreateWithoutStripeProductsInput[] | StripeSubscriptionUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeProductsInput | StripeSubscriptionCreateOrConnectWithoutStripeProductsInput[]
    upsert?: StripeSubscriptionUpsertWithWhereUniqueWithoutStripeProductsInput | StripeSubscriptionUpsertWithWhereUniqueWithoutStripeProductsInput[]
    createMany?: StripeSubscriptionCreateManyStripeProductsInputEnvelope
    set?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    disconnect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    delete?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    update?: StripeSubscriptionUpdateWithWhereUniqueWithoutStripeProductsInput | StripeSubscriptionUpdateWithWhereUniqueWithoutStripeProductsInput[]
    updateMany?: StripeSubscriptionUpdateManyWithWhereWithoutStripeProductsInput | StripeSubscriptionUpdateManyWithWhereWithoutStripeProductsInput[]
    deleteMany?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeProductsNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput> | StripeInvoiceCreateWithoutStripeProductsInput[] | StripeInvoiceUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeProductsInput | StripeInvoiceCreateOrConnectWithoutStripeProductsInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeProductsInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeProductsInput[]
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeProductsInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeProductsInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeProductsInput | StripeInvoiceUpdateManyWithWhereWithoutStripeProductsInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput> | StripeSubscriptionCreateWithoutStripeProductsInput[] | StripeSubscriptionUncheckedCreateWithoutStripeProductsInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeProductsInput | StripeSubscriptionCreateOrConnectWithoutStripeProductsInput[]
    upsert?: StripeSubscriptionUpsertWithWhereUniqueWithoutStripeProductsInput | StripeSubscriptionUpsertWithWhereUniqueWithoutStripeProductsInput[]
    createMany?: StripeSubscriptionCreateManyStripeProductsInputEnvelope
    set?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    disconnect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    delete?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    update?: StripeSubscriptionUpdateWithWhereUniqueWithoutStripeProductsInput | StripeSubscriptionUpdateWithWhereUniqueWithoutStripeProductsInput[]
    updateMany?: StripeSubscriptionUpdateManyWithWhereWithoutStripeProductsInput | StripeSubscriptionUpdateManyWithWhereWithoutStripeProductsInput[]
    deleteMany?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
  }

  export type StripeProductCreateNestedManyWithoutStripeInvoicesInput = {
    create?: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput> | StripeProductCreateWithoutStripeInvoicesInput[] | StripeProductUncheckedCreateWithoutStripeInvoicesInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeInvoicesInput | StripeProductCreateOrConnectWithoutStripeInvoicesInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
  }

  export type StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoicesInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoicesInput
    connect?: StripeInvoiceWhereUniqueInput
  }

  export type StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput> | StripeInvoiceCreateWithoutCombinedInvoiceInput[] | StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput | StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput[]
    createMany?: StripeInvoiceCreateManyCombinedInvoiceInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedCreateWithoutStripeInvoicesInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeInvoicesInput
    connect?: StripeSubscriptionWhereUniqueInput
  }

  export type StripeEntityCreateNestedOneWithoutStripeInvoicesInput = {
    create?: XOR<StripeEntityCreateWithoutStripeInvoicesInput, StripeEntityUncheckedCreateWithoutStripeInvoicesInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeInvoicesInput
    connect?: StripeEntityWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutStripeInvoiceInput = {
    create?: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput> | EvaluationCreateWithoutStripeInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeInvoiceInput | EvaluationCreateOrConnectWithoutStripeInvoiceInput[]
    createMany?: EvaluationCreateManyStripeInvoiceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput = {
    create?: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput> | EvaluationCreateWithoutStripeCheckoutInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput | EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput[]
    createMany?: EvaluationCreateManyStripeCheckoutInvoiceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput = {
    create?: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput> | StripeProductCreateWithoutStripeInvoicesInput[] | StripeProductUncheckedCreateWithoutStripeInvoicesInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeInvoicesInput | StripeProductCreateOrConnectWithoutStripeInvoicesInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
  }

  export type StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput> | StripeInvoiceCreateWithoutCombinedInvoiceInput[] | StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput | StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput[]
    createMany?: StripeInvoiceCreateManyCombinedInvoiceInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput = {
    create?: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput> | EvaluationCreateWithoutStripeInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeInvoiceInput | EvaluationCreateOrConnectWithoutStripeInvoiceInput[]
    createMany?: EvaluationCreateManyStripeInvoiceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput = {
    create?: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput> | EvaluationCreateWithoutStripeCheckoutInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput | EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput[]
    createMany?: EvaluationCreateManyStripeCheckoutInvoiceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EnumStripeInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.StripeInvoiceType
  }

  export type EnumStripeInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.StripeInvoiceStatus
  }

  export type StripeProductUpdateManyWithoutStripeInvoicesNestedInput = {
    create?: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput> | StripeProductCreateWithoutStripeInvoicesInput[] | StripeProductUncheckedCreateWithoutStripeInvoicesInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeInvoicesInput | StripeProductCreateOrConnectWithoutStripeInvoicesInput[]
    upsert?: StripeProductUpsertWithWhereUniqueWithoutStripeInvoicesInput | StripeProductUpsertWithWhereUniqueWithoutStripeInvoicesInput[]
    set?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    disconnect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    delete?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    update?: StripeProductUpdateWithWhereUniqueWithoutStripeInvoicesInput | StripeProductUpdateWithWhereUniqueWithoutStripeInvoicesInput[]
    updateMany?: StripeProductUpdateManyWithWhereWithoutStripeInvoicesInput | StripeProductUpdateManyWithWhereWithoutStripeInvoicesInput[]
    deleteMany?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
  }

  export type StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoicesInput>
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoicesInput
    upsert?: StripeInvoiceUpsertWithoutCombinedInvoicesInput
    disconnect?: StripeInvoiceWhereInput | boolean
    delete?: StripeInvoiceWhereInput | boolean
    connect?: StripeInvoiceWhereUniqueInput
    update?: XOR<XOR<StripeInvoiceUpdateToOneWithWhereWithoutCombinedInvoicesInput, StripeInvoiceUpdateWithoutCombinedInvoicesInput>, StripeInvoiceUncheckedUpdateWithoutCombinedInvoicesInput>
  }

  export type StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput> | StripeInvoiceCreateWithoutCombinedInvoiceInput[] | StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput | StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutCombinedInvoiceInput | StripeInvoiceUpsertWithWhereUniqueWithoutCombinedInvoiceInput[]
    createMany?: StripeInvoiceCreateManyCombinedInvoiceInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutCombinedInvoiceInput | StripeInvoiceUpdateWithWhereUniqueWithoutCombinedInvoiceInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutCombinedInvoiceInput | StripeInvoiceUpdateManyWithWhereWithoutCombinedInvoiceInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedCreateWithoutStripeInvoicesInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeInvoicesInput
    upsert?: StripeSubscriptionUpsertWithoutStripeInvoicesInput
    disconnect?: StripeSubscriptionWhereInput | boolean
    delete?: StripeSubscriptionWhereInput | boolean
    connect?: StripeSubscriptionWhereUniqueInput
    update?: XOR<XOR<StripeSubscriptionUpdateToOneWithWhereWithoutStripeInvoicesInput, StripeSubscriptionUpdateWithoutStripeInvoicesInput>, StripeSubscriptionUncheckedUpdateWithoutStripeInvoicesInput>
  }

  export type StripeEntityUpdateOneWithoutStripeInvoicesNestedInput = {
    create?: XOR<StripeEntityCreateWithoutStripeInvoicesInput, StripeEntityUncheckedCreateWithoutStripeInvoicesInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeInvoicesInput
    upsert?: StripeEntityUpsertWithoutStripeInvoicesInput
    disconnect?: StripeEntityWhereInput | boolean
    delete?: StripeEntityWhereInput | boolean
    connect?: StripeEntityWhereUniqueInput
    update?: XOR<XOR<StripeEntityUpdateToOneWithWhereWithoutStripeInvoicesInput, StripeEntityUpdateWithoutStripeInvoicesInput>, StripeEntityUncheckedUpdateWithoutStripeInvoicesInput>
  }

  export type EvaluationUpdateManyWithoutStripeInvoiceNestedInput = {
    create?: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput> | EvaluationCreateWithoutStripeInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeInvoiceInput | EvaluationCreateOrConnectWithoutStripeInvoiceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStripeInvoiceInput | EvaluationUpsertWithWhereUniqueWithoutStripeInvoiceInput[]
    createMany?: EvaluationCreateManyStripeInvoiceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStripeInvoiceInput | EvaluationUpdateWithWhereUniqueWithoutStripeInvoiceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStripeInvoiceInput | EvaluationUpdateManyWithWhereWithoutStripeInvoiceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput = {
    create?: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput> | EvaluationCreateWithoutStripeCheckoutInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput | EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStripeCheckoutInvoiceInput | EvaluationUpsertWithWhereUniqueWithoutStripeCheckoutInvoiceInput[]
    createMany?: EvaluationCreateManyStripeCheckoutInvoiceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStripeCheckoutInvoiceInput | EvaluationUpdateWithWhereUniqueWithoutStripeCheckoutInvoiceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStripeCheckoutInvoiceInput | EvaluationUpdateManyWithWhereWithoutStripeCheckoutInvoiceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput = {
    create?: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput> | StripeProductCreateWithoutStripeInvoicesInput[] | StripeProductUncheckedCreateWithoutStripeInvoicesInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeInvoicesInput | StripeProductCreateOrConnectWithoutStripeInvoicesInput[]
    upsert?: StripeProductUpsertWithWhereUniqueWithoutStripeInvoicesInput | StripeProductUpsertWithWhereUniqueWithoutStripeInvoicesInput[]
    set?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    disconnect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    delete?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    update?: StripeProductUpdateWithWhereUniqueWithoutStripeInvoicesInput | StripeProductUpdateWithWhereUniqueWithoutStripeInvoicesInput[]
    updateMany?: StripeProductUpdateManyWithWhereWithoutStripeInvoicesInput | StripeProductUpdateManyWithWhereWithoutStripeInvoicesInput[]
    deleteMany?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput> | StripeInvoiceCreateWithoutCombinedInvoiceInput[] | StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput | StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutCombinedInvoiceInput | StripeInvoiceUpsertWithWhereUniqueWithoutCombinedInvoiceInput[]
    createMany?: StripeInvoiceCreateManyCombinedInvoiceInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutCombinedInvoiceInput | StripeInvoiceUpdateWithWhereUniqueWithoutCombinedInvoiceInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutCombinedInvoiceInput | StripeInvoiceUpdateManyWithWhereWithoutCombinedInvoiceInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput = {
    create?: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput> | EvaluationCreateWithoutStripeInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeInvoiceInput | EvaluationCreateOrConnectWithoutStripeInvoiceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStripeInvoiceInput | EvaluationUpsertWithWhereUniqueWithoutStripeInvoiceInput[]
    createMany?: EvaluationCreateManyStripeInvoiceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStripeInvoiceInput | EvaluationUpdateWithWhereUniqueWithoutStripeInvoiceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStripeInvoiceInput | EvaluationUpdateManyWithWhereWithoutStripeInvoiceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput = {
    create?: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput> | EvaluationCreateWithoutStripeCheckoutInvoiceInput[] | EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput | EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutStripeCheckoutInvoiceInput | EvaluationUpsertWithWhereUniqueWithoutStripeCheckoutInvoiceInput[]
    createMany?: EvaluationCreateManyStripeCheckoutInvoiceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutStripeCheckoutInvoiceInput | EvaluationUpdateWithWhereUniqueWithoutStripeCheckoutInvoiceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutStripeCheckoutInvoiceInput | EvaluationUpdateManyWithWhereWithoutStripeCheckoutInvoiceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutStripeEntitiesInput = {
    create?: XOR<CompanyCreateWithoutStripeEntitiesInput, CompanyUncheckedCreateWithoutStripeEntitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStripeEntitiesInput
    connect?: CompanyWhereUniqueInput
  }

  export type StripeEntityCreateNestedOneWithoutChildEntitiesInput = {
    create?: XOR<StripeEntityCreateWithoutChildEntitiesInput, StripeEntityUncheckedCreateWithoutChildEntitiesInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutChildEntitiesInput
    connect?: StripeEntityWhereUniqueInput
  }

  export type StripeEntityCreateNestedManyWithoutParentEntityInput = {
    create?: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput> | StripeEntityCreateWithoutParentEntityInput[] | StripeEntityUncheckedCreateWithoutParentEntityInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutParentEntityInput | StripeEntityCreateOrConnectWithoutParentEntityInput[]
    createMany?: StripeEntityCreateManyParentEntityInputEnvelope
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
  }

  export type StripeProductCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput> | StripeProductCreateWithoutStripeEntityInput[] | StripeProductUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeEntityInput | StripeProductCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeProductCreateManyStripeEntityInputEnvelope
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
  }

  export type StripeSubscriptionCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput> | StripeSubscriptionCreateWithoutStripeEntityInput[] | StripeSubscriptionUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeEntityInput | StripeSubscriptionCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeSubscriptionCreateManyStripeEntityInputEnvelope
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
  }

  export type StripeInvoiceCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput> | StripeInvoiceCreateWithoutStripeEntityInput[] | StripeInvoiceUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeEntityInput | StripeInvoiceCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeInvoiceCreateManyStripeEntityInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput = {
    create?: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput> | StripeEntityCreateWithoutParentEntityInput[] | StripeEntityUncheckedCreateWithoutParentEntityInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutParentEntityInput | StripeEntityCreateOrConnectWithoutParentEntityInput[]
    createMany?: StripeEntityCreateManyParentEntityInputEnvelope
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
  }

  export type StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput> | StripeProductCreateWithoutStripeEntityInput[] | StripeProductUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeEntityInput | StripeProductCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeProductCreateManyStripeEntityInputEnvelope
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
  }

  export type StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput> | StripeSubscriptionCreateWithoutStripeEntityInput[] | StripeSubscriptionUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeEntityInput | StripeSubscriptionCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeSubscriptionCreateManyStripeEntityInputEnvelope
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
  }

  export type StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput> | StripeInvoiceCreateWithoutStripeEntityInput[] | StripeInvoiceUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeEntityInput | StripeInvoiceCreateOrConnectWithoutStripeEntityInput[]
    createMany?: StripeInvoiceCreateManyStripeEntityInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type EnumStripeEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.StripeEntityType
  }

  export type CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput = {
    create?: XOR<CompanyCreateWithoutStripeEntitiesInput, CompanyUncheckedCreateWithoutStripeEntitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStripeEntitiesInput
    upsert?: CompanyUpsertWithoutStripeEntitiesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStripeEntitiesInput, CompanyUpdateWithoutStripeEntitiesInput>, CompanyUncheckedUpdateWithoutStripeEntitiesInput>
  }

  export type StripeEntityUpdateOneWithoutChildEntitiesNestedInput = {
    create?: XOR<StripeEntityCreateWithoutChildEntitiesInput, StripeEntityUncheckedCreateWithoutChildEntitiesInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutChildEntitiesInput
    upsert?: StripeEntityUpsertWithoutChildEntitiesInput
    disconnect?: StripeEntityWhereInput | boolean
    delete?: StripeEntityWhereInput | boolean
    connect?: StripeEntityWhereUniqueInput
    update?: XOR<XOR<StripeEntityUpdateToOneWithWhereWithoutChildEntitiesInput, StripeEntityUpdateWithoutChildEntitiesInput>, StripeEntityUncheckedUpdateWithoutChildEntitiesInput>
  }

  export type StripeEntityUpdateManyWithoutParentEntityNestedInput = {
    create?: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput> | StripeEntityCreateWithoutParentEntityInput[] | StripeEntityUncheckedCreateWithoutParentEntityInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutParentEntityInput | StripeEntityCreateOrConnectWithoutParentEntityInput[]
    upsert?: StripeEntityUpsertWithWhereUniqueWithoutParentEntityInput | StripeEntityUpsertWithWhereUniqueWithoutParentEntityInput[]
    createMany?: StripeEntityCreateManyParentEntityInputEnvelope
    set?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    disconnect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    delete?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    update?: StripeEntityUpdateWithWhereUniqueWithoutParentEntityInput | StripeEntityUpdateWithWhereUniqueWithoutParentEntityInput[]
    updateMany?: StripeEntityUpdateManyWithWhereWithoutParentEntityInput | StripeEntityUpdateManyWithWhereWithoutParentEntityInput[]
    deleteMany?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
  }

  export type StripeProductUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput> | StripeProductCreateWithoutStripeEntityInput[] | StripeProductUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeEntityInput | StripeProductCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeProductUpsertWithWhereUniqueWithoutStripeEntityInput | StripeProductUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeProductCreateManyStripeEntityInputEnvelope
    set?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    disconnect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    delete?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    update?: StripeProductUpdateWithWhereUniqueWithoutStripeEntityInput | StripeProductUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeProductUpdateManyWithWhereWithoutStripeEntityInput | StripeProductUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
  }

  export type StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput> | StripeSubscriptionCreateWithoutStripeEntityInput[] | StripeSubscriptionUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeEntityInput | StripeSubscriptionCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeSubscriptionUpsertWithWhereUniqueWithoutStripeEntityInput | StripeSubscriptionUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeSubscriptionCreateManyStripeEntityInputEnvelope
    set?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    disconnect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    delete?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    update?: StripeSubscriptionUpdateWithWhereUniqueWithoutStripeEntityInput | StripeSubscriptionUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeSubscriptionUpdateManyWithWhereWithoutStripeEntityInput | StripeSubscriptionUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
  }

  export type StripeInvoiceUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput> | StripeInvoiceCreateWithoutStripeEntityInput[] | StripeInvoiceUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeEntityInput | StripeInvoiceCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeEntityInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeInvoiceCreateManyStripeEntityInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeEntityInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeEntityInput | StripeInvoiceUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput = {
    create?: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput> | StripeEntityCreateWithoutParentEntityInput[] | StripeEntityUncheckedCreateWithoutParentEntityInput[]
    connectOrCreate?: StripeEntityCreateOrConnectWithoutParentEntityInput | StripeEntityCreateOrConnectWithoutParentEntityInput[]
    upsert?: StripeEntityUpsertWithWhereUniqueWithoutParentEntityInput | StripeEntityUpsertWithWhereUniqueWithoutParentEntityInput[]
    createMany?: StripeEntityCreateManyParentEntityInputEnvelope
    set?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    disconnect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    delete?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    connect?: StripeEntityWhereUniqueInput | StripeEntityWhereUniqueInput[]
    update?: StripeEntityUpdateWithWhereUniqueWithoutParentEntityInput | StripeEntityUpdateWithWhereUniqueWithoutParentEntityInput[]
    updateMany?: StripeEntityUpdateManyWithWhereWithoutParentEntityInput | StripeEntityUpdateManyWithWhereWithoutParentEntityInput[]
    deleteMany?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
  }

  export type StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput> | StripeProductCreateWithoutStripeEntityInput[] | StripeProductUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeEntityInput | StripeProductCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeProductUpsertWithWhereUniqueWithoutStripeEntityInput | StripeProductUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeProductCreateManyStripeEntityInputEnvelope
    set?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    disconnect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    delete?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    connect?: StripeProductWhereUniqueInput | StripeProductWhereUniqueInput[]
    update?: StripeProductUpdateWithWhereUniqueWithoutStripeEntityInput | StripeProductUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeProductUpdateManyWithWhereWithoutStripeEntityInput | StripeProductUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
  }

  export type StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput> | StripeSubscriptionCreateWithoutStripeEntityInput[] | StripeSubscriptionUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutStripeEntityInput | StripeSubscriptionCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeSubscriptionUpsertWithWhereUniqueWithoutStripeEntityInput | StripeSubscriptionUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeSubscriptionCreateManyStripeEntityInputEnvelope
    set?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    disconnect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    delete?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    connect?: StripeSubscriptionWhereUniqueInput | StripeSubscriptionWhereUniqueInput[]
    update?: StripeSubscriptionUpdateWithWhereUniqueWithoutStripeEntityInput | StripeSubscriptionUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeSubscriptionUpdateManyWithWhereWithoutStripeEntityInput | StripeSubscriptionUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput> | StripeInvoiceCreateWithoutStripeEntityInput[] | StripeInvoiceUncheckedCreateWithoutStripeEntityInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeEntityInput | StripeInvoiceCreateOrConnectWithoutStripeEntityInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeEntityInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeEntityInput[]
    createMany?: StripeInvoiceCreateManyStripeEntityInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeEntityInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeEntityInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeEntityInput | StripeInvoiceUpdateManyWithWhereWithoutStripeEntityInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeEntityCreateNestedOneWithoutStripeSubscriptionsInput = {
    create?: XOR<StripeEntityCreateWithoutStripeSubscriptionsInput, StripeEntityUncheckedCreateWithoutStripeSubscriptionsInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeSubscriptionsInput
    connect?: StripeEntityWhereUniqueInput
  }

  export type StripeInvoiceCreateNestedManyWithoutStripeSubscriptionInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput> | StripeInvoiceCreateWithoutStripeSubscriptionInput[] | StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput | StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput[]
    createMany?: StripeInvoiceCreateManyStripeSubscriptionInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeProductCreateNestedOneWithoutStripeSubscriptionsInput = {
    create?: XOR<StripeProductCreateWithoutStripeSubscriptionsInput, StripeProductUncheckedCreateWithoutStripeSubscriptionsInput>
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeSubscriptionsInput
    connect?: StripeProductWhereUniqueInput
  }

  export type StripeInvoiceUncheckedCreateNestedManyWithoutStripeSubscriptionInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput> | StripeInvoiceCreateWithoutStripeSubscriptionInput[] | StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput | StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput[]
    createMany?: StripeInvoiceCreateManyStripeSubscriptionInputEnvelope
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
  }

  export type StripeEntityUpdateOneRequiredWithoutStripeSubscriptionsNestedInput = {
    create?: XOR<StripeEntityCreateWithoutStripeSubscriptionsInput, StripeEntityUncheckedCreateWithoutStripeSubscriptionsInput>
    connectOrCreate?: StripeEntityCreateOrConnectWithoutStripeSubscriptionsInput
    upsert?: StripeEntityUpsertWithoutStripeSubscriptionsInput
    connect?: StripeEntityWhereUniqueInput
    update?: XOR<XOR<StripeEntityUpdateToOneWithWhereWithoutStripeSubscriptionsInput, StripeEntityUpdateWithoutStripeSubscriptionsInput>, StripeEntityUncheckedUpdateWithoutStripeSubscriptionsInput>
  }

  export type StripeInvoiceUpdateManyWithoutStripeSubscriptionNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput> | StripeInvoiceCreateWithoutStripeSubscriptionInput[] | StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput | StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeSubscriptionInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeSubscriptionInput[]
    createMany?: StripeInvoiceCreateManyStripeSubscriptionInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeSubscriptionInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeSubscriptionInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeSubscriptionInput | StripeInvoiceUpdateManyWithWhereWithoutStripeSubscriptionInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type StripeProductUpdateOneRequiredWithoutStripeSubscriptionsNestedInput = {
    create?: XOR<StripeProductCreateWithoutStripeSubscriptionsInput, StripeProductUncheckedCreateWithoutStripeSubscriptionsInput>
    connectOrCreate?: StripeProductCreateOrConnectWithoutStripeSubscriptionsInput
    upsert?: StripeProductUpsertWithoutStripeSubscriptionsInput
    connect?: StripeProductWhereUniqueInput
    update?: XOR<XOR<StripeProductUpdateToOneWithWhereWithoutStripeSubscriptionsInput, StripeProductUpdateWithoutStripeSubscriptionsInput>, StripeProductUncheckedUpdateWithoutStripeSubscriptionsInput>
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionNestedInput = {
    create?: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput> | StripeInvoiceCreateWithoutStripeSubscriptionInput[] | StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput[]
    connectOrCreate?: StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput | StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput[]
    upsert?: StripeInvoiceUpsertWithWhereUniqueWithoutStripeSubscriptionInput | StripeInvoiceUpsertWithWhereUniqueWithoutStripeSubscriptionInput[]
    createMany?: StripeInvoiceCreateManyStripeSubscriptionInputEnvelope
    set?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    disconnect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    delete?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    connect?: StripeInvoiceWhereUniqueInput | StripeInvoiceWhereUniqueInput[]
    update?: StripeInvoiceUpdateWithWhereUniqueWithoutStripeSubscriptionInput | StripeInvoiceUpdateWithWhereUniqueWithoutStripeSubscriptionInput[]
    updateMany?: StripeInvoiceUpdateManyWithWhereWithoutStripeSubscriptionInput | StripeInvoiceUpdateManyWithWhereWithoutStripeSubscriptionInput[]
    deleteMany?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
  }

  export type NotificationMessageCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput> | NotificationMessageCreateWithoutNotificationInput[] | NotificationMessageUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationInput | NotificationMessageCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationMessageCreateManyNotificationInputEnvelope
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
  }

  export type NotificationMessageUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput> | NotificationMessageCreateWithoutNotificationInput[] | NotificationMessageUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationInput | NotificationMessageCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationMessageCreateManyNotificationInputEnvelope
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NullableEnumNotificationResponseTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationResponseType | null
  }

  export type NotificationMessageUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput> | NotificationMessageCreateWithoutNotificationInput[] | NotificationMessageUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationInput | NotificationMessageCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationMessageUpsertWithWhereUniqueWithoutNotificationInput | NotificationMessageUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationMessageCreateManyNotificationInputEnvelope
    set?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    disconnect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    delete?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    update?: NotificationMessageUpdateWithWhereUniqueWithoutNotificationInput | NotificationMessageUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationMessageUpdateManyWithWhereWithoutNotificationInput | NotificationMessageUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
  }

  export type NotificationMessageUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput> | NotificationMessageCreateWithoutNotificationInput[] | NotificationMessageUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationInput | NotificationMessageCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationMessageUpsertWithWhereUniqueWithoutNotificationInput | NotificationMessageUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationMessageCreateManyNotificationInputEnvelope
    set?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    disconnect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    delete?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    update?: NotificationMessageUpdateWithWhereUniqueWithoutNotificationInput | NotificationMessageUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationMessageUpdateManyWithWhereWithoutNotificationInput | NotificationMessageUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<NotificationCreateWithoutMessagesInput, NotificationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutMessagesInput
    connect?: NotificationWhereUniqueInput
  }

  export type EmailTemplateCreateNestedOneWithoutNotificationMessagesInput = {
    create?: XOR<EmailTemplateCreateWithoutNotificationMessagesInput, EmailTemplateUncheckedCreateWithoutNotificationMessagesInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutNotificationMessagesInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type NotificationHistoryCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput> | NotificationHistoryCreateWithoutMessageInput[] | NotificationHistoryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutMessageInput | NotificationHistoryCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationHistoryCreateManyMessageInputEnvelope
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
  }

  export type NotificationHistoryUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput> | NotificationHistoryCreateWithoutMessageInput[] | NotificationHistoryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutMessageInput | NotificationHistoryCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationHistoryCreateManyMessageInputEnvelope
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
  }

  export type EnumCommunicationChannelFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationChannel
  }

  export type NotificationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<NotificationCreateWithoutMessagesInput, NotificationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutMessagesInput
    upsert?: NotificationUpsertWithoutMessagesInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutMessagesInput, NotificationUpdateWithoutMessagesInput>, NotificationUncheckedUpdateWithoutMessagesInput>
  }

  export type EmailTemplateUpdateOneWithoutNotificationMessagesNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutNotificationMessagesInput, EmailTemplateUncheckedCreateWithoutNotificationMessagesInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutNotificationMessagesInput
    upsert?: EmailTemplateUpsertWithoutNotificationMessagesInput
    disconnect?: EmailTemplateWhereInput | boolean
    delete?: EmailTemplateWhereInput | boolean
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutNotificationMessagesInput, EmailTemplateUpdateWithoutNotificationMessagesInput>, EmailTemplateUncheckedUpdateWithoutNotificationMessagesInput>
  }

  export type NotificationHistoryUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput> | NotificationHistoryCreateWithoutMessageInput[] | NotificationHistoryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutMessageInput | NotificationHistoryCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationHistoryUpsertWithWhereUniqueWithoutMessageInput | NotificationHistoryUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationHistoryCreateManyMessageInputEnvelope
    set?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    disconnect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    delete?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    update?: NotificationHistoryUpdateWithWhereUniqueWithoutMessageInput | NotificationHistoryUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationHistoryUpdateManyWithWhereWithoutMessageInput | NotificationHistoryUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
  }

  export type NotificationHistoryUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput> | NotificationHistoryCreateWithoutMessageInput[] | NotificationHistoryUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationHistoryCreateOrConnectWithoutMessageInput | NotificationHistoryCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationHistoryUpsertWithWhereUniqueWithoutMessageInput | NotificationHistoryUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationHistoryCreateManyMessageInputEnvelope
    set?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    disconnect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    delete?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    connect?: NotificationHistoryWhereUniqueInput | NotificationHistoryWhereUniqueInput[]
    update?: NotificationHistoryUpdateWithWhereUniqueWithoutMessageInput | NotificationHistoryUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationHistoryUpdateManyWithWhereWithoutMessageInput | NotificationHistoryUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutNotificationHistoryInput = {
    create?: XOR<PatientCreateWithoutNotificationHistoryInput, PatientUncheckedCreateWithoutNotificationHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutNotificationHistoryInput
    connect?: PatientWhereUniqueInput
  }

  export type NotificationMessageCreateNestedOneWithoutNotificationHistoryInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationHistoryInput, NotificationMessageUncheckedCreateWithoutNotificationHistoryInput>
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationHistoryInput
    connect?: NotificationMessageWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutNotificationHistoryNestedInput = {
    create?: XOR<PatientCreateWithoutNotificationHistoryInput, PatientUncheckedCreateWithoutNotificationHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutNotificationHistoryInput
    upsert?: PatientUpsertWithoutNotificationHistoryInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutNotificationHistoryInput, PatientUpdateWithoutNotificationHistoryInput>, PatientUncheckedUpdateWithoutNotificationHistoryInput>
  }

  export type NotificationMessageUpdateOneRequiredWithoutNotificationHistoryNestedInput = {
    create?: XOR<NotificationMessageCreateWithoutNotificationHistoryInput, NotificationMessageUncheckedCreateWithoutNotificationHistoryInput>
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutNotificationHistoryInput
    upsert?: NotificationMessageUpsertWithoutNotificationHistoryInput
    connect?: NotificationMessageWhereUniqueInput
    update?: XOR<XOR<NotificationMessageUpdateToOneWithWhereWithoutNotificationHistoryInput, NotificationMessageUpdateWithoutNotificationHistoryInput>, NotificationMessageUncheckedUpdateWithoutNotificationHistoryInput>
  }

  export type NotificationMessageCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput> | NotificationMessageCreateWithoutEmailTemplateInput[] | NotificationMessageUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutEmailTemplateInput | NotificationMessageCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: NotificationMessageCreateManyEmailTemplateInputEnvelope
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
  }

  export type NotificationMessageUncheckedCreateNestedManyWithoutEmailTemplateInput = {
    create?: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput> | NotificationMessageCreateWithoutEmailTemplateInput[] | NotificationMessageUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutEmailTemplateInput | NotificationMessageCreateOrConnectWithoutEmailTemplateInput[]
    createMany?: NotificationMessageCreateManyEmailTemplateInputEnvelope
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
  }

  export type NotificationMessageUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput> | NotificationMessageCreateWithoutEmailTemplateInput[] | NotificationMessageUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutEmailTemplateInput | NotificationMessageCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: NotificationMessageUpsertWithWhereUniqueWithoutEmailTemplateInput | NotificationMessageUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: NotificationMessageCreateManyEmailTemplateInputEnvelope
    set?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    disconnect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    delete?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    update?: NotificationMessageUpdateWithWhereUniqueWithoutEmailTemplateInput | NotificationMessageUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: NotificationMessageUpdateManyWithWhereWithoutEmailTemplateInput | NotificationMessageUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
  }

  export type NotificationMessageUncheckedUpdateManyWithoutEmailTemplateNestedInput = {
    create?: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput> | NotificationMessageCreateWithoutEmailTemplateInput[] | NotificationMessageUncheckedCreateWithoutEmailTemplateInput[]
    connectOrCreate?: NotificationMessageCreateOrConnectWithoutEmailTemplateInput | NotificationMessageCreateOrConnectWithoutEmailTemplateInput[]
    upsert?: NotificationMessageUpsertWithWhereUniqueWithoutEmailTemplateInput | NotificationMessageUpsertWithWhereUniqueWithoutEmailTemplateInput[]
    createMany?: NotificationMessageCreateManyEmailTemplateInputEnvelope
    set?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    disconnect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    delete?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    connect?: NotificationMessageWhereUniqueInput | NotificationMessageWhereUniqueInput[]
    update?: NotificationMessageUpdateWithWhereUniqueWithoutEmailTemplateInput | NotificationMessageUpdateWithWhereUniqueWithoutEmailTemplateInput[]
    updateMany?: NotificationMessageUpdateManyWithWhereWithoutEmailTemplateInput | NotificationMessageUpdateManyWithWhereWithoutEmailTemplateInput[]
    deleteMany?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DepartmentUserCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput> | DepartmentUserCreateWithoutUserInput[] | DepartmentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutUserInput | DepartmentUserCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentUserCreateManyUserInputEnvelope
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
  }

  export type ClinicianCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    connect?: ClinicianWhereUniqueInput
  }

  export type WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserAgreementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput> | UserAgreementCreateWithoutUserInput[] | UserAgreementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput | UserAgreementCreateOrConnectWithoutUserInput[]
    createMany?: UserAgreementCreateManyUserInputEnvelope
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DepartmentUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput> | DepartmentUserCreateWithoutUserInput[] | DepartmentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutUserInput | DepartmentUserCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentUserCreateManyUserInputEnvelope
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
  }

  export type ClinicianUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    connect?: ClinicianWhereUniqueInput
  }

  export type WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserAgreementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput> | UserAgreementCreateWithoutUserInput[] | UserAgreementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput | UserAgreementCreateOrConnectWithoutUserInput[]
    createMany?: UserAgreementCreateManyUserInputEnvelope
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DepartmentUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput> | DepartmentUserCreateWithoutUserInput[] | DepartmentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutUserInput | DepartmentUserCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentUserUpsertWithWhereUniqueWithoutUserInput | DepartmentUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentUserCreateManyUserInputEnvelope
    set?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    disconnect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    delete?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    update?: DepartmentUserUpdateWithWhereUniqueWithoutUserInput | DepartmentUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentUserUpdateManyWithWhereWithoutUserInput | DepartmentUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
  }

  export type ClinicianUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    upsert?: ClinicianUpsertWithoutUserInput
    disconnect?: ClinicianWhereInput | boolean
    delete?: ClinicianWhereInput | boolean
    connect?: ClinicianWhereUniqueInput
    update?: XOR<XOR<ClinicianUpdateToOneWithWhereWithoutUserInput, ClinicianUpdateWithoutUserInput>, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput | WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserAgreementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput> | UserAgreementCreateWithoutUserInput[] | UserAgreementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput | UserAgreementCreateOrConnectWithoutUserInput[]
    upsert?: UserAgreementUpsertWithWhereUniqueWithoutUserInput | UserAgreementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAgreementCreateManyUserInputEnvelope
    set?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    disconnect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    delete?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    update?: UserAgreementUpdateWithWhereUniqueWithoutUserInput | UserAgreementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAgreementUpdateManyWithWhereWithoutUserInput | UserAgreementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DepartmentUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput> | DepartmentUserCreateWithoutUserInput[] | DepartmentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentUserCreateOrConnectWithoutUserInput | DepartmentUserCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentUserUpsertWithWhereUniqueWithoutUserInput | DepartmentUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentUserCreateManyUserInputEnvelope
    set?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    disconnect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    delete?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    connect?: DepartmentUserWhereUniqueInput | DepartmentUserWhereUniqueInput[]
    update?: DepartmentUserUpdateWithWhereUniqueWithoutUserInput | DepartmentUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentUserUpdateManyWithWhereWithoutUserInput | DepartmentUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
  }

  export type ClinicianUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    upsert?: ClinicianUpsertWithoutUserInput
    disconnect?: ClinicianWhereInput | boolean
    delete?: ClinicianWhereInput | boolean
    connect?: ClinicianWhereUniqueInput
    update?: XOR<XOR<ClinicianUpdateToOneWithWhereWithoutUserInput, ClinicianUpdateWithoutUserInput>, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput | WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserAgreementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput> | UserAgreementCreateWithoutUserInput[] | UserAgreementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput | UserAgreementCreateOrConnectWithoutUserInput[]
    upsert?: UserAgreementUpsertWithWhereUniqueWithoutUserInput | UserAgreementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAgreementCreateManyUserInputEnvelope
    set?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    disconnect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    delete?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    update?: UserAgreementUpdateWithWhereUniqueWithoutUserInput | UserAgreementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAgreementUpdateManyWithWhereWithoutUserInput | UserAgreementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<UserCreateWithoutAgreementsInput, UserUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementsInput
    connect?: UserWhereUniqueInput
  }

  export type AgreementCreateNestedOneWithoutUserAgreementsInput = {
    create?: XOR<AgreementCreateWithoutUserAgreementsInput, AgreementUncheckedCreateWithoutUserAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserAgreementsInput
    connect?: AgreementWhereUniqueInput
  }

  export type EnumAgreementStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgreementStatus
  }

  export type UserUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<UserCreateWithoutAgreementsInput, UserUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementsInput
    upsert?: UserUpsertWithoutAgreementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgreementsInput, UserUpdateWithoutAgreementsInput>, UserUncheckedUpdateWithoutAgreementsInput>
  }

  export type AgreementUpdateOneRequiredWithoutUserAgreementsNestedInput = {
    create?: XOR<AgreementCreateWithoutUserAgreementsInput, AgreementUncheckedCreateWithoutUserAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserAgreementsInput
    upsert?: AgreementUpsertWithoutUserAgreementsInput
    connect?: AgreementWhereUniqueInput
    update?: XOR<XOR<AgreementUpdateToOneWithWhereWithoutUserAgreementsInput, AgreementUpdateWithoutUserAgreementsInput>, AgreementUncheckedUpdateWithoutUserAgreementsInput>
  }

  export type UserAgreementCreateNestedManyWithoutAgreementInput = {
    create?: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput> | UserAgreementCreateWithoutAgreementInput[] | UserAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutAgreementInput | UserAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: UserAgreementCreateManyAgreementInputEnvelope
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
  }

  export type UserAgreementUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput> | UserAgreementCreateWithoutAgreementInput[] | UserAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutAgreementInput | UserAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: UserAgreementCreateManyAgreementInputEnvelope
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
  }

  export type EnumAgreementTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgreementType
  }

  export type UserAgreementUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput> | UserAgreementCreateWithoutAgreementInput[] | UserAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutAgreementInput | UserAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: UserAgreementUpsertWithWhereUniqueWithoutAgreementInput | UserAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: UserAgreementCreateManyAgreementInputEnvelope
    set?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    disconnect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    delete?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    update?: UserAgreementUpdateWithWhereUniqueWithoutAgreementInput | UserAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: UserAgreementUpdateManyWithWhereWithoutAgreementInput | UserAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
  }

  export type UserAgreementUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput> | UserAgreementCreateWithoutAgreementInput[] | UserAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: UserAgreementCreateOrConnectWithoutAgreementInput | UserAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: UserAgreementUpsertWithWhereUniqueWithoutAgreementInput | UserAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: UserAgreementCreateManyAgreementInputEnvelope
    set?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    disconnect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    delete?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    connect?: UserAgreementWhereUniqueInput | UserAgreementWhereUniqueInput[]
    update?: UserAgreementUpdateWithWhereUniqueWithoutAgreementInput | UserAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: UserAgreementUpdateManyWithWhereWithoutAgreementInput | UserAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type EnumAccountRecoveryTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountRecoveryType
  }

  export type CompanyCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvitationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type CompanyUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvitationsInput
    upsert?: CompanyUpsertWithoutInvitationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvitationsInput, CompanyUpdateWithoutInvitationsInput>, CompanyUncheckedUpdateWithoutInvitationsInput>
  }

  export type CompanyCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiKeysInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiKeysInput
    upsert?: CompanyUpsertWithoutApiKeysInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutApiKeysInput, CompanyUpdateWithoutApiKeysInput>, CompanyUncheckedUpdateWithoutApiKeysInput>
  }

  export type NullableEnumWorkbenchStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchStatus | null
  }

  export type NullableEnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus | null
  }

  export type NullableEnumShippingTrackingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShippingTrackingStatus | null
  }

  export type NullableEnumOrderAuthorizationStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderAuthorizationStatus | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeFilter<$PrismaModel> | $Enums.CareType
  }

  export type NestedEnumSideNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableFilter<$PrismaModel> | $Enums.Side | null
  }

  export type NestedEnumVerticalPositionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableFilter<$PrismaModel> | $Enums.VerticalPosition | null
  }

  export type NestedEnumCareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTypeFilter<$PrismaModel>
  }

  export type NestedEnumSideNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableWithAggregatesFilter<$PrismaModel> | $Enums.Side | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSideNullableFilter<$PrismaModel>
    _max?: NestedEnumSideNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerticalPosition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
    _max?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
  }

  export type NestedEnumSideFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideFilter<$PrismaModel> | $Enums.Side
  }

  export type NestedEnumShoeWidthNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShoeWidthNullableFilter<$PrismaModel> | $Enums.ShoeWidth | null
  }

  export type NestedEnumShoeSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemFilter<$PrismaModel> | $Enums.ShoeSystem
  }

  export type NestedEnumInactiveFootReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel> | $Enums.InactiveFootReason | null
  }

  export type NestedEnumSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideWithAggregatesFilter<$PrismaModel> | $Enums.Side
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSideFilter<$PrismaModel>
    _max?: NestedEnumSideFilter<$PrismaModel>
  }

  export type NestedEnumShoeWidthNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShoeWidthNullableWithAggregatesFilter<$PrismaModel> | $Enums.ShoeWidth | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumShoeWidthNullableFilter<$PrismaModel>
    _max?: NestedEnumShoeWidthNullableFilter<$PrismaModel>
  }

  export type NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel> | $Enums.ShoeSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeSystemFilter<$PrismaModel>
    _max?: NestedEnumShoeSystemFilter<$PrismaModel>
  }

  export type NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.InactiveFootReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssetAugmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetAugmentType | EnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetAugmentTypeFilter<$PrismaModel> | $Enums.AssetAugmentType
  }

  export type NestedEnumAssetAugmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetAugmentType | EnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetAugmentType[] | ListEnumAssetAugmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetAugmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetAugmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetAugmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetAugmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
  }

  export type NestedEnumWorkbenchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusFilter<$PrismaModel> | $Enums.WorkbenchStatus
  }

  export type NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderAuthorizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCarrierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableFilter<$PrismaModel> | $Enums.Carrier | null
  }

  export type NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel> | $Enums.Carrier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCarrierNullableFilter<$PrismaModel>
    _max?: NestedEnumCarrierNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumWeightUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitFilter<$PrismaModel> | $Enums.WeightUnit
  }

  export type NestedEnumDimensionUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitFilter<$PrismaModel> | $Enums.DimensionUnit
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel> | $Enums.WeightUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeightUnitFilter<$PrismaModel>
    _max?: NestedEnumWeightUnitFilter<$PrismaModel>
  }

  export type NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumShippingTrackingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTrackingStatusFilter<$PrismaModel> | $Enums.ShippingTrackingStatus
  }

  export type NestedEnumShippingTrackingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTrackingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShippingTrackingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingTrackingStatusFilter<$PrismaModel>
    _max?: NestedEnumShippingTrackingStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiagnosisStandardFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardFilter<$PrismaModel> | $Enums.DiagnosisStandard
  }

  export type NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel> | $Enums.DiagnosisStandard
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
    _max?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFormSchemaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel> | $Enums.FormSchemaType | null
  }

  export type NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FormSchemaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProductAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeFilter<$PrismaModel> | $Enums.ProductAttributeType
  }

  export type NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
  }

  export type NestedEnumCompanyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleFilter<$PrismaModel> | $Enums.CompanyRole
  }

  export type NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyRoleFilter<$PrismaModel>
    _max?: NestedEnumCompanyRoleFilter<$PrismaModel>
  }

  export type NestedEnumCompanyDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyDepartment | EnumCompanyDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyDepartmentFilter<$PrismaModel> | $Enums.CompanyDepartment
  }

  export type NestedEnumCompanyDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyDepartment | EnumCompanyDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyDepartment[] | ListEnumCompanyDepartmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.CompanyDepartment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyDepartmentFilter<$PrismaModel>
    _max?: NestedEnumCompanyDepartmentFilter<$PrismaModel>
  }

  export type NestedEnumStripeProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeProductType | EnumStripeProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeProductTypeFilter<$PrismaModel> | $Enums.StripeProductType
  }

  export type NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeBillingFrequency | EnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel> | $Enums.StripeBillingFrequency | null
  }

  export type NestedEnumStripeProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeProductType | EnumStripeProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeProductType[] | ListEnumStripeProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeProductTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumStripeBillingFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeBillingFrequency | EnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StripeBillingFrequency[] | ListEnumStripeBillingFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStripeBillingFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.StripeBillingFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumStripeBillingFrequencyNullableFilter<$PrismaModel>
  }

  export type NestedEnumStripeInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceType | EnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel> | $Enums.StripeInvoiceType
  }

  export type NestedEnumStripeInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceStatus | EnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel> | $Enums.StripeInvoiceStatus
  }

  export type NestedEnumStripeInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceType | EnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceType[] | ListEnumStripeInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeInvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumStripeInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeInvoiceStatus | EnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeInvoiceStatus[] | ListEnumStripeInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.StripeInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumStripeInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumStripeEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeEntityType | EnumStripeEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeEntityTypeFilter<$PrismaModel> | $Enums.StripeEntityType
  }

  export type NestedEnumStripeEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StripeEntityType | EnumStripeEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StripeEntityType[] | ListEnumStripeEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStripeEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.StripeEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStripeEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumStripeEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationResponseType | EnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel> | $Enums.NotificationResponseType | null
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationResponseTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationResponseType | EnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationResponseType[] | ListEnumNotificationResponseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationResponseTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationResponseType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationResponseTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelFilter<$PrismaModel> | $Enums.CommunicationChannel
  }

  export type NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationChannelFilter<$PrismaModel>
    _max?: NestedEnumCommunicationChannelFilter<$PrismaModel>
  }

  export type NestedEnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type NestedEnumAgreementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementType | EnumAgreementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementTypeFilter<$PrismaModel> | $Enums.AgreementType
  }

  export type NestedEnumAgreementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementType | EnumAgreementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementType[] | ListEnumAgreementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgreementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementTypeFilter<$PrismaModel>
    _max?: NestedEnumAgreementTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountRecoveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountRecoveryType | EnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel> | $Enums.AccountRecoveryType
  }

  export type NestedEnumAccountRecoveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountRecoveryType | EnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountRecoveryType[] | ListEnumAccountRecoveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountRecoveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountRecoveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountRecoveryTypeFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
  }

  export type NestedEnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel> | $Enums.ShippingTrackingStatus | null
  }

  export type NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus | null
  }

  export type NestedEnumProductTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductTypeNullableFilter<$PrismaModel> | $Enums.ProductType | null
  }

  export type NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumShippingTrackingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingTrackingStatus | EnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ShippingTrackingStatus[] | ListEnumShippingTrackingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumShippingTrackingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ShippingTrackingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumShippingTrackingStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderAuthorizationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderAuthorizationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProductType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProductTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumProductTypeNullableFilter<$PrismaModel>
  }

  export type FacilityCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput>
  }

  export type FacilityCreateManyCompanyInputEnvelope = {
    data: FacilityCreateManyCompanyInput | FacilityCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput>
  }

  export type EvaluationCreateManyCompanyInputEnvelope = {
    data: EvaluationCreateManyCompanyInput | EvaluationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput>
  }

  export type ApiKeyCreateManyCompanyInputEnvelope = {
    data: ApiKeyCreateManyCompanyInput | ApiKeyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ShippingPackageCreateWithoutCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageCreateOrConnectWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    create: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput>
  }

  export type ShippingPackageCreateManyCompanyInputEnvelope = {
    data: ShippingPackageCreateManyCompanyInput | ShippingPackageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserCreateWithoutCompanyInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateWithoutCompanyInput = {
    userId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserCreateManyCompanyInputEnvelope = {
    data: CompanyUserCreateManyCompanyInput | CompanyUserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUserCreateWithoutCompanyInput = {
    id?: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUserUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserCreateOrConnectWithoutCompanyInput = {
    where: DepartmentUserWhereUniqueInput
    create: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentUserCreateManyCompanyInputEnvelope = {
    data: DepartmentUserCreateManyCompanyInput | DepartmentUserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPatientCreateWithoutCompanyInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutCompaniesInput
    contact?: ContactCreateNestedOneWithoutPatientsInput
  }

  export type CompanyPatientUncheckedCreateWithoutCompanyInput = {
    patientId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type CompanyPatientCreateOrConnectWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    create: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyPatientCreateManyCompanyInputEnvelope = {
    data: CompanyPatientCreateManyCompanyInput | CompanyPatientCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyInvitationCreateWithoutCompanyInput = {
    id?: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationUncheckedCreateWithoutCompanyInput = {
    id?: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateOrConnectWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    create: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvitationCreateManyCompanyInputEnvelope = {
    data: CompanyInvitationCreateManyCompanyInput | CompanyInvitationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type StripeEntityCreateWithoutCompanyInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutCompanyInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutCompanyInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput>
  }

  export type StripeEntityCreateManyCompanyInputEnvelope = {
    data: StripeEntityCreateManyCompanyInput | StripeEntityCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutCompanyInput, FacilityUncheckedUpdateWithoutCompanyInput>
    create: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutCompanyInput, FacilityUncheckedUpdateWithoutCompanyInput>
  }

  export type FacilityUpdateManyWithWhereWithoutCompanyInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FacilityScalarWhereInput = {
    AND?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    OR?: FacilityScalarWhereInput[]
    NOT?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    parentId?: StringNullableFilter<"Facility"> | string | null
    contactId?: StringNullableFilter<"Facility"> | string | null
  }

  export type EvaluationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutCompanyInput, EvaluationUncheckedUpdateWithoutCompanyInput>
    create: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutCompanyInput, EvaluationUncheckedUpdateWithoutCompanyInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutCompanyInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    stripeInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    stripeCheckoutInvoiceId?: StringNullableFilter<"Evaluation"> | string | null
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutCompanyInput, ApiKeyUncheckedUpdateWithoutCompanyInput>
    create: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutCompanyInput, ApiKeyUncheckedUpdateWithoutCompanyInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutCompanyInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    update: XOR<ShippingPackageUpdateWithoutCompanyInput, ShippingPackageUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput>
  }

  export type ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    data: XOR<ShippingPackageUpdateWithoutCompanyInput, ShippingPackageUncheckedUpdateWithoutCompanyInput>
  }

  export type ShippingPackageUpdateManyWithWhereWithoutCompanyInput = {
    where: ShippingPackageScalarWhereInput
    data: XOR<ShippingPackageUpdateManyMutationInput, ShippingPackageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShippingPackageScalarWhereInput = {
    AND?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
    OR?: ShippingPackageScalarWhereInput[]
    NOT?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
    id?: StringFilter<"ShippingPackage"> | string
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyUserScalarWhereInput = {
    AND?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    OR?: CompanyUserScalarWhereInput[]
    NOT?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
  }

  export type DepartmentUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentUserWhereUniqueInput
    update: XOR<DepartmentUserUpdateWithoutCompanyInput, DepartmentUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<DepartmentUserCreateWithoutCompanyInput, DepartmentUserUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentUserWhereUniqueInput
    data: XOR<DepartmentUserUpdateWithoutCompanyInput, DepartmentUserUncheckedUpdateWithoutCompanyInput>
  }

  export type DepartmentUserUpdateManyWithWhereWithoutCompanyInput = {
    where: DepartmentUserScalarWhereInput
    data: XOR<DepartmentUserUpdateManyMutationInput, DepartmentUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DepartmentUserScalarWhereInput = {
    AND?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
    OR?: DepartmentUserScalarWhereInput[]
    NOT?: DepartmentUserScalarWhereInput | DepartmentUserScalarWhereInput[]
    id?: StringFilter<"DepartmentUser"> | string
    userId?: StringFilter<"DepartmentUser"> | string
    companyId?: StringFilter<"DepartmentUser"> | string
    department?: EnumCompanyDepartmentFilter<"DepartmentUser"> | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFilter<"DepartmentUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"DepartmentUser"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentUser"> | Date | string
  }

  export type CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    update: XOR<CompanyPatientUpdateWithoutCompanyInput, CompanyPatientUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    data: XOR<CompanyPatientUpdateWithoutCompanyInput, CompanyPatientUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyPatientUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyPatientScalarWhereInput
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyPatientScalarWhereInput = {
    AND?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
    OR?: CompanyPatientScalarWhereInput[]
    NOT?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    contactId?: StringNullableFilter<"CompanyPatient"> | string | null
  }

  export type CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    update: XOR<CompanyInvitationUpdateWithoutCompanyInput, CompanyInvitationUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    data: XOR<CompanyInvitationUpdateWithoutCompanyInput, CompanyInvitationUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyInvitationUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyInvitationScalarWhereInput
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyInvitationScalarWhereInput = {
    AND?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
    OR?: CompanyInvitationScalarWhereInput[]
    NOT?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
    id?: StringFilter<"CompanyInvitation"> | string
    companyId?: StringFilter<"CompanyInvitation"> | string
    contact?: StringFilter<"CompanyInvitation"> | string
    contactType?: EnumContactTypeFilter<"CompanyInvitation"> | $Enums.ContactType
    role?: EnumCompanyRoleFilter<"CompanyInvitation"> | $Enums.CompanyRole
    token?: StringFilter<"CompanyInvitation"> | string
    verified?: BoolFilter<"CompanyInvitation"> | boolean
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type StripeEntityUpsertWithWhereUniqueWithoutCompanyInput = {
    where: StripeEntityWhereUniqueInput
    update: XOR<StripeEntityUpdateWithoutCompanyInput, StripeEntityUncheckedUpdateWithoutCompanyInput>
    create: XOR<StripeEntityCreateWithoutCompanyInput, StripeEntityUncheckedCreateWithoutCompanyInput>
  }

  export type StripeEntityUpdateWithWhereUniqueWithoutCompanyInput = {
    where: StripeEntityWhereUniqueInput
    data: XOR<StripeEntityUpdateWithoutCompanyInput, StripeEntityUncheckedUpdateWithoutCompanyInput>
  }

  export type StripeEntityUpdateManyWithWhereWithoutCompanyInput = {
    where: StripeEntityScalarWhereInput
    data: XOR<StripeEntityUpdateManyMutationInput, StripeEntityUncheckedUpdateManyWithoutCompanyInput>
  }

  export type StripeEntityScalarWhereInput = {
    AND?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
    OR?: StripeEntityScalarWhereInput[]
    NOT?: StripeEntityScalarWhereInput | StripeEntityScalarWhereInput[]
    id?: StringFilter<"StripeEntity"> | string
    companyId?: StringFilter<"StripeEntity"> | string
    entityId?: StringFilter<"StripeEntity"> | string
    stripeCustomerId?: StringNullableFilter<"StripeEntity"> | string | null
    billingPreferences?: JsonNullableFilter<"StripeEntity">
    autoAdvance?: BoolFilter<"StripeEntity"> | boolean
    autoAdvanceCombined?: BoolFilter<"StripeEntity"> | boolean
    collectionSendInvoice?: BoolFilter<"StripeEntity"> | boolean
    active?: BoolFilter<"StripeEntity"> | boolean
    entityParentId?: StringNullableFilter<"StripeEntity"> | string | null
    stripeEntityType?: EnumStripeEntityTypeFilter<"StripeEntity"> | $Enums.StripeEntityType
    createdAt?: DateTimeFilter<"StripeEntity"> | Date | string
    updatedAt?: DateTimeFilter<"StripeEntity"> | Date | string
  }

  export type FacilityCreateWithoutChildrenInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutChildrenInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutChildrenInput, FacilityUncheckedCreateWithoutChildrenInput>
  }

  export type FacilityCreateWithoutParentInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutParentInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput>
  }

  export type FacilityCreateManyParentInputEnvelope = {
    data: FacilityCreateManyParentInput | FacilityCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutFacilitiesInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: CompanyPatientCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutFacilitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFacilitiesInput, ContactUncheckedCreateWithoutFacilitiesInput>
  }

  export type CompanyCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFacilitiesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityPatientCreateWithoutFacilityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityPatientUncheckedCreateWithoutFacilityInput = {
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityPatientCreateOrConnectWithoutFacilityInput = {
    where: FacilityPatientWhereUniqueInput
    create: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityPatientCreateManyFacilityInputEnvelope = {
    data: FacilityPatientCreateManyFacilityInput | FacilityPatientCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput>
  }

  export type EvaluationCreateManyFacilityInputEnvelope = {
    data: EvaluationCreateManyFacilityInput | EvaluationCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type ShippingLabelCreateWithoutFacilityInput = {
    id?: string
    addressName: string
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutShippingLabelInput
  }

  export type ShippingLabelUncheckedCreateWithoutFacilityInput = {
    id?: string
    addressName: string
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutShippingLabelInput
  }

  export type ShippingLabelCreateOrConnectWithoutFacilityInput = {
    where: ShippingLabelWhereUniqueInput
    create: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput>
  }

  export type ShippingLabelCreateManyFacilityInputEnvelope = {
    data: ShippingLabelCreateManyFacilityInput | ShippingLabelCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithoutChildrenInput = {
    update: XOR<FacilityUpdateWithoutChildrenInput, FacilityUncheckedUpdateWithoutChildrenInput>
    create: XOR<FacilityCreateWithoutChildrenInput, FacilityUncheckedCreateWithoutChildrenInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutChildrenInput, FacilityUncheckedUpdateWithoutChildrenInput>
  }

  export type FacilityUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUpsertWithWhereUniqueWithoutParentInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutParentInput, FacilityUncheckedUpdateWithoutParentInput>
    create: XOR<FacilityCreateWithoutParentInput, FacilityUncheckedCreateWithoutParentInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutParentInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutParentInput, FacilityUncheckedUpdateWithoutParentInput>
  }

  export type FacilityUpdateManyWithWhereWithoutParentInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutParentInput>
  }

  export type ContactUpsertWithoutFacilitiesInput = {
    update: XOR<ContactUpdateWithoutFacilitiesInput, ContactUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<ContactCreateWithoutFacilitiesInput, ContactUncheckedCreateWithoutFacilitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutFacilitiesInput, ContactUncheckedUpdateWithoutFacilitiesInput>
  }

  export type ContactUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: CompanyPatientUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: CompanyPatientUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CompanyUpsertWithoutFacilitiesInput = {
    update: XOR<CompanyUpdateWithoutFacilitiesInput, CompanyUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFacilitiesInput, CompanyUncheckedUpdateWithoutFacilitiesInput>
  }

  export type CompanyUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FacilityPatientUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityPatientWhereUniqueInput
    update: XOR<FacilityPatientUpdateWithoutFacilityInput, FacilityPatientUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityPatientCreateWithoutFacilityInput, FacilityPatientUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityPatientUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityPatientWhereUniqueInput
    data: XOR<FacilityPatientUpdateWithoutFacilityInput, FacilityPatientUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityPatientUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityPatientScalarWhereInput
    data: XOR<FacilityPatientUpdateManyMutationInput, FacilityPatientUncheckedUpdateManyWithoutFacilityInput>
  }

  export type FacilityPatientScalarWhereInput = {
    AND?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
    OR?: FacilityPatientScalarWhereInput[]
    NOT?: FacilityPatientScalarWhereInput | FacilityPatientScalarWhereInput[]
    patientId?: StringFilter<"FacilityPatient"> | string
    facilityId?: StringFilter<"FacilityPatient"> | string
    createdAt?: DateTimeFilter<"FacilityPatient"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityPatient"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutFacilityInput, EvaluationUncheckedUpdateWithoutFacilityInput>
    create: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutFacilityInput, EvaluationUncheckedUpdateWithoutFacilityInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutFacilityInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutFacilityInput>
  }

  export type ShippingLabelUpsertWithWhereUniqueWithoutFacilityInput = {
    where: ShippingLabelWhereUniqueInput
    update: XOR<ShippingLabelUpdateWithoutFacilityInput, ShippingLabelUncheckedUpdateWithoutFacilityInput>
    create: XOR<ShippingLabelCreateWithoutFacilityInput, ShippingLabelUncheckedCreateWithoutFacilityInput>
  }

  export type ShippingLabelUpdateWithWhereUniqueWithoutFacilityInput = {
    where: ShippingLabelWhereUniqueInput
    data: XOR<ShippingLabelUpdateWithoutFacilityInput, ShippingLabelUncheckedUpdateWithoutFacilityInput>
  }

  export type ShippingLabelUpdateManyWithWhereWithoutFacilityInput = {
    where: ShippingLabelScalarWhereInput
    data: XOR<ShippingLabelUpdateManyMutationInput, ShippingLabelUncheckedUpdateManyWithoutFacilityInput>
  }

  export type ShippingLabelScalarWhereInput = {
    AND?: ShippingLabelScalarWhereInput | ShippingLabelScalarWhereInput[]
    OR?: ShippingLabelScalarWhereInput[]
    NOT?: ShippingLabelScalarWhereInput | ShippingLabelScalarWhereInput[]
    id?: StringFilter<"ShippingLabel"> | string
    addressName?: StringFilter<"ShippingLabel"> | string
    facilityId?: StringNullableFilter<"ShippingLabel"> | string | null
    labelId?: StringFilter<"ShippingLabel"> | string
    trackingNumber?: StringFilter<"ShippingLabel"> | string
    trackingStatus?: EnumShippingTrackingStatusFilter<"ShippingLabel"> | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFilter<"ShippingLabel"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingLabel"> | Date | string
  }

  export type PhysicianCreateWithoutPatientInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutReferringPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutPatientInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutPatientInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
  }

  export type FootCreateWithoutPatientInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateWithoutPatientInput = {
    id?: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootCreateOrConnectWithoutPatientInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput>
  }

  export type FootCreateManyPatientInputEnvelope = {
    data: FootCreateManyPatientInput | FootCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationCreateManyPatientInputEnvelope = {
    data: EvaluationCreateManyPatientInput | EvaluationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type WorkbenchCreateWithoutPatientInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutPatientInput = {
    id?: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput>
  }

  export type WorkbenchCreateManyPatientInputEnvelope = {
    data: WorkbenchCreateManyPatientInput | WorkbenchCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPatientCreateWithoutPatientInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPatientsInput
    contact?: ContactCreateNestedOneWithoutPatientsInput
  }

  export type CompanyPatientUncheckedCreateWithoutPatientInput = {
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type CompanyPatientCreateOrConnectWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    create: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput>
  }

  export type CompanyPatientCreateManyPatientInputEnvelope = {
    data: CompanyPatientCreateManyPatientInput | CompanyPatientCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationHistoryCreateWithoutPatientInput = {
    id?: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message: NotificationMessageCreateNestedOneWithoutNotificationHistoryInput
  }

  export type NotificationHistoryUncheckedCreateWithoutPatientInput = {
    id?: string
    messageId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationHistoryCreateOrConnectWithoutPatientInput = {
    where: NotificationHistoryWhereUniqueInput
    create: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput>
  }

  export type NotificationHistoryCreateManyPatientInputEnvelope = {
    data: NotificationHistoryCreateManyPatientInput | NotificationHistoryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type FacilityPatientCreateWithoutPatientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutPatientsInput
  }

  export type FacilityPatientUncheckedCreateWithoutPatientInput = {
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityPatientCreateOrConnectWithoutPatientInput = {
    where: FacilityPatientWhereUniqueInput
    create: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput>
  }

  export type FacilityPatientCreateManyPatientInputEnvelope = {
    data: FacilityPatientCreateManyPatientInput | FacilityPatientCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PhysicianUpsertWithoutPatientInput = {
    update: XOR<PhysicianUpdateWithoutPatientInput, PhysicianUncheckedUpdateWithoutPatientInput>
    create: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutPatientInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutPatientInput, PhysicianUncheckedUpdateWithoutPatientInput>
  }

  export type PhysicianUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutReferringPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput
  }

  export type FootUpsertWithWhereUniqueWithoutPatientInput = {
    where: FootWhereUniqueInput
    update: XOR<FootUpdateWithoutPatientInput, FootUncheckedUpdateWithoutPatientInput>
    create: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput>
  }

  export type FootUpdateWithWhereUniqueWithoutPatientInput = {
    where: FootWhereUniqueInput
    data: XOR<FootUpdateWithoutPatientInput, FootUncheckedUpdateWithoutPatientInput>
  }

  export type FootUpdateManyWithWhereWithoutPatientInput = {
    where: FootScalarWhereInput
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyWithoutPatientInput>
  }

  export type FootScalarWhereInput = {
    AND?: FootScalarWhereInput | FootScalarWhereInput[]
    OR?: FootScalarWhereInput[]
    NOT?: FootScalarWhereInput | FootScalarWhereInput[]
    id?: StringFilter<"Foot"> | string
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthNullableFilter<"Foot"> | $Enums.ShoeWidth | null
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutPatientInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutPatientInput>
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutPatientInput, WorkbenchUncheckedUpdateWithoutPatientInput>
    create: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutPatientInput, WorkbenchUncheckedUpdateWithoutPatientInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutPatientInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutPatientInput>
  }

  export type WorkbenchScalarWhereInput = {
    AND?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
    OR?: WorkbenchScalarWhereInput[]
    NOT?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
    id?: StringFilter<"Workbench"> | string
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
  }

  export type CompanyPatientUpsertWithWhereUniqueWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    update: XOR<CompanyPatientUpdateWithoutPatientInput, CompanyPatientUncheckedUpdateWithoutPatientInput>
    create: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput>
  }

  export type CompanyPatientUpdateWithWhereUniqueWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    data: XOR<CompanyPatientUpdateWithoutPatientInput, CompanyPatientUncheckedUpdateWithoutPatientInput>
  }

  export type CompanyPatientUpdateManyWithWhereWithoutPatientInput = {
    where: CompanyPatientScalarWhereInput
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyWithoutPatientInput>
  }

  export type NotificationHistoryUpsertWithWhereUniqueWithoutPatientInput = {
    where: NotificationHistoryWhereUniqueInput
    update: XOR<NotificationHistoryUpdateWithoutPatientInput, NotificationHistoryUncheckedUpdateWithoutPatientInput>
    create: XOR<NotificationHistoryCreateWithoutPatientInput, NotificationHistoryUncheckedCreateWithoutPatientInput>
  }

  export type NotificationHistoryUpdateWithWhereUniqueWithoutPatientInput = {
    where: NotificationHistoryWhereUniqueInput
    data: XOR<NotificationHistoryUpdateWithoutPatientInput, NotificationHistoryUncheckedUpdateWithoutPatientInput>
  }

  export type NotificationHistoryUpdateManyWithWhereWithoutPatientInput = {
    where: NotificationHistoryScalarWhereInput
    data: XOR<NotificationHistoryUpdateManyMutationInput, NotificationHistoryUncheckedUpdateManyWithoutPatientInput>
  }

  export type NotificationHistoryScalarWhereInput = {
    AND?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
    OR?: NotificationHistoryScalarWhereInput[]
    NOT?: NotificationHistoryScalarWhereInput | NotificationHistoryScalarWhereInput[]
    id?: StringFilter<"NotificationHistory"> | string
    patientId?: StringFilter<"NotificationHistory"> | string
    messageId?: StringFilter<"NotificationHistory"> | string
    sentAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    response?: StringNullableFilter<"NotificationHistory"> | string | null
    responseReceivedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"NotificationHistory"> | Date | string | null
    jobId?: StringNullableFilter<"NotificationHistory"> | string | null
    createdAt?: DateTimeFilter<"NotificationHistory"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationHistory"> | Date | string
  }

  export type FacilityPatientUpsertWithWhereUniqueWithoutPatientInput = {
    where: FacilityPatientWhereUniqueInput
    update: XOR<FacilityPatientUpdateWithoutPatientInput, FacilityPatientUncheckedUpdateWithoutPatientInput>
    create: XOR<FacilityPatientCreateWithoutPatientInput, FacilityPatientUncheckedCreateWithoutPatientInput>
  }

  export type FacilityPatientUpdateWithWhereUniqueWithoutPatientInput = {
    where: FacilityPatientWhereUniqueInput
    data: XOR<FacilityPatientUpdateWithoutPatientInput, FacilityPatientUncheckedUpdateWithoutPatientInput>
  }

  export type FacilityPatientUpdateManyWithWhereWithoutPatientInput = {
    where: FacilityPatientScalarWhereInput
    data: XOR<FacilityPatientUpdateManyMutationInput, FacilityPatientUncheckedUpdateManyWithoutPatientInput>
  }

  export type UserCreateWithoutClinicianInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicianInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicianInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
  }

  export type EvaluationCreateWithoutCliniciansInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutCliniciansInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput>
  }

  export type UserUpsertWithoutClinicianInput = {
    update: XOR<UserUpdateWithoutClinicianInput, UserUncheckedUpdateWithoutClinicianInput>
    create: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinicianInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinicianInput, UserUncheckedUpdateWithoutClinicianInput>
  }

  export type UserUpdateWithoutClinicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutCliniciansInput, EvaluationUncheckedUpdateWithoutCliniciansInput>
    create: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutCliniciansInput, EvaluationUncheckedUpdateWithoutCliniciansInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutCliniciansInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutCliniciansInput>
  }

  export type PatientCreateWithoutEvaluationsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEvaluationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
  }

  export type CompanyCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEvaluationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
  }

  export type DeviceTypeCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeCreateOrConnectWithoutEvaluationsInput = {
    where: DeviceTypeWhereUniqueInput
    create: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
  }

  export type VisitTypeCreateWithoutEvaluationsInput = {
    id?: string
    name: string
  }

  export type VisitTypeUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
  }

  export type VisitTypeCreateOrConnectWithoutEvaluationsInput = {
    where: VisitTypeWhereUniqueInput
    create: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
  }

  export type PhysicianCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutEvaluationsInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type DiagnosisCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutEvaluationsInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
  }

  export type FacilityCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutEvaluationsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
  }

  export type StripeInvoiceCreateWithoutEmployerEvaluationsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutEmployerEvaluationsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutEmployerEvaluationsInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedCreateWithoutEmployerEvaluationsInput>
  }

  export type StripeInvoiceCreateWithoutCheckoutEvaluationsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutCheckoutEvaluationsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutCheckoutEvaluationsInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedCreateWithoutCheckoutEvaluationsInput>
  }

  export type ClinicianCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutClinicianInput
  }

  export type ClinicianUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianCreateOrConnectWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    create: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type WorkbenchCreateWithoutEvaluationInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutEvaluationInput = {
    id?: string
    patientId: string
    productId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput>
  }

  export type WorkbenchCreateManyEvaluationInputEnvelope = {
    data: WorkbenchCreateManyEvaluationInput | WorkbenchCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutEvaluationsInput = {
    update: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PatientUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type CompanyUpsertWithoutEvaluationsInput = {
    update: XOR<CompanyUpdateWithoutEvaluationsInput, CompanyUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEvaluationsInput, CompanyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CompanyUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DeviceTypeUpsertWithoutEvaluationsInput = {
    update: XOR<DeviceTypeUpdateWithoutEvaluationsInput, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    where?: DeviceTypeWhereInput
  }

  export type DeviceTypeUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: DeviceTypeWhereInput
    data: XOR<DeviceTypeUpdateWithoutEvaluationsInput, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DeviceTypeUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceTypeUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VisitTypeUpsertWithoutEvaluationsInput = {
    update: XOR<VisitTypeUpdateWithoutEvaluationsInput, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    where?: VisitTypeWhereInput
  }

  export type VisitTypeUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: VisitTypeWhereInput
    data: XOR<VisitTypeUpdateWithoutEvaluationsInput, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type VisitTypeUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VisitTypeUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhysicianUpsertWithoutEvaluationsInput = {
    update: XOR<PhysicianUpdateWithoutEvaluationsInput, PhysicianUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutEvaluationsInput, PhysicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PhysicianUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type DiagnosisUpsertWithoutEvaluationsInput = {
    update: XOR<DiagnosisUpdateWithoutEvaluationsInput, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutEvaluationsInput, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DiagnosisUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUpsertWithoutEvaluationsInput = {
    update: XOR<FacilityUpdateWithoutEvaluationsInput, FacilityUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutEvaluationsInput, FacilityUncheckedUpdateWithoutEvaluationsInput>
  }

  export type FacilityUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type StripeInvoiceUpsertWithoutEmployerEvaluationsInput = {
    update: XOR<StripeInvoiceUpdateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedUpdateWithoutEmployerEvaluationsInput>
    create: XOR<StripeInvoiceCreateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedCreateWithoutEmployerEvaluationsInput>
    where?: StripeInvoiceWhereInput
  }

  export type StripeInvoiceUpdateToOneWithWhereWithoutEmployerEvaluationsInput = {
    where?: StripeInvoiceWhereInput
    data: XOR<StripeInvoiceUpdateWithoutEmployerEvaluationsInput, StripeInvoiceUncheckedUpdateWithoutEmployerEvaluationsInput>
  }

  export type StripeInvoiceUpdateWithoutEmployerEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutEmployerEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUpsertWithoutCheckoutEvaluationsInput = {
    update: XOR<StripeInvoiceUpdateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedUpdateWithoutCheckoutEvaluationsInput>
    create: XOR<StripeInvoiceCreateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedCreateWithoutCheckoutEvaluationsInput>
    where?: StripeInvoiceWhereInput
  }

  export type StripeInvoiceUpdateToOneWithWhereWithoutCheckoutEvaluationsInput = {
    where?: StripeInvoiceWhereInput
    data: XOR<StripeInvoiceUpdateWithoutCheckoutEvaluationsInput, StripeInvoiceUncheckedUpdateWithoutCheckoutEvaluationsInput>
  }

  export type StripeInvoiceUpdateWithoutCheckoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutCheckoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
  }

  export type ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    update: XOR<ClinicianUpdateWithoutEvaluationsInput, ClinicianUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    data: XOR<ClinicianUpdateWithoutEvaluationsInput, ClinicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ClinicianUpdateManyWithWhereWithoutEvaluationsInput = {
    where: ClinicianScalarWhereInput
    data: XOR<ClinicianUpdateManyMutationInput, ClinicianUncheckedUpdateManyWithoutEvaluationsInput>
  }

  export type ClinicianScalarWhereInput = {
    AND?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
    OR?: ClinicianScalarWhereInput[]
    NOT?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
    id?: StringFilter<"Clinician"> | string
    name?: StringFilter<"Clinician"> | string
    userId?: StringNullableFilter<"Clinician"> | string | null
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutEvaluationInput, WorkbenchUncheckedUpdateWithoutEvaluationInput>
    create: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutEvaluationInput, WorkbenchUncheckedUpdateWithoutEvaluationInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutEvaluationInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type PatientCreateWithoutFeetInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutFeetInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutFeetInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
  }

  export type WorkbenchCreateWithoutFeetInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutFeetInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutFeetInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
  }

  export type AssetCreateWithoutFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchCreateNestedManyWithoutAssetsInput
    augments?: AssetAugmentCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutAssetsInput
    augments?: AssetAugmentUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutFootInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput>
  }

  export type AssetCreateManyFootInputEnvelope = {
    data: AssetCreateManyFootInput | AssetCreateManyFootInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutFeetInput = {
    update: XOR<PatientUpdateWithoutFeetInput, PatientUncheckedUpdateWithoutFeetInput>
    create: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutFeetInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutFeetInput, PatientUncheckedUpdateWithoutFeetInput>
  }

  export type PatientUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type WorkbenchUpsertWithoutFeetInput = {
    update: XOR<WorkbenchUpdateWithoutFeetInput, WorkbenchUncheckedUpdateWithoutFeetInput>
    create: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutFeetInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutFeetInput, WorkbenchUncheckedUpdateWithoutFeetInput>
  }

  export type WorkbenchUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutFootInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutFootInput, AssetUncheckedUpdateWithoutFootInput>
    create: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutFootInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutFootInput, AssetUncheckedUpdateWithoutFootInput>
  }

  export type AssetUpdateManyWithWhereWithoutFootInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutFootInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type FootCreateWithoutAssetsInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
  }

  export type FootUncheckedCreateWithoutAssetsInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootCreateOrConnectWithoutAssetsInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
  }

  export type WorkbenchCreateWithoutAssetsInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutAssetsInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput>
  }

  export type AssetAugmentCreateWithoutAssetInput = {
    id?: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: AssetAugmentMediaCreateNestedManyWithoutAugmentInput
  }

  export type AssetAugmentUncheckedCreateWithoutAssetInput = {
    id?: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: AssetAugmentMediaUncheckedCreateNestedManyWithoutAugmentInput
  }

  export type AssetAugmentCreateOrConnectWithoutAssetInput = {
    where: AssetAugmentWhereUniqueInput
    create: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput>
  }

  export type AssetAugmentCreateManyAssetInputEnvelope = {
    data: AssetAugmentCreateManyAssetInput | AssetAugmentCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type FootUpsertWithoutAssetsInput = {
    update: XOR<FootUpdateWithoutAssetsInput, FootUncheckedUpdateWithoutAssetsInput>
    create: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    where?: FootWhereInput
  }

  export type FootUpdateToOneWithWhereWithoutAssetsInput = {
    where?: FootWhereInput
    data: XOR<FootUpdateWithoutAssetsInput, FootUncheckedUpdateWithoutAssetsInput>
  }

  export type FootUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
  }

  export type FootUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutAssetsInput, WorkbenchUncheckedUpdateWithoutAssetsInput>
    create: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutAssetsInput, WorkbenchUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutAssetsInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutAssetsInput>
  }

  export type AssetAugmentUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetAugmentWhereUniqueInput
    update: XOR<AssetAugmentUpdateWithoutAssetInput, AssetAugmentUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetAugmentCreateWithoutAssetInput, AssetAugmentUncheckedCreateWithoutAssetInput>
  }

  export type AssetAugmentUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetAugmentWhereUniqueInput
    data: XOR<AssetAugmentUpdateWithoutAssetInput, AssetAugmentUncheckedUpdateWithoutAssetInput>
  }

  export type AssetAugmentUpdateManyWithWhereWithoutAssetInput = {
    where: AssetAugmentScalarWhereInput
    data: XOR<AssetAugmentUpdateManyMutationInput, AssetAugmentUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetAugmentScalarWhereInput = {
    AND?: AssetAugmentScalarWhereInput | AssetAugmentScalarWhereInput[]
    OR?: AssetAugmentScalarWhereInput[]
    NOT?: AssetAugmentScalarWhereInput | AssetAugmentScalarWhereInput[]
    id?: StringFilter<"AssetAugment"> | string
    assetId?: StringFilter<"AssetAugment"> | string
    type?: EnumAssetAugmentTypeFilter<"AssetAugment"> | $Enums.AssetAugmentType
    data?: JsonNullableFilter<"AssetAugment">
    createdAt?: DateTimeFilter<"AssetAugment"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugment"> | Date | string
  }

  export type AssetCreateWithoutAugmentsInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    foot: FootCreateNestedOneWithoutAssetsInput
    workbenches?: WorkbenchCreateNestedManyWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutAugmentsInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type AssetCreateOrConnectWithoutAugmentsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAugmentsInput, AssetUncheckedCreateWithoutAugmentsInput>
  }

  export type AssetAugmentMediaCreateWithoutAugmentInput = {
    id?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentMediaUncheckedCreateWithoutAugmentInput = {
    id?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentMediaCreateOrConnectWithoutAugmentInput = {
    where: AssetAugmentMediaWhereUniqueInput
    create: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput>
  }

  export type AssetAugmentMediaCreateManyAugmentInputEnvelope = {
    data: AssetAugmentMediaCreateManyAugmentInput | AssetAugmentMediaCreateManyAugmentInput[]
    skipDuplicates?: boolean
  }

  export type AssetUpsertWithoutAugmentsInput = {
    update: XOR<AssetUpdateWithoutAugmentsInput, AssetUncheckedUpdateWithoutAugmentsInput>
    create: XOR<AssetCreateWithoutAugmentsInput, AssetUncheckedCreateWithoutAugmentsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAugmentsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAugmentsInput, AssetUncheckedUpdateWithoutAugmentsInput>
  }

  export type AssetUpdateWithoutAugmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foot?: FootUpdateOneRequiredWithoutAssetsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutAugmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type AssetAugmentMediaUpsertWithWhereUniqueWithoutAugmentInput = {
    where: AssetAugmentMediaWhereUniqueInput
    update: XOR<AssetAugmentMediaUpdateWithoutAugmentInput, AssetAugmentMediaUncheckedUpdateWithoutAugmentInput>
    create: XOR<AssetAugmentMediaCreateWithoutAugmentInput, AssetAugmentMediaUncheckedCreateWithoutAugmentInput>
  }

  export type AssetAugmentMediaUpdateWithWhereUniqueWithoutAugmentInput = {
    where: AssetAugmentMediaWhereUniqueInput
    data: XOR<AssetAugmentMediaUpdateWithoutAugmentInput, AssetAugmentMediaUncheckedUpdateWithoutAugmentInput>
  }

  export type AssetAugmentMediaUpdateManyWithWhereWithoutAugmentInput = {
    where: AssetAugmentMediaScalarWhereInput
    data: XOR<AssetAugmentMediaUpdateManyMutationInput, AssetAugmentMediaUncheckedUpdateManyWithoutAugmentInput>
  }

  export type AssetAugmentMediaScalarWhereInput = {
    AND?: AssetAugmentMediaScalarWhereInput | AssetAugmentMediaScalarWhereInput[]
    OR?: AssetAugmentMediaScalarWhereInput[]
    NOT?: AssetAugmentMediaScalarWhereInput | AssetAugmentMediaScalarWhereInput[]
    id?: StringFilter<"AssetAugmentMedia"> | string
    augmentId?: StringFilter<"AssetAugmentMedia"> | string
    data?: JsonNullableFilter<"AssetAugmentMedia">
    originalData?: JsonNullableFilter<"AssetAugmentMedia">
    region?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    bucket?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    key?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    active?: BoolFilter<"AssetAugmentMedia"> | boolean
    inactiveReason?: StringNullableFilter<"AssetAugmentMedia"> | string | null
    reviewedAt?: DateTimeNullableFilter<"AssetAugmentMedia"> | Date | string | null
    createdAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
    updatedAt?: DateTimeFilter<"AssetAugmentMedia"> | Date | string
  }

  export type AssetAugmentCreateWithoutMediaInput = {
    id?: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    asset: AssetCreateNestedOneWithoutAugmentsInput
  }

  export type AssetAugmentUncheckedCreateWithoutMediaInput = {
    id?: string
    assetId: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentCreateOrConnectWithoutMediaInput = {
    where: AssetAugmentWhereUniqueInput
    create: XOR<AssetAugmentCreateWithoutMediaInput, AssetAugmentUncheckedCreateWithoutMediaInput>
  }

  export type AssetAugmentUpsertWithoutMediaInput = {
    update: XOR<AssetAugmentUpdateWithoutMediaInput, AssetAugmentUncheckedUpdateWithoutMediaInput>
    create: XOR<AssetAugmentCreateWithoutMediaInput, AssetAugmentUncheckedCreateWithoutMediaInput>
    where?: AssetAugmentWhereInput
  }

  export type AssetAugmentUpdateToOneWithWhereWithoutMediaInput = {
    where?: AssetAugmentWhereInput
    data: XOR<AssetAugmentUpdateWithoutMediaInput, AssetAugmentUncheckedUpdateWithoutMediaInput>
  }

  export type AssetAugmentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutAugmentsNestedInput
  }

  export type AssetAugmentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutUsedByProductsInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUsedByProductsInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput>
  }

  export type ProductCreateWithoutBuildingBlocksInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBuildingBlocksInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput>
  }

  export type WorkbenchCreateWithoutProductInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutProductInput = {
    id?: string
    patientId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput>
  }

  export type WorkbenchCreateManyProductInputEnvelope = {
    data: WorkbenchCreateManyProductInput | WorkbenchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUsedByProductsInput, ProductUncheckedUpdateWithoutUsedByProductsInput>
    create: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUsedByProductsInput, ProductUncheckedUpdateWithoutUsedByProductsInput>
  }

  export type ProductUpdateManyWithWhereWithoutUsedByProductsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUsedByProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBuildingBlocksInput, ProductUncheckedUpdateWithoutBuildingBlocksInput>
    create: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBuildingBlocksInput, ProductUncheckedUpdateWithoutBuildingBlocksInput>
  }

  export type ProductUpdateManyWithWhereWithoutBuildingBlocksInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBuildingBlocksInput>
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutProductInput, WorkbenchUncheckedUpdateWithoutProductInput>
    create: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutProductInput, WorkbenchUncheckedUpdateWithoutProductInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutProductInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutProductInput>
  }

  export type PatientCreateWithoutWorkbenchesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutWorkbenchesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
  }

  export type ProductCreateWithoutWorkbenchesInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
  }

  export type ProductUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
  }

  export type ProductCreateOrConnectWithoutWorkbenchesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
  }

  export type EvaluationCreateWithoutWorkbenchesInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
  }

  export type EvaluationCreateOrConnectWithoutWorkbenchesInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
  }

  export type AssetCreateWithoutWorkbenchesInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    foot: FootCreateNestedOneWithoutAssetsInput
    augments?: AssetAugmentCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    augments?: AssetAugmentUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput>
  }

  export type OrderCreateWithoutWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingLabel?: ShippingLabelCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    shippingLabelId?: string | null
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput>
  }

  export type OrderCreateManyWorkbenchInputEnvelope = {
    data: OrderCreateManyWorkbenchInput | OrderCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type FootCreateWithoutWorkbenchInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    patientId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootCreateOrConnectWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput>
  }

  export type FootCreateManyWorkbenchInputEnvelope = {
    data: FootCreateManyWorkbenchInput | FootCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutWorkbenchInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: FormSchemaCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    schemaId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput>
  }

  export type FormSubmissionCreateManyWorkbenchInputEnvelope = {
    data: FormSubmissionCreateManyWorkbenchInput | FormSubmissionCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type WorkbenchNotesCreateWithoutWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdByUser?: UserCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesCreateOrConnectWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    create: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesCreateManyWorkbenchInputEnvelope = {
    data: WorkbenchNotesCreateManyWorkbenchInput | WorkbenchNotesCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutWorkbenchesInput = {
    update: XOR<PatientUpdateWithoutWorkbenchesInput, PatientUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutWorkbenchesInput, PatientUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type PatientUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ProductUpsertWithoutWorkbenchesInput = {
    update: XOR<ProductUpdateWithoutWorkbenchesInput, ProductUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWorkbenchesInput, ProductUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type ProductUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
  }

  export type ProductUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
  }

  export type EvaluationUpsertWithoutWorkbenchesInput = {
    update: XOR<EvaluationUpdateWithoutWorkbenchesInput, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutWorkbenchesInput, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type EvaluationUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutWorkbenchesInput, AssetUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutWorkbenchesInput, AssetUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type AssetUpdateManyWithWhereWithoutWorkbenchesInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutWorkbenchesInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWorkbenchInput, OrderUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWorkbenchInput, OrderUncheckedUpdateWithoutWorkbenchInput>
  }

  export type OrderUpdateManyWithWhereWithoutWorkbenchInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    shippingLabelId?: StringNullableFilter<"Order"> | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type FootUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    update: XOR<FootUpdateWithoutWorkbenchInput, FootUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput>
  }

  export type FootUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    data: XOR<FootUpdateWithoutWorkbenchInput, FootUncheckedUpdateWithoutWorkbenchInput>
  }

  export type FootUpdateManyWithWhereWithoutWorkbenchInput = {
    where: FootScalarWhereInput
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutWorkbenchInput, FormSubmissionUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutWorkbenchInput, FormSubmissionUncheckedUpdateWithoutWorkbenchInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    update: XOR<WorkbenchNotesUpdateWithoutWorkbenchInput, WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    data: XOR<WorkbenchNotesUpdateWithoutWorkbenchInput, WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput = {
    where: WorkbenchNotesScalarWhereInput
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type WorkbenchNotesScalarWhereInput = {
    AND?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
    OR?: WorkbenchNotesScalarWhereInput[]
    NOT?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
    id?: StringFilter<"WorkbenchNotes"> | string
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
  }

  export type WorkbenchCreateWithoutNotesInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutNotesInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutNotesInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type WorkbenchUpsertWithoutNotesInput = {
    update: XOR<WorkbenchUpdateWithoutNotesInput, WorkbenchUncheckedUpdateWithoutNotesInput>
    create: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutNotesInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutNotesInput, WorkbenchUncheckedUpdateWithoutNotesInput>
  }

  export type WorkbenchUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkbenchCreateWithoutOrdersInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutOrdersInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutOrdersInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
  }

  export type ShippingLabelCreateWithoutOrdersInput = {
    id?: string
    addressName: string
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    facility?: FacilityCreateNestedOneWithoutShippingLabelsInput
  }

  export type ShippingLabelUncheckedCreateWithoutOrdersInput = {
    id?: string
    addressName: string
    facilityId?: string | null
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingLabelCreateOrConnectWithoutOrdersInput = {
    where: ShippingLabelWhereUniqueInput
    create: XOR<ShippingLabelCreateWithoutOrdersInput, ShippingLabelUncheckedCreateWithoutOrdersInput>
  }

  export type WorkbenchUpsertWithoutOrdersInput = {
    update: XOR<WorkbenchUpdateWithoutOrdersInput, WorkbenchUncheckedUpdateWithoutOrdersInput>
    create: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutOrdersInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutOrdersInput, WorkbenchUncheckedUpdateWithoutOrdersInput>
  }

  export type WorkbenchUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type ShippingLabelUpsertWithoutOrdersInput = {
    update: XOR<ShippingLabelUpdateWithoutOrdersInput, ShippingLabelUncheckedUpdateWithoutOrdersInput>
    create: XOR<ShippingLabelCreateWithoutOrdersInput, ShippingLabelUncheckedCreateWithoutOrdersInput>
    where?: ShippingLabelWhereInput
  }

  export type ShippingLabelUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ShippingLabelWhereInput
    data: XOR<ShippingLabelUpdateWithoutOrdersInput, ShippingLabelUncheckedUpdateWithoutOrdersInput>
  }

  export type ShippingLabelUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneWithoutShippingLabelsNestedInput
  }

  export type ShippingLabelUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateWithoutContactInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutContactInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutContactInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput>
  }

  export type FacilityCreateManyContactInputEnvelope = {
    data: FacilityCreateManyContactInput | FacilityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPatientCreateWithoutContactInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPatientsInput
    patient: PatientCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyPatientUncheckedCreateWithoutContactInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateOrConnectWithoutContactInput = {
    where: CompanyPatientWhereUniqueInput
    create: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput>
  }

  export type CompanyPatientCreateManyContactInputEnvelope = {
    data: CompanyPatientCreateManyContactInput | CompanyPatientCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithWhereUniqueWithoutContactInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutContactInput, FacilityUncheckedUpdateWithoutContactInput>
    create: XOR<FacilityCreateWithoutContactInput, FacilityUncheckedCreateWithoutContactInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutContactInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutContactInput, FacilityUncheckedUpdateWithoutContactInput>
  }

  export type FacilityUpdateManyWithWhereWithoutContactInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutContactInput>
  }

  export type CompanyPatientUpsertWithWhereUniqueWithoutContactInput = {
    where: CompanyPatientWhereUniqueInput
    update: XOR<CompanyPatientUpdateWithoutContactInput, CompanyPatientUncheckedUpdateWithoutContactInput>
    create: XOR<CompanyPatientCreateWithoutContactInput, CompanyPatientUncheckedCreateWithoutContactInput>
  }

  export type CompanyPatientUpdateWithWhereUniqueWithoutContactInput = {
    where: CompanyPatientWhereUniqueInput
    data: XOR<CompanyPatientUpdateWithoutContactInput, CompanyPatientUncheckedUpdateWithoutContactInput>
  }

  export type CompanyPatientUpdateManyWithWhereWithoutContactInput = {
    where: CompanyPatientScalarWhereInput
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyWithoutContactInput>
  }

  export type CompanyCreateWithoutPackagesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPackagesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPackagesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
  }

  export type CompanyUpsertWithoutPackagesInput = {
    update: XOR<CompanyUpdateWithoutPackagesInput, CompanyUncheckedUpdateWithoutPackagesInput>
    create: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPackagesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPackagesInput, CompanyUncheckedUpdateWithoutPackagesInput>
  }

  export type CompanyUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FacilityCreateWithoutShippingLabelsInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    patients?: FacilityPatientCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutShippingLabelsInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    patients?: FacilityPatientUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutShippingLabelsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutShippingLabelsInput, FacilityUncheckedCreateWithoutShippingLabelsInput>
  }

  export type OrderCreateWithoutShippingLabelInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutShippingLabelInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutShippingLabelInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput>
  }

  export type OrderCreateManyShippingLabelInputEnvelope = {
    data: OrderCreateManyShippingLabelInput | OrderCreateManyShippingLabelInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithoutShippingLabelsInput = {
    update: XOR<FacilityUpdateWithoutShippingLabelsInput, FacilityUncheckedUpdateWithoutShippingLabelsInput>
    create: XOR<FacilityCreateWithoutShippingLabelsInput, FacilityUncheckedCreateWithoutShippingLabelsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutShippingLabelsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutShippingLabelsInput, FacilityUncheckedUpdateWithoutShippingLabelsInput>
  }

  export type FacilityUpdateWithoutShippingLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutShippingLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutShippingLabelInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutShippingLabelInput, OrderUncheckedUpdateWithoutShippingLabelInput>
    create: XOR<OrderCreateWithoutShippingLabelInput, OrderUncheckedCreateWithoutShippingLabelInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutShippingLabelInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutShippingLabelInput, OrderUncheckedUpdateWithoutShippingLabelInput>
  }

  export type OrderUpdateManyWithWhereWithoutShippingLabelInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutShippingLabelInput>
  }

  export type EvaluationCreateWithoutReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput>
  }

  export type EvaluationCreateManyReferringPhysicianInputEnvelope = {
    data: EvaluationCreateManyReferringPhysicianInput | EvaluationCreateManyReferringPhysicianInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput>
  }

  export type PatientCreateManyPrimaryPhysicianInputEnvelope = {
    data: PatientCreateManyPrimaryPhysicianInput | PatientCreateManyPrimaryPhysicianInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutReferringPhysicianInput, EvaluationUncheckedUpdateWithoutReferringPhysicianInput>
    create: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutReferringPhysicianInput, EvaluationUncheckedUpdateWithoutReferringPhysicianInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutReferringPhysicianInput>
  }

  export type PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutPrimaryPhysicianInput, PatientUncheckedUpdateWithoutPrimaryPhysicianInput>
    create: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutPrimaryPhysicianInput, PatientUncheckedUpdateWithoutPrimaryPhysicianInput>
  }

  export type PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutPrimaryPhysicianInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
  }

  export type EvaluationCreateWithoutDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput>
  }

  export type EvaluationCreateManyDiagnosisInputEnvelope = {
    data: EvaluationCreateManyDiagnosisInput | EvaluationCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutDiagnosisInput, EvaluationUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutDiagnosisInput, EvaluationUncheckedUpdateWithoutDiagnosisInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutDiagnosisInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type EvaluationCreateWithoutDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput>
  }

  export type EvaluationCreateManyDeviceTypeInputEnvelope = {
    data: EvaluationCreateManyDeviceTypeInput | EvaluationCreateManyDeviceTypeInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutDeviceTypeInput, EvaluationUncheckedUpdateWithoutDeviceTypeInput>
    create: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutDeviceTypeInput, EvaluationUncheckedUpdateWithoutDeviceTypeInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutDeviceTypeInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutDeviceTypeInput>
  }

  export type EvaluationCreateWithoutVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput>
  }

  export type EvaluationCreateManyVisitTypeInputEnvelope = {
    data: EvaluationCreateManyVisitTypeInput | EvaluationCreateManyVisitTypeInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutVisitTypeInput, EvaluationUncheckedUpdateWithoutVisitTypeInput>
    create: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutVisitTypeInput, EvaluationUncheckedUpdateWithoutVisitTypeInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutVisitTypeInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutVisitTypeInput>
  }

  export type FormSubmissionCreateWithoutSchemaInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutSchemaInput = {
    id?: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput>
  }

  export type FormSubmissionCreateManySchemaInputEnvelope = {
    data: FormSubmissionCreateManySchemaInput | FormSubmissionCreateManySchemaInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutSchemaInput, FormSubmissionUncheckedUpdateWithoutSchemaInput>
    create: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutSchemaInput, FormSubmissionUncheckedUpdateWithoutSchemaInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutSchemaInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutSchemaInput>
  }

  export type FormSchemaCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaCreateOrConnectWithoutSubmissionsInput = {
    where: FormSchemaWhereUniqueInput
    create: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
  }

  export type WorkbenchCreateWithoutFormSubmissionsInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutFormSubmissionsInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutFormSubmissionsInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
  }

  export type FormSchemaUpsertWithoutSubmissionsInput = {
    update: XOR<FormSchemaUpdateWithoutSubmissionsInput, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    where?: FormSchemaWhereInput
  }

  export type FormSchemaUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormSchemaWhereInput
    data: XOR<FormSchemaUpdateWithoutSubmissionsInput, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormSchemaUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSchemaUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpsertWithoutFormSubmissionsInput = {
    update: XOR<WorkbenchUpdateWithoutFormSubmissionsInput, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
    create: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutFormSubmissionsInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutFormSubmissionsInput, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type WorkbenchUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type CatalogProductAttributeCreateWithoutProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUncheckedCreateWithoutProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeCreateOrConnectWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    create: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductAttributeCreateManyProductInputEnvelope = {
    data: CatalogProductAttributeCreateManyProductInput | CatalogProductAttributeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CatalogProductVariantCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantCreateOrConnectWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    create: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductVariantCreateManyProductInputEnvelope = {
    data: CatalogProductVariantCreateManyProductInput | CatalogProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CatalogCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryCreateOrConnectWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    create: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CatalogVendorCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorCreateOrConnectWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    create: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput>
  }

  export type CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    update: XOR<CatalogProductAttributeUpdateWithoutProductInput, CatalogProductAttributeUncheckedUpdateWithoutProductInput>
    create: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    data: XOR<CatalogProductAttributeUpdateWithoutProductInput, CatalogProductAttributeUncheckedUpdateWithoutProductInput>
  }

  export type CatalogProductAttributeUpdateManyWithWhereWithoutProductInput = {
    where: CatalogProductAttributeScalarWhereInput
    data: XOR<CatalogProductAttributeUpdateManyMutationInput, CatalogProductAttributeUncheckedUpdateManyWithoutProductInput>
  }

  export type CatalogProductAttributeScalarWhereInput = {
    AND?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
    OR?: CatalogProductAttributeScalarWhereInput[]
    NOT?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
    id?: StringFilter<"CatalogProductAttribute"> | string
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
  }

  export type CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    update: XOR<CatalogProductVariantUpdateWithoutProductInput, CatalogProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    data: XOR<CatalogProductVariantUpdateWithoutProductInput, CatalogProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type CatalogProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: CatalogProductVariantScalarWhereInput
    data: XOR<CatalogProductVariantUpdateManyMutationInput, CatalogProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type CatalogProductVariantScalarWhereInput = {
    AND?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
    OR?: CatalogProductVariantScalarWhereInput[]
    NOT?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
    id?: StringFilter<"CatalogProductVariant"> | string
    productId?: StringFilter<"CatalogProductVariant"> | string
    sku?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
  }

  export type CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    update: XOR<CatalogCategoryUpdateWithoutProductsInput, CatalogCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    data: XOR<CatalogCategoryUpdateWithoutProductsInput, CatalogCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CatalogCategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CatalogCategoryScalarWhereInput
    data: XOR<CatalogCategoryUpdateManyMutationInput, CatalogCategoryUncheckedUpdateManyWithoutProductsInput>
  }

  export type CatalogCategoryScalarWhereInput = {
    AND?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
    OR?: CatalogCategoryScalarWhereInput[]
    NOT?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
    id?: StringFilter<"CatalogCategory"> | string
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
  }

  export type CatalogVendorUpsertWithWhereUniqueWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    update: XOR<CatalogVendorUpdateWithoutProductsInput, CatalogVendorUncheckedUpdateWithoutProductsInput>
    create: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput>
  }

  export type CatalogVendorUpdateWithWhereUniqueWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    data: XOR<CatalogVendorUpdateWithoutProductsInput, CatalogVendorUncheckedUpdateWithoutProductsInput>
  }

  export type CatalogVendorUpdateManyWithWhereWithoutProductsInput = {
    where: CatalogVendorScalarWhereInput
    data: XOR<CatalogVendorUpdateManyMutationInput, CatalogVendorUncheckedUpdateManyWithoutProductsInput>
  }

  export type CatalogVendorScalarWhereInput = {
    AND?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
    OR?: CatalogVendorScalarWhereInput[]
    NOT?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
    id?: StringFilter<"CatalogVendor"> | string
    name?: StringFilter<"CatalogVendor"> | string
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
  }

  export type CatalogProductCreateWithoutAttributesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutAttributesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutAttributesInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
  }

  export type CatalogProductUpsertWithoutAttributesInput = {
    update: XOR<CatalogProductUpdateWithoutAttributesInput, CatalogProductUncheckedUpdateWithoutAttributesInput>
    create: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    where?: CatalogProductWhereInput
  }

  export type CatalogProductUpdateToOneWithWhereWithoutAttributesInput = {
    where?: CatalogProductWhereInput
    data: XOR<CatalogProductUpdateWithoutAttributesInput, CatalogProductUncheckedUpdateWithoutAttributesInput>
  }

  export type CatalogProductUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutVariantsInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
  }

  export type CatalogProductUpsertWithoutVariantsInput = {
    update: XOR<CatalogProductUpdateWithoutVariantsInput, CatalogProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    where?: CatalogProductWhereInput
  }

  export type CatalogProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: CatalogProductWhereInput
    data: XOR<CatalogProductUpdateWithoutVariantsInput, CatalogProductUncheckedUpdateWithoutVariantsInput>
  }

  export type CatalogProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    update: XOR<CatalogProductUpdateWithoutCategoriesInput, CatalogProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    data: XOR<CatalogProductUpdateWithoutCategoriesInput, CatalogProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type CatalogProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: CatalogProductScalarWhereInput
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CatalogProductScalarWhereInput = {
    AND?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
    OR?: CatalogProductScalarWhereInput[]
    NOT?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
    id?: StringFilter<"CatalogProduct"> | string
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    favorite?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
  }

  export type CatalogProductCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    favorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput>
  }

  export type CatalogProductUpsertWithWhereUniqueWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    update: XOR<CatalogProductUpdateWithoutVendorsInput, CatalogProductUncheckedUpdateWithoutVendorsInput>
    create: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput>
  }

  export type CatalogProductUpdateWithWhereUniqueWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    data: XOR<CatalogProductUpdateWithoutVendorsInput, CatalogProductUncheckedUpdateWithoutVendorsInput>
  }

  export type CatalogProductUpdateManyWithWhereWithoutVendorsInput = {
    where: CatalogProductScalarWhereInput
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyWithoutVendorsInput>
  }

  export type UserCreateWithoutAuditsLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditsLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditsLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditsLogsInput = {
    update: XOR<UserUpdateWithoutAuditsLogsInput, UserUncheckedUpdateWithoutAuditsLogsInput>
    create: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsLogsInput, UserUncheckedUpdateWithoutAuditsLogsInput>
  }

  export type UserUpdateWithoutAuditsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDepartmentsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
  }

  export type CompanyCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDepartmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserUpsertWithoutDepartmentsInput = {
    update: XOR<UserUpdateWithoutDepartmentsInput, UserUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepartmentsInput, UserUncheckedUpdateWithoutDepartmentsInput>
  }

  export type UserUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutDepartmentsInput = {
    update: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPatientsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPatientsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
  }

  export type PatientCreateWithoutCompaniesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCompaniesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCompaniesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
  }

  export type ContactCreateWithoutPatientsInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutPatientsInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    phoneNumber?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutPatientsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPatientsInput, ContactUncheckedCreateWithoutPatientsInput>
  }

  export type CompanyUpsertWithoutPatientsInput = {
    update: XOR<CompanyUpdateWithoutPatientsInput, CompanyUncheckedUpdateWithoutPatientsInput>
    create: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPatientsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPatientsInput, CompanyUncheckedUpdateWithoutPatientsInput>
  }

  export type CompanyUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PatientUpsertWithoutCompaniesInput = {
    update: XOR<PatientUpdateWithoutCompaniesInput, PatientUncheckedUpdateWithoutCompaniesInput>
    create: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutCompaniesInput, PatientUncheckedUpdateWithoutCompaniesInput>
  }

  export type PatientUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ContactUpsertWithoutPatientsInput = {
    update: XOR<ContactUpdateWithoutPatientsInput, ContactUncheckedUpdateWithoutPatientsInput>
    create: XOR<ContactCreateWithoutPatientsInput, ContactUncheckedCreateWithoutPatientsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPatientsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPatientsInput, ContactUncheckedUpdateWithoutPatientsInput>
  }

  export type ContactUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type FacilityCreateWithoutPatientsInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FacilityCreateNestedOneWithoutChildrenInput
    children?: FacilityCreateNestedManyWithoutParentInput
    contact?: ContactCreateNestedOneWithoutFacilitiesInput
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
    children?: FacilityUncheckedCreateNestedManyWithoutParentInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
    shippingLabels?: ShippingLabelUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutPatientsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutPatientsInput, FacilityUncheckedCreateWithoutPatientsInput>
  }

  export type PatientCreateWithoutFacilitiesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutFacilitiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutFacilitiesInput, PatientUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityUpsertWithoutPatientsInput = {
    update: XOR<FacilityUpdateWithoutPatientsInput, FacilityUncheckedUpdateWithoutPatientsInput>
    create: XOR<FacilityCreateWithoutPatientsInput, FacilityUncheckedCreateWithoutPatientsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutPatientsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutPatientsInput, FacilityUncheckedUpdateWithoutPatientsInput>
  }

  export type FacilityUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type PatientUpsertWithoutFacilitiesInput = {
    update: XOR<PatientUpdateWithoutFacilitiesInput, PatientUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<PatientCreateWithoutFacilitiesInput, PatientUncheckedCreateWithoutFacilitiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutFacilitiesInput, PatientUncheckedUpdateWithoutFacilitiesInput>
  }

  export type PatientUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StripeEntityCreateWithoutStripeProductsInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutStripeProductsInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutStripeProductsInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutStripeProductsInput, StripeEntityUncheckedCreateWithoutStripeProductsInput>
  }

  export type StripeInvoiceCreateWithoutStripeProductsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutStripeProductsInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutStripeProductsInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput>
  }

  export type StripeSubscriptionCreateWithoutStripeProductsInput = {
    id?: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity: StripeEntityCreateNestedOneWithoutStripeSubscriptionsInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeSubscriptionInput
  }

  export type StripeSubscriptionUncheckedCreateWithoutStripeProductsInput = {
    id?: string
    stripeEntityId: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeSubscriptionInput
  }

  export type StripeSubscriptionCreateOrConnectWithoutStripeProductsInput = {
    where: StripeSubscriptionWhereUniqueInput
    create: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput>
  }

  export type StripeSubscriptionCreateManyStripeProductsInputEnvelope = {
    data: StripeSubscriptionCreateManyStripeProductsInput | StripeSubscriptionCreateManyStripeProductsInput[]
    skipDuplicates?: boolean
  }

  export type StripeEntityUpsertWithoutStripeProductsInput = {
    update: XOR<StripeEntityUpdateWithoutStripeProductsInput, StripeEntityUncheckedUpdateWithoutStripeProductsInput>
    create: XOR<StripeEntityCreateWithoutStripeProductsInput, StripeEntityUncheckedCreateWithoutStripeProductsInput>
    where?: StripeEntityWhereInput
  }

  export type StripeEntityUpdateToOneWithWhereWithoutStripeProductsInput = {
    where?: StripeEntityWhereInput
    data: XOR<StripeEntityUpdateWithoutStripeProductsInput, StripeEntityUncheckedUpdateWithoutStripeProductsInput>
  }

  export type StripeEntityUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeInvoiceUpsertWithWhereUniqueWithoutStripeProductsInput = {
    where: StripeInvoiceWhereUniqueInput
    update: XOR<StripeInvoiceUpdateWithoutStripeProductsInput, StripeInvoiceUncheckedUpdateWithoutStripeProductsInput>
    create: XOR<StripeInvoiceCreateWithoutStripeProductsInput, StripeInvoiceUncheckedCreateWithoutStripeProductsInput>
  }

  export type StripeInvoiceUpdateWithWhereUniqueWithoutStripeProductsInput = {
    where: StripeInvoiceWhereUniqueInput
    data: XOR<StripeInvoiceUpdateWithoutStripeProductsInput, StripeInvoiceUncheckedUpdateWithoutStripeProductsInput>
  }

  export type StripeInvoiceUpdateManyWithWhereWithoutStripeProductsInput = {
    where: StripeInvoiceScalarWhereInput
    data: XOR<StripeInvoiceUpdateManyMutationInput, StripeInvoiceUncheckedUpdateManyWithoutStripeProductsInput>
  }

  export type StripeInvoiceScalarWhereInput = {
    AND?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
    OR?: StripeInvoiceScalarWhereInput[]
    NOT?: StripeInvoiceScalarWhereInput | StripeInvoiceScalarWhereInput[]
    id?: StringFilter<"StripeInvoice"> | string
    stripeInvoiceId?: StringFilter<"StripeInvoice"> | string
    price?: FloatFilter<"StripeInvoice"> | number
    type?: EnumStripeInvoiceTypeFilter<"StripeInvoice"> | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFilter<"StripeInvoice"> | $Enums.StripeInvoiceStatus
    lastWebhookId?: StringNullableFilter<"StripeInvoice"> | string | null
    metadata?: JsonNullableFilter<"StripeInvoice">
    subscriptionId?: StringNullableFilter<"StripeInvoice"> | string | null
    combinedInvoiceId?: StringNullableFilter<"StripeInvoice"> | string | null
    stripeEntityId?: StringNullableFilter<"StripeInvoice"> | string | null
    createdAt?: DateTimeFilter<"StripeInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"StripeInvoice"> | Date | string
  }

  export type StripeSubscriptionUpsertWithWhereUniqueWithoutStripeProductsInput = {
    where: StripeSubscriptionWhereUniqueInput
    update: XOR<StripeSubscriptionUpdateWithoutStripeProductsInput, StripeSubscriptionUncheckedUpdateWithoutStripeProductsInput>
    create: XOR<StripeSubscriptionCreateWithoutStripeProductsInput, StripeSubscriptionUncheckedCreateWithoutStripeProductsInput>
  }

  export type StripeSubscriptionUpdateWithWhereUniqueWithoutStripeProductsInput = {
    where: StripeSubscriptionWhereUniqueInput
    data: XOR<StripeSubscriptionUpdateWithoutStripeProductsInput, StripeSubscriptionUncheckedUpdateWithoutStripeProductsInput>
  }

  export type StripeSubscriptionUpdateManyWithWhereWithoutStripeProductsInput = {
    where: StripeSubscriptionScalarWhereInput
    data: XOR<StripeSubscriptionUpdateManyMutationInput, StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsInput>
  }

  export type StripeSubscriptionScalarWhereInput = {
    AND?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
    OR?: StripeSubscriptionScalarWhereInput[]
    NOT?: StripeSubscriptionScalarWhereInput | StripeSubscriptionScalarWhereInput[]
    id?: StringFilter<"StripeSubscription"> | string
    stripeEntityId?: StringFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringFilter<"StripeSubscription"> | string
    stripeProductId?: StringFilter<"StripeSubscription"> | string
    active?: BoolFilter<"StripeSubscription"> | boolean
    createdAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"StripeSubscription"> | Date | string
  }

  export type StripeProductCreateWithoutStripeInvoicesInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeProductsInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductUncheckedCreateWithoutStripeInvoicesInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeEntityId?: string | null
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductCreateOrConnectWithoutStripeInvoicesInput = {
    where: StripeProductWhereUniqueInput
    create: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput>
  }

  export type StripeInvoiceCreateWithoutCombinedInvoicesInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutCombinedInvoicesInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutCombinedInvoicesInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoicesInput>
  }

  export type StripeInvoiceCreateWithoutCombinedInvoiceInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutCombinedInvoiceInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput>
  }

  export type StripeInvoiceCreateManyCombinedInvoiceInputEnvelope = {
    data: StripeInvoiceCreateManyCombinedInvoiceInput | StripeInvoiceCreateManyCombinedInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type StripeSubscriptionCreateWithoutStripeInvoicesInput = {
    id?: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity: StripeEntityCreateNestedOneWithoutStripeSubscriptionsInput
    stripeProducts: StripeProductCreateNestedOneWithoutStripeSubscriptionsInput
  }

  export type StripeSubscriptionUncheckedCreateWithoutStripeInvoicesInput = {
    id?: string
    stripeEntityId: string
    stripeSubscriptionId: string
    stripeProductId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionCreateOrConnectWithoutStripeInvoicesInput = {
    where: StripeSubscriptionWhereUniqueInput
    create: XOR<StripeSubscriptionCreateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedCreateWithoutStripeInvoicesInput>
  }

  export type StripeEntityCreateWithoutStripeInvoicesInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutStripeInvoicesInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutStripeInvoicesInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutStripeInvoicesInput, StripeEntityUncheckedCreateWithoutStripeInvoicesInput>
  }

  export type EvaluationCreateWithoutStripeInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeCheckoutInvoice?: StripeInvoiceCreateNestedOneWithoutCheckoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutStripeInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutStripeInvoiceInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput>
  }

  export type EvaluationCreateManyStripeInvoiceInputEnvelope = {
    data: EvaluationCreateManyStripeInvoiceInput | EvaluationCreateManyStripeInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutStripeCheckoutInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    stripeInvoice?: StripeInvoiceCreateNestedOneWithoutEmployerEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutStripeCheckoutInvoiceInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput>
  }

  export type EvaluationCreateManyStripeCheckoutInvoiceInputEnvelope = {
    data: EvaluationCreateManyStripeCheckoutInvoiceInput | EvaluationCreateManyStripeCheckoutInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type StripeProductUpsertWithWhereUniqueWithoutStripeInvoicesInput = {
    where: StripeProductWhereUniqueInput
    update: XOR<StripeProductUpdateWithoutStripeInvoicesInput, StripeProductUncheckedUpdateWithoutStripeInvoicesInput>
    create: XOR<StripeProductCreateWithoutStripeInvoicesInput, StripeProductUncheckedCreateWithoutStripeInvoicesInput>
  }

  export type StripeProductUpdateWithWhereUniqueWithoutStripeInvoicesInput = {
    where: StripeProductWhereUniqueInput
    data: XOR<StripeProductUpdateWithoutStripeInvoicesInput, StripeProductUncheckedUpdateWithoutStripeInvoicesInput>
  }

  export type StripeProductUpdateManyWithWhereWithoutStripeInvoicesInput = {
    where: StripeProductScalarWhereInput
    data: XOR<StripeProductUpdateManyMutationInput, StripeProductUncheckedUpdateManyWithoutStripeInvoicesInput>
  }

  export type StripeProductScalarWhereInput = {
    AND?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
    OR?: StripeProductScalarWhereInput[]
    NOT?: StripeProductScalarWhereInput | StripeProductScalarWhereInput[]
    id?: StringFilter<"StripeProduct"> | string
    type?: EnumStripeProductTypeFilter<"StripeProduct"> | $Enums.StripeProductType
    stripeEntityId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeProductId?: StringFilter<"StripeProduct"> | string
    stripePriceId?: StringNullableFilter<"StripeProduct"> | string | null
    stripeCouponId?: StringNullableFilter<"StripeProduct"> | string | null
    frequency?: EnumStripeBillingFrequencyNullableFilter<"StripeProduct"> | $Enums.StripeBillingFrequency | null
    amount?: FloatNullableFilter<"StripeProduct"> | number | null
    description?: StringNullableFilter<"StripeProduct"> | string | null
    active?: BoolFilter<"StripeProduct"> | boolean
    createdAt?: DateTimeFilter<"StripeProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StripeProduct"> | Date | string
  }

  export type StripeInvoiceUpsertWithoutCombinedInvoicesInput = {
    update: XOR<StripeInvoiceUpdateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedUpdateWithoutCombinedInvoicesInput>
    create: XOR<StripeInvoiceCreateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoicesInput>
    where?: StripeInvoiceWhereInput
  }

  export type StripeInvoiceUpdateToOneWithWhereWithoutCombinedInvoicesInput = {
    where?: StripeInvoiceWhereInput
    data: XOR<StripeInvoiceUpdateWithoutCombinedInvoicesInput, StripeInvoiceUncheckedUpdateWithoutCombinedInvoicesInput>
  }

  export type StripeInvoiceUpdateWithoutCombinedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutCombinedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUpsertWithWhereUniqueWithoutCombinedInvoiceInput = {
    where: StripeInvoiceWhereUniqueInput
    update: XOR<StripeInvoiceUpdateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedUpdateWithoutCombinedInvoiceInput>
    create: XOR<StripeInvoiceCreateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedCreateWithoutCombinedInvoiceInput>
  }

  export type StripeInvoiceUpdateWithWhereUniqueWithoutCombinedInvoiceInput = {
    where: StripeInvoiceWhereUniqueInput
    data: XOR<StripeInvoiceUpdateWithoutCombinedInvoiceInput, StripeInvoiceUncheckedUpdateWithoutCombinedInvoiceInput>
  }

  export type StripeInvoiceUpdateManyWithWhereWithoutCombinedInvoiceInput = {
    where: StripeInvoiceScalarWhereInput
    data: XOR<StripeInvoiceUpdateManyMutationInput, StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceInput>
  }

  export type StripeSubscriptionUpsertWithoutStripeInvoicesInput = {
    update: XOR<StripeSubscriptionUpdateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedUpdateWithoutStripeInvoicesInput>
    create: XOR<StripeSubscriptionCreateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedCreateWithoutStripeInvoicesInput>
    where?: StripeSubscriptionWhereInput
  }

  export type StripeSubscriptionUpdateToOneWithWhereWithoutStripeInvoicesInput = {
    where?: StripeSubscriptionWhereInput
    data: XOR<StripeSubscriptionUpdateWithoutStripeInvoicesInput, StripeSubscriptionUncheckedUpdateWithoutStripeInvoicesInput>
  }

  export type StripeSubscriptionUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
    stripeProducts?: StripeProductUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEntityId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripeProductId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeEntityUpsertWithoutStripeInvoicesInput = {
    update: XOR<StripeEntityUpdateWithoutStripeInvoicesInput, StripeEntityUncheckedUpdateWithoutStripeInvoicesInput>
    create: XOR<StripeEntityCreateWithoutStripeInvoicesInput, StripeEntityUncheckedCreateWithoutStripeInvoicesInput>
    where?: StripeEntityWhereInput
  }

  export type StripeEntityUpdateToOneWithWhereWithoutStripeInvoicesInput = {
    where?: StripeEntityWhereInput
    data: XOR<StripeEntityUpdateWithoutStripeInvoicesInput, StripeEntityUncheckedUpdateWithoutStripeInvoicesInput>
  }

  export type StripeEntityUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutStripeInvoiceInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutStripeInvoiceInput, EvaluationUncheckedUpdateWithoutStripeInvoiceInput>
    create: XOR<EvaluationCreateWithoutStripeInvoiceInput, EvaluationUncheckedCreateWithoutStripeInvoiceInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutStripeInvoiceInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutStripeInvoiceInput, EvaluationUncheckedUpdateWithoutStripeInvoiceInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutStripeInvoiceInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutStripeInvoiceInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutStripeCheckoutInvoiceInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedUpdateWithoutStripeCheckoutInvoiceInput>
    create: XOR<EvaluationCreateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedCreateWithoutStripeCheckoutInvoiceInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutStripeCheckoutInvoiceInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutStripeCheckoutInvoiceInput, EvaluationUncheckedUpdateWithoutStripeCheckoutInvoiceInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutStripeCheckoutInvoiceInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceInput>
  }

  export type CompanyCreateWithoutStripeEntitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStripeEntitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStripeEntitiesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStripeEntitiesInput, CompanyUncheckedCreateWithoutStripeEntitiesInput>
  }

  export type StripeEntityCreateWithoutChildEntitiesInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutChildEntitiesInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutChildEntitiesInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutChildEntitiesInput, StripeEntityUncheckedCreateWithoutChildEntitiesInput>
  }

  export type StripeEntityCreateWithoutParentEntityInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutParentEntityInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutParentEntityInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput>
  }

  export type StripeEntityCreateManyParentEntityInputEnvelope = {
    data: StripeEntityCreateManyParentEntityInput | StripeEntityCreateManyParentEntityInput[]
    skipDuplicates?: boolean
  }

  export type StripeProductCreateWithoutStripeEntityInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeProductsInput
    stripeSubscriptions?: StripeSubscriptionCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductUncheckedCreateWithoutStripeEntityInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeProductsInput
    stripeSubscriptions?: StripeSubscriptionUncheckedCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductCreateOrConnectWithoutStripeEntityInput = {
    where: StripeProductWhereUniqueInput
    create: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeProductCreateManyStripeEntityInputEnvelope = {
    data: StripeProductCreateManyStripeEntityInput | StripeProductCreateManyStripeEntityInput[]
    skipDuplicates?: boolean
  }

  export type StripeSubscriptionCreateWithoutStripeEntityInput = {
    id?: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeSubscriptionInput
    stripeProducts: StripeProductCreateNestedOneWithoutStripeSubscriptionsInput
  }

  export type StripeSubscriptionUncheckedCreateWithoutStripeEntityInput = {
    id?: string
    stripeSubscriptionId: string
    stripeProductId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeSubscriptionInput
  }

  export type StripeSubscriptionCreateOrConnectWithoutStripeEntityInput = {
    where: StripeSubscriptionWhereUniqueInput
    create: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeSubscriptionCreateManyStripeEntityInputEnvelope = {
    data: StripeSubscriptionCreateManyStripeEntityInput | StripeSubscriptionCreateManyStripeEntityInput[]
    skipDuplicates?: boolean
  }

  export type StripeInvoiceCreateWithoutStripeEntityInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutStripeEntityInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutStripeEntityInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeInvoiceCreateManyStripeEntityInputEnvelope = {
    data: StripeInvoiceCreateManyStripeEntityInput | StripeInvoiceCreateManyStripeEntityInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutStripeEntitiesInput = {
    update: XOR<CompanyUpdateWithoutStripeEntitiesInput, CompanyUncheckedUpdateWithoutStripeEntitiesInput>
    create: XOR<CompanyCreateWithoutStripeEntitiesInput, CompanyUncheckedCreateWithoutStripeEntitiesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStripeEntitiesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStripeEntitiesInput, CompanyUncheckedUpdateWithoutStripeEntitiesInput>
  }

  export type CompanyUpdateWithoutStripeEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStripeEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type StripeEntityUpsertWithoutChildEntitiesInput = {
    update: XOR<StripeEntityUpdateWithoutChildEntitiesInput, StripeEntityUncheckedUpdateWithoutChildEntitiesInput>
    create: XOR<StripeEntityCreateWithoutChildEntitiesInput, StripeEntityUncheckedCreateWithoutChildEntitiesInput>
    where?: StripeEntityWhereInput
  }

  export type StripeEntityUpdateToOneWithWhereWithoutChildEntitiesInput = {
    where?: StripeEntityWhereInput
    data: XOR<StripeEntityUpdateWithoutChildEntitiesInput, StripeEntityUncheckedUpdateWithoutChildEntitiesInput>
  }

  export type StripeEntityUpdateWithoutChildEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutChildEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUpsertWithWhereUniqueWithoutParentEntityInput = {
    where: StripeEntityWhereUniqueInput
    update: XOR<StripeEntityUpdateWithoutParentEntityInput, StripeEntityUncheckedUpdateWithoutParentEntityInput>
    create: XOR<StripeEntityCreateWithoutParentEntityInput, StripeEntityUncheckedCreateWithoutParentEntityInput>
  }

  export type StripeEntityUpdateWithWhereUniqueWithoutParentEntityInput = {
    where: StripeEntityWhereUniqueInput
    data: XOR<StripeEntityUpdateWithoutParentEntityInput, StripeEntityUncheckedUpdateWithoutParentEntityInput>
  }

  export type StripeEntityUpdateManyWithWhereWithoutParentEntityInput = {
    where: StripeEntityScalarWhereInput
    data: XOR<StripeEntityUpdateManyMutationInput, StripeEntityUncheckedUpdateManyWithoutParentEntityInput>
  }

  export type StripeProductUpsertWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeProductWhereUniqueInput
    update: XOR<StripeProductUpdateWithoutStripeEntityInput, StripeProductUncheckedUpdateWithoutStripeEntityInput>
    create: XOR<StripeProductCreateWithoutStripeEntityInput, StripeProductUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeProductUpdateWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeProductWhereUniqueInput
    data: XOR<StripeProductUpdateWithoutStripeEntityInput, StripeProductUncheckedUpdateWithoutStripeEntityInput>
  }

  export type StripeProductUpdateManyWithWhereWithoutStripeEntityInput = {
    where: StripeProductScalarWhereInput
    data: XOR<StripeProductUpdateManyMutationInput, StripeProductUncheckedUpdateManyWithoutStripeEntityInput>
  }

  export type StripeSubscriptionUpsertWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeSubscriptionWhereUniqueInput
    update: XOR<StripeSubscriptionUpdateWithoutStripeEntityInput, StripeSubscriptionUncheckedUpdateWithoutStripeEntityInput>
    create: XOR<StripeSubscriptionCreateWithoutStripeEntityInput, StripeSubscriptionUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeSubscriptionUpdateWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeSubscriptionWhereUniqueInput
    data: XOR<StripeSubscriptionUpdateWithoutStripeEntityInput, StripeSubscriptionUncheckedUpdateWithoutStripeEntityInput>
  }

  export type StripeSubscriptionUpdateManyWithWhereWithoutStripeEntityInput = {
    where: StripeSubscriptionScalarWhereInput
    data: XOR<StripeSubscriptionUpdateManyMutationInput, StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityInput>
  }

  export type StripeInvoiceUpsertWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeInvoiceWhereUniqueInput
    update: XOR<StripeInvoiceUpdateWithoutStripeEntityInput, StripeInvoiceUncheckedUpdateWithoutStripeEntityInput>
    create: XOR<StripeInvoiceCreateWithoutStripeEntityInput, StripeInvoiceUncheckedCreateWithoutStripeEntityInput>
  }

  export type StripeInvoiceUpdateWithWhereUniqueWithoutStripeEntityInput = {
    where: StripeInvoiceWhereUniqueInput
    data: XOR<StripeInvoiceUpdateWithoutStripeEntityInput, StripeInvoiceUncheckedUpdateWithoutStripeEntityInput>
  }

  export type StripeInvoiceUpdateManyWithWhereWithoutStripeEntityInput = {
    where: StripeInvoiceScalarWhereInput
    data: XOR<StripeInvoiceUpdateManyMutationInput, StripeInvoiceUncheckedUpdateManyWithoutStripeEntityInput>
  }

  export type StripeEntityCreateWithoutStripeSubscriptionsInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStripeEntitiesInput
    parentEntity?: StripeEntityCreateNestedOneWithoutChildEntitiesInput
    childEntities?: StripeEntityCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityUncheckedCreateWithoutStripeSubscriptionsInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
    childEntities?: StripeEntityUncheckedCreateNestedManyWithoutParentEntityInput
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeEntityInput
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeEntityInput
  }

  export type StripeEntityCreateOrConnectWithoutStripeSubscriptionsInput = {
    where: StripeEntityWhereUniqueInput
    create: XOR<StripeEntityCreateWithoutStripeSubscriptionsInput, StripeEntityUncheckedCreateWithoutStripeSubscriptionsInput>
  }

  export type StripeInvoiceCreateWithoutStripeSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoice?: StripeInvoiceCreateNestedOneWithoutCombinedInvoicesInput
    combinedInvoices?: StripeInvoiceCreateNestedManyWithoutCombinedInvoiceInput
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeInvoicesInput
    employerEvaluations?: EvaluationCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeProducts?: StripeProductUncheckedCreateNestedManyWithoutStripeInvoicesInput
    combinedInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutCombinedInvoiceInput
    employerEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeInvoiceInput
    checkoutEvaluations?: EvaluationUncheckedCreateNestedManyWithoutStripeCheckoutInvoiceInput
  }

  export type StripeInvoiceCreateOrConnectWithoutStripeSubscriptionInput = {
    where: StripeInvoiceWhereUniqueInput
    create: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput>
  }

  export type StripeInvoiceCreateManyStripeSubscriptionInputEnvelope = {
    data: StripeInvoiceCreateManyStripeSubscriptionInput | StripeInvoiceCreateManyStripeSubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type StripeProductCreateWithoutStripeSubscriptionsInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeEntity?: StripeEntityCreateNestedOneWithoutStripeProductsInput
    stripeInvoices?: StripeInvoiceCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductUncheckedCreateWithoutStripeSubscriptionsInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeEntityId?: string | null
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeInvoices?: StripeInvoiceUncheckedCreateNestedManyWithoutStripeProductsInput
  }

  export type StripeProductCreateOrConnectWithoutStripeSubscriptionsInput = {
    where: StripeProductWhereUniqueInput
    create: XOR<StripeProductCreateWithoutStripeSubscriptionsInput, StripeProductUncheckedCreateWithoutStripeSubscriptionsInput>
  }

  export type StripeEntityUpsertWithoutStripeSubscriptionsInput = {
    update: XOR<StripeEntityUpdateWithoutStripeSubscriptionsInput, StripeEntityUncheckedUpdateWithoutStripeSubscriptionsInput>
    create: XOR<StripeEntityCreateWithoutStripeSubscriptionsInput, StripeEntityUncheckedCreateWithoutStripeSubscriptionsInput>
    where?: StripeEntityWhereInput
  }

  export type StripeEntityUpdateToOneWithWhereWithoutStripeSubscriptionsInput = {
    where?: StripeEntityWhereInput
    data: XOR<StripeEntityUpdateWithoutStripeSubscriptionsInput, StripeEntityUncheckedUpdateWithoutStripeSubscriptionsInput>
  }

  export type StripeEntityUpdateWithoutStripeSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutStripeSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeInvoiceUpsertWithWhereUniqueWithoutStripeSubscriptionInput = {
    where: StripeInvoiceWhereUniqueInput
    update: XOR<StripeInvoiceUpdateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedUpdateWithoutStripeSubscriptionInput>
    create: XOR<StripeInvoiceCreateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedCreateWithoutStripeSubscriptionInput>
  }

  export type StripeInvoiceUpdateWithWhereUniqueWithoutStripeSubscriptionInput = {
    where: StripeInvoiceWhereUniqueInput
    data: XOR<StripeInvoiceUpdateWithoutStripeSubscriptionInput, StripeInvoiceUncheckedUpdateWithoutStripeSubscriptionInput>
  }

  export type StripeInvoiceUpdateManyWithWhereWithoutStripeSubscriptionInput = {
    where: StripeInvoiceScalarWhereInput
    data: XOR<StripeInvoiceUpdateManyMutationInput, StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionInput>
  }

  export type StripeProductUpsertWithoutStripeSubscriptionsInput = {
    update: XOR<StripeProductUpdateWithoutStripeSubscriptionsInput, StripeProductUncheckedUpdateWithoutStripeSubscriptionsInput>
    create: XOR<StripeProductCreateWithoutStripeSubscriptionsInput, StripeProductUncheckedCreateWithoutStripeSubscriptionsInput>
    where?: StripeProductWhereInput
  }

  export type StripeProductUpdateToOneWithWhereWithoutStripeSubscriptionsInput = {
    where?: StripeProductWhereInput
    data: XOR<StripeProductUpdateWithoutStripeSubscriptionsInput, StripeProductUncheckedUpdateWithoutStripeSubscriptionsInput>
  }

  export type StripeProductUpdateWithoutStripeSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneWithoutStripeProductsNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateWithoutStripeSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeProductsNestedInput
  }

  export type NotificationMessageCreateWithoutNotificationInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTemplate?: EmailTemplateCreateNestedOneWithoutNotificationMessagesInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageUncheckedCreateWithoutNotificationInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    emailTemplateId?: string | null
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageCreateOrConnectWithoutNotificationInput = {
    where: NotificationMessageWhereUniqueInput
    create: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationMessageCreateManyNotificationInputEnvelope = {
    data: NotificationMessageCreateManyNotificationInput | NotificationMessageCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationMessageUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationMessageWhereUniqueInput
    update: XOR<NotificationMessageUpdateWithoutNotificationInput, NotificationMessageUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationMessageCreateWithoutNotificationInput, NotificationMessageUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationMessageUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationMessageWhereUniqueInput
    data: XOR<NotificationMessageUpdateWithoutNotificationInput, NotificationMessageUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationMessageUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationMessageScalarWhereInput
    data: XOR<NotificationMessageUpdateManyMutationInput, NotificationMessageUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationMessageScalarWhereInput = {
    AND?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
    OR?: NotificationMessageScalarWhereInput[]
    NOT?: NotificationMessageScalarWhereInput | NotificationMessageScalarWhereInput[]
    id?: StringFilter<"NotificationMessage"> | string
    notificationId?: StringFilter<"NotificationMessage"> | string
    sequence?: FloatFilter<"NotificationMessage"> | number
    delayMinutes?: FloatNullableFilter<"NotificationMessage"> | number | null
    recurrencePattern?: StringNullableFilter<"NotificationMessage"> | string | null
    sequenceLimit?: FloatNullableFilter<"NotificationMessage"> | number | null
    content?: StringFilter<"NotificationMessage"> | string
    emailTemplateId?: StringNullableFilter<"NotificationMessage"> | string | null
    channel?: EnumCommunicationChannelFilter<"NotificationMessage"> | $Enums.CommunicationChannel
    createdAt?: DateTimeFilter<"NotificationMessage"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationMessage"> | Date | string
  }

  export type NotificationCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    responseType?: $Enums.NotificationResponseType | null
    publish?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    responseType?: $Enums.NotificationResponseType | null
    publish?: boolean
    startTime?: Date | string | null
    endTime?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutMessagesInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMessagesInput, NotificationUncheckedCreateWithoutMessagesInput>
  }

  export type EmailTemplateCreateWithoutNotificationMessagesInput = {
    id?: string
    title: string
    design: JsonNullValueInput | InputJsonValue
    htmlContent: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateWithoutNotificationMessagesInput = {
    id?: string
    title: string
    design: JsonNullValueInput | InputJsonValue
    htmlContent: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateCreateOrConnectWithoutNotificationMessagesInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutNotificationMessagesInput, EmailTemplateUncheckedCreateWithoutNotificationMessagesInput>
  }

  export type NotificationHistoryCreateWithoutMessageInput = {
    id?: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutNotificationHistoryInput
  }

  export type NotificationHistoryUncheckedCreateWithoutMessageInput = {
    id?: string
    patientId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationHistoryCreateOrConnectWithoutMessageInput = {
    where: NotificationHistoryWhereUniqueInput
    create: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput>
  }

  export type NotificationHistoryCreateManyMessageInputEnvelope = {
    data: NotificationHistoryCreateManyMessageInput | NotificationHistoryCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithoutMessagesInput = {
    update: XOR<NotificationUpdateWithoutMessagesInput, NotificationUncheckedUpdateWithoutMessagesInput>
    create: XOR<NotificationCreateWithoutMessagesInput, NotificationUncheckedCreateWithoutMessagesInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutMessagesInput, NotificationUncheckedUpdateWithoutMessagesInput>
  }

  export type NotificationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    responseType?: NullableEnumNotificationResponseTypeFieldUpdateOperationsInput | $Enums.NotificationResponseType | null
    publish?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUpsertWithoutNotificationMessagesInput = {
    update: XOR<EmailTemplateUpdateWithoutNotificationMessagesInput, EmailTemplateUncheckedUpdateWithoutNotificationMessagesInput>
    create: XOR<EmailTemplateCreateWithoutNotificationMessagesInput, EmailTemplateUncheckedCreateWithoutNotificationMessagesInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutNotificationMessagesInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutNotificationMessagesInput, EmailTemplateUncheckedUpdateWithoutNotificationMessagesInput>
  }

  export type EmailTemplateUpdateWithoutNotificationMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateWithoutNotificationMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    design?: JsonNullValueInput | InputJsonValue
    htmlContent?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryUpsertWithWhereUniqueWithoutMessageInput = {
    where: NotificationHistoryWhereUniqueInput
    update: XOR<NotificationHistoryUpdateWithoutMessageInput, NotificationHistoryUncheckedUpdateWithoutMessageInput>
    create: XOR<NotificationHistoryCreateWithoutMessageInput, NotificationHistoryUncheckedCreateWithoutMessageInput>
  }

  export type NotificationHistoryUpdateWithWhereUniqueWithoutMessageInput = {
    where: NotificationHistoryWhereUniqueInput
    data: XOR<NotificationHistoryUpdateWithoutMessageInput, NotificationHistoryUncheckedUpdateWithoutMessageInput>
  }

  export type NotificationHistoryUpdateManyWithWhereWithoutMessageInput = {
    where: NotificationHistoryScalarWhereInput
    data: XOR<NotificationHistoryUpdateManyMutationInput, NotificationHistoryUncheckedUpdateManyWithoutMessageInput>
  }

  export type PatientCreateWithoutNotificationHistoryInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutNotificationHistoryInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
    facilities?: FacilityPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutNotificationHistoryInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutNotificationHistoryInput, PatientUncheckedCreateWithoutNotificationHistoryInput>
  }

  export type NotificationMessageCreateWithoutNotificationHistoryInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutMessagesInput
    emailTemplate?: EmailTemplateCreateNestedOneWithoutNotificationMessagesInput
  }

  export type NotificationMessageUncheckedCreateWithoutNotificationHistoryInput = {
    id?: string
    notificationId: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    emailTemplateId?: string | null
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationMessageCreateOrConnectWithoutNotificationHistoryInput = {
    where: NotificationMessageWhereUniqueInput
    create: XOR<NotificationMessageCreateWithoutNotificationHistoryInput, NotificationMessageUncheckedCreateWithoutNotificationHistoryInput>
  }

  export type PatientUpsertWithoutNotificationHistoryInput = {
    update: XOR<PatientUpdateWithoutNotificationHistoryInput, PatientUncheckedUpdateWithoutNotificationHistoryInput>
    create: XOR<PatientCreateWithoutNotificationHistoryInput, PatientUncheckedCreateWithoutNotificationHistoryInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutNotificationHistoryInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutNotificationHistoryInput, PatientUncheckedUpdateWithoutNotificationHistoryInput>
  }

  export type PatientUpdateWithoutNotificationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutNotificationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type NotificationMessageUpsertWithoutNotificationHistoryInput = {
    update: XOR<NotificationMessageUpdateWithoutNotificationHistoryInput, NotificationMessageUncheckedUpdateWithoutNotificationHistoryInput>
    create: XOR<NotificationMessageCreateWithoutNotificationHistoryInput, NotificationMessageUncheckedCreateWithoutNotificationHistoryInput>
    where?: NotificationMessageWhereInput
  }

  export type NotificationMessageUpdateToOneWithWhereWithoutNotificationHistoryInput = {
    where?: NotificationMessageWhereInput
    data: XOR<NotificationMessageUpdateWithoutNotificationHistoryInput, NotificationMessageUncheckedUpdateWithoutNotificationHistoryInput>
  }

  export type NotificationMessageUpdateWithoutNotificationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutMessagesNestedInput
    emailTemplate?: EmailTemplateUpdateOneWithoutNotificationMessagesNestedInput
  }

  export type NotificationMessageUncheckedUpdateWithoutNotificationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationMessageCreateWithoutEmailTemplateInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutMessagesInput
    notificationHistory?: NotificationHistoryCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageUncheckedCreateWithoutEmailTemplateInput = {
    id?: string
    notificationId: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationHistory?: NotificationHistoryUncheckedCreateNestedManyWithoutMessageInput
  }

  export type NotificationMessageCreateOrConnectWithoutEmailTemplateInput = {
    where: NotificationMessageWhereUniqueInput
    create: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput>
  }

  export type NotificationMessageCreateManyEmailTemplateInputEnvelope = {
    data: NotificationMessageCreateManyEmailTemplateInput | NotificationMessageCreateManyEmailTemplateInput[]
    skipDuplicates?: boolean
  }

  export type NotificationMessageUpsertWithWhereUniqueWithoutEmailTemplateInput = {
    where: NotificationMessageWhereUniqueInput
    update: XOR<NotificationMessageUpdateWithoutEmailTemplateInput, NotificationMessageUncheckedUpdateWithoutEmailTemplateInput>
    create: XOR<NotificationMessageCreateWithoutEmailTemplateInput, NotificationMessageUncheckedCreateWithoutEmailTemplateInput>
  }

  export type NotificationMessageUpdateWithWhereUniqueWithoutEmailTemplateInput = {
    where: NotificationMessageWhereUniqueInput
    data: XOR<NotificationMessageUpdateWithoutEmailTemplateInput, NotificationMessageUncheckedUpdateWithoutEmailTemplateInput>
  }

  export type NotificationMessageUpdateManyWithWhereWithoutEmailTemplateInput = {
    where: NotificationMessageScalarWhereInput
    data: XOR<NotificationMessageUpdateManyMutationInput, NotificationMessageUncheckedUpdateManyWithoutEmailTemplateInput>
  }

  export type AccountCreateWithoutUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserCreateWithoutUserInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutUserInput = {
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserCreateManyUserInputEnvelope = {
    data: CompanyUserCreateManyUserInput | CompanyUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUserCreateWithoutUserInput = {
    id?: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUserUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserCreateOrConnectWithoutUserInput = {
    where: DepartmentUserWhereUniqueInput
    create: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput>
  }

  export type DepartmentUserCreateManyUserInputEnvelope = {
    data: DepartmentUserCreateManyUserInput | DepartmentUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicianCreateWithoutUserInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianCreateOrConnectWithoutUserInput = {
    where: ClinicianWhereUniqueInput
    create: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
  }

  export type WorkbenchNotesCreateWithoutCreatedByUserInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workbench: WorkbenchCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    create: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesCreateManyCreatedByUserInputEnvelope = {
    data: WorkbenchNotesCreateManyCreatedByUserInput | WorkbenchNotesCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAgreementCreateWithoutUserInput = {
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement: AgreementCreateNestedOneWithoutUserAgreementsInput
  }

  export type UserAgreementUncheckedCreateWithoutUserInput = {
    agreementId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAgreementCreateOrConnectWithoutUserInput = {
    where: UserAgreementWhereUniqueInput
    create: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
  }

  export type UserAgreementCreateManyUserInputEnvelope = {
    data: UserAgreementCreateManyUserInput | UserAgreementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type DepartmentUserUpsertWithWhereUniqueWithoutUserInput = {
    where: DepartmentUserWhereUniqueInput
    update: XOR<DepartmentUserUpdateWithoutUserInput, DepartmentUserUncheckedUpdateWithoutUserInput>
    create: XOR<DepartmentUserCreateWithoutUserInput, DepartmentUserUncheckedCreateWithoutUserInput>
  }

  export type DepartmentUserUpdateWithWhereUniqueWithoutUserInput = {
    where: DepartmentUserWhereUniqueInput
    data: XOR<DepartmentUserUpdateWithoutUserInput, DepartmentUserUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentUserUpdateManyWithWhereWithoutUserInput = {
    where: DepartmentUserScalarWhereInput
    data: XOR<DepartmentUserUpdateManyMutationInput, DepartmentUserUncheckedUpdateManyWithoutUserInput>
  }

  export type ClinicianUpsertWithoutUserInput = {
    update: XOR<ClinicianUpdateWithoutUserInput, ClinicianUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    where?: ClinicianWhereInput
  }

  export type ClinicianUpdateToOneWithWhereWithoutUserInput = {
    where?: ClinicianWhereInput
    data: XOR<ClinicianUpdateWithoutUserInput, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type ClinicianUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput
  }

  export type WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    update: XOR<WorkbenchNotesUpdateWithoutCreatedByUserInput, WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    data: XOR<WorkbenchNotesUpdateWithoutCreatedByUserInput, WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: WorkbenchNotesScalarWhereInput
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAgreementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAgreementWhereUniqueInput
    update: XOR<UserAgreementUpdateWithoutUserInput, UserAgreementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
  }

  export type UserAgreementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAgreementWhereUniqueInput
    data: XOR<UserAgreementUpdateWithoutUserInput, UserAgreementUncheckedUpdateWithoutUserInput>
  }

  export type UserAgreementUpdateManyWithWhereWithoutUserInput = {
    where: UserAgreementScalarWhereInput
    data: XOR<UserAgreementUpdateManyMutationInput, UserAgreementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAgreementScalarWhereInput = {
    AND?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
    OR?: UserAgreementScalarWhereInput[]
    NOT?: UserAgreementScalarWhereInput | UserAgreementScalarWhereInput[]
    userId?: StringFilter<"UserAgreement"> | string
    agreementId?: StringFilter<"UserAgreement"> | string
    status?: EnumAgreementStatusFilter<"UserAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"UserAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAgreement"> | Date | string
  }

  export type UserCreateWithoutAgreementsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgreementsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgreementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgreementsInput, UserUncheckedCreateWithoutAgreementsInput>
  }

  export type AgreementCreateWithoutUserAgreementsInput = {
    id?: string
    type: $Enums.AgreementType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementUncheckedCreateWithoutUserAgreementsInput = {
    id?: string
    type: $Enums.AgreementType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementCreateOrConnectWithoutUserAgreementsInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutUserAgreementsInput, AgreementUncheckedCreateWithoutUserAgreementsInput>
  }

  export type UserUpsertWithoutAgreementsInput = {
    update: XOR<UserUpdateWithoutAgreementsInput, UserUncheckedUpdateWithoutAgreementsInput>
    create: XOR<UserCreateWithoutAgreementsInput, UserUncheckedCreateWithoutAgreementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgreementsInput, UserUncheckedUpdateWithoutAgreementsInput>
  }

  export type UserUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgreementUpsertWithoutUserAgreementsInput = {
    update: XOR<AgreementUpdateWithoutUserAgreementsInput, AgreementUncheckedUpdateWithoutUserAgreementsInput>
    create: XOR<AgreementCreateWithoutUserAgreementsInput, AgreementUncheckedCreateWithoutUserAgreementsInput>
    where?: AgreementWhereInput
  }

  export type AgreementUpdateToOneWithWhereWithoutUserAgreementsInput = {
    where?: AgreementWhereInput
    data: XOR<AgreementUpdateWithoutUserAgreementsInput, AgreementUncheckedUpdateWithoutUserAgreementsInput>
  }

  export type AgreementUpdateWithoutUserAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUncheckedUpdateWithoutUserAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAgreementTypeFieldUpdateOperationsInput | $Enums.AgreementType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateWithoutAgreementInput = {
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgreementsInput
  }

  export type UserAgreementUncheckedCreateWithoutAgreementInput = {
    userId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAgreementCreateOrConnectWithoutAgreementInput = {
    where: UserAgreementWhereUniqueInput
    create: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type UserAgreementCreateManyAgreementInputEnvelope = {
    data: UserAgreementCreateManyAgreementInput | UserAgreementCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type UserAgreementUpsertWithWhereUniqueWithoutAgreementInput = {
    where: UserAgreementWhereUniqueInput
    update: XOR<UserAgreementUpdateWithoutAgreementInput, UserAgreementUncheckedUpdateWithoutAgreementInput>
    create: XOR<UserAgreementCreateWithoutAgreementInput, UserAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type UserAgreementUpdateWithWhereUniqueWithoutAgreementInput = {
    where: UserAgreementWhereUniqueInput
    data: XOR<UserAgreementUpdateWithoutAgreementInput, UserAgreementUncheckedUpdateWithoutAgreementInput>
  }

  export type UserAgreementUpdateManyWithWhereWithoutAgreementInput = {
    where: UserAgreementScalarWhereInput
    data: XOR<UserAgreementUpdateManyMutationInput, UserAgreementUncheckedUpdateManyWithoutAgreementInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    departments?: DepartmentUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreements?: UserAgreementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreements?: UserAgreementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreements?: UserAgreementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutInvitationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvitationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
  }

  export type CompanyUpsertWithoutInvitationsInput = {
    update: XOR<CompanyUpdateWithoutInvitationsInput, CompanyUncheckedUpdateWithoutInvitationsInput>
    create: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvitationsInput, CompanyUncheckedUpdateWithoutInvitationsInput>
  }

  export type CompanyUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutApiKeysInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    stripeEntities?: StripeEntityUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutApiKeysInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
  }

  export type CompanyUpsertWithoutApiKeysInput = {
    update: XOR<CompanyUpdateWithoutApiKeysInput, CompanyUncheckedUpdateWithoutApiKeysInput>
    create: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutApiKeysInput, CompanyUncheckedUpdateWithoutApiKeysInput>
  }

  export type CompanyUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    stripeEntities?: StripeEntityUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FacilityCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    contactId?: string | null
  }

  export type EvaluationCreateManyCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageCreateManyCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateManyCompanyInput = {
    userId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserCreateManyCompanyInput = {
    id?: string
    userId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateManyCompanyInput = {
    patientId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type CompanyInvitationCreateManyCompanyInput = {
    id?: string
    contact: string
    contactType: $Enums.ContactType
    role: $Enums.CompanyRole
    token: string
    verified?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    userId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type StripeEntityCreateManyCompanyInput = {
    id?: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    entityParentId?: string | null
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutCompanyInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUpdateWithoutCompanyInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutCompaniesNestedInput
    contact?: ContactUpdateOneWithoutPatientsNestedInput
  }

  export type CompanyPatientUncheckedUpdateWithoutCompanyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyPatientUncheckedUpdateManyWithoutCompanyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyInvitationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    token?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeEntityUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentEntity?: StripeEntityUpdateOneWithoutChildEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    entityParentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateManyParentInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type FacilityPatientCreateManyFacilityInput = {
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingLabelCreateManyFacilityInput = {
    id?: string
    addressName: string
    labelId: string
    trackingNumber: string
    trackingStatus: $Enums.ShippingTrackingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FacilityUpdateManyWithoutParentNestedInput
    contact?: ContactUpdateOneWithoutFacilitiesNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityPatientUpdateWithoutFacilityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFacilitiesNestedInput
  }

  export type FacilityPatientUncheckedUpdateWithoutFacilityInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityPatientUncheckedUpdateManyWithoutFacilityInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingLabelUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutShippingLabelNestedInput
  }

  export type ShippingLabelUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutShippingLabelNestedInput
  }

  export type ShippingLabelUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressName?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    trackingStatus?: EnumShippingTrackingStatusFieldUpdateOperationsInput | $Enums.ShippingTrackingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootCreateManyPatientInput = {
    id?: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchCreateManyPatientInput = {
    id?: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateManyPatientInput = {
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type NotificationHistoryCreateManyPatientInput = {
    id?: string
    messageId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityPatientCreateManyPatientInput = {
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUpdateWithoutPatientInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPatientsNestedInput
    contact?: ContactUpdateOneWithoutPatientsNestedInput
  }

  export type CompanyPatientUncheckedUpdateWithoutPatientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyPatientUncheckedUpdateManyWithoutPatientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationHistoryUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NotificationMessageUpdateOneRequiredWithoutNotificationHistoryNestedInput
  }

  export type NotificationHistoryUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityPatientUpdateWithoutPatientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type FacilityPatientUncheckedUpdateWithoutPatientInput = {
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityPatientUncheckedUpdateManyWithoutPatientInput = {
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateManyEvaluationInput = {
    id?: string
    patientId: string
    productId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutClinicianNestedInput
  }

  export type ClinicianUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicianUncheckedUpdateManyWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUpdateManyWithoutAssetsNestedInput
    augments?: AssetAugmentUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput
    augments?: AssetAugmentUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentCreateManyAssetInput = {
    id?: string
    type: $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: AssetAugmentMediaUpdateManyWithoutAugmentNestedInput
  }

  export type AssetAugmentUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: AssetAugmentMediaUncheckedUpdateManyWithoutAugmentNestedInput
  }

  export type AssetAugmentUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetAugmentTypeFieldUpdateOperationsInput | $Enums.AssetAugmentType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaCreateManyAugmentInput = {
    id?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: string | null
    bucket?: string | null
    key?: string | null
    active?: boolean
    inactiveReason?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetAugmentMediaUpdateWithoutAugmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaUncheckedUpdateWithoutAugmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAugmentMediaUncheckedUpdateManyWithoutAugmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    originalData?: NullableJsonNullValueInput | InputJsonValue
    region?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    inactiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateManyProductInput = {
    id?: string
    patientId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    shippingLabelId?: string | null
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootCreateManyWorkbenchInput = {
    id?: string
    patientId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth | null
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateManyWorkbenchInput = {
    id?: string
    schemaId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchNotesCreateManyWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foot?: FootUpdateOneRequiredWithoutAssetsNestedInput
    augments?: AssetAugmentUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    augments?: AssetAugmentUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingLabel?: ShippingLabelUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    shippingLabelId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    shippingLabelId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: NullableEnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth | null
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FacilityCreateManyContactInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type CompanyPatientCreateManyContactInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FacilityUpdateOneWithoutChildrenNestedInput
    children?: FacilityUpdateManyWithoutParentNestedInput
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    patients?: FacilityPatientUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: FacilityUncheckedUpdateManyWithoutParentNestedInput
    patients?: FacilityPatientUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
    shippingLabels?: ShippingLabelUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyPatientUpdateWithoutContactInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPatientsNestedInput
    patient?: PatientUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyPatientUncheckedUpdateWithoutContactInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUncheckedUpdateManyWithoutContactInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyShippingLabelInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutShippingLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutShippingLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutShippingLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutPatientNestedInput
    facilities?: FacilityPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManySchemaInput = {
    id?: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateManyProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantCreateManyProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateManyWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    favorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionCreateManyStripeProductsInput = {
    id?: string
    stripeEntityId: string
    stripeSubscriptionId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeInvoiceUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeSubscriptionNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEntityId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEntityId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceCreateManyCombinedInvoiceInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyStripeInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeCheckoutInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyStripeCheckoutInvoiceInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    stripeInvoiceId?: string | null
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeProductUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeEntity?: StripeEntityUpdateOneWithoutStripeProductsNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateManyWithoutStripeInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceUpdateWithoutCombinedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutCombinedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutStripeInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeCheckoutInvoice?: StripeInvoiceUpdateOneWithoutCheckoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutStripeInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutStripeInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeCheckoutInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutStripeCheckoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    stripeInvoice?: StripeInvoiceUpdateOneWithoutEmployerEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutStripeCheckoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeEntityCreateManyParentEntityInput = {
    id?: string
    companyId: string
    entityId: string
    stripeCustomerId?: string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: boolean
    autoAdvanceCombined?: boolean
    collectionSendInvoice?: boolean
    active?: boolean
    stripeEntityType: $Enums.StripeEntityType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeProductCreateManyStripeEntityInput = {
    id?: string
    type: $Enums.StripeProductType
    stripeProductId: string
    stripePriceId?: string | null
    stripeCouponId?: string | null
    frequency?: $Enums.StripeBillingFrequency | null
    amount?: number | null
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionCreateManyStripeEntityInput = {
    id?: string
    stripeSubscriptionId: string
    stripeProductId: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeInvoiceCreateManyStripeEntityInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    combinedInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeEntityUpdateWithoutParentEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStripeEntitiesNestedInput
    childEntities?: StripeEntityUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateWithoutParentEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childEntities?: StripeEntityUncheckedUpdateManyWithoutParentEntityNestedInput
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityNestedInput
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeEntityNestedInput
  }

  export type StripeEntityUncheckedUpdateManyWithoutParentEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingPreferences?: NullableJsonNullValueInput | InputJsonValue
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    autoAdvanceCombined?: BoolFieldUpdateOperationsInput | boolean
    collectionSendInvoice?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    stripeEntityType?: EnumStripeEntityTypeFieldUpdateOperationsInput | $Enums.StripeEntityType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeProductUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeProductsNestedInput
    stripeSubscriptions?: StripeSubscriptionUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeProductsNestedInput
    stripeSubscriptions?: StripeSubscriptionUncheckedUpdateManyWithoutStripeProductsNestedInput
  }

  export type StripeProductUncheckedUpdateManyWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStripeProductTypeFieldUpdateOperationsInput | $Enums.StripeProductType
    stripeProductId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableEnumStripeBillingFrequencyFieldUpdateOperationsInput | $Enums.StripeBillingFrequency | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUpdateManyWithoutStripeSubscriptionNestedInput
    stripeProducts?: StripeProductUpdateOneRequiredWithoutStripeSubscriptionsNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripeProductId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoices?: StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateManyWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripeProductId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeInvoiceCreateManyStripeSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    price: number
    type: $Enums.StripeInvoiceType
    status: $Enums.StripeInvoiceStatus
    lastWebhookId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    combinedInvoiceId?: string | null
    stripeEntityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeInvoiceUpdateWithoutStripeSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoice?: StripeInvoiceUpdateOneWithoutCombinedInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUpdateManyWithoutCombinedInvoiceNestedInput
    stripeEntity?: StripeEntityUpdateOneWithoutStripeInvoicesNestedInput
    employerEvaluations?: EvaluationUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateWithoutStripeSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeProducts?: StripeProductUncheckedUpdateManyWithoutStripeInvoicesNestedInput
    combinedInvoices?: StripeInvoiceUncheckedUpdateManyWithoutCombinedInvoiceNestedInput
    employerEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeInvoiceNestedInput
    checkoutEvaluations?: EvaluationUncheckedUpdateManyWithoutStripeCheckoutInvoiceNestedInput
  }

  export type StripeInvoiceUncheckedUpdateManyWithoutStripeSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    type?: EnumStripeInvoiceTypeFieldUpdateOperationsInput | $Enums.StripeInvoiceType
    status?: EnumStripeInvoiceStatusFieldUpdateOperationsInput | $Enums.StripeInvoiceStatus
    lastWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    combinedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationMessageCreateManyNotificationInput = {
    id?: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    emailTemplateId?: string | null
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationMessageUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTemplate?: EmailTemplateUpdateOneWithoutNotificationMessagesNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    emailTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryCreateManyMessageInput = {
    id?: string
    patientId: string
    sentAt?: Date | string | null
    response?: string | null
    responseReceivedAt?: Date | string | null
    removedAt?: Date | string | null
    jobId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationHistoryUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutNotificationHistoryNestedInput
  }

  export type NotificationHistoryUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationHistoryUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    responseReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationMessageCreateManyEmailTemplateInput = {
    id?: string
    notificationId: string
    sequence: number
    delayMinutes?: number | null
    recurrencePattern?: string | null
    sequenceLimit?: number | null
    content: string
    channel: $Enums.CommunicationChannel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationMessageUpdateWithoutEmailTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutMessagesNestedInput
    notificationHistory?: NotificationHistoryUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageUncheckedUpdateWithoutEmailTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationHistory?: NotificationHistoryUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type NotificationMessageUncheckedUpdateManyWithoutEmailTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    sequence?: FloatFieldUpdateOperationsInput | number
    delayMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    recurrencePattern?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateManyUserInput = {
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUserCreateManyUserInput = {
    id?: string
    companyId: string
    department: $Enums.CompanyDepartment
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchNotesCreateManyCreatedByUserInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type UserAgreementCreateManyUserInput = {
    agreementId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutUserInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    department?: EnumCompanyDepartmentFieldUpdateOperationsInput | $Enums.CompanyDepartment
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workbench?: WorkbenchUpdateOneRequiredWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUpdateWithoutUserInput = {
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: AgreementUpdateOneRequiredWithoutUserAgreementsNestedInput
  }

  export type UserAgreementUncheckedUpdateWithoutUserInput = {
    agreementId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUncheckedUpdateManyWithoutUserInput = {
    agreementId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateManyAgreementInput = {
    userId: string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAgreementUpdateWithoutAgreementInput = {
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgreementsNestedInput
  }

  export type UserAgreementUncheckedUpdateWithoutAgreementInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUncheckedUpdateManyWithoutAgreementInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCountOutputTypeDefaultArgs instead
     */
    export type FacilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicianCountOutputTypeDefaultArgs instead
     */
    export type ClinicianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationCountOutputTypeDefaultArgs instead
     */
    export type EvaluationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FootCountOutputTypeDefaultArgs instead
     */
    export type FootCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FootCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCountOutputTypeDefaultArgs instead
     */
    export type AssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetAugmentCountOutputTypeDefaultArgs instead
     */
    export type AssetAugmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetAugmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchCountOutputTypeDefaultArgs instead
     */
    export type WorkbenchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShippingLabelCountOutputTypeDefaultArgs instead
     */
    export type ShippingLabelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShippingLabelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhysicianCountOutputTypeDefaultArgs instead
     */
    export type PhysicianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhysicianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisCountOutputTypeDefaultArgs instead
     */
    export type DiagnosisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTypeCountOutputTypeDefaultArgs instead
     */
    export type DeviceTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitTypeCountOutputTypeDefaultArgs instead
     */
    export type VisitTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSchemaCountOutputTypeDefaultArgs instead
     */
    export type FormSchemaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductCountOutputTypeDefaultArgs instead
     */
    export type CatalogProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogCategoryCountOutputTypeDefaultArgs instead
     */
    export type CatalogCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogVendorCountOutputTypeDefaultArgs instead
     */
    export type CatalogVendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeProductCountOutputTypeDefaultArgs instead
     */
    export type StripeProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeInvoiceCountOutputTypeDefaultArgs instead
     */
    export type StripeInvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeInvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeEntityCountOutputTypeDefaultArgs instead
     */
    export type StripeEntityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeEntityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type StripeSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationCountOutputTypeDefaultArgs instead
     */
    export type NotificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationMessageCountOutputTypeDefaultArgs instead
     */
    export type NotificationMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateCountOutputTypeDefaultArgs instead
     */
    export type EmailTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementCountOutputTypeDefaultArgs instead
     */
    export type AgreementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityDefaultArgs instead
     */
    export type FacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicianDefaultArgs instead
     */
    export type ClinicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDefaultArgs instead
     */
    export type EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FootDefaultArgs instead
     */
    export type FootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FootDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetAugmentDefaultArgs instead
     */
    export type AssetAugmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetAugmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetAugmentMediaDefaultArgs instead
     */
    export type AssetAugmentMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetAugmentMediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchDefaultArgs instead
     */
    export type WorkbenchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchNotesDefaultArgs instead
     */
    export type WorkbenchNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchNotesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShippingPackageDefaultArgs instead
     */
    export type ShippingPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShippingPackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShippingLabelDefaultArgs instead
     */
    export type ShippingLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShippingLabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhysicianDefaultArgs instead
     */
    export type PhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhysicianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisDefaultArgs instead
     */
    export type DiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingCodeDefaultArgs instead
     */
    export type BillingCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTypeDefaultArgs instead
     */
    export type DeviceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitTypeDefaultArgs instead
     */
    export type VisitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSchemaDefaultArgs instead
     */
    export type FormSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSchemaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionDefaultArgs instead
     */
    export type FormSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormTemplateDefaultArgs instead
     */
    export type FormTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductDefaultArgs instead
     */
    export type CatalogProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductAttributeDefaultArgs instead
     */
    export type CatalogProductAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductAttributeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductVariantDefaultArgs instead
     */
    export type CatalogProductVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductVariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogCategoryDefaultArgs instead
     */
    export type CatalogCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogVendorDefaultArgs instead
     */
    export type CatalogVendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogVendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrinterDefaultArgs instead
     */
    export type PrinterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrinterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyUserDefaultArgs instead
     */
    export type CompanyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentUserDefaultArgs instead
     */
    export type DepartmentUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyPatientDefaultArgs instead
     */
    export type CompanyPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyPatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityPatientDefaultArgs instead
     */
    export type FacilityPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityPatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeProductDefaultArgs instead
     */
    export type StripeProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeInvoiceDefaultArgs instead
     */
    export type StripeInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeEntityDefaultArgs instead
     */
    export type StripeEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeEntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeSubscriptionDefaultArgs instead
     */
    export type StripeSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationMessageDefaultArgs instead
     */
    export type NotificationMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationHistoryDefaultArgs instead
     */
    export type NotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateDefaultArgs instead
     */
    export type EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAgreementDefaultArgs instead
     */
    export type UserAgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAgreementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementDefaultArgs instead
     */
    export type AgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountVerificationDefaultArgs instead
     */
    export type AccountVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountVerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyInvitationDefaultArgs instead
     */
    export type CompanyInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViewFlattenedWorkbenchDefaultArgs instead
     */
    export type ViewFlattenedWorkbenchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViewFlattenedWorkbenchDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}