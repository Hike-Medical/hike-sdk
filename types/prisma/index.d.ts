
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Clinician
 * 
 */
export type Clinician = $Result.DefaultSelection<Prisma.$ClinicianPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Foot
 * 
 */
export type Foot = $Result.DefaultSelection<Prisma.$FootPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Workbench
 * 
 */
export type Workbench = $Result.DefaultSelection<Prisma.$WorkbenchPayload>
/**
 * Model WorkbenchNotes
 * 
 */
export type WorkbenchNotes = $Result.DefaultSelection<Prisma.$WorkbenchNotesPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model FacilityAddress
 * 
 */
export type FacilityAddress = $Result.DefaultSelection<Prisma.$FacilityAddressPayload>
/**
 * Model ShippingPackage
 * 
 */
export type ShippingPackage = $Result.DefaultSelection<Prisma.$ShippingPackagePayload>
/**
 * Model Physician
 * 
 */
export type Physician = $Result.DefaultSelection<Prisma.$PhysicianPayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model BillingCode
 * 
 */
export type BillingCode = $Result.DefaultSelection<Prisma.$BillingCodePayload>
/**
 * Model DeviceType
 * 
 */
export type DeviceType = $Result.DefaultSelection<Prisma.$DeviceTypePayload>
/**
 * Model VisitType
 * 
 */
export type VisitType = $Result.DefaultSelection<Prisma.$VisitTypePayload>
/**
 * Model FormSchema
 * 
 */
export type FormSchema = $Result.DefaultSelection<Prisma.$FormSchemaPayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model FormTemplate
 * 
 */
export type FormTemplate = $Result.DefaultSelection<Prisma.$FormTemplatePayload>
/**
 * Model CatalogProduct
 * 
 */
export type CatalogProduct = $Result.DefaultSelection<Prisma.$CatalogProductPayload>
/**
 * Model CatalogProductAttribute
 * 
 */
export type CatalogProductAttribute = $Result.DefaultSelection<Prisma.$CatalogProductAttributePayload>
/**
 * Model CatalogProductVariant
 * 
 */
export type CatalogProductVariant = $Result.DefaultSelection<Prisma.$CatalogProductVariantPayload>
/**
 * Model CatalogCategory
 * 
 */
export type CatalogCategory = $Result.DefaultSelection<Prisma.$CatalogCategoryPayload>
/**
 * Model CatalogVendor
 * 
 */
export type CatalogVendor = $Result.DefaultSelection<Prisma.$CatalogVendorPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Printer
 * 
 */
export type Printer = $Result.DefaultSelection<Prisma.$PrinterPayload>
/**
 * Model CompanyUser
 * 
 */
export type CompanyUser = $Result.DefaultSelection<Prisma.$CompanyUserPayload>
/**
 * Model CompanyUserPermission
 * 
 */
export type CompanyUserPermission = $Result.DefaultSelection<Prisma.$CompanyUserPermissionPayload>
/**
 * Model CompanyPatient
 * 
 */
export type CompanyPatient = $Result.DefaultSelection<Prisma.$CompanyPatientPayload>
/**
 * Model FacilityUser
 * 
 */
export type FacilityUser = $Result.DefaultSelection<Prisma.$FacilityUserPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model ViewFlattenedWorkbench
 * 
 */
export type ViewFlattenedWorkbench = $Result.DefaultSelection<Prisma.$ViewFlattenedWorkbenchPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FacilityType: {
  CLINIC: 'CLINIC',
  EMPLOYER: 'EMPLOYER',
  PARTNER: 'PARTNER'
};

export type FacilityType = (typeof FacilityType)[keyof typeof FacilityType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MaritalStatus: {
  S: 'S',
  M: 'M',
  D: 'D',
  W: 'W'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const CareType: {
  ORTHOTIC: 'ORTHOTIC',
  PROSTHETIC: 'PROSTHETIC'
};

export type CareType = (typeof CareType)[keyof typeof CareType]


export const Side: {
  LEFT: 'LEFT',
  RIGHT: 'RIGHT',
  BILATERAL: 'BILATERAL'
};

export type Side = (typeof Side)[keyof typeof Side]


export const VerticalPosition: {
  UPPER: 'UPPER',
  LOWER: 'LOWER',
  SPINAL: 'SPINAL',
  CRANIAL: 'CRANIAL'
};

export type VerticalPosition = (typeof VerticalPosition)[keyof typeof VerticalPosition]


export const ShoeWidth: {
  NARROW: 'NARROW',
  MEDIUM: 'MEDIUM',
  WIDE: 'WIDE',
  EXTRA_WIDE: 'EXTRA_WIDE',
  YOUTH: 'YOUTH',
  TODDLER: 'TODDLER'
};

export type ShoeWidth = (typeof ShoeWidth)[keyof typeof ShoeWidth]


export const ShoeSystem: {
  US: 'US',
  UK: 'UK',
  EU: 'EU'
};

export type ShoeSystem = (typeof ShoeSystem)[keyof typeof ShoeSystem]


export const InactiveFootReason: {
  AMPUTATION: 'AMPUTATION',
  SKIPPED: 'SKIPPED',
  TOE_FILLER: 'TOE_FILLER'
};

export type InactiveFootReason = (typeof InactiveFootReason)[keyof typeof InactiveFootReason]


export const ProductType: {
  FOOT_SCAN: 'FOOT_SCAN',
  FOOT_RENDER: 'FOOT_RENDER',
  INSOLE_RENDER: 'INSOLE_RENDER',
  INSOLE_GCODE: 'INSOLE_GCODE',
  INSOLE: 'INSOLE',
  PREFABRICATED_DEVICE: 'PREFABRICATED_DEVICE',
  FABRICATED_DEVICE: 'FABRICATED_DEVICE'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const AssetStatus: {
  AR_IDLE: 'AR_IDLE',
  AR_PENDING: 'AR_PENDING',
  AR_COMPLETED: 'AR_COMPLETED',
  AR_REJECTED: 'AR_REJECTED',
  AR_ERROR: 'AR_ERROR',
  AR_HOLD: 'AR_HOLD',
  AR_SKIP: 'AR_SKIP',
  CV_IDLE: 'CV_IDLE',
  CV_PENDING: 'CV_PENDING',
  CV_COMPLETED: 'CV_COMPLETED',
  CV_REJECTED: 'CV_REJECTED',
  CV_ERROR: 'CV_ERROR',
  CV_HOLD: 'CV_HOLD',
  CV_ADJUSTMENTS_IDLE: 'CV_ADJUSTMENTS_IDLE',
  CV_ADJUSTMENTS_PENDING: 'CV_ADJUSTMENTS_PENDING',
  CV_ADJUSTMENTS_COMPLETED: 'CV_ADJUSTMENTS_COMPLETED',
  CV_ADJUSTMENTS_REJECTED: 'CV_ADJUSTMENTS_REJECTED',
  CV_ADJUSTMENTS_ERROR: 'CV_ADJUSTMENTS_ERROR',
  CV_ADJUSTMENTS_SKIP: 'CV_ADJUSTMENTS_SKIP',
  CV_VALIDATE_IDLE: 'CV_VALIDATE_IDLE',
  CV_VALIDATE_PENDING: 'CV_VALIDATE_PENDING',
  CV_VALIDATE_COMPLETED: 'CV_VALIDATE_COMPLETED',
  CV_VALIDATE_REJECTED: 'CV_VALIDATE_REJECTED',
  CV_VALIDATE_ERROR: 'CV_VALIDATE_ERROR',
  NEEDS_COMPLETION: 'NEEDS_COMPLETION'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const WorkbenchCreatedReason: {
  REMAKE: 'REMAKE',
  REORDER: 'REORDER',
  EDIT: 'EDIT'
};

export type WorkbenchCreatedReason = (typeof WorkbenchCreatedReason)[keyof typeof WorkbenchCreatedReason]


export const WorkbenchStatus: {
  DRAFT: 'DRAFT',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type WorkbenchStatus = (typeof WorkbenchStatus)[keyof typeof WorkbenchStatus]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  TOE_FILLER: 'TOE_FILLER',
  NEEDS_MANUFACTURING: 'NEEDS_MANUFACTURING',
  PRINTING: 'PRINTING',
  NEEDS_GRINDING: 'NEEDS_GRINDING',
  NEEDS_GLUING: 'NEEDS_GLUING',
  NEEDS_FINISHING: 'NEEDS_FINISHING',
  NEEDS_SHIPPING: 'NEEDS_SHIPPING',
  NEEDS_ADDON: 'NEEDS_ADDON',
  PACKAGED: 'PACKAGED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderAuthorizationStatus: {
  NO_AUTH_NEEDED: 'NO_AUTH_NEEDED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PENDING: 'PENDING'
};

export type OrderAuthorizationStatus = (typeof OrderAuthorizationStatus)[keyof typeof OrderAuthorizationStatus]


export const Carrier: {
  UPS: 'UPS'
};

export type Carrier = (typeof Carrier)[keyof typeof Carrier]


export const WeightUnit: {
  KG: 'KG',
  LB: 'LB'
};

export type WeightUnit = (typeof WeightUnit)[keyof typeof WeightUnit]


export const DimensionUnit: {
  CM: 'CM',
  INCH: 'INCH'
};

export type DimensionUnit = (typeof DimensionUnit)[keyof typeof DimensionUnit]


export const DiagnosisStandard: {
  ICD10: 'ICD10'
};

export type DiagnosisStandard = (typeof DiagnosisStandard)[keyof typeof DiagnosisStandard]


export const FormSchemaType: {
  EVALUATION: 'EVALUATION',
  ORDER: 'ORDER',
  DELIVERY: 'DELIVERY'
};

export type FormSchemaType = (typeof FormSchemaType)[keyof typeof FormSchemaType]


export const ProductAttributeType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  LINK: 'LINK',
  RESOURCE: 'RESOURCE',
  LCODE: 'LCODE'
};

export type ProductAttributeType = (typeof ProductAttributeType)[keyof typeof ProductAttributeType]


export const CompanyRole: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER',
  PATIENT: 'PATIENT'
};

export type CompanyRole = (typeof CompanyRole)[keyof typeof CompanyRole]


export const CompanyPermission: {
  MANUFACTURING: 'MANUFACTURING',
  PRINT_FARM: 'PRINT_FARM',
  SHIPPING: 'SHIPPING',
  STATIONS: 'STATIONS'
};

export type CompanyPermission = (typeof CompanyPermission)[keyof typeof CompanyPermission]

}

export type FacilityType = $Enums.FacilityType

export const FacilityType: typeof $Enums.FacilityType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type CareType = $Enums.CareType

export const CareType: typeof $Enums.CareType

export type Side = $Enums.Side

export const Side: typeof $Enums.Side

export type VerticalPosition = $Enums.VerticalPosition

export const VerticalPosition: typeof $Enums.VerticalPosition

export type ShoeWidth = $Enums.ShoeWidth

export const ShoeWidth: typeof $Enums.ShoeWidth

export type ShoeSystem = $Enums.ShoeSystem

export const ShoeSystem: typeof $Enums.ShoeSystem

export type InactiveFootReason = $Enums.InactiveFootReason

export const InactiveFootReason: typeof $Enums.InactiveFootReason

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type WorkbenchCreatedReason = $Enums.WorkbenchCreatedReason

export const WorkbenchCreatedReason: typeof $Enums.WorkbenchCreatedReason

export type WorkbenchStatus = $Enums.WorkbenchStatus

export const WorkbenchStatus: typeof $Enums.WorkbenchStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderAuthorizationStatus = $Enums.OrderAuthorizationStatus

export const OrderAuthorizationStatus: typeof $Enums.OrderAuthorizationStatus

export type Carrier = $Enums.Carrier

export const Carrier: typeof $Enums.Carrier

export type WeightUnit = $Enums.WeightUnit

export const WeightUnit: typeof $Enums.WeightUnit

export type DimensionUnit = $Enums.DimensionUnit

export const DimensionUnit: typeof $Enums.DimensionUnit

export type DiagnosisStandard = $Enums.DiagnosisStandard

export const DiagnosisStandard: typeof $Enums.DiagnosisStandard

export type FormSchemaType = $Enums.FormSchemaType

export const FormSchemaType: typeof $Enums.FormSchemaType

export type ProductAttributeType = $Enums.ProductAttributeType

export const ProductAttributeType: typeof $Enums.ProductAttributeType

export type CompanyRole = $Enums.CompanyRole

export const CompanyRole: typeof $Enums.CompanyRole

export type CompanyPermission = $Enums.CompanyPermission

export const CompanyPermission: typeof $Enums.CompanyPermission

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.clinician`: Exposes CRUD operations for the **Clinician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinicians
    * const clinicians = await prisma.clinician.findMany()
    * ```
    */
  get clinician(): Prisma.ClinicianDelegate<ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs>;

  /**
   * `prisma.foot`: Exposes CRUD operations for the **Foot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feet
    * const feet = await prisma.foot.findMany()
    * ```
    */
  get foot(): Prisma.FootDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.workbench`: Exposes CRUD operations for the **Workbench** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workbenches
    * const workbenches = await prisma.workbench.findMany()
    * ```
    */
  get workbench(): Prisma.WorkbenchDelegate<ExtArgs>;

  /**
   * `prisma.workbenchNotes`: Exposes CRUD operations for the **WorkbenchNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkbenchNotes
    * const workbenchNotes = await prisma.workbenchNotes.findMany()
    * ```
    */
  get workbenchNotes(): Prisma.WorkbenchNotesDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.facilityAddress`: Exposes CRUD operations for the **FacilityAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityAddresses
    * const facilityAddresses = await prisma.facilityAddress.findMany()
    * ```
    */
  get facilityAddress(): Prisma.FacilityAddressDelegate<ExtArgs>;

  /**
   * `prisma.shippingPackage`: Exposes CRUD operations for the **ShippingPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingPackages
    * const shippingPackages = await prisma.shippingPackage.findMany()
    * ```
    */
  get shippingPackage(): Prisma.ShippingPackageDelegate<ExtArgs>;

  /**
   * `prisma.physician`: Exposes CRUD operations for the **Physician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physicians
    * const physicians = await prisma.physician.findMany()
    * ```
    */
  get physician(): Prisma.PhysicianDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.billingCode`: Exposes CRUD operations for the **BillingCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingCodes
    * const billingCodes = await prisma.billingCode.findMany()
    * ```
    */
  get billingCode(): Prisma.BillingCodeDelegate<ExtArgs>;

  /**
   * `prisma.deviceType`: Exposes CRUD operations for the **DeviceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTypes
    * const deviceTypes = await prisma.deviceType.findMany()
    * ```
    */
  get deviceType(): Prisma.DeviceTypeDelegate<ExtArgs>;

  /**
   * `prisma.visitType`: Exposes CRUD operations for the **VisitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitTypes
    * const visitTypes = await prisma.visitType.findMany()
    * ```
    */
  get visitType(): Prisma.VisitTypeDelegate<ExtArgs>;

  /**
   * `prisma.formSchema`: Exposes CRUD operations for the **FormSchema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSchemas
    * const formSchemas = await prisma.formSchema.findMany()
    * ```
    */
  get formSchema(): Prisma.FormSchemaDelegate<ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.formTemplate`: Exposes CRUD operations for the **FormTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTemplates
    * const formTemplates = await prisma.formTemplate.findMany()
    * ```
    */
  get formTemplate(): Prisma.FormTemplateDelegate<ExtArgs>;

  /**
   * `prisma.catalogProduct`: Exposes CRUD operations for the **CatalogProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProducts
    * const catalogProducts = await prisma.catalogProduct.findMany()
    * ```
    */
  get catalogProduct(): Prisma.CatalogProductDelegate<ExtArgs>;

  /**
   * `prisma.catalogProductAttribute`: Exposes CRUD operations for the **CatalogProductAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProductAttributes
    * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany()
    * ```
    */
  get catalogProductAttribute(): Prisma.CatalogProductAttributeDelegate<ExtArgs>;

  /**
   * `prisma.catalogProductVariant`: Exposes CRUD operations for the **CatalogProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogProductVariants
    * const catalogProductVariants = await prisma.catalogProductVariant.findMany()
    * ```
    */
  get catalogProductVariant(): Prisma.CatalogProductVariantDelegate<ExtArgs>;

  /**
   * `prisma.catalogCategory`: Exposes CRUD operations for the **CatalogCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogCategories
    * const catalogCategories = await prisma.catalogCategory.findMany()
    * ```
    */
  get catalogCategory(): Prisma.CatalogCategoryDelegate<ExtArgs>;

  /**
   * `prisma.catalogVendor`: Exposes CRUD operations for the **CatalogVendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogVendors
    * const catalogVendors = await prisma.catalogVendor.findMany()
    * ```
    */
  get catalogVendor(): Prisma.CatalogVendorDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.printer`: Exposes CRUD operations for the **Printer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Printers
    * const printers = await prisma.printer.findMany()
    * ```
    */
  get printer(): Prisma.PrinterDelegate<ExtArgs>;

  /**
   * `prisma.companyUser`: Exposes CRUD operations for the **CompanyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUsers
    * const companyUsers = await prisma.companyUser.findMany()
    * ```
    */
  get companyUser(): Prisma.CompanyUserDelegate<ExtArgs>;

  /**
   * `prisma.companyUserPermission`: Exposes CRUD operations for the **CompanyUserPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUserPermissions
    * const companyUserPermissions = await prisma.companyUserPermission.findMany()
    * ```
    */
  get companyUserPermission(): Prisma.CompanyUserPermissionDelegate<ExtArgs>;

  /**
   * `prisma.companyPatient`: Exposes CRUD operations for the **CompanyPatient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyPatients
    * const companyPatients = await prisma.companyPatient.findMany()
    * ```
    */
  get companyPatient(): Prisma.CompanyPatientDelegate<ExtArgs>;

  /**
   * `prisma.facilityUser`: Exposes CRUD operations for the **FacilityUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityUsers
    * const facilityUsers = await prisma.facilityUser.findMany()
    * ```
    */
  get facilityUser(): Prisma.FacilityUserDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.viewFlattenedWorkbench`: Exposes CRUD operations for the **ViewFlattenedWorkbench** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewFlattenedWorkbenches
    * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany()
    * ```
    */
  get viewFlattenedWorkbench(): Prisma.ViewFlattenedWorkbenchDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.14.0
   * Query Engine version: e9771e62de70f79a5e1c604a2d7c8e2a0a874b48
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Facility: 'Facility',
    Patient: 'Patient',
    Clinician: 'Clinician',
    Evaluation: 'Evaluation',
    Foot: 'Foot',
    Asset: 'Asset',
    Product: 'Product',
    Workbench: 'Workbench',
    WorkbenchNotes: 'WorkbenchNotes',
    Order: 'Order',
    FacilityAddress: 'FacilityAddress',
    ShippingPackage: 'ShippingPackage',
    Physician: 'Physician',
    Diagnosis: 'Diagnosis',
    BillingCode: 'BillingCode',
    DeviceType: 'DeviceType',
    VisitType: 'VisitType',
    FormSchema: 'FormSchema',
    FormSubmission: 'FormSubmission',
    FormTemplate: 'FormTemplate',
    CatalogProduct: 'CatalogProduct',
    CatalogProductAttribute: 'CatalogProductAttribute',
    CatalogProductVariant: 'CatalogProductVariant',
    CatalogCategory: 'CatalogCategory',
    CatalogVendor: 'CatalogVendor',
    AuditLog: 'AuditLog',
    Printer: 'Printer',
    CompanyUser: 'CompanyUser',
    CompanyUserPermission: 'CompanyUserPermission',
    CompanyPatient: 'CompanyPatient',
    FacilityUser: 'FacilityUser',
    User: 'User',
    Account: 'Account',
    ApiKey: 'ApiKey',
    ViewFlattenedWorkbench: 'ViewFlattenedWorkbench'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'company' | 'facility' | 'patient' | 'clinician' | 'evaluation' | 'foot' | 'asset' | 'product' | 'workbench' | 'workbenchNotes' | 'order' | 'facilityAddress' | 'shippingPackage' | 'physician' | 'diagnosis' | 'billingCode' | 'deviceType' | 'visitType' | 'formSchema' | 'formSubmission' | 'formTemplate' | 'catalogProduct' | 'catalogProductAttribute' | 'catalogProductVariant' | 'catalogCategory' | 'catalogVendor' | 'auditLog' | 'printer' | 'companyUser' | 'companyUserPermission' | 'companyPatient' | 'facilityUser' | 'user' | 'account' | 'apiKey' | 'viewFlattenedWorkbench'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>,
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Clinician: {
        payload: Prisma.$ClinicianPayload<ExtArgs>
        fields: Prisma.ClinicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          findFirst: {
            args: Prisma.ClinicianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          findMany: {
            args: Prisma.ClinicianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>[]
          }
          create: {
            args: Prisma.ClinicianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          createMany: {
            args: Prisma.ClinicianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicianCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>[]
          }
          delete: {
            args: Prisma.ClinicianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          update: {
            args: Prisma.ClinicianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          deleteMany: {
            args: Prisma.ClinicianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClinicianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicianPayload>
          }
          aggregate: {
            args: Prisma.ClinicianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClinician>
          }
          groupBy: {
            args: Prisma.ClinicianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClinicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicianCountArgs<ExtArgs>,
            result: $Utils.Optional<ClinicianCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Foot: {
        payload: Prisma.$FootPayload<ExtArgs>
        fields: Prisma.FootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FootFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FootFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          findFirst: {
            args: Prisma.FootFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FootFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          findMany: {
            args: Prisma.FootFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>[]
          }
          create: {
            args: Prisma.FootCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          createMany: {
            args: Prisma.FootCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FootCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>[]
          }
          delete: {
            args: Prisma.FootDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          update: {
            args: Prisma.FootUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          deleteMany: {
            args: Prisma.FootDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FootUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FootUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FootPayload>
          }
          aggregate: {
            args: Prisma.FootAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFoot>
          }
          groupBy: {
            args: Prisma.FootGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FootGroupByOutputType>[]
          }
          count: {
            args: Prisma.FootCountArgs<ExtArgs>,
            result: $Utils.Optional<FootCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>,
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Workbench: {
        payload: Prisma.$WorkbenchPayload<ExtArgs>
        fields: Prisma.WorkbenchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkbenchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkbenchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          findFirst: {
            args: Prisma.WorkbenchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkbenchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          findMany: {
            args: Prisma.WorkbenchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>[]
          }
          create: {
            args: Prisma.WorkbenchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          createMany: {
            args: Prisma.WorkbenchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkbenchCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>[]
          }
          delete: {
            args: Prisma.WorkbenchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          update: {
            args: Prisma.WorkbenchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          deleteMany: {
            args: Prisma.WorkbenchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkbenchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkbenchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchPayload>
          }
          aggregate: {
            args: Prisma.WorkbenchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkbench>
          }
          groupBy: {
            args: Prisma.WorkbenchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkbenchCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchCountAggregateOutputType> | number
          }
        }
      }
      WorkbenchNotes: {
        payload: Prisma.$WorkbenchNotesPayload<ExtArgs>
        fields: Prisma.WorkbenchNotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkbenchNotesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          findFirst: {
            args: Prisma.WorkbenchNotesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          findMany: {
            args: Prisma.WorkbenchNotesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>[]
          }
          create: {
            args: Prisma.WorkbenchNotesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          createMany: {
            args: Prisma.WorkbenchNotesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>[]
          }
          delete: {
            args: Prisma.WorkbenchNotesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          update: {
            args: Prisma.WorkbenchNotesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          deleteMany: {
            args: Prisma.WorkbenchNotesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkbenchNotesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkbenchNotesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkbenchNotesPayload>
          }
          aggregate: {
            args: Prisma.WorkbenchNotesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkbenchNotes>
          }
          groupBy: {
            args: Prisma.WorkbenchNotesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchNotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkbenchNotesCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkbenchNotesCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      FacilityAddress: {
        payload: Prisma.$FacilityAddressPayload<ExtArgs>
        fields: Prisma.FacilityAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityAddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityAddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          findFirst: {
            args: Prisma.FacilityAddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityAddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          findMany: {
            args: Prisma.FacilityAddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>[]
          }
          create: {
            args: Prisma.FacilityAddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          createMany: {
            args: Prisma.FacilityAddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityAddressCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>[]
          }
          delete: {
            args: Prisma.FacilityAddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          update: {
            args: Prisma.FacilityAddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          deleteMany: {
            args: Prisma.FacilityAddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityAddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacilityAddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityAddressPayload>
          }
          aggregate: {
            args: Prisma.FacilityAddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacilityAddress>
          }
          groupBy: {
            args: Prisma.FacilityAddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacilityAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityAddressCountArgs<ExtArgs>,
            result: $Utils.Optional<FacilityAddressCountAggregateOutputType> | number
          }
        }
      }
      ShippingPackage: {
        payload: Prisma.$ShippingPackagePayload<ExtArgs>
        fields: Prisma.ShippingPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingPackageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingPackageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          findFirst: {
            args: Prisma.ShippingPackageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingPackageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          findMany: {
            args: Prisma.ShippingPackageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>[]
          }
          create: {
            args: Prisma.ShippingPackageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          createMany: {
            args: Prisma.ShippingPackageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingPackageCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>[]
          }
          delete: {
            args: Prisma.ShippingPackageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          update: {
            args: Prisma.ShippingPackageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          deleteMany: {
            args: Prisma.ShippingPackageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingPackageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShippingPackageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShippingPackagePayload>
          }
          aggregate: {
            args: Prisma.ShippingPackageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShippingPackage>
          }
          groupBy: {
            args: Prisma.ShippingPackageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShippingPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingPackageCountArgs<ExtArgs>,
            result: $Utils.Optional<ShippingPackageCountAggregateOutputType> | number
          }
        }
      }
      Physician: {
        payload: Prisma.$PhysicianPayload<ExtArgs>
        fields: Prisma.PhysicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhysicianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhysicianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findFirst: {
            args: Prisma.PhysicianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhysicianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findMany: {
            args: Prisma.PhysicianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          create: {
            args: Prisma.PhysicianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          createMany: {
            args: Prisma.PhysicianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhysicianCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          delete: {
            args: Prisma.PhysicianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          update: {
            args: Prisma.PhysicianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          deleteMany: {
            args: Prisma.PhysicianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PhysicianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PhysicianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          aggregate: {
            args: Prisma.PhysicianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhysician>
          }
          groupBy: {
            args: Prisma.PhysicianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhysicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhysicianCountArgs<ExtArgs>,
            result: $Utils.Optional<PhysicianCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>,
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      BillingCode: {
        payload: Prisma.$BillingCodePayload<ExtArgs>
        fields: Prisma.BillingCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingCodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingCodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          findFirst: {
            args: Prisma.BillingCodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingCodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          findMany: {
            args: Prisma.BillingCodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>[]
          }
          create: {
            args: Prisma.BillingCodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          createMany: {
            args: Prisma.BillingCodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingCodeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>[]
          }
          delete: {
            args: Prisma.BillingCodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          update: {
            args: Prisma.BillingCodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          deleteMany: {
            args: Prisma.BillingCodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillingCodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillingCodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BillingCodePayload>
          }
          aggregate: {
            args: Prisma.BillingCodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillingCode>
          }
          groupBy: {
            args: Prisma.BillingCodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillingCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingCodeCountArgs<ExtArgs>,
            result: $Utils.Optional<BillingCodeCountAggregateOutputType> | number
          }
        }
      }
      DeviceType: {
        payload: Prisma.$DeviceTypePayload<ExtArgs>
        fields: Prisma.DeviceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          findFirst: {
            args: Prisma.DeviceTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          findMany: {
            args: Prisma.DeviceTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>[]
          }
          create: {
            args: Prisma.DeviceTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          createMany: {
            args: Prisma.DeviceTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTypeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>[]
          }
          delete: {
            args: Prisma.DeviceTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          update: {
            args: Prisma.DeviceTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          deleteMany: {
            args: Prisma.DeviceTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeviceTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeviceTypePayload>
          }
          aggregate: {
            args: Prisma.DeviceTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeviceType>
          }
          groupBy: {
            args: Prisma.DeviceTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeviceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<DeviceTypeCountAggregateOutputType> | number
          }
        }
      }
      VisitType: {
        payload: Prisma.$VisitTypePayload<ExtArgs>
        fields: Prisma.VisitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findFirst: {
            args: Prisma.VisitTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          findMany: {
            args: Prisma.VisitTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          create: {
            args: Prisma.VisitTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          createMany: {
            args: Prisma.VisitTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitTypeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>[]
          }
          delete: {
            args: Prisma.VisitTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          update: {
            args: Prisma.VisitTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          deleteMany: {
            args: Prisma.VisitTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VisitTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VisitTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VisitTypePayload>
          }
          aggregate: {
            args: Prisma.VisitTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVisitType>
          }
          groupBy: {
            args: Prisma.VisitTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VisitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<VisitTypeCountAggregateOutputType> | number
          }
        }
      }
      FormSchema: {
        payload: Prisma.$FormSchemaPayload<ExtArgs>
        fields: Prisma.FormSchemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSchemaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSchemaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          findFirst: {
            args: Prisma.FormSchemaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSchemaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          findMany: {
            args: Prisma.FormSchemaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>[]
          }
          create: {
            args: Prisma.FormSchemaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          createMany: {
            args: Prisma.FormSchemaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSchemaCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>[]
          }
          delete: {
            args: Prisma.FormSchemaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          update: {
            args: Prisma.FormSchemaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          deleteMany: {
            args: Prisma.FormSchemaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSchemaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSchemaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSchemaPayload>
          }
          aggregate: {
            args: Prisma.FormSchemaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSchema>
          }
          groupBy: {
            args: Prisma.FormSchemaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSchemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSchemaCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSchemaCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      FormTemplate: {
        payload: Prisma.$FormTemplatePayload<ExtArgs>
        fields: Prisma.FormTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findFirst: {
            args: Prisma.FormTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findMany: {
            args: Prisma.FormTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          create: {
            args: Prisma.FormTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          createMany: {
            args: Prisma.FormTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormTemplateCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          delete: {
            args: Prisma.FormTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          update: {
            args: Prisma.FormTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FormTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          aggregate: {
            args: Prisma.FormTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormTemplate>
          }
          groupBy: {
            args: Prisma.FormTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<FormTemplateCountAggregateOutputType> | number
          }
        }
      }
      CatalogProduct: {
        payload: Prisma.$CatalogProductPayload<ExtArgs>
        fields: Prisma.CatalogProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          findFirst: {
            args: Prisma.CatalogProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          findMany: {
            args: Prisma.CatalogProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>[]
          }
          create: {
            args: Prisma.CatalogProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          createMany: {
            args: Prisma.CatalogProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>[]
          }
          delete: {
            args: Prisma.CatalogProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          update: {
            args: Prisma.CatalogProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductPayload>
          }
          aggregate: {
            args: Prisma.CatalogProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProduct>
          }
          groupBy: {
            args: Prisma.CatalogProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductCountAggregateOutputType> | number
          }
        }
      }
      CatalogProductAttribute: {
        payload: Prisma.$CatalogProductAttributePayload<ExtArgs>
        fields: Prisma.CatalogProductAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductAttributeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          findFirst: {
            args: Prisma.CatalogProductAttributeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          findMany: {
            args: Prisma.CatalogProductAttributeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>[]
          }
          create: {
            args: Prisma.CatalogProductAttributeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          createMany: {
            args: Prisma.CatalogProductAttributeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>[]
          }
          delete: {
            args: Prisma.CatalogProductAttributeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          update: {
            args: Prisma.CatalogProductAttributeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductAttributeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductAttributeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductAttributeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductAttributePayload>
          }
          aggregate: {
            args: Prisma.CatalogProductAttributeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProductAttribute>
          }
          groupBy: {
            args: Prisma.CatalogProductAttributeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductAttributeCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductAttributeCountAggregateOutputType> | number
          }
        }
      }
      CatalogProductVariant: {
        payload: Prisma.$CatalogProductVariantPayload<ExtArgs>
        fields: Prisma.CatalogProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogProductVariantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          findFirst: {
            args: Prisma.CatalogProductVariantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          findMany: {
            args: Prisma.CatalogProductVariantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>[]
          }
          create: {
            args: Prisma.CatalogProductVariantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          createMany: {
            args: Prisma.CatalogProductVariantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>[]
          }
          delete: {
            args: Prisma.CatalogProductVariantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          update: {
            args: Prisma.CatalogProductVariantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.CatalogProductVariantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogProductVariantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogProductVariantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogProductVariantPayload>
          }
          aggregate: {
            args: Prisma.CatalogProductVariantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogProductVariant>
          }
          groupBy: {
            args: Prisma.CatalogProductVariantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogProductVariantCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogProductVariantCountAggregateOutputType> | number
          }
        }
      }
      CatalogCategory: {
        payload: Prisma.$CatalogCategoryPayload<ExtArgs>
        fields: Prisma.CatalogCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          findFirst: {
            args: Prisma.CatalogCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          findMany: {
            args: Prisma.CatalogCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>[]
          }
          create: {
            args: Prisma.CatalogCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          createMany: {
            args: Prisma.CatalogCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogCategoryCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>[]
          }
          delete: {
            args: Prisma.CatalogCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          update: {
            args: Prisma.CatalogCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CatalogCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogCategoryPayload>
          }
          aggregate: {
            args: Prisma.CatalogCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogCategory>
          }
          groupBy: {
            args: Prisma.CatalogCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogCategoryCountAggregateOutputType> | number
          }
        }
      }
      CatalogVendor: {
        payload: Prisma.$CatalogVendorPayload<ExtArgs>
        fields: Prisma.CatalogVendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogVendorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogVendorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          findFirst: {
            args: Prisma.CatalogVendorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogVendorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          findMany: {
            args: Prisma.CatalogVendorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>[]
          }
          create: {
            args: Prisma.CatalogVendorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          createMany: {
            args: Prisma.CatalogVendorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogVendorCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>[]
          }
          delete: {
            args: Prisma.CatalogVendorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          update: {
            args: Prisma.CatalogVendorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          deleteMany: {
            args: Prisma.CatalogVendorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogVendorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogVendorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVendorPayload>
          }
          aggregate: {
            args: Prisma.CatalogVendorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogVendor>
          }
          groupBy: {
            args: Prisma.CatalogVendorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogVendorCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVendorCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Printer: {
        payload: Prisma.$PrinterPayload<ExtArgs>
        fields: Prisma.PrinterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrinterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrinterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          findFirst: {
            args: Prisma.PrinterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrinterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          findMany: {
            args: Prisma.PrinterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>[]
          }
          create: {
            args: Prisma.PrinterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          createMany: {
            args: Prisma.PrinterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrinterCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>[]
          }
          delete: {
            args: Prisma.PrinterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          update: {
            args: Prisma.PrinterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          deleteMany: {
            args: Prisma.PrinterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PrinterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PrinterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PrinterPayload>
          }
          aggregate: {
            args: Prisma.PrinterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrinter>
          }
          groupBy: {
            args: Prisma.PrinterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrinterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrinterCountArgs<ExtArgs>,
            result: $Utils.Optional<PrinterCountAggregateOutputType> | number
          }
        }
      }
      CompanyUser: {
        payload: Prisma.$CompanyUserPayload<ExtArgs>
        fields: Prisma.CompanyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findMany: {
            args: Prisma.CompanyUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          create: {
            args: Prisma.CompanyUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          createMany: {
            args: Prisma.CompanyUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          update: {
            args: Prisma.CompanyUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyUser>
          }
          groupBy: {
            args: Prisma.CompanyUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserCountAggregateOutputType> | number
          }
        }
      }
      CompanyUserPermission: {
        payload: Prisma.$CompanyUserPermissionPayload<ExtArgs>
        fields: Prisma.CompanyUserPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserPermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserPermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserPermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserPermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          findMany: {
            args: Prisma.CompanyUserPermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>[]
          }
          create: {
            args: Prisma.CompanyUserPermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          createMany: {
            args: Prisma.CompanyUserPermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserPermissionCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserPermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          update: {
            args: Prisma.CompanyUserPermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserPermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserPermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUserPermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPermissionPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserPermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyUserPermission>
          }
          groupBy: {
            args: Prisma.CompanyUserPermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserPermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyUserPermissionCountAggregateOutputType> | number
          }
        }
      }
      CompanyPatient: {
        payload: Prisma.$CompanyPatientPayload<ExtArgs>
        fields: Prisma.CompanyPatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyPatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyPatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          findFirst: {
            args: Prisma.CompanyPatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyPatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          findMany: {
            args: Prisma.CompanyPatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>[]
          }
          create: {
            args: Prisma.CompanyPatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          createMany: {
            args: Prisma.CompanyPatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyPatientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>[]
          }
          delete: {
            args: Prisma.CompanyPatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          update: {
            args: Prisma.CompanyPatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          deleteMany: {
            args: Prisma.CompanyPatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyPatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyPatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPatientPayload>
          }
          aggregate: {
            args: Prisma.CompanyPatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompanyPatient>
          }
          groupBy: {
            args: Prisma.CompanyPatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyPatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyPatientCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyPatientCountAggregateOutputType> | number
          }
        }
      }
      FacilityUser: {
        payload: Prisma.$FacilityUserPayload<ExtArgs>
        fields: Prisma.FacilityUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          findFirst: {
            args: Prisma.FacilityUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          findMany: {
            args: Prisma.FacilityUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>[]
          }
          create: {
            args: Prisma.FacilityUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          createMany: {
            args: Prisma.FacilityUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityUserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>[]
          }
          delete: {
            args: Prisma.FacilityUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          update: {
            args: Prisma.FacilityUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          deleteMany: {
            args: Prisma.FacilityUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacilityUserPayload>
          }
          aggregate: {
            args: Prisma.FacilityUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFacilityUser>
          }
          groupBy: {
            args: Prisma.FacilityUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacilityUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityUserCountArgs<ExtArgs>,
            result: $Utils.Optional<FacilityUserCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      ViewFlattenedWorkbench: {
        payload: Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>
        fields: Prisma.ViewFlattenedWorkbenchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          findFirst: {
            args: Prisma.ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          findMany: {
            args: Prisma.ViewFlattenedWorkbenchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>[]
          }
          create: {
            args: Prisma.ViewFlattenedWorkbenchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          createMany: {
            args: Prisma.ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>[]
          }
          delete: {
            args: Prisma.ViewFlattenedWorkbenchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          update: {
            args: Prisma.ViewFlattenedWorkbenchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          deleteMany: {
            args: Prisma.ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ViewFlattenedWorkbenchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViewFlattenedWorkbenchPayload>
          }
          aggregate: {
            args: Prisma.ViewFlattenedWorkbenchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateViewFlattenedWorkbench>
          }
          groupBy: {
            args: Prisma.ViewFlattenedWorkbenchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ViewFlattenedWorkbenchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewFlattenedWorkbenchCountArgs<ExtArgs>,
            result: $Utils.Optional<ViewFlattenedWorkbenchCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    facilities: number
    evaluations: number
    apiKeys: number
    packages: number
    users: number
    permissions: number
    patients: number
    auditLogs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | CompanyCountOutputTypeCountFacilitiesArgs
    evaluations?: boolean | CompanyCountOutputTypeCountEvaluationsArgs
    apiKeys?: boolean | CompanyCountOutputTypeCountApiKeysArgs
    packages?: boolean | CompanyCountOutputTypeCountPackagesArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    permissions?: boolean | CompanyCountOutputTypeCountPermissionsArgs
    patients?: boolean | CompanyCountOutputTypeCountPatientsArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingPackageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserPermissionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    users: number
    evaluations: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | FacilityCountOutputTypeCountUsersArgs
    evaluations?: boolean | FacilityCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityUserWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    feet: number
    evaluations: number
    workbenches: number
    companies: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feet?: boolean | PatientCountOutputTypeCountFeetArgs
    evaluations?: boolean | PatientCountOutputTypeCountEvaluationsArgs
    workbenches?: boolean | PatientCountOutputTypeCountWorkbenchesArgs
    companies?: boolean | PatientCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
  }


  /**
   * Count Type ClinicianCountOutputType
   */

  export type ClinicianCountOutputType = {
    evaluations: number
  }

  export type ClinicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | ClinicianCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * ClinicianCountOutputType without action
   */
  export type ClinicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicianCountOutputType
     */
    select?: ClinicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicianCountOutputType without action
   */
  export type ClinicianCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type EvaluationCountOutputType
   */

  export type EvaluationCountOutputType = {
    clinicians: number
    workbenches: number
  }

  export type EvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicians?: boolean | EvaluationCountOutputTypeCountCliniciansArgs
    workbenches?: boolean | EvaluationCountOutputTypeCountWorkbenchesArgs
  }

  // Custom InputTypes
  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationCountOutputType
     */
    select?: EvaluationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountCliniciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicianWhereInput
  }

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }


  /**
   * Count Type FootCountOutputType
   */

  export type FootCountOutputType = {
    assets: number
  }

  export type FootCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | FootCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * FootCountOutputType without action
   */
  export type FootCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FootCountOutputType
     */
    select?: FootCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FootCountOutputType without action
   */
  export type FootCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    workbenches: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbenches?: boolean | AssetCountOutputTypeCountWorkbenchesArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    buildingBlocks: number
    usedByProducts: number
    workbenches: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingBlocks?: boolean | ProductCountOutputTypeCountBuildingBlocksArgs
    usedByProducts?: boolean | ProductCountOutputTypeCountUsedByProductsArgs
    workbenches?: boolean | ProductCountOutputTypeCountWorkbenchesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBuildingBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountUsedByProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWorkbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
  }


  /**
   * Count Type WorkbenchCountOutputType
   */

  export type WorkbenchCountOutputType = {
    assets: number
    orders: number
    feet: number
    formSubmissions: number
    notes: number
  }

  export type WorkbenchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | WorkbenchCountOutputTypeCountAssetsArgs
    orders?: boolean | WorkbenchCountOutputTypeCountOrdersArgs
    feet?: boolean | WorkbenchCountOutputTypeCountFeetArgs
    formSubmissions?: boolean | WorkbenchCountOutputTypeCountFormSubmissionsArgs
    notes?: boolean | WorkbenchCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchCountOutputType
     */
    select?: WorkbenchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountFormSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * WorkbenchCountOutputType without action
   */
  export type WorkbenchCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
  }


  /**
   * Count Type PhysicianCountOutputType
   */

  export type PhysicianCountOutputType = {
    evaluations: number
    patient: number
  }

  export type PhysicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | PhysicianCountOutputTypeCountEvaluationsArgs
    patient?: boolean | PhysicianCountOutputTypeCountPatientArgs
  }

  // Custom InputTypes
  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicianCountOutputType
     */
    select?: PhysicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Count Type DiagnosisCountOutputType
   */

  export type DiagnosisCountOutputType = {
    evaluations: number
  }

  export type DiagnosisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DiagnosisCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisCountOutputType
     */
    select?: DiagnosisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type DeviceTypeCountOutputType
   */

  export type DeviceTypeCountOutputType = {
    evaluations: number
  }

  export type DeviceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DeviceTypeCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * DeviceTypeCountOutputType without action
   */
  export type DeviceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTypeCountOutputType
     */
    select?: DeviceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceTypeCountOutputType without action
   */
  export type DeviceTypeCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type VisitTypeCountOutputType
   */

  export type VisitTypeCountOutputType = {
    evaluations: number
  }

  export type VisitTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | VisitTypeCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTypeCountOutputType
     */
    select?: VisitTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitTypeCountOutputType without action
   */
  export type VisitTypeCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type FormSchemaCountOutputType
   */

  export type FormSchemaCountOutputType = {
    submissions: number
  }

  export type FormSchemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormSchemaCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FormSchemaCountOutputType without action
   */
  export type FormSchemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchemaCountOutputType
     */
    select?: FormSchemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormSchemaCountOutputType without action
   */
  export type FormSchemaCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }


  /**
   * Count Type CatalogProductCountOutputType
   */

  export type CatalogProductCountOutputType = {
    attributes: number
    variants: number
    categories: number
    vendors: number
  }

  export type CatalogProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | CatalogProductCountOutputTypeCountAttributesArgs
    variants?: boolean | CatalogProductCountOutputTypeCountVariantsArgs
    categories?: boolean | CatalogProductCountOutputTypeCountCategoriesArgs
    vendors?: boolean | CatalogProductCountOutputTypeCountVendorsArgs
  }

  // Custom InputTypes
  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductCountOutputType
     */
    select?: CatalogProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogProductCountOutputType without action
   */
  export type CatalogProductCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogVendorWhereInput
  }


  /**
   * Count Type CatalogCategoryCountOutputType
   */

  export type CatalogCategoryCountOutputType = {
    products: number
  }

  export type CatalogCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CatalogCategoryCountOutputType without action
   */
  export type CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategoryCountOutputType
     */
    select?: CatalogCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogCategoryCountOutputType without action
   */
  export type CatalogCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
  }


  /**
   * Count Type CatalogVendorCountOutputType
   */

  export type CatalogVendorCountOutputType = {
    products: number
  }

  export type CatalogVendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogVendorCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CatalogVendorCountOutputType without action
   */
  export type CatalogVendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendorCountOutputType
     */
    select?: CatalogVendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogVendorCountOutputType without action
   */
  export type CatalogVendorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    companies: number
    permissions: number
    facilities: number
    notes: number
    auditsLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    facilities?: boolean | UserCountOutputTypeCountFacilitiesArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    auditsLogs?: boolean | UserCountOutputTypeCountAuditsLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logoUrl: string | null
    slug: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logoUrl: string | null
    slug: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    url: number
    logoUrl: number
    slug: number
    preferences: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logoUrl?: true
    slug?: true
    preferences?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    url: string | null
    logoUrl: string | null
    slug: string
    preferences: JsonValue | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    logoUrl?: boolean
    slug?: boolean
    preferences?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilities?: boolean | Company$facilitiesArgs<ExtArgs>
    evaluations?: boolean | Company$evaluationsArgs<ExtArgs>
    apiKeys?: boolean | Company$apiKeysArgs<ExtArgs>
    packages?: boolean | Company$packagesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    permissions?: boolean | Company$permissionsArgs<ExtArgs>
    patients?: boolean | Company$patientsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    logoUrl?: boolean
    slug?: boolean
    preferences?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | Company$facilitiesArgs<ExtArgs>
    evaluations?: boolean | Company$evaluationsArgs<ExtArgs>
    apiKeys?: boolean | Company$apiKeysArgs<ExtArgs>
    packages?: boolean | Company$packagesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    permissions?: boolean | Company$permissionsArgs<ExtArgs>
    patients?: boolean | Company$patientsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      packages: Prisma.$ShippingPackagePayload<ExtArgs>[]
      users: Prisma.$CompanyUserPayload<ExtArgs>[]
      permissions: Prisma.$CompanyUserPermissionPayload<ExtArgs>[]
      patients: Prisma.$CompanyPatientPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string | null
      logoUrl: string | null
      slug: string
      preferences: Prisma.JsonValue | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facilities<T extends Company$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Company$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Company$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    apiKeys<T extends Company$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Company$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'> | Null>;

    packages<T extends Company$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Company$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    permissions<T extends Company$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    patients<T extends Company$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Company$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly url: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly slug: FieldRef<"Company", 'String'>
    readonly preferences: FieldRef<"Company", 'Json'>
    readonly active: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.facilities
   */
  export type Company$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Company.evaluations
   */
  export type Company$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Company.apiKeys
   */
  export type Company$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Company.packages
   */
  export type Company$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    where?: ShippingPackageWhereInput
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    cursor?: ShippingPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * Company.permissions
   */
  export type Company$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    where?: CompanyUserPermissionWhereInput
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    cursor?: CompanyUserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserPermissionScalarFieldEnum | CompanyUserPermissionScalarFieldEnum[]
  }

  /**
   * Company.patients
   */
  export type Company$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    cursor?: CompanyPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    id: string | null
    name: string | null
    companyId: string | null
    type: $Enums.FacilityType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    companyId: string | null
    type: $Enums.FacilityType | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    name: number
    companyId: number
    type: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    type?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    address?: boolean | Facility$addressArgs<ExtArgs>
    users?: boolean | Facility$usersArgs<ExtArgs>
    evaluations?: boolean | Facility$evaluationsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    id?: boolean
    name?: boolean
    companyId?: boolean
    type?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    address?: boolean | Facility$addressArgs<ExtArgs>
    users?: boolean | Facility$usersArgs<ExtArgs>
    evaluations?: boolean | Facility$evaluationsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      address: Prisma.$FacilityAddressPayload<ExtArgs> | null
      users: Prisma.$FacilityUserPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      companyId: string
      type: $Enums.FacilityType
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }


  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacilityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
    **/
    create<T extends FacilityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FacilityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
    **/
    delete<T extends FacilityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>
    ): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    address<T extends Facility$addressArgs<ExtArgs> = {}>(args?: Subset<T, Facility$addressArgs<ExtArgs>>): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    users<T extends Facility$usersArgs<ExtArgs> = {}>(args?: Subset<T, Facility$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Facility$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Facility model
   */ 
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'String'>
    readonly name: FieldRef<"Facility", 'String'>
    readonly companyId: FieldRef<"Facility", 'String'>
    readonly type: FieldRef<"Facility", 'FacilityType'>
    readonly active: FieldRef<"Facility", 'Boolean'>
    readonly createdAt: FieldRef<"Facility", 'DateTime'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
  }

  /**
   * Facility.address
   */
  export type Facility$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    where?: FacilityAddressWhereInput
  }

  /**
   * Facility.users
   */
  export type Facility$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    where?: FacilityUserWhereInput
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    cursor?: FacilityUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityUserScalarFieldEnum | FacilityUserScalarFieldEnum[]
  }

  /**
   * Facility.evaluations
   */
  export type Facility$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type PatientSumAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean | null
    deceasedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryPhysicianId: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean | null
    deceasedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryPhysicianId: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    birthDate: number
    height: number
    weight: number
    maritalStatus: number
    photoUrl: number
    active: number
    deceasedAt: number
    createdAt: number
    updatedAt: number
    primaryPhysicianId: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    height?: true
    weight?: true
  }

  export type PatientSumAggregateInputType = {
    height?: true
    weight?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    birthDate?: true
    height?: true
    weight?: true
    maritalStatus?: true
    photoUrl?: true
    active?: true
    deceasedAt?: true
    createdAt?: true
    updatedAt?: true
    primaryPhysicianId?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    height: number | null
    weight: number | null
    maritalStatus: $Enums.MaritalStatus | null
    photoUrl: string | null
    active: boolean
    deceasedAt: Date | null
    createdAt: Date
    updatedAt: Date
    primaryPhysicianId: string | null
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    birthDate?: boolean
    height?: boolean
    weight?: boolean
    maritalStatus?: boolean
    photoUrl?: boolean
    active?: boolean
    deceasedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryPhysicianId?: boolean
    primaryPhysician?: boolean | Patient$primaryPhysicianArgs<ExtArgs>
    feet?: boolean | Patient$feetArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    workbenches?: boolean | Patient$workbenchesArgs<ExtArgs>
    companies?: boolean | Patient$companiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    birthDate?: boolean
    height?: boolean
    weight?: boolean
    maritalStatus?: boolean
    photoUrl?: boolean
    active?: boolean
    deceasedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryPhysicianId?: boolean
  }


  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryPhysician?: boolean | Patient$primaryPhysicianArgs<ExtArgs>
    feet?: boolean | Patient$feetArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    workbenches?: boolean | Patient$workbenchesArgs<ExtArgs>
    companies?: boolean | Patient$companiesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      primaryPhysician: Prisma.$PhysicianPayload<ExtArgs> | null
      feet: Prisma.$FootPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
      companies: Prisma.$CompanyPatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      middleName: string | null
      lastName: string | null
      gender: $Enums.Gender | null
      birthDate: Date | null
      height: number | null
      weight: number | null
      maritalStatus: $Enums.MaritalStatus | null
      photoUrl: string | null
      active: boolean
      deceasedAt: Date | null
      createdAt: Date
      updatedAt: Date
      primaryPhysicianId: string | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    primaryPhysician<T extends Patient$primaryPhysicianArgs<ExtArgs> = {}>(args?: Subset<T, Patient$primaryPhysicianArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    feet<T extends Patient$feetArgs<ExtArgs> = {}>(args?: Subset<T, Patient$feetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends Patient$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Patient$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    companies<T extends Patient$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly middleName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly maritalStatus: FieldRef<"Patient", 'MaritalStatus'>
    readonly photoUrl: FieldRef<"Patient", 'String'>
    readonly active: FieldRef<"Patient", 'Boolean'>
    readonly deceasedAt: FieldRef<"Patient", 'DateTime'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly primaryPhysicianId: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data?: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.primaryPhysician
   */
  export type Patient$primaryPhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    where?: PhysicianWhereInput
  }

  /**
   * Patient.feet
   */
  export type Patient$feetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    where?: FootWhereInput
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    cursor?: FootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Patient.evaluations
   */
  export type Patient$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Patient.workbenches
   */
  export type Patient$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Patient.companies
   */
  export type Patient$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    cursor?: CompanyPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Clinician
   */

  export type AggregateClinician = {
    _count: ClinicianCountAggregateOutputType | null
    _min: ClinicianMinAggregateOutputType | null
    _max: ClinicianMaxAggregateOutputType | null
  }

  export type ClinicianMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicianMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicianCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicianMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicianMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicianCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinician to aggregate.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinicians
    **/
    _count?: true | ClinicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicianMaxAggregateInputType
  }

  export type GetClinicianAggregateType<T extends ClinicianAggregateArgs> = {
        [P in keyof T & keyof AggregateClinician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinician[P]>
      : GetScalarType<T[P], AggregateClinician[P]>
  }




  export type ClinicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicianWhereInput
    orderBy?: ClinicianOrderByWithAggregationInput | ClinicianOrderByWithAggregationInput[]
    by: ClinicianScalarFieldEnum[] | ClinicianScalarFieldEnum
    having?: ClinicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicianCountAggregateInputType | true
    _min?: ClinicianMinAggregateInputType
    _max?: ClinicianMaxAggregateInputType
  }

  export type ClinicianGroupByOutputType = {
    id: string
    name: string
    userId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicianCountAggregateOutputType | null
    _min: ClinicianMinAggregateOutputType | null
    _max: ClinicianMaxAggregateOutputType | null
  }

  type GetClinicianGroupByPayload<T extends ClinicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicianGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicianGroupByOutputType[P]>
        }
      >
    >


  export type ClinicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Clinician$userArgs<ExtArgs>
    evaluations?: boolean | Clinician$evaluationsArgs<ExtArgs>
    _count?: boolean | ClinicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinician"]>

  export type ClinicianSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ClinicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Clinician$userArgs<ExtArgs>
    evaluations?: boolean | Clinician$evaluationsArgs<ExtArgs>
    _count?: boolean | ClinicianCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClinicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinician"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinician"]>
    composites: {}
  }


  type ClinicianGetPayload<S extends boolean | null | undefined | ClinicianDefaultArgs> = $Result.GetResult<Prisma.$ClinicianPayload, S>

  type ClinicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicianCountAggregateInputType | true
    }

  export interface ClinicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinician'], meta: { name: 'Clinician' } }
    /**
     * Find zero or one Clinician that matches the filter.
     * @param {ClinicianFindUniqueArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClinicianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianFindUniqueArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Clinician that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClinicianFindUniqueOrThrowArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClinicianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Clinician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindFirstArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClinicianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindFirstArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Clinician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindFirstOrThrowArgs} args - Arguments to find a Clinician
     * @example
     * // Get one Clinician
     * const clinician = await prisma.clinician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClinicianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clinicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinicians
     * const clinicians = await prisma.clinician.findMany()
     * 
     * // Get first 10 Clinicians
     * const clinicians = await prisma.clinician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicianWithIdOnly = await prisma.clinician.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClinicianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Clinician.
     * @param {ClinicianCreateArgs} args - Arguments to create a Clinician.
     * @example
     * // Create one Clinician
     * const Clinician = await prisma.clinician.create({
     *   data: {
     *     // ... data to create a Clinician
     *   }
     * })
     * 
    **/
    create<T extends ClinicianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianCreateArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clinicians.
     * @param {ClinicianCreateManyArgs} args - Arguments to create many Clinicians.
     * @example
     * // Create many Clinicians
     * const clinician = await prisma.clinician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClinicianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinicians and returns the data saved in the database.
     * @param {ClinicianCreateManyAndReturnArgs} args - Arguments to create many Clinicians.
     * @example
     * // Create many Clinicians
     * const clinician = await prisma.clinician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinicians and only return the `id`
     * const clinicianWithIdOnly = await prisma.clinician.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ClinicianCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Clinician.
     * @param {ClinicianDeleteArgs} args - Arguments to delete one Clinician.
     * @example
     * // Delete one Clinician
     * const Clinician = await prisma.clinician.delete({
     *   where: {
     *     // ... filter to delete one Clinician
     *   }
     * })
     * 
    **/
    delete<T extends ClinicianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianDeleteArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Clinician.
     * @param {ClinicianUpdateArgs} args - Arguments to update one Clinician.
     * @example
     * // Update one Clinician
     * const clinician = await prisma.clinician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClinicianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpdateArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clinicians.
     * @param {ClinicianDeleteManyArgs} args - Arguments to filter Clinicians to delete.
     * @example
     * // Delete a few Clinicians
     * const { count } = await prisma.clinician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClinicianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinicians
     * const clinician = await prisma.clinician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClinicianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinician.
     * @param {ClinicianUpsertArgs} args - Arguments to update or create a Clinician.
     * @example
     * // Update or create a Clinician
     * const clinician = await prisma.clinician.upsert({
     *   create: {
     *     // ... data to create a Clinician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinician we want to update
     *   }
     * })
    **/
    upsert<T extends ClinicianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicianUpsertArgs<ExtArgs>>
    ): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clinicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianCountArgs} args - Arguments to filter Clinicians to count.
     * @example
     * // Count the number of Clinicians
     * const count = await prisma.clinician.count({
     *   where: {
     *     // ... the filter for the Clinicians we want to count
     *   }
     * })
    **/
    count<T extends ClinicianCountArgs>(
      args?: Subset<T, ClinicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicianAggregateArgs>(args: Subset<T, ClinicianAggregateArgs>): Prisma.PrismaPromise<GetClinicianAggregateType<T>>

    /**
     * Group by Clinician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicianGroupByArgs['orderBy'] }
        : { orderBy?: ClinicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinician model
   */
  readonly fields: ClinicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Clinician$userArgs<ExtArgs> = {}>(args?: Subset<T, Clinician$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    evaluations<T extends Clinician$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Clinician$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Clinician model
   */ 
  interface ClinicianFieldRefs {
    readonly id: FieldRef<"Clinician", 'String'>
    readonly name: FieldRef<"Clinician", 'String'>
    readonly userId: FieldRef<"Clinician", 'String'>
    readonly active: FieldRef<"Clinician", 'Boolean'>
    readonly createdAt: FieldRef<"Clinician", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinician", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinician findUnique
   */
  export type ClinicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician findUniqueOrThrow
   */
  export type ClinicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician findFirst
   */
  export type ClinicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinicians.
     */
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician findFirstOrThrow
   */
  export type ClinicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinician to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinicians.
     */
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician findMany
   */
  export type ClinicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter, which Clinicians to fetch.
     */
    where?: ClinicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinicians to fetch.
     */
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinicians.
     */
    cursor?: ClinicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinicians.
     */
    skip?: number
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Clinician create
   */
  export type ClinicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinician.
     */
    data: XOR<ClinicianCreateInput, ClinicianUncheckedCreateInput>
  }

  /**
   * Clinician createMany
   */
  export type ClinicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinicians.
     */
    data: ClinicianCreateManyInput | ClinicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinician createManyAndReturn
   */
  export type ClinicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data used to create many Clinicians.
     */
    data: ClinicianCreateManyInput | ClinicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinician update
   */
  export type ClinicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinician.
     */
    data: XOR<ClinicianUpdateInput, ClinicianUncheckedUpdateInput>
    /**
     * Choose, which Clinician to update.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician updateMany
   */
  export type ClinicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinicians.
     */
    data: XOR<ClinicianUpdateManyMutationInput, ClinicianUncheckedUpdateManyInput>
    /**
     * Filter which Clinicians to update
     */
    where?: ClinicianWhereInput
  }

  /**
   * Clinician upsert
   */
  export type ClinicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinician to update in case it exists.
     */
    where: ClinicianWhereUniqueInput
    /**
     * In case the Clinician found by the `where` argument doesn't exist, create a new Clinician with this data.
     */
    create: XOR<ClinicianCreateInput, ClinicianUncheckedCreateInput>
    /**
     * In case the Clinician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicianUpdateInput, ClinicianUncheckedUpdateInput>
  }

  /**
   * Clinician delete
   */
  export type ClinicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    /**
     * Filter which Clinician to delete.
     */
    where: ClinicianWhereUniqueInput
  }

  /**
   * Clinician deleteMany
   */
  export type ClinicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinicians to delete
     */
    where?: ClinicianWhereInput
  }

  /**
   * Clinician.user
   */
  export type Clinician$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Clinician.evaluations
   */
  export type Clinician$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Clinician without action
   */
  export type ClinicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType | null
    patientId: string | null
    companyId: string | null
    deviceTypeId: string | null
    isDiabetic: boolean | null
    isVeteran: boolean | null
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean | null
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType | null
    patientId: string | null
    companyId: string | null
    deviceTypeId: string | null
    isDiabetic: boolean | null
    isVeteran: boolean | null
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean | null
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    externalId: number
    poNumber: number
    type: number
    patientId: number
    companyId: number
    deviceTypeId: number
    isDiabetic: number
    isVeteran: number
    deviceSide: number
    devicePosition: number
    appointmentAt: number
    appointmentStatus: number
    referringPhysicianId: number
    diagnosisId: number
    diagnosisedAt: number
    visitTypeId: number
    visitedAt: number
    facilityId: number
    location: number
    prescribedAt: number
    prescribedActive: number
    primaryInsurance: number
    secondaryInsurance: number
    submittedAt: number
    startedAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationMinAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    externalId?: true
    poNumber?: true
    type?: true
    patientId?: true
    companyId?: true
    deviceTypeId?: true
    isDiabetic?: true
    isVeteran?: true
    deviceSide?: true
    devicePosition?: true
    appointmentAt?: true
    appointmentStatus?: true
    referringPhysicianId?: true
    diagnosisId?: true
    diagnosisedAt?: true
    visitTypeId?: true
    visitedAt?: true
    facilityId?: true
    location?: true
    prescribedAt?: true
    prescribedActive?: true
    primaryInsurance?: true
    secondaryInsurance?: true
    submittedAt?: true
    startedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: string
    externalId: string | null
    poNumber: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId: string | null
    isDiabetic: boolean
    isVeteran: boolean
    deviceSide: $Enums.Side | null
    devicePosition: $Enums.VerticalPosition | null
    appointmentAt: Date | null
    appointmentStatus: string | null
    referringPhysicianId: string | null
    diagnosisId: string | null
    diagnosisedAt: Date | null
    visitTypeId: string | null
    visitedAt: Date | null
    facilityId: string | null
    location: string | null
    prescribedAt: Date | null
    prescribedActive: boolean
    primaryInsurance: string | null
    secondaryInsurance: string | null
    submittedAt: Date | null
    startedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EvaluationCountAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    poNumber?: boolean
    type?: boolean
    patientId?: boolean
    companyId?: boolean
    deviceTypeId?: boolean
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: boolean
    devicePosition?: boolean
    appointmentAt?: boolean
    appointmentStatus?: boolean
    referringPhysicianId?: boolean
    diagnosisId?: boolean
    diagnosisedAt?: boolean
    visitTypeId?: boolean
    visitedAt?: boolean
    facilityId?: boolean
    location?: boolean
    prescribedAt?: boolean
    prescribedActive?: boolean
    primaryInsurance?: boolean
    secondaryInsurance?: boolean
    submittedAt?: boolean
    startedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deviceType?: boolean | Evaluation$deviceTypeArgs<ExtArgs>
    visitType?: boolean | Evaluation$visitTypeArgs<ExtArgs>
    referringPhysician?: boolean | Evaluation$referringPhysicianArgs<ExtArgs>
    diagnosis?: boolean | Evaluation$diagnosisArgs<ExtArgs>
    facility?: boolean | Evaluation$facilityArgs<ExtArgs>
    clinicians?: boolean | Evaluation$cliniciansArgs<ExtArgs>
    workbenches?: boolean | Evaluation$workbenchesArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    externalId?: boolean
    poNumber?: boolean
    type?: boolean
    patientId?: boolean
    companyId?: boolean
    deviceTypeId?: boolean
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: boolean
    devicePosition?: boolean
    appointmentAt?: boolean
    appointmentStatus?: boolean
    referringPhysicianId?: boolean
    diagnosisId?: boolean
    diagnosisedAt?: boolean
    visitTypeId?: boolean
    visitedAt?: boolean
    facilityId?: boolean
    location?: boolean
    prescribedAt?: boolean
    prescribedActive?: boolean
    primaryInsurance?: boolean
    secondaryInsurance?: boolean
    submittedAt?: boolean
    startedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deviceType?: boolean | Evaluation$deviceTypeArgs<ExtArgs>
    visitType?: boolean | Evaluation$visitTypeArgs<ExtArgs>
    referringPhysician?: boolean | Evaluation$referringPhysicianArgs<ExtArgs>
    diagnosis?: boolean | Evaluation$diagnosisArgs<ExtArgs>
    facility?: boolean | Evaluation$facilityArgs<ExtArgs>
    clinicians?: boolean | Evaluation$cliniciansArgs<ExtArgs>
    workbenches?: boolean | Evaluation$workbenchesArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      deviceType: Prisma.$DeviceTypePayload<ExtArgs> | null
      visitType: Prisma.$VisitTypePayload<ExtArgs> | null
      referringPhysician: Prisma.$PhysicianPayload<ExtArgs> | null
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs> | null
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      clinicians: Prisma.$ClinicianPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      poNumber: string | null
      type: $Enums.CareType
      patientId: string
      companyId: string
      deviceTypeId: string | null
      isDiabetic: boolean
      isVeteran: boolean
      deviceSide: $Enums.Side | null
      devicePosition: $Enums.VerticalPosition | null
      appointmentAt: Date | null
      appointmentStatus: string | null
      referringPhysicianId: string | null
      diagnosisId: string | null
      diagnosisedAt: Date | null
      visitTypeId: string | null
      visitedAt: Date | null
      facilityId: string | null
      location: string | null
      prescribedAt: Date | null
      prescribedActive: boolean
      primaryInsurance: string | null
      secondaryInsurance: string | null
      submittedAt: Date | null
      startedAt: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }


  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
    **/
    create<T extends EvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluations and returns the data saved in the database.
     * @param {EvaluationCreateManyAndReturnArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends EvaluationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    deviceType<T extends Evaluation$deviceTypeArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$deviceTypeArgs<ExtArgs>>): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    visitType<T extends Evaluation$visitTypeArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$visitTypeArgs<ExtArgs>>): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    referringPhysician<T extends Evaluation$referringPhysicianArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$referringPhysicianArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    diagnosis<T extends Evaluation$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$diagnosisArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    facility<T extends Evaluation$facilityArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clinicians<T extends Evaluation$cliniciansArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$cliniciansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Evaluation$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'String'>
    readonly externalId: FieldRef<"Evaluation", 'String'>
    readonly poNumber: FieldRef<"Evaluation", 'String'>
    readonly type: FieldRef<"Evaluation", 'CareType'>
    readonly patientId: FieldRef<"Evaluation", 'String'>
    readonly companyId: FieldRef<"Evaluation", 'String'>
    readonly deviceTypeId: FieldRef<"Evaluation", 'String'>
    readonly isDiabetic: FieldRef<"Evaluation", 'Boolean'>
    readonly isVeteran: FieldRef<"Evaluation", 'Boolean'>
    readonly deviceSide: FieldRef<"Evaluation", 'Side'>
    readonly devicePosition: FieldRef<"Evaluation", 'VerticalPosition'>
    readonly appointmentAt: FieldRef<"Evaluation", 'DateTime'>
    readonly appointmentStatus: FieldRef<"Evaluation", 'String'>
    readonly referringPhysicianId: FieldRef<"Evaluation", 'String'>
    readonly diagnosisId: FieldRef<"Evaluation", 'String'>
    readonly diagnosisedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly visitTypeId: FieldRef<"Evaluation", 'String'>
    readonly visitedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly facilityId: FieldRef<"Evaluation", 'String'>
    readonly location: FieldRef<"Evaluation", 'String'>
    readonly prescribedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly prescribedActive: FieldRef<"Evaluation", 'Boolean'>
    readonly primaryInsurance: FieldRef<"Evaluation", 'String'>
    readonly secondaryInsurance: FieldRef<"Evaluation", 'String'>
    readonly submittedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly startedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly cancelledAt: FieldRef<"Evaluation", 'DateTime'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"Evaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation createManyAndReturn
   */
  export type EvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }

  /**
   * Evaluation.deviceType
   */
  export type Evaluation$deviceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    where?: DeviceTypeWhereInput
  }

  /**
   * Evaluation.visitType
   */
  export type Evaluation$visitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    where?: VisitTypeWhereInput
  }

  /**
   * Evaluation.referringPhysician
   */
  export type Evaluation$referringPhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    where?: PhysicianWhereInput
  }

  /**
   * Evaluation.diagnosis
   */
  export type Evaluation$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
  }

  /**
   * Evaluation.facility
   */
  export type Evaluation$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * Evaluation.clinicians
   */
  export type Evaluation$cliniciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    where?: ClinicianWhereInput
    orderBy?: ClinicianOrderByWithRelationInput | ClinicianOrderByWithRelationInput[]
    cursor?: ClinicianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicianScalarFieldEnum | ClinicianScalarFieldEnum[]
  }

  /**
   * Evaluation.workbenches
   */
  export type Evaluation$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Foot
   */

  export type AggregateFoot = {
    _count: FootCountAggregateOutputType | null
    _avg: FootAvgAggregateOutputType | null
    _sum: FootSumAggregateOutputType | null
    _min: FootMinAggregateOutputType | null
    _max: FootMaxAggregateOutputType | null
  }

  export type FootAvgAggregateOutputType = {
    shoeSize: number | null
  }

  export type FootSumAggregateOutputType = {
    shoeSize: number | null
  }

  export type FootMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    workbenchId: string | null
    side: $Enums.Side | null
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth | null
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem | null
    shoeBrand: string | null
    shoeModel: string | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FootMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    workbenchId: string | null
    side: $Enums.Side | null
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth | null
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem | null
    shoeBrand: string | null
    shoeModel: string | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FootCountAggregateOutputType = {
    id: number
    patientId: number
    workbenchId: number
    side: number
    shoeSize: number
    shoeWidth: number
    shoeGender: number
    shoeSystem: number
    shoeBrand: number
    shoeModel: number
    questionnaire: number
    inactiveReason: number
    isChild: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FootAvgAggregateInputType = {
    shoeSize?: true
  }

  export type FootSumAggregateInputType = {
    shoeSize?: true
  }

  export type FootMinAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FootMaxAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FootCountAggregateInputType = {
    id?: true
    patientId?: true
    workbenchId?: true
    side?: true
    shoeSize?: true
    shoeWidth?: true
    shoeGender?: true
    shoeSystem?: true
    shoeBrand?: true
    shoeModel?: true
    questionnaire?: true
    inactiveReason?: true
    isChild?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foot to aggregate.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feet
    **/
    _count?: true | FootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FootMaxAggregateInputType
  }

  export type GetFootAggregateType<T extends FootAggregateArgs> = {
        [P in keyof T & keyof AggregateFoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoot[P]>
      : GetScalarType<T[P], AggregateFoot[P]>
  }




  export type FootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FootWhereInput
    orderBy?: FootOrderByWithAggregationInput | FootOrderByWithAggregationInput[]
    by: FootScalarFieldEnum[] | FootScalarFieldEnum
    having?: FootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FootCountAggregateInputType | true
    _avg?: FootAvgAggregateInputType
    _sum?: FootSumAggregateInputType
    _min?: FootMinAggregateInputType
    _max?: FootMaxAggregateInputType
  }

  export type FootGroupByOutputType = {
    id: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize: number | null
    shoeWidth: $Enums.ShoeWidth
    shoeGender: $Enums.Gender | null
    shoeSystem: $Enums.ShoeSystem
    shoeBrand: string | null
    shoeModel: string | null
    questionnaire: JsonValue | null
    inactiveReason: $Enums.InactiveFootReason | null
    isChild: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FootCountAggregateOutputType | null
    _avg: FootAvgAggregateOutputType | null
    _sum: FootSumAggregateOutputType | null
    _min: FootMinAggregateOutputType | null
    _max: FootMaxAggregateOutputType | null
  }

  type GetFootGroupByPayload<T extends FootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FootGroupByOutputType[P]>
            : GetScalarType<T[P], FootGroupByOutputType[P]>
        }
      >
    >


  export type FootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    workbenchId?: boolean
    side?: boolean
    shoeSize?: boolean
    shoeWidth?: boolean
    shoeGender?: boolean
    shoeSystem?: boolean
    shoeBrand?: boolean
    shoeModel?: boolean
    questionnaire?: boolean
    inactiveReason?: boolean
    isChild?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    assets?: boolean | Foot$assetsArgs<ExtArgs>
    _count?: boolean | FootCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foot"]>

  export type FootSelectScalar = {
    id?: boolean
    patientId?: boolean
    workbenchId?: boolean
    side?: boolean
    shoeSize?: boolean
    shoeWidth?: boolean
    shoeGender?: boolean
    shoeSystem?: boolean
    shoeBrand?: boolean
    shoeModel?: boolean
    questionnaire?: boolean
    inactiveReason?: boolean
    isChild?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    assets?: boolean | Foot$assetsArgs<ExtArgs>
    _count?: boolean | FootCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foot"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      workbenchId: string
      side: $Enums.Side
      shoeSize: number | null
      shoeWidth: $Enums.ShoeWidth
      shoeGender: $Enums.Gender | null
      shoeSystem: $Enums.ShoeSystem
      shoeBrand: string | null
      shoeModel: string | null
      questionnaire: Prisma.JsonValue | null
      inactiveReason: $Enums.InactiveFootReason | null
      isChild: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foot"]>
    composites: {}
  }


  type FootGetPayload<S extends boolean | null | undefined | FootDefaultArgs> = $Result.GetResult<Prisma.$FootPayload, S>

  type FootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FootFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FootCountAggregateInputType | true
    }

  export interface FootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foot'], meta: { name: 'Foot' } }
    /**
     * Find zero or one Foot that matches the filter.
     * @param {FootFindUniqueArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FootFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FootFindUniqueArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FootFindUniqueOrThrowArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FootFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindFirstArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FootFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindFirstArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindFirstOrThrowArgs} args - Arguments to find a Foot
     * @example
     * // Get one Foot
     * const foot = await prisma.foot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FootFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feet
     * const feet = await prisma.foot.findMany()
     * 
     * // Get first 10 Feet
     * const feet = await prisma.foot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footWithIdOnly = await prisma.foot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FootFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foot.
     * @param {FootCreateArgs} args - Arguments to create a Foot.
     * @example
     * // Create one Foot
     * const Foot = await prisma.foot.create({
     *   data: {
     *     // ... data to create a Foot
     *   }
     * })
     * 
    **/
    create<T extends FootCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FootCreateArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feet.
     * @param {FootCreateManyArgs} args - Arguments to create many Feet.
     * @example
     * // Create many Feet
     * const foot = await prisma.foot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FootCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feet and returns the data saved in the database.
     * @param {FootCreateManyAndReturnArgs} args - Arguments to create many Feet.
     * @example
     * // Create many Feet
     * const foot = await prisma.foot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feet and only return the `id`
     * const footWithIdOnly = await prisma.foot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FootCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FootCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Foot.
     * @param {FootDeleteArgs} args - Arguments to delete one Foot.
     * @example
     * // Delete one Foot
     * const Foot = await prisma.foot.delete({
     *   where: {
     *     // ... filter to delete one Foot
     *   }
     * })
     * 
    **/
    delete<T extends FootDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FootDeleteArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foot.
     * @param {FootUpdateArgs} args - Arguments to update one Foot.
     * @example
     * // Update one Foot
     * const foot = await prisma.foot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FootUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpdateArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feet.
     * @param {FootDeleteManyArgs} args - Arguments to filter Feet to delete.
     * @example
     * // Delete a few Feet
     * const { count } = await prisma.foot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FootDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FootDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feet
     * const foot = await prisma.foot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FootUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foot.
     * @param {FootUpsertArgs} args - Arguments to update or create a Foot.
     * @example
     * // Update or create a Foot
     * const foot = await prisma.foot.upsert({
     *   create: {
     *     // ... data to create a Foot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foot we want to update
     *   }
     * })
    **/
    upsert<T extends FootUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FootUpsertArgs<ExtArgs>>
    ): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootCountArgs} args - Arguments to filter Feet to count.
     * @example
     * // Count the number of Feet
     * const count = await prisma.foot.count({
     *   where: {
     *     // ... the filter for the Feet we want to count
     *   }
     * })
    **/
    count<T extends FootCountArgs>(
      args?: Subset<T, FootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FootAggregateArgs>(args: Subset<T, FootAggregateArgs>): Prisma.PrismaPromise<GetFootAggregateType<T>>

    /**
     * Group by Foot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FootGroupByArgs['orderBy'] }
        : { orderBy?: FootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foot model
   */
  readonly fields: FootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assets<T extends Foot$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Foot$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Foot model
   */ 
  interface FootFieldRefs {
    readonly id: FieldRef<"Foot", 'String'>
    readonly patientId: FieldRef<"Foot", 'String'>
    readonly workbenchId: FieldRef<"Foot", 'String'>
    readonly side: FieldRef<"Foot", 'Side'>
    readonly shoeSize: FieldRef<"Foot", 'Float'>
    readonly shoeWidth: FieldRef<"Foot", 'ShoeWidth'>
    readonly shoeGender: FieldRef<"Foot", 'Gender'>
    readonly shoeSystem: FieldRef<"Foot", 'ShoeSystem'>
    readonly shoeBrand: FieldRef<"Foot", 'String'>
    readonly shoeModel: FieldRef<"Foot", 'String'>
    readonly questionnaire: FieldRef<"Foot", 'Json'>
    readonly inactiveReason: FieldRef<"Foot", 'InactiveFootReason'>
    readonly isChild: FieldRef<"Foot", 'Boolean'>
    readonly active: FieldRef<"Foot", 'Boolean'>
    readonly createdAt: FieldRef<"Foot", 'DateTime'>
    readonly updatedAt: FieldRef<"Foot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Foot findUnique
   */
  export type FootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot findUniqueOrThrow
   */
  export type FootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot findFirst
   */
  export type FootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feet.
     */
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot findFirstOrThrow
   */
  export type FootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Foot to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feet.
     */
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot findMany
   */
  export type FootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter, which Feet to fetch.
     */
    where?: FootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feet to fetch.
     */
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feet.
     */
    cursor?: FootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feet from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feet.
     */
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Foot create
   */
  export type FootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data needed to create a Foot.
     */
    data: XOR<FootCreateInput, FootUncheckedCreateInput>
  }

  /**
   * Foot createMany
   */
  export type FootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feet.
     */
    data: FootCreateManyInput | FootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foot createManyAndReturn
   */
  export type FootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data used to create many Feet.
     */
    data: FootCreateManyInput | FootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foot update
   */
  export type FootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The data needed to update a Foot.
     */
    data: XOR<FootUpdateInput, FootUncheckedUpdateInput>
    /**
     * Choose, which Foot to update.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot updateMany
   */
  export type FootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feet.
     */
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyInput>
    /**
     * Filter which Feet to update
     */
    where?: FootWhereInput
  }

  /**
   * Foot upsert
   */
  export type FootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * The filter to search for the Foot to update in case it exists.
     */
    where: FootWhereUniqueInput
    /**
     * In case the Foot found by the `where` argument doesn't exist, create a new Foot with this data.
     */
    create: XOR<FootCreateInput, FootUncheckedCreateInput>
    /**
     * In case the Foot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FootUpdateInput, FootUncheckedUpdateInput>
  }

  /**
   * Foot delete
   */
  export type FootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    /**
     * Filter which Foot to delete.
     */
    where: FootWhereUniqueInput
  }

  /**
   * Foot deleteMany
   */
  export type FootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feet to delete
     */
    where?: FootWhereInput
  }

  /**
   * Foot.assets
   */
  export type Foot$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Foot without action
   */
  export type FootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    footId: string | null
    type: $Enums.ProductType | null
    fileUrl: string | null
    status: $Enums.AssetStatus | null
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    footId: string | null
    type: $Enums.ProductType | null
    fileUrl: string | null
    status: $Enums.AssetStatus | null
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    footId: number
    type: number
    fileUrl: number
    metadata: number
    status: number
    statusCheckpoints: number
    statusReason: number
    statusUpdatedAt: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    status?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    status?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    footId?: true
    type?: true
    fileUrl?: true
    metadata?: true
    status?: true
    statusCheckpoints?: true
    statusReason?: true
    statusUpdatedAt?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    footId: string
    type: $Enums.ProductType
    fileUrl: string | null
    metadata: JsonValue | null
    status: $Enums.AssetStatus
    statusCheckpoints: $Enums.AssetStatus[]
    statusReason: string | null
    statusUpdatedAt: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footId?: boolean
    type?: boolean
    fileUrl?: boolean
    metadata?: boolean
    status?: boolean
    statusCheckpoints?: boolean
    statusReason?: boolean
    statusUpdatedAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foot?: boolean | FootDefaultArgs<ExtArgs>
    workbenches?: boolean | Asset$workbenchesArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    footId?: boolean
    type?: boolean
    fileUrl?: boolean
    metadata?: boolean
    status?: boolean
    statusCheckpoints?: boolean
    statusReason?: boolean
    statusUpdatedAt?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foot?: boolean | FootDefaultArgs<ExtArgs>
    workbenches?: boolean | Asset$workbenchesArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      foot: Prisma.$FootPayload<ExtArgs>
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      footId: string
      type: $Enums.ProductType
      fileUrl: string | null
      metadata: Prisma.JsonValue | null
      status: $Enums.AssetStatus
      statusCheckpoints: $Enums.AssetStatus[]
      statusReason: string | null
      statusUpdatedAt: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }


  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
    **/
    create<T extends AssetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetCreateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
    **/
    delete<T extends AssetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
    **/
    upsert<T extends AssetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    foot<T extends FootDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FootDefaultArgs<ExtArgs>>): Prisma__FootClient<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbenches<T extends Asset$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Asset$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly footId: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'ProductType'>
    readonly fileUrl: FieldRef<"Asset", 'String'>
    readonly metadata: FieldRef<"Asset", 'Json'>
    readonly status: FieldRef<"Asset", 'AssetStatus'>
    readonly statusCheckpoints: FieldRef<"Asset", 'AssetStatus[]'>
    readonly statusReason: FieldRef<"Asset", 'String'>
    readonly statusUpdatedAt: FieldRef<"Asset", 'DateTime'>
    readonly active: FieldRef<"Asset", 'Boolean'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset.workbenches
   */
  export type Asset$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProductType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProductType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    type: number
    sides: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    sides?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ProductType
    sides: $Enums.Side[]
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    sides?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buildingBlocks?: boolean | Product$buildingBlocksArgs<ExtArgs>
    usedByProducts?: boolean | Product$usedByProductsArgs<ExtArgs>
    workbenches?: boolean | Product$workbenchesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    sides?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingBlocks?: boolean | Product$buildingBlocksArgs<ExtArgs>
    usedByProducts?: boolean | Product$usedByProductsArgs<ExtArgs>
    workbenches?: boolean | Product$workbenchesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      buildingBlocks: Prisma.$ProductPayload<ExtArgs>[]
      usedByProducts: Prisma.$ProductPayload<ExtArgs>[]
      workbenches: Prisma.$WorkbenchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ProductType
      sides: $Enums.Side[]
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingBlocks<T extends Product$buildingBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Product$buildingBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    usedByProducts<T extends Product$usedByProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$usedByProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    workbenches<T extends Product$workbenchesArgs<ExtArgs> = {}>(args?: Subset<T, Product$workbenchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly sides: FieldRef<"Product", 'Side[]'>
    readonly description: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.buildingBlocks
   */
  export type Product$buildingBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.usedByProducts
   */
  export type Product$usedByProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.workbenches
   */
  export type Product$workbenchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    cursor?: WorkbenchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Workbench
   */

  export type AggregateWorkbench = {
    _count: WorkbenchCountAggregateOutputType | null
    _min: WorkbenchMinAggregateOutputType | null
    _max: WorkbenchMaxAggregateOutputType | null
  }

  export type WorkbenchMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    productId: string | null
    evaluationId: string | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus | null
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkbenchMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    productId: string | null
    evaluationId: string | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus | null
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkbenchCountAggregateOutputType = {
    id: number
    patientId: number
    productId: number
    evaluationId: number
    customization: number
    webhookUrl: number
    createdReason: number
    status: number
    failedAt: number
    completedAt: number
    submittedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkbenchMinAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkbenchMaxAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkbenchCountAggregateInputType = {
    id?: true
    patientId?: true
    productId?: true
    evaluationId?: true
    customization?: true
    webhookUrl?: true
    createdReason?: true
    status?: true
    failedAt?: true
    completedAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkbenchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workbench to aggregate.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workbenches
    **/
    _count?: true | WorkbenchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkbenchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkbenchMaxAggregateInputType
  }

  export type GetWorkbenchAggregateType<T extends WorkbenchAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkbench]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkbench[P]>
      : GetScalarType<T[P], AggregateWorkbench[P]>
  }




  export type WorkbenchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchWhereInput
    orderBy?: WorkbenchOrderByWithAggregationInput | WorkbenchOrderByWithAggregationInput[]
    by: WorkbenchScalarFieldEnum[] | WorkbenchScalarFieldEnum
    having?: WorkbenchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkbenchCountAggregateInputType | true
    _min?: WorkbenchMinAggregateInputType
    _max?: WorkbenchMaxAggregateInputType
  }

  export type WorkbenchGroupByOutputType = {
    id: string
    patientId: string
    productId: string
    evaluationId: string
    customization: JsonValue | null
    webhookUrl: string | null
    createdReason: $Enums.WorkbenchCreatedReason | null
    status: $Enums.WorkbenchStatus
    failedAt: Date | null
    completedAt: Date | null
    submittedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WorkbenchCountAggregateOutputType | null
    _min: WorkbenchMinAggregateOutputType | null
    _max: WorkbenchMaxAggregateOutputType | null
  }

  type GetWorkbenchGroupByPayload<T extends WorkbenchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkbenchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkbenchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkbenchGroupByOutputType[P]>
            : GetScalarType<T[P], WorkbenchGroupByOutputType[P]>
        }
      >
    >


  export type WorkbenchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    productId?: boolean
    evaluationId?: boolean
    customization?: boolean
    webhookUrl?: boolean
    createdReason?: boolean
    status?: boolean
    failedAt?: boolean
    completedAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    assets?: boolean | Workbench$assetsArgs<ExtArgs>
    orders?: boolean | Workbench$ordersArgs<ExtArgs>
    feet?: boolean | Workbench$feetArgs<ExtArgs>
    formSubmissions?: boolean | Workbench$formSubmissionsArgs<ExtArgs>
    notes?: boolean | Workbench$notesArgs<ExtArgs>
    _count?: boolean | WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workbench"]>

  export type WorkbenchSelectScalar = {
    id?: boolean
    patientId?: boolean
    productId?: boolean
    evaluationId?: boolean
    customization?: boolean
    webhookUrl?: boolean
    createdReason?: boolean
    status?: boolean
    failedAt?: boolean
    completedAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WorkbenchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    assets?: boolean | Workbench$assetsArgs<ExtArgs>
    orders?: boolean | Workbench$ordersArgs<ExtArgs>
    feet?: boolean | Workbench$feetArgs<ExtArgs>
    formSubmissions?: boolean | Workbench$formSubmissionsArgs<ExtArgs>
    notes?: boolean | Workbench$notesArgs<ExtArgs>
    _count?: boolean | WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WorkbenchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workbench"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      feet: Prisma.$FootPayload<ExtArgs>[]
      formSubmissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
      notes: Prisma.$WorkbenchNotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      productId: string
      evaluationId: string
      customization: Prisma.JsonValue | null
      webhookUrl: string | null
      createdReason: $Enums.WorkbenchCreatedReason | null
      status: $Enums.WorkbenchStatus
      failedAt: Date | null
      completedAt: Date | null
      submittedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workbench"]>
    composites: {}
  }


  type WorkbenchGetPayload<S extends boolean | null | undefined | WorkbenchDefaultArgs> = $Result.GetResult<Prisma.$WorkbenchPayload, S>

  type WorkbenchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkbenchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkbenchCountAggregateInputType | true
    }

  export interface WorkbenchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workbench'], meta: { name: 'Workbench' } }
    /**
     * Find zero or one Workbench that matches the filter.
     * @param {WorkbenchFindUniqueArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkbenchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Workbench that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkbenchFindUniqueOrThrowArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkbenchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Workbench that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindFirstArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkbenchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindFirstArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Workbench that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindFirstOrThrowArgs} args - Arguments to find a Workbench
     * @example
     * // Get one Workbench
     * const workbench = await prisma.workbench.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkbenchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Workbenches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workbenches
     * const workbenches = await prisma.workbench.findMany()
     * 
     * // Get first 10 Workbenches
     * const workbenches = await prisma.workbench.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workbenchWithIdOnly = await prisma.workbench.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkbenchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Workbench.
     * @param {WorkbenchCreateArgs} args - Arguments to create a Workbench.
     * @example
     * // Create one Workbench
     * const Workbench = await prisma.workbench.create({
     *   data: {
     *     // ... data to create a Workbench
     *   }
     * })
     * 
    **/
    create<T extends WorkbenchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchCreateArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Workbenches.
     * @param {WorkbenchCreateManyArgs} args - Arguments to create many Workbenches.
     * @example
     * // Create many Workbenches
     * const workbench = await prisma.workbench.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkbenchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workbenches and returns the data saved in the database.
     * @param {WorkbenchCreateManyAndReturnArgs} args - Arguments to create many Workbenches.
     * @example
     * // Create many Workbenches
     * const workbench = await prisma.workbench.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workbenches and only return the `id`
     * const workbenchWithIdOnly = await prisma.workbench.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkbenchCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Workbench.
     * @param {WorkbenchDeleteArgs} args - Arguments to delete one Workbench.
     * @example
     * // Delete one Workbench
     * const Workbench = await prisma.workbench.delete({
     *   where: {
     *     // ... filter to delete one Workbench
     *   }
     * })
     * 
    **/
    delete<T extends WorkbenchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchDeleteArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Workbench.
     * @param {WorkbenchUpdateArgs} args - Arguments to update one Workbench.
     * @example
     * // Update one Workbench
     * const workbench = await prisma.workbench.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkbenchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpdateArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Workbenches.
     * @param {WorkbenchDeleteManyArgs} args - Arguments to filter Workbenches to delete.
     * @example
     * // Delete a few Workbenches
     * const { count } = await prisma.workbench.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkbenchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workbenches
     * const workbench = await prisma.workbench.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkbenchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workbench.
     * @param {WorkbenchUpsertArgs} args - Arguments to update or create a Workbench.
     * @example
     * // Update or create a Workbench
     * const workbench = await prisma.workbench.upsert({
     *   create: {
     *     // ... data to create a Workbench
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workbench we want to update
     *   }
     * })
    **/
    upsert<T extends WorkbenchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchUpsertArgs<ExtArgs>>
    ): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Workbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchCountArgs} args - Arguments to filter Workbenches to count.
     * @example
     * // Count the number of Workbenches
     * const count = await prisma.workbench.count({
     *   where: {
     *     // ... the filter for the Workbenches we want to count
     *   }
     * })
    **/
    count<T extends WorkbenchCountArgs>(
      args?: Subset<T, WorkbenchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkbenchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkbenchAggregateArgs>(args: Subset<T, WorkbenchAggregateArgs>): Prisma.PrismaPromise<GetWorkbenchAggregateType<T>>

    /**
     * Group by Workbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkbenchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkbenchGroupByArgs['orderBy'] }
        : { orderBy?: WorkbenchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkbenchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkbenchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workbench model
   */
  readonly fields: WorkbenchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workbench.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkbenchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    assets<T extends Workbench$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Workbench$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    feet<T extends Workbench$feetArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$feetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FootPayload<ExtArgs>, T, 'findMany'> | Null>;

    formSubmissions<T extends Workbench$formSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$formSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends Workbench$notesArgs<ExtArgs> = {}>(args?: Subset<T, Workbench$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Workbench model
   */ 
  interface WorkbenchFieldRefs {
    readonly id: FieldRef<"Workbench", 'String'>
    readonly patientId: FieldRef<"Workbench", 'String'>
    readonly productId: FieldRef<"Workbench", 'String'>
    readonly evaluationId: FieldRef<"Workbench", 'String'>
    readonly customization: FieldRef<"Workbench", 'Json'>
    readonly webhookUrl: FieldRef<"Workbench", 'String'>
    readonly createdReason: FieldRef<"Workbench", 'WorkbenchCreatedReason'>
    readonly status: FieldRef<"Workbench", 'WorkbenchStatus'>
    readonly failedAt: FieldRef<"Workbench", 'DateTime'>
    readonly completedAt: FieldRef<"Workbench", 'DateTime'>
    readonly submittedAt: FieldRef<"Workbench", 'DateTime'>
    readonly createdAt: FieldRef<"Workbench", 'DateTime'>
    readonly updatedAt: FieldRef<"Workbench", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workbench findUnique
   */
  export type WorkbenchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench findUniqueOrThrow
   */
  export type WorkbenchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench findFirst
   */
  export type WorkbenchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workbenches.
     */
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench findFirstOrThrow
   */
  export type WorkbenchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbench to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workbenches.
     */
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench findMany
   */
  export type WorkbenchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter, which Workbenches to fetch.
     */
    where?: WorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workbenches to fetch.
     */
    orderBy?: WorkbenchOrderByWithRelationInput | WorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workbenches.
     */
    cursor?: WorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workbenches.
     */
    skip?: number
    distinct?: WorkbenchScalarFieldEnum | WorkbenchScalarFieldEnum[]
  }

  /**
   * Workbench create
   */
  export type WorkbenchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data needed to create a Workbench.
     */
    data: XOR<WorkbenchCreateInput, WorkbenchUncheckedCreateInput>
  }

  /**
   * Workbench createMany
   */
  export type WorkbenchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workbenches.
     */
    data: WorkbenchCreateManyInput | WorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workbench createManyAndReturn
   */
  export type WorkbenchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data used to create many Workbenches.
     */
    data: WorkbenchCreateManyInput | WorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workbench update
   */
  export type WorkbenchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The data needed to update a Workbench.
     */
    data: XOR<WorkbenchUpdateInput, WorkbenchUncheckedUpdateInput>
    /**
     * Choose, which Workbench to update.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench updateMany
   */
  export type WorkbenchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workbenches.
     */
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyInput>
    /**
     * Filter which Workbenches to update
     */
    where?: WorkbenchWhereInput
  }

  /**
   * Workbench upsert
   */
  export type WorkbenchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * The filter to search for the Workbench to update in case it exists.
     */
    where: WorkbenchWhereUniqueInput
    /**
     * In case the Workbench found by the `where` argument doesn't exist, create a new Workbench with this data.
     */
    create: XOR<WorkbenchCreateInput, WorkbenchUncheckedCreateInput>
    /**
     * In case the Workbench was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkbenchUpdateInput, WorkbenchUncheckedUpdateInput>
  }

  /**
   * Workbench delete
   */
  export type WorkbenchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
    /**
     * Filter which Workbench to delete.
     */
    where: WorkbenchWhereUniqueInput
  }

  /**
   * Workbench deleteMany
   */
  export type WorkbenchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workbenches to delete
     */
    where?: WorkbenchWhereInput
  }

  /**
   * Workbench.assets
   */
  export type Workbench$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Workbench.orders
   */
  export type Workbench$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Workbench.feet
   */
  export type Workbench$feetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foot
     */
    select?: FootSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FootInclude<ExtArgs> | null
    where?: FootWhereInput
    orderBy?: FootOrderByWithRelationInput | FootOrderByWithRelationInput[]
    cursor?: FootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FootScalarFieldEnum | FootScalarFieldEnum[]
  }

  /**
   * Workbench.formSubmissions
   */
  export type Workbench$formSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Workbench.notes
   */
  export type Workbench$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    cursor?: WorkbenchNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * Workbench without action
   */
  export type WorkbenchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workbench
     */
    select?: WorkbenchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchInclude<ExtArgs> | null
  }


  /**
   * Model WorkbenchNotes
   */

  export type AggregateWorkbenchNotes = {
    _count: WorkbenchNotesCountAggregateOutputType | null
    _min: WorkbenchNotesMinAggregateOutputType | null
    _max: WorkbenchNotesMaxAggregateOutputType | null
  }

  export type WorkbenchNotesMinAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkbenchNotesMaxAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkbenchNotesCountAggregateOutputType = {
    id: number
    workbenchId: number
    title: number
    content: number
    tags: number
    blocks: number
    createdAt: number
    createdBy: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WorkbenchNotesMinAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkbenchNotesMaxAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkbenchNotesCountAggregateInputType = {
    id?: true
    workbenchId?: true
    title?: true
    content?: true
    tags?: true
    blocks?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkbenchNotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkbenchNotes to aggregate.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkbenchNotes
    **/
    _count?: true | WorkbenchNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkbenchNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkbenchNotesMaxAggregateInputType
  }

  export type GetWorkbenchNotesAggregateType<T extends WorkbenchNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkbenchNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkbenchNotes[P]>
      : GetScalarType<T[P], AggregateWorkbenchNotes[P]>
  }




  export type WorkbenchNotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithAggregationInput | WorkbenchNotesOrderByWithAggregationInput[]
    by: WorkbenchNotesScalarFieldEnum[] | WorkbenchNotesScalarFieldEnum
    having?: WorkbenchNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkbenchNotesCountAggregateInputType | true
    _min?: WorkbenchNotesMinAggregateInputType
    _max?: WorkbenchNotesMaxAggregateInputType
  }

  export type WorkbenchNotesGroupByOutputType = {
    id: string
    workbenchId: string
    title: string | null
    content: string | null
    tags: string[]
    blocks: JsonValue | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    deletedAt: Date | null
    _count: WorkbenchNotesCountAggregateOutputType | null
    _min: WorkbenchNotesMinAggregateOutputType | null
    _max: WorkbenchNotesMaxAggregateOutputType | null
  }

  type GetWorkbenchNotesGroupByPayload<T extends WorkbenchNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkbenchNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkbenchNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkbenchNotesGroupByOutputType[P]>
            : GetScalarType<T[P], WorkbenchNotesGroupByOutputType[P]>
        }
      >
    >


  export type WorkbenchNotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workbenchId?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    blocks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    createdByUser?: boolean | WorkbenchNotes$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["workbenchNotes"]>

  export type WorkbenchNotesSelectScalar = {
    id?: boolean
    workbenchId?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    blocks?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }


  export type WorkbenchNotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
    createdByUser?: boolean | WorkbenchNotes$createdByUserArgs<ExtArgs>
  }


  export type $WorkbenchNotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkbenchNotes"
    objects: {
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workbenchId: string
      title: string | null
      content: string | null
      tags: string[]
      blocks: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["workbenchNotes"]>
    composites: {}
  }


  type WorkbenchNotesGetPayload<S extends boolean | null | undefined | WorkbenchNotesDefaultArgs> = $Result.GetResult<Prisma.$WorkbenchNotesPayload, S>

  type WorkbenchNotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkbenchNotesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkbenchNotesCountAggregateInputType | true
    }

  export interface WorkbenchNotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkbenchNotes'], meta: { name: 'WorkbenchNotes' } }
    /**
     * Find zero or one WorkbenchNotes that matches the filter.
     * @param {WorkbenchNotesFindUniqueArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkbenchNotesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WorkbenchNotes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkbenchNotesFindUniqueOrThrowArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WorkbenchNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindFirstArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkbenchNotesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindFirstArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WorkbenchNotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindFirstOrThrowArgs} args - Arguments to find a WorkbenchNotes
     * @example
     * // Get one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WorkbenchNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findMany()
     * 
     * // Get first 10 WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workbenchNotesWithIdOnly = await prisma.workbenchNotes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkbenchNotesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WorkbenchNotes.
     * @param {WorkbenchNotesCreateArgs} args - Arguments to create a WorkbenchNotes.
     * @example
     * // Create one WorkbenchNotes
     * const WorkbenchNotes = await prisma.workbenchNotes.create({
     *   data: {
     *     // ... data to create a WorkbenchNotes
     *   }
     * })
     * 
    **/
    create<T extends WorkbenchNotesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesCreateArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WorkbenchNotes.
     * @param {WorkbenchNotesCreateManyArgs} args - Arguments to create many WorkbenchNotes.
     * @example
     * // Create many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends WorkbenchNotesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkbenchNotes and returns the data saved in the database.
     * @param {WorkbenchNotesCreateManyAndReturnArgs} args - Arguments to create many WorkbenchNotes.
     * @example
     * // Create many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkbenchNotes and only return the `id`
     * const workbenchNotesWithIdOnly = await prisma.workbenchNotes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a WorkbenchNotes.
     * @param {WorkbenchNotesDeleteArgs} args - Arguments to delete one WorkbenchNotes.
     * @example
     * // Delete one WorkbenchNotes
     * const WorkbenchNotes = await prisma.workbenchNotes.delete({
     *   where: {
     *     // ... filter to delete one WorkbenchNotes
     *   }
     * })
     * 
    **/
    delete<T extends WorkbenchNotesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesDeleteArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WorkbenchNotes.
     * @param {WorkbenchNotesUpdateArgs} args - Arguments to update one WorkbenchNotes.
     * @example
     * // Update one WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkbenchNotesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpdateArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WorkbenchNotes.
     * @param {WorkbenchNotesDeleteManyArgs} args - Arguments to filter WorkbenchNotes to delete.
     * @example
     * // Delete a few WorkbenchNotes
     * const { count } = await prisma.workbenchNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkbenchNotesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkbenchNotesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkbenchNotesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkbenchNotes.
     * @param {WorkbenchNotesUpsertArgs} args - Arguments to update or create a WorkbenchNotes.
     * @example
     * // Update or create a WorkbenchNotes
     * const workbenchNotes = await prisma.workbenchNotes.upsert({
     *   create: {
     *     // ... data to create a WorkbenchNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkbenchNotes we want to update
     *   }
     * })
    **/
    upsert<T extends WorkbenchNotesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkbenchNotesUpsertArgs<ExtArgs>>
    ): Prisma__WorkbenchNotesClient<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesCountArgs} args - Arguments to filter WorkbenchNotes to count.
     * @example
     * // Count the number of WorkbenchNotes
     * const count = await prisma.workbenchNotes.count({
     *   where: {
     *     // ... the filter for the WorkbenchNotes we want to count
     *   }
     * })
    **/
    count<T extends WorkbenchNotesCountArgs>(
      args?: Subset<T, WorkbenchNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkbenchNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkbenchNotesAggregateArgs>(args: Subset<T, WorkbenchNotesAggregateArgs>): Prisma.PrismaPromise<GetWorkbenchNotesAggregateType<T>>

    /**
     * Group by WorkbenchNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkbenchNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkbenchNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkbenchNotesGroupByArgs['orderBy'] }
        : { orderBy?: WorkbenchNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkbenchNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkbenchNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkbenchNotes model
   */
  readonly fields: WorkbenchNotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkbenchNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkbenchNotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    createdByUser<T extends WorkbenchNotes$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchNotes$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WorkbenchNotes model
   */ 
  interface WorkbenchNotesFieldRefs {
    readonly id: FieldRef<"WorkbenchNotes", 'String'>
    readonly workbenchId: FieldRef<"WorkbenchNotes", 'String'>
    readonly title: FieldRef<"WorkbenchNotes", 'String'>
    readonly content: FieldRef<"WorkbenchNotes", 'String'>
    readonly tags: FieldRef<"WorkbenchNotes", 'String[]'>
    readonly blocks: FieldRef<"WorkbenchNotes", 'Json'>
    readonly createdAt: FieldRef<"WorkbenchNotes", 'DateTime'>
    readonly createdBy: FieldRef<"WorkbenchNotes", 'String'>
    readonly updatedAt: FieldRef<"WorkbenchNotes", 'DateTime'>
    readonly deletedAt: FieldRef<"WorkbenchNotes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkbenchNotes findUnique
   */
  export type WorkbenchNotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes findUniqueOrThrow
   */
  export type WorkbenchNotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes findFirst
   */
  export type WorkbenchNotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkbenchNotes.
     */
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes findFirstOrThrow
   */
  export type WorkbenchNotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkbenchNotes.
     */
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes findMany
   */
  export type WorkbenchNotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter, which WorkbenchNotes to fetch.
     */
    where?: WorkbenchNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkbenchNotes to fetch.
     */
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkbenchNotes.
     */
    cursor?: WorkbenchNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkbenchNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkbenchNotes.
     */
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * WorkbenchNotes create
   */
  export type WorkbenchNotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesCreateInput, WorkbenchNotesUncheckedCreateInput>
  }

  /**
   * WorkbenchNotes createMany
   */
  export type WorkbenchNotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkbenchNotes.
     */
    data: WorkbenchNotesCreateManyInput | WorkbenchNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkbenchNotes createManyAndReturn
   */
  export type WorkbenchNotesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data used to create many WorkbenchNotes.
     */
    data: WorkbenchNotesCreateManyInput | WorkbenchNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkbenchNotes update
   */
  export type WorkbenchNotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesUpdateInput, WorkbenchNotesUncheckedUpdateInput>
    /**
     * Choose, which WorkbenchNotes to update.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes updateMany
   */
  export type WorkbenchNotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkbenchNotes.
     */
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyInput>
    /**
     * Filter which WorkbenchNotes to update
     */
    where?: WorkbenchNotesWhereInput
  }

  /**
   * WorkbenchNotes upsert
   */
  export type WorkbenchNotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkbenchNotes to update in case it exists.
     */
    where: WorkbenchNotesWhereUniqueInput
    /**
     * In case the WorkbenchNotes found by the `where` argument doesn't exist, create a new WorkbenchNotes with this data.
     */
    create: XOR<WorkbenchNotesCreateInput, WorkbenchNotesUncheckedCreateInput>
    /**
     * In case the WorkbenchNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkbenchNotesUpdateInput, WorkbenchNotesUncheckedUpdateInput>
  }

  /**
   * WorkbenchNotes delete
   */
  export type WorkbenchNotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    /**
     * Filter which WorkbenchNotes to delete.
     */
    where: WorkbenchNotesWhereUniqueInput
  }

  /**
   * WorkbenchNotes deleteMany
   */
  export type WorkbenchNotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkbenchNotes to delete
     */
    where?: WorkbenchNotesWhereInput
  }

  /**
   * WorkbenchNotes.createdByUser
   */
  export type WorkbenchNotes$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkbenchNotes without action
   */
  export type WorkbenchNotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    status: $Enums.OrderStatus | null
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean | null
    authorizationStatus: $Enums.OrderAuthorizationStatus | null
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    workbenchId: string | null
    status: $Enums.OrderStatus | null
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean | null
    authorizationStatus: $Enums.OrderAuthorizationStatus | null
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    workbenchId: number
    status: number
    statusUpdatedAt: number
    committedDeliveryAt: number
    parcelId: number
    active: number
    authorizationStatus: number
    authorizationUpdatedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    workbenchId?: true
    status?: true
    statusUpdatedAt?: true
    committedDeliveryAt?: true
    parcelId?: true
    active?: true
    authorizationStatus?: true
    authorizationUpdatedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    workbenchId: string
    status: $Enums.OrderStatus
    statusUpdatedAt: Date | null
    committedDeliveryAt: Date | null
    parcelId: string | null
    active: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workbenchId?: boolean
    status?: boolean
    statusUpdatedAt?: boolean
    committedDeliveryAt?: boolean
    parcelId?: boolean
    active?: boolean
    authorizationStatus?: boolean
    authorizationUpdatedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    workbenchId?: boolean
    status?: boolean
    statusUpdatedAt?: boolean
    committedDeliveryAt?: boolean
    parcelId?: boolean
    active?: boolean
    authorizationStatus?: boolean
    authorizationUpdatedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }


  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workbenchId: string
      status: $Enums.OrderStatus
      statusUpdatedAt: Date | null
      committedDeliveryAt: Date | null
      parcelId: string | null
      active: boolean
      authorizationStatus: $Enums.OrderAuthorizationStatus
      authorizationUpdatedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly workbenchId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly statusUpdatedAt: FieldRef<"Order", 'DateTime'>
    readonly committedDeliveryAt: FieldRef<"Order", 'DateTime'>
    readonly parcelId: FieldRef<"Order", 'String'>
    readonly active: FieldRef<"Order", 'Boolean'>
    readonly authorizationStatus: FieldRef<"Order", 'OrderAuthorizationStatus'>
    readonly authorizationUpdatedAt: FieldRef<"Order", 'DateTime'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model FacilityAddress
   */

  export type AggregateFacilityAddress = {
    _count: FacilityAddressCountAggregateOutputType | null
    _min: FacilityAddressMinAggregateOutputType | null
    _max: FacilityAddressMaxAggregateOutputType | null
  }

  export type FacilityAddressMinAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    stateOrProvince: string | null
    postalCode: string | null
    countryCode: string | null
    shippingAccountId: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityId: string | null
  }

  export type FacilityAddressMaxAggregateOutputType = {
    id: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    stateOrProvince: string | null
    postalCode: string | null
    countryCode: string | null
    shippingAccountId: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityId: string | null
  }

  export type FacilityAddressCountAggregateOutputType = {
    id: number
    name: number
    addressLine1: number
    addressLine2: number
    city: number
    stateOrProvince: number
    postalCode: number
    countryCode: number
    shippingAccountId: number
    shippingAccountCarrier: number
    createdAt: number
    updatedAt: number
    facilityId: number
    _all: number
  }


  export type FacilityAddressMinAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
    facilityId?: true
  }

  export type FacilityAddressMaxAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
    facilityId?: true
  }

  export type FacilityAddressCountAggregateInputType = {
    id?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    stateOrProvince?: true
    postalCode?: true
    countryCode?: true
    shippingAccountId?: true
    shippingAccountCarrier?: true
    createdAt?: true
    updatedAt?: true
    facilityId?: true
    _all?: true
  }

  export type FacilityAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityAddress to aggregate.
     */
    where?: FacilityAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityAddresses to fetch.
     */
    orderBy?: FacilityAddressOrderByWithRelationInput | FacilityAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityAddresses
    **/
    _count?: true | FacilityAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityAddressMaxAggregateInputType
  }

  export type GetFacilityAddressAggregateType<T extends FacilityAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityAddress[P]>
      : GetScalarType<T[P], AggregateFacilityAddress[P]>
  }




  export type FacilityAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityAddressWhereInput
    orderBy?: FacilityAddressOrderByWithAggregationInput | FacilityAddressOrderByWithAggregationInput[]
    by: FacilityAddressScalarFieldEnum[] | FacilityAddressScalarFieldEnum
    having?: FacilityAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityAddressCountAggregateInputType | true
    _min?: FacilityAddressMinAggregateInputType
    _max?: FacilityAddressMaxAggregateInputType
  }

  export type FacilityAddressGroupByOutputType = {
    id: string
    name: string | null
    addressLine1: string
    addressLine2: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId: string | null
    shippingAccountCarrier: $Enums.Carrier | null
    createdAt: Date
    updatedAt: Date
    facilityId: string
    _count: FacilityAddressCountAggregateOutputType | null
    _min: FacilityAddressMinAggregateOutputType | null
    _max: FacilityAddressMaxAggregateOutputType | null
  }

  type GetFacilityAddressGroupByPayload<T extends FacilityAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityAddressGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityAddressGroupByOutputType[P]>
        }
      >
    >


  export type FacilityAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    stateOrProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    shippingAccountId?: boolean
    shippingAccountCarrier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityId?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityAddress"]>

  export type FacilityAddressSelectScalar = {
    id?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    stateOrProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    shippingAccountId?: boolean
    shippingAccountCarrier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityId?: boolean
  }


  export type FacilityAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }


  export type $FacilityAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityAddress"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      addressLine1: string
      addressLine2: string | null
      city: string
      stateOrProvince: string
      postalCode: string
      countryCode: string
      shippingAccountId: string | null
      shippingAccountCarrier: $Enums.Carrier | null
      createdAt: Date
      updatedAt: Date
      facilityId: string
    }, ExtArgs["result"]["facilityAddress"]>
    composites: {}
  }


  type FacilityAddressGetPayload<S extends boolean | null | undefined | FacilityAddressDefaultArgs> = $Result.GetResult<Prisma.$FacilityAddressPayload, S>

  type FacilityAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityAddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityAddressCountAggregateInputType | true
    }

  export interface FacilityAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityAddress'], meta: { name: 'FacilityAddress' } }
    /**
     * Find zero or one FacilityAddress that matches the filter.
     * @param {FacilityAddressFindUniqueArgs} args - Arguments to find a FacilityAddress
     * @example
     * // Get one FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityAddressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FacilityAddress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityAddressFindUniqueOrThrowArgs} args - Arguments to find a FacilityAddress
     * @example
     * // Get one FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacilityAddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FacilityAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressFindFirstArgs} args - Arguments to find a FacilityAddress
     * @example
     * // Get one FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityAddressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FacilityAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressFindFirstOrThrowArgs} args - Arguments to find a FacilityAddress
     * @example
     * // Get one FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacilityAddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FacilityAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityAddresses
     * const facilityAddresses = await prisma.facilityAddress.findMany()
     * 
     * // Get first 10 FacilityAddresses
     * const facilityAddresses = await prisma.facilityAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityAddressWithIdOnly = await prisma.facilityAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacilityAddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FacilityAddress.
     * @param {FacilityAddressCreateArgs} args - Arguments to create a FacilityAddress.
     * @example
     * // Create one FacilityAddress
     * const FacilityAddress = await prisma.facilityAddress.create({
     *   data: {
     *     // ... data to create a FacilityAddress
     *   }
     * })
     * 
    **/
    create<T extends FacilityAddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressCreateArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FacilityAddresses.
     * @param {FacilityAddressCreateManyArgs} args - Arguments to create many FacilityAddresses.
     * @example
     * // Create many FacilityAddresses
     * const facilityAddress = await prisma.facilityAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FacilityAddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityAddresses and returns the data saved in the database.
     * @param {FacilityAddressCreateManyAndReturnArgs} args - Arguments to create many FacilityAddresses.
     * @example
     * // Create many FacilityAddresses
     * const facilityAddress = await prisma.facilityAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityAddresses and only return the `id`
     * const facilityAddressWithIdOnly = await prisma.facilityAddress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FacilityAddressCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FacilityAddress.
     * @param {FacilityAddressDeleteArgs} args - Arguments to delete one FacilityAddress.
     * @example
     * // Delete one FacilityAddress
     * const FacilityAddress = await prisma.facilityAddress.delete({
     *   where: {
     *     // ... filter to delete one FacilityAddress
     *   }
     * })
     * 
    **/
    delete<T extends FacilityAddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressDeleteArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FacilityAddress.
     * @param {FacilityAddressUpdateArgs} args - Arguments to update one FacilityAddress.
     * @example
     * // Update one FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityAddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressUpdateArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FacilityAddresses.
     * @param {FacilityAddressDeleteManyArgs} args - Arguments to filter FacilityAddresses to delete.
     * @example
     * // Delete a few FacilityAddresses
     * const { count } = await prisma.facilityAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityAddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityAddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityAddresses
     * const facilityAddress = await prisma.facilityAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityAddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacilityAddress.
     * @param {FacilityAddressUpsertArgs} args - Arguments to update or create a FacilityAddress.
     * @example
     * // Update or create a FacilityAddress
     * const facilityAddress = await prisma.facilityAddress.upsert({
     *   create: {
     *     // ... data to create a FacilityAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityAddress we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityAddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityAddressUpsertArgs<ExtArgs>>
    ): Prisma__FacilityAddressClient<$Result.GetResult<Prisma.$FacilityAddressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FacilityAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressCountArgs} args - Arguments to filter FacilityAddresses to count.
     * @example
     * // Count the number of FacilityAddresses
     * const count = await prisma.facilityAddress.count({
     *   where: {
     *     // ... the filter for the FacilityAddresses we want to count
     *   }
     * })
    **/
    count<T extends FacilityAddressCountArgs>(
      args?: Subset<T, FacilityAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAddressAggregateArgs>(args: Subset<T, FacilityAddressAggregateArgs>): Prisma.PrismaPromise<GetFacilityAddressAggregateType<T>>

    /**
     * Group by FacilityAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityAddressGroupByArgs['orderBy'] }
        : { orderBy?: FacilityAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityAddress model
   */
  readonly fields: FacilityAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FacilityAddress model
   */ 
  interface FacilityAddressFieldRefs {
    readonly id: FieldRef<"FacilityAddress", 'String'>
    readonly name: FieldRef<"FacilityAddress", 'String'>
    readonly addressLine1: FieldRef<"FacilityAddress", 'String'>
    readonly addressLine2: FieldRef<"FacilityAddress", 'String'>
    readonly city: FieldRef<"FacilityAddress", 'String'>
    readonly stateOrProvince: FieldRef<"FacilityAddress", 'String'>
    readonly postalCode: FieldRef<"FacilityAddress", 'String'>
    readonly countryCode: FieldRef<"FacilityAddress", 'String'>
    readonly shippingAccountId: FieldRef<"FacilityAddress", 'String'>
    readonly shippingAccountCarrier: FieldRef<"FacilityAddress", 'Carrier'>
    readonly createdAt: FieldRef<"FacilityAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"FacilityAddress", 'DateTime'>
    readonly facilityId: FieldRef<"FacilityAddress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacilityAddress findUnique
   */
  export type FacilityAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter, which FacilityAddress to fetch.
     */
    where: FacilityAddressWhereUniqueInput
  }

  /**
   * FacilityAddress findUniqueOrThrow
   */
  export type FacilityAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter, which FacilityAddress to fetch.
     */
    where: FacilityAddressWhereUniqueInput
  }

  /**
   * FacilityAddress findFirst
   */
  export type FacilityAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter, which FacilityAddress to fetch.
     */
    where?: FacilityAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityAddresses to fetch.
     */
    orderBy?: FacilityAddressOrderByWithRelationInput | FacilityAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityAddresses.
     */
    cursor?: FacilityAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityAddresses.
     */
    distinct?: FacilityAddressScalarFieldEnum | FacilityAddressScalarFieldEnum[]
  }

  /**
   * FacilityAddress findFirstOrThrow
   */
  export type FacilityAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter, which FacilityAddress to fetch.
     */
    where?: FacilityAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityAddresses to fetch.
     */
    orderBy?: FacilityAddressOrderByWithRelationInput | FacilityAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityAddresses.
     */
    cursor?: FacilityAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityAddresses.
     */
    distinct?: FacilityAddressScalarFieldEnum | FacilityAddressScalarFieldEnum[]
  }

  /**
   * FacilityAddress findMany
   */
  export type FacilityAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter, which FacilityAddresses to fetch.
     */
    where?: FacilityAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityAddresses to fetch.
     */
    orderBy?: FacilityAddressOrderByWithRelationInput | FacilityAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityAddresses.
     */
    cursor?: FacilityAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityAddresses.
     */
    skip?: number
    distinct?: FacilityAddressScalarFieldEnum | FacilityAddressScalarFieldEnum[]
  }

  /**
   * FacilityAddress create
   */
  export type FacilityAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityAddress.
     */
    data: XOR<FacilityAddressCreateInput, FacilityAddressUncheckedCreateInput>
  }

  /**
   * FacilityAddress createMany
   */
  export type FacilityAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityAddresses.
     */
    data: FacilityAddressCreateManyInput | FacilityAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityAddress createManyAndReturn
   */
  export type FacilityAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * The data used to create many FacilityAddresses.
     */
    data: FacilityAddressCreateManyInput | FacilityAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityAddress update
   */
  export type FacilityAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityAddress.
     */
    data: XOR<FacilityAddressUpdateInput, FacilityAddressUncheckedUpdateInput>
    /**
     * Choose, which FacilityAddress to update.
     */
    where: FacilityAddressWhereUniqueInput
  }

  /**
   * FacilityAddress updateMany
   */
  export type FacilityAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityAddresses.
     */
    data: XOR<FacilityAddressUpdateManyMutationInput, FacilityAddressUncheckedUpdateManyInput>
    /**
     * Filter which FacilityAddresses to update
     */
    where?: FacilityAddressWhereInput
  }

  /**
   * FacilityAddress upsert
   */
  export type FacilityAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityAddress to update in case it exists.
     */
    where: FacilityAddressWhereUniqueInput
    /**
     * In case the FacilityAddress found by the `where` argument doesn't exist, create a new FacilityAddress with this data.
     */
    create: XOR<FacilityAddressCreateInput, FacilityAddressUncheckedCreateInput>
    /**
     * In case the FacilityAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityAddressUpdateInput, FacilityAddressUncheckedUpdateInput>
  }

  /**
   * FacilityAddress delete
   */
  export type FacilityAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
    /**
     * Filter which FacilityAddress to delete.
     */
    where: FacilityAddressWhereUniqueInput
  }

  /**
   * FacilityAddress deleteMany
   */
  export type FacilityAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityAddresses to delete
     */
    where?: FacilityAddressWhereInput
  }

  /**
   * FacilityAddress without action
   */
  export type FacilityAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityAddress
     */
    select?: FacilityAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityAddressInclude<ExtArgs> | null
  }


  /**
   * Model ShippingPackage
   */

  export type AggregateShippingPackage = {
    _count: ShippingPackageCountAggregateOutputType | null
    _avg: ShippingPackageAvgAggregateOutputType | null
    _sum: ShippingPackageSumAggregateOutputType | null
    _min: ShippingPackageMinAggregateOutputType | null
    _max: ShippingPackageMaxAggregateOutputType | null
  }

  export type ShippingPackageAvgAggregateOutputType = {
    weight: number | null
    length: number | null
    width: number | null
    height: number | null
    insoleCapacity: number | null
  }

  export type ShippingPackageSumAggregateOutputType = {
    weight: number | null
    length: number | null
    width: number | null
    height: number | null
    insoleCapacity: number | null
  }

  export type ShippingPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    weightUnit: $Enums.WeightUnit | null
    length: number | null
    width: number | null
    height: number | null
    dimensionUnit: $Enums.DimensionUnit | null
    insoleCapacity: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    weightUnit: $Enums.WeightUnit | null
    length: number | null
    width: number | null
    height: number | null
    dimensionUnit: $Enums.DimensionUnit | null
    insoleCapacity: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingPackageCountAggregateOutputType = {
    id: number
    name: number
    weight: number
    weightUnit: number
    length: number
    width: number
    height: number
    dimensionUnit: number
    insoleCapacity: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingPackageAvgAggregateInputType = {
    weight?: true
    length?: true
    width?: true
    height?: true
    insoleCapacity?: true
  }

  export type ShippingPackageSumAggregateInputType = {
    weight?: true
    length?: true
    width?: true
    height?: true
    insoleCapacity?: true
  }

  export type ShippingPackageMinAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingPackageMaxAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingPackageCountAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    weightUnit?: true
    length?: true
    width?: true
    height?: true
    dimensionUnit?: true
    insoleCapacity?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingPackage to aggregate.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingPackages
    **/
    _count?: true | ShippingPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingPackageMaxAggregateInputType
  }

  export type GetShippingPackageAggregateType<T extends ShippingPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingPackage[P]>
      : GetScalarType<T[P], AggregateShippingPackage[P]>
  }




  export type ShippingPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingPackageWhereInput
    orderBy?: ShippingPackageOrderByWithAggregationInput | ShippingPackageOrderByWithAggregationInput[]
    by: ShippingPackageScalarFieldEnum[] | ShippingPackageScalarFieldEnum
    having?: ShippingPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingPackageCountAggregateInputType | true
    _avg?: ShippingPackageAvgAggregateInputType
    _sum?: ShippingPackageSumAggregateInputType
    _min?: ShippingPackageMinAggregateInputType
    _max?: ShippingPackageMaxAggregateInputType
  }

  export type ShippingPackageGroupByOutputType = {
    id: string
    name: string
    weight: number
    weightUnit: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: ShippingPackageCountAggregateOutputType | null
    _avg: ShippingPackageAvgAggregateOutputType | null
    _sum: ShippingPackageSumAggregateOutputType | null
    _min: ShippingPackageMinAggregateOutputType | null
    _max: ShippingPackageMaxAggregateOutputType | null
  }

  type GetShippingPackageGroupByPayload<T extends ShippingPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingPackageGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingPackageGroupByOutputType[P]>
        }
      >
    >


  export type ShippingPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    weightUnit?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    dimensionUnit?: boolean
    insoleCapacity?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingPackage"]>

  export type ShippingPackageSelectScalar = {
    id?: boolean
    name?: boolean
    weight?: boolean
    weightUnit?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    dimensionUnit?: boolean
    insoleCapacity?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ShippingPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $ShippingPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingPackage"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weight: number
      weightUnit: $Enums.WeightUnit
      length: number
      width: number
      height: number
      dimensionUnit: $Enums.DimensionUnit
      insoleCapacity: number
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingPackage"]>
    composites: {}
  }


  type ShippingPackageGetPayload<S extends boolean | null | undefined | ShippingPackageDefaultArgs> = $Result.GetResult<Prisma.$ShippingPackagePayload, S>

  type ShippingPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShippingPackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShippingPackageCountAggregateInputType | true
    }

  export interface ShippingPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingPackage'], meta: { name: 'ShippingPackage' } }
    /**
     * Find zero or one ShippingPackage that matches the filter.
     * @param {ShippingPackageFindUniqueArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingPackageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageFindUniqueArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShippingPackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShippingPackageFindUniqueOrThrowArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShippingPackageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShippingPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindFirstArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingPackageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindFirstArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShippingPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindFirstOrThrowArgs} args - Arguments to find a ShippingPackage
     * @example
     * // Get one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShippingPackageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShippingPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingPackages
     * const shippingPackages = await prisma.shippingPackage.findMany()
     * 
     * // Get first 10 ShippingPackages
     * const shippingPackages = await prisma.shippingPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingPackageWithIdOnly = await prisma.shippingPackage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingPackageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShippingPackage.
     * @param {ShippingPackageCreateArgs} args - Arguments to create a ShippingPackage.
     * @example
     * // Create one ShippingPackage
     * const ShippingPackage = await prisma.shippingPackage.create({
     *   data: {
     *     // ... data to create a ShippingPackage
     *   }
     * })
     * 
    **/
    create<T extends ShippingPackageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageCreateArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShippingPackages.
     * @param {ShippingPackageCreateManyArgs} args - Arguments to create many ShippingPackages.
     * @example
     * // Create many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShippingPackageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingPackages and returns the data saved in the database.
     * @param {ShippingPackageCreateManyAndReturnArgs} args - Arguments to create many ShippingPackages.
     * @example
     * // Create many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingPackages and only return the `id`
     * const shippingPackageWithIdOnly = await prisma.shippingPackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShippingPackageCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ShippingPackage.
     * @param {ShippingPackageDeleteArgs} args - Arguments to delete one ShippingPackage.
     * @example
     * // Delete one ShippingPackage
     * const ShippingPackage = await prisma.shippingPackage.delete({
     *   where: {
     *     // ... filter to delete one ShippingPackage
     *   }
     * })
     * 
    **/
    delete<T extends ShippingPackageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageDeleteArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShippingPackage.
     * @param {ShippingPackageUpdateArgs} args - Arguments to update one ShippingPackage.
     * @example
     * // Update one ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingPackageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpdateArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShippingPackages.
     * @param {ShippingPackageDeleteManyArgs} args - Arguments to filter ShippingPackages to delete.
     * @example
     * // Delete a few ShippingPackages
     * const { count } = await prisma.shippingPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingPackageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShippingPackageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingPackages
     * const shippingPackage = await prisma.shippingPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingPackageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingPackage.
     * @param {ShippingPackageUpsertArgs} args - Arguments to update or create a ShippingPackage.
     * @example
     * // Update or create a ShippingPackage
     * const shippingPackage = await prisma.shippingPackage.upsert({
     *   create: {
     *     // ... data to create a ShippingPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingPackage we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingPackageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShippingPackageUpsertArgs<ExtArgs>>
    ): Prisma__ShippingPackageClient<$Result.GetResult<Prisma.$ShippingPackagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShippingPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageCountArgs} args - Arguments to filter ShippingPackages to count.
     * @example
     * // Count the number of ShippingPackages
     * const count = await prisma.shippingPackage.count({
     *   where: {
     *     // ... the filter for the ShippingPackages we want to count
     *   }
     * })
    **/
    count<T extends ShippingPackageCountArgs>(
      args?: Subset<T, ShippingPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingPackageAggregateArgs>(args: Subset<T, ShippingPackageAggregateArgs>): Prisma.PrismaPromise<GetShippingPackageAggregateType<T>>

    /**
     * Group by ShippingPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingPackageGroupByArgs['orderBy'] }
        : { orderBy?: ShippingPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingPackage model
   */
  readonly fields: ShippingPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShippingPackage model
   */ 
  interface ShippingPackageFieldRefs {
    readonly id: FieldRef<"ShippingPackage", 'String'>
    readonly name: FieldRef<"ShippingPackage", 'String'>
    readonly weight: FieldRef<"ShippingPackage", 'Float'>
    readonly weightUnit: FieldRef<"ShippingPackage", 'WeightUnit'>
    readonly length: FieldRef<"ShippingPackage", 'Float'>
    readonly width: FieldRef<"ShippingPackage", 'Float'>
    readonly height: FieldRef<"ShippingPackage", 'Float'>
    readonly dimensionUnit: FieldRef<"ShippingPackage", 'DimensionUnit'>
    readonly insoleCapacity: FieldRef<"ShippingPackage", 'Int'>
    readonly companyId: FieldRef<"ShippingPackage", 'String'>
    readonly createdAt: FieldRef<"ShippingPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingPackage findUnique
   */
  export type ShippingPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage findUniqueOrThrow
   */
  export type ShippingPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage findFirst
   */
  export type ShippingPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingPackages.
     */
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage findFirstOrThrow
   */
  export type ShippingPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackage to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingPackages.
     */
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage findMany
   */
  export type ShippingPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter, which ShippingPackages to fetch.
     */
    where?: ShippingPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingPackages to fetch.
     */
    orderBy?: ShippingPackageOrderByWithRelationInput | ShippingPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingPackages.
     */
    cursor?: ShippingPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingPackages.
     */
    skip?: number
    distinct?: ShippingPackageScalarFieldEnum | ShippingPackageScalarFieldEnum[]
  }

  /**
   * ShippingPackage create
   */
  export type ShippingPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingPackage.
     */
    data: XOR<ShippingPackageCreateInput, ShippingPackageUncheckedCreateInput>
  }

  /**
   * ShippingPackage createMany
   */
  export type ShippingPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingPackages.
     */
    data: ShippingPackageCreateManyInput | ShippingPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingPackage createManyAndReturn
   */
  export type ShippingPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data used to create many ShippingPackages.
     */
    data: ShippingPackageCreateManyInput | ShippingPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingPackage update
   */
  export type ShippingPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingPackage.
     */
    data: XOR<ShippingPackageUpdateInput, ShippingPackageUncheckedUpdateInput>
    /**
     * Choose, which ShippingPackage to update.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage updateMany
   */
  export type ShippingPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingPackages.
     */
    data: XOR<ShippingPackageUpdateManyMutationInput, ShippingPackageUncheckedUpdateManyInput>
    /**
     * Filter which ShippingPackages to update
     */
    where?: ShippingPackageWhereInput
  }

  /**
   * ShippingPackage upsert
   */
  export type ShippingPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingPackage to update in case it exists.
     */
    where: ShippingPackageWhereUniqueInput
    /**
     * In case the ShippingPackage found by the `where` argument doesn't exist, create a new ShippingPackage with this data.
     */
    create: XOR<ShippingPackageCreateInput, ShippingPackageUncheckedCreateInput>
    /**
     * In case the ShippingPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingPackageUpdateInput, ShippingPackageUncheckedUpdateInput>
  }

  /**
   * ShippingPackage delete
   */
  export type ShippingPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
    /**
     * Filter which ShippingPackage to delete.
     */
    where: ShippingPackageWhereUniqueInput
  }

  /**
   * ShippingPackage deleteMany
   */
  export type ShippingPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingPackages to delete
     */
    where?: ShippingPackageWhereInput
  }

  /**
   * ShippingPackage without action
   */
  export type ShippingPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingPackage
     */
    select?: ShippingPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingPackageInclude<ExtArgs> | null
  }


  /**
   * Model Physician
   */

  export type AggregatePhysician = {
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  export type PhysicianMinAggregateOutputType = {
    id: string | null
    name: string | null
    npi: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicianMaxAggregateOutputType = {
    id: string | null
    name: string | null
    npi: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhysicianCountAggregateOutputType = {
    id: number
    name: number
    npi: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhysicianMinAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicianMaxAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhysicianCountAggregateInputType = {
    id?: true
    name?: true
    npi?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhysicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physician to aggregate.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Physicians
    **/
    _count?: true | PhysicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhysicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhysicianMaxAggregateInputType
  }

  export type GetPhysicianAggregateType<T extends PhysicianAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician[P]>
      : GetScalarType<T[P], AggregatePhysician[P]>
  }




  export type PhysicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhysicianWhereInput
    orderBy?: PhysicianOrderByWithAggregationInput | PhysicianOrderByWithAggregationInput[]
    by: PhysicianScalarFieldEnum[] | PhysicianScalarFieldEnum
    having?: PhysicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhysicianCountAggregateInputType | true
    _min?: PhysicianMinAggregateInputType
    _max?: PhysicianMaxAggregateInputType
  }

  export type PhysicianGroupByOutputType = {
    id: string
    name: string
    npi: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  type GetPhysicianGroupByPayload<T extends PhysicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhysicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhysicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
            : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
        }
      >
    >


  export type PhysicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    npi?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Physician$evaluationsArgs<ExtArgs>
    patient?: boolean | Physician$patientArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physician"]>

  export type PhysicianSelectScalar = {
    id?: boolean
    name?: boolean
    npi?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type PhysicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Physician$evaluationsArgs<ExtArgs>
    patient?: boolean | Physician$patientArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PhysicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Physician"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      npi: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["physician"]>
    composites: {}
  }


  type PhysicianGetPayload<S extends boolean | null | undefined | PhysicianDefaultArgs> = $Result.GetResult<Prisma.$PhysicianPayload, S>

  type PhysicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhysicianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhysicianCountAggregateInputType | true
    }

  export interface PhysicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Physician'], meta: { name: 'Physician' } }
    /**
     * Find zero or one Physician that matches the filter.
     * @param {PhysicianFindUniqueArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhysicianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianFindUniqueArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Physician that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhysicianFindUniqueOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhysicianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Physician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhysicianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindFirstArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Physician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhysicianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Physicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physicians
     * const physicians = await prisma.physician.findMany()
     * 
     * // Get first 10 Physicians
     * const physicians = await prisma.physician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physicianWithIdOnly = await prisma.physician.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhysicianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Physician.
     * @param {PhysicianCreateArgs} args - Arguments to create a Physician.
     * @example
     * // Create one Physician
     * const Physician = await prisma.physician.create({
     *   data: {
     *     // ... data to create a Physician
     *   }
     * })
     * 
    **/
    create<T extends PhysicianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianCreateArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Physicians.
     * @param {PhysicianCreateManyArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PhysicianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Physicians and returns the data saved in the database.
     * @param {PhysicianCreateManyAndReturnArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Physicians and only return the `id`
     * const physicianWithIdOnly = await prisma.physician.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PhysicianCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Physician.
     * @param {PhysicianDeleteArgs} args - Arguments to delete one Physician.
     * @example
     * // Delete one Physician
     * const Physician = await prisma.physician.delete({
     *   where: {
     *     // ... filter to delete one Physician
     *   }
     * })
     * 
    **/
    delete<T extends PhysicianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianDeleteArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Physician.
     * @param {PhysicianUpdateArgs} args - Arguments to update one Physician.
     * @example
     * // Update one Physician
     * const physician = await prisma.physician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhysicianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpdateArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Physicians.
     * @param {PhysicianDeleteManyArgs} args - Arguments to filter Physicians to delete.
     * @example
     * // Delete a few Physicians
     * const { count } = await prisma.physician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhysicianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhysicianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physicians
     * const physician = await prisma.physician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhysicianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Physician.
     * @param {PhysicianUpsertArgs} args - Arguments to update or create a Physician.
     * @example
     * // Update or create a Physician
     * const physician = await prisma.physician.upsert({
     *   create: {
     *     // ... data to create a Physician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician we want to update
     *   }
     * })
    **/
    upsert<T extends PhysicianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhysicianUpsertArgs<ExtArgs>>
    ): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianCountArgs} args - Arguments to filter Physicians to count.
     * @example
     * // Count the number of Physicians
     * const count = await prisma.physician.count({
     *   where: {
     *     // ... the filter for the Physicians we want to count
     *   }
     * })
    **/
    count<T extends PhysicianCountArgs>(
      args?: Subset<T, PhysicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhysicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhysicianAggregateArgs>(args: Subset<T, PhysicianAggregateArgs>): Prisma.PrismaPromise<GetPhysicianAggregateType<T>>

    /**
     * Group by Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhysicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhysicianGroupByArgs['orderBy'] }
        : { orderBy?: PhysicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhysicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Physician model
   */
  readonly fields: PhysicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Physician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhysicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Physician$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Physician$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    patient<T extends Physician$patientArgs<ExtArgs> = {}>(args?: Subset<T, Physician$patientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Physician model
   */ 
  interface PhysicianFieldRefs {
    readonly id: FieldRef<"Physician", 'String'>
    readonly name: FieldRef<"Physician", 'String'>
    readonly npi: FieldRef<"Physician", 'String'>
    readonly active: FieldRef<"Physician", 'Boolean'>
    readonly createdAt: FieldRef<"Physician", 'DateTime'>
    readonly updatedAt: FieldRef<"Physician", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Physician findUnique
   */
  export type PhysicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findUniqueOrThrow
   */
  export type PhysicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findFirst
   */
  export type PhysicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findFirstOrThrow
   */
  export type PhysicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findMany
   */
  export type PhysicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physicians to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician create
   */
  export type PhysicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Physician.
     */
    data: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
  }

  /**
   * Physician createMany
   */
  export type PhysicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Physician createManyAndReturn
   */
  export type PhysicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Physician update
   */
  export type PhysicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Physician.
     */
    data: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
    /**
     * Choose, which Physician to update.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician updateMany
   */
  export type PhysicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Physicians.
     */
    data: XOR<PhysicianUpdateManyMutationInput, PhysicianUncheckedUpdateManyInput>
    /**
     * Filter which Physicians to update
     */
    where?: PhysicianWhereInput
  }

  /**
   * Physician upsert
   */
  export type PhysicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Physician to update in case it exists.
     */
    where: PhysicianWhereUniqueInput
    /**
     * In case the Physician found by the `where` argument doesn't exist, create a new Physician with this data.
     */
    create: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
    /**
     * In case the Physician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
  }

  /**
   * Physician delete
   */
  export type PhysicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter which Physician to delete.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician deleteMany
   */
  export type PhysicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physicians to delete
     */
    where?: PhysicianWhereInput
  }

  /**
   * Physician.evaluations
   */
  export type Physician$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Physician.patient
   */
  export type Physician$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Physician without action
   */
  export type PhysicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    diabetic: boolean | null
    standard: $Enums.DiagnosisStandard | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    diabetic: boolean | null
    standard: $Enums.DiagnosisStandard | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    code: number
    description: number
    diabetic: number
    standard: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiagnosisMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    diabetic?: true
    standard?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: string
    code: string
    description: string
    diabetic: boolean
    standard: $Enums.DiagnosisStandard
    createdAt: Date
    updatedAt: Date
    _count: DiagnosisCountAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    diabetic?: boolean
    standard?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Diagnosis$evaluationsArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    diabetic?: boolean
    standard?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Diagnosis$evaluationsArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string
      diabetic: boolean
      standard: $Enums.DiagnosisStandard
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }


  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiagnosisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiagnosisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiagnosisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
    **/
    create<T extends DiagnosisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DiagnosisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
    **/
    delete<T extends DiagnosisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiagnosisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiagnosisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiagnosisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
    **/
    upsert<T extends DiagnosisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>
    ): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends Diagnosis$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Diagnosis model
   */ 
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'String'>
    readonly code: FieldRef<"Diagnosis", 'String'>
    readonly description: FieldRef<"Diagnosis", 'String'>
    readonly diabetic: FieldRef<"Diagnosis", 'Boolean'>
    readonly standard: FieldRef<"Diagnosis", 'DiagnosisStandard'>
    readonly createdAt: FieldRef<"Diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis.evaluations
   */
  export type Diagnosis$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model BillingCode
   */

  export type AggregateBillingCode = {
    _count: BillingCodeCountAggregateOutputType | null
    _min: BillingCodeMinAggregateOutputType | null
    _max: BillingCodeMaxAggregateOutputType | null
  }

  export type BillingCodeMinAggregateOutputType = {
    id: string | null
    summary: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingCodeMaxAggregateOutputType = {
    id: string | null
    summary: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingCodeCountAggregateOutputType = {
    id: number
    summary: number
    description: number
    justifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingCodeMinAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingCodeMaxAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingCodeCountAggregateInputType = {
    id?: true
    summary?: true
    description?: true
    justifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingCode to aggregate.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingCodes
    **/
    _count?: true | BillingCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingCodeMaxAggregateInputType
  }

  export type GetBillingCodeAggregateType<T extends BillingCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingCode[P]>
      : GetScalarType<T[P], AggregateBillingCode[P]>
  }




  export type BillingCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingCodeWhereInput
    orderBy?: BillingCodeOrderByWithAggregationInput | BillingCodeOrderByWithAggregationInput[]
    by: BillingCodeScalarFieldEnum[] | BillingCodeScalarFieldEnum
    having?: BillingCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingCodeCountAggregateInputType | true
    _min?: BillingCodeMinAggregateInputType
    _max?: BillingCodeMaxAggregateInputType
  }

  export type BillingCodeGroupByOutputType = {
    id: string
    summary: string | null
    description: string
    justifications: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BillingCodeCountAggregateOutputType | null
    _min: BillingCodeMinAggregateOutputType | null
    _max: BillingCodeMaxAggregateOutputType | null
  }

  type GetBillingCodeGroupByPayload<T extends BillingCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingCodeGroupByOutputType[P]>
            : GetScalarType<T[P], BillingCodeGroupByOutputType[P]>
        }
      >
    >


  export type BillingCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    summary?: boolean
    description?: boolean
    justifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingCode"]>

  export type BillingCodeSelectScalar = {
    id?: boolean
    summary?: boolean
    description?: boolean
    justifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }



  export type $BillingCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      summary: string | null
      description: string
      justifications: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingCode"]>
    composites: {}
  }


  type BillingCodeGetPayload<S extends boolean | null | undefined | BillingCodeDefaultArgs> = $Result.GetResult<Prisma.$BillingCodePayload, S>

  type BillingCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillingCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillingCodeCountAggregateInputType | true
    }

  export interface BillingCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingCode'], meta: { name: 'BillingCode' } }
    /**
     * Find zero or one BillingCode that matches the filter.
     * @param {BillingCodeFindUniqueArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillingCodeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeFindUniqueArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BillingCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillingCodeFindUniqueOrThrowArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillingCodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BillingCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindFirstArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillingCodeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindFirstArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BillingCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindFirstOrThrowArgs} args - Arguments to find a BillingCode
     * @example
     * // Get one BillingCode
     * const billingCode = await prisma.billingCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillingCodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BillingCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingCodes
     * const billingCodes = await prisma.billingCode.findMany()
     * 
     * // Get first 10 BillingCodes
     * const billingCodes = await prisma.billingCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingCodeWithIdOnly = await prisma.billingCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillingCodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BillingCode.
     * @param {BillingCodeCreateArgs} args - Arguments to create a BillingCode.
     * @example
     * // Create one BillingCode
     * const BillingCode = await prisma.billingCode.create({
     *   data: {
     *     // ... data to create a BillingCode
     *   }
     * })
     * 
    **/
    create<T extends BillingCodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeCreateArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BillingCodes.
     * @param {BillingCodeCreateManyArgs} args - Arguments to create many BillingCodes.
     * @example
     * // Create many BillingCodes
     * const billingCode = await prisma.billingCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends BillingCodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingCodes and returns the data saved in the database.
     * @param {BillingCodeCreateManyAndReturnArgs} args - Arguments to create many BillingCodes.
     * @example
     * // Create many BillingCodes
     * const billingCode = await prisma.billingCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingCodes and only return the `id`
     * const billingCodeWithIdOnly = await prisma.billingCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends BillingCodeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a BillingCode.
     * @param {BillingCodeDeleteArgs} args - Arguments to delete one BillingCode.
     * @example
     * // Delete one BillingCode
     * const BillingCode = await prisma.billingCode.delete({
     *   where: {
     *     // ... filter to delete one BillingCode
     *   }
     * })
     * 
    **/
    delete<T extends BillingCodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeDeleteArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BillingCode.
     * @param {BillingCodeUpdateArgs} args - Arguments to update one BillingCode.
     * @example
     * // Update one BillingCode
     * const billingCode = await prisma.billingCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillingCodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpdateArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BillingCodes.
     * @param {BillingCodeDeleteManyArgs} args - Arguments to filter BillingCodes to delete.
     * @example
     * // Delete a few BillingCodes
     * const { count } = await prisma.billingCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillingCodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingCodes
     * const billingCode = await prisma.billingCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillingCodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingCode.
     * @param {BillingCodeUpsertArgs} args - Arguments to update or create a BillingCode.
     * @example
     * // Update or create a BillingCode
     * const billingCode = await prisma.billingCode.upsert({
     *   create: {
     *     // ... data to create a BillingCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingCode we want to update
     *   }
     * })
    **/
    upsert<T extends BillingCodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillingCodeUpsertArgs<ExtArgs>>
    ): Prisma__BillingCodeClient<$Result.GetResult<Prisma.$BillingCodePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BillingCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeCountArgs} args - Arguments to filter BillingCodes to count.
     * @example
     * // Count the number of BillingCodes
     * const count = await prisma.billingCode.count({
     *   where: {
     *     // ... the filter for the BillingCodes we want to count
     *   }
     * })
    **/
    count<T extends BillingCodeCountArgs>(
      args?: Subset<T, BillingCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingCodeAggregateArgs>(args: Subset<T, BillingCodeAggregateArgs>): Prisma.PrismaPromise<GetBillingCodeAggregateType<T>>

    /**
     * Group by BillingCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingCodeGroupByArgs['orderBy'] }
        : { orderBy?: BillingCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingCode model
   */
  readonly fields: BillingCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BillingCode model
   */ 
  interface BillingCodeFieldRefs {
    readonly id: FieldRef<"BillingCode", 'String'>
    readonly summary: FieldRef<"BillingCode", 'String'>
    readonly description: FieldRef<"BillingCode", 'String'>
    readonly justifications: FieldRef<"BillingCode", 'Json'>
    readonly createdAt: FieldRef<"BillingCode", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingCode findUnique
   */
  export type BillingCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode findUniqueOrThrow
   */
  export type BillingCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode findFirst
   */
  export type BillingCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingCodes.
     */
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode findFirstOrThrow
   */
  export type BillingCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCode to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingCodes.
     */
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode findMany
   */
  export type BillingCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter, which BillingCodes to fetch.
     */
    where?: BillingCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingCodes to fetch.
     */
    orderBy?: BillingCodeOrderByWithRelationInput | BillingCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingCodes.
     */
    cursor?: BillingCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingCodes.
     */
    skip?: number
    distinct?: BillingCodeScalarFieldEnum | BillingCodeScalarFieldEnum[]
  }

  /**
   * BillingCode create
   */
  export type BillingCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data needed to create a BillingCode.
     */
    data: XOR<BillingCodeCreateInput, BillingCodeUncheckedCreateInput>
  }

  /**
   * BillingCode createMany
   */
  export type BillingCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingCodes.
     */
    data: BillingCodeCreateManyInput | BillingCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingCode createManyAndReturn
   */
  export type BillingCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data used to create many BillingCodes.
     */
    data: BillingCodeCreateManyInput | BillingCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingCode update
   */
  export type BillingCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The data needed to update a BillingCode.
     */
    data: XOR<BillingCodeUpdateInput, BillingCodeUncheckedUpdateInput>
    /**
     * Choose, which BillingCode to update.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode updateMany
   */
  export type BillingCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingCodes.
     */
    data: XOR<BillingCodeUpdateManyMutationInput, BillingCodeUncheckedUpdateManyInput>
    /**
     * Filter which BillingCodes to update
     */
    where?: BillingCodeWhereInput
  }

  /**
   * BillingCode upsert
   */
  export type BillingCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * The filter to search for the BillingCode to update in case it exists.
     */
    where: BillingCodeWhereUniqueInput
    /**
     * In case the BillingCode found by the `where` argument doesn't exist, create a new BillingCode with this data.
     */
    create: XOR<BillingCodeCreateInput, BillingCodeUncheckedCreateInput>
    /**
     * In case the BillingCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingCodeUpdateInput, BillingCodeUncheckedUpdateInput>
  }

  /**
   * BillingCode delete
   */
  export type BillingCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
    /**
     * Filter which BillingCode to delete.
     */
    where: BillingCodeWhereUniqueInput
  }

  /**
   * BillingCode deleteMany
   */
  export type BillingCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingCodes to delete
     */
    where?: BillingCodeWhereInput
  }

  /**
   * BillingCode without action
   */
  export type BillingCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingCode
     */
    select?: BillingCodeSelect<ExtArgs> | null
  }


  /**
   * Model DeviceType
   */

  export type AggregateDeviceType = {
    _count: DeviceTypeCountAggregateOutputType | null
    _min: DeviceTypeMinAggregateOutputType | null
    _max: DeviceTypeMaxAggregateOutputType | null
  }

  export type DeviceTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    diabetic: boolean | null
    custom: boolean | null
  }

  export type DeviceTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    diabetic: boolean | null
    custom: boolean | null
  }

  export type DeviceTypeCountAggregateOutputType = {
    id: number
    name: number
    diabetic: number
    custom: number
    _all: number
  }


  export type DeviceTypeMinAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
  }

  export type DeviceTypeMaxAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
  }

  export type DeviceTypeCountAggregateInputType = {
    id?: true
    name?: true
    diabetic?: true
    custom?: true
    _all?: true
  }

  export type DeviceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceType to aggregate.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTypes
    **/
    _count?: true | DeviceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTypeMaxAggregateInputType
  }

  export type GetDeviceTypeAggregateType<T extends DeviceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceType[P]>
      : GetScalarType<T[P], AggregateDeviceType[P]>
  }




  export type DeviceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTypeWhereInput
    orderBy?: DeviceTypeOrderByWithAggregationInput | DeviceTypeOrderByWithAggregationInput[]
    by: DeviceTypeScalarFieldEnum[] | DeviceTypeScalarFieldEnum
    having?: DeviceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTypeCountAggregateInputType | true
    _min?: DeviceTypeMinAggregateInputType
    _max?: DeviceTypeMaxAggregateInputType
  }

  export type DeviceTypeGroupByOutputType = {
    id: string
    name: string
    diabetic: boolean
    custom: boolean | null
    _count: DeviceTypeCountAggregateOutputType | null
    _min: DeviceTypeMinAggregateOutputType | null
    _max: DeviceTypeMaxAggregateOutputType | null
  }

  type GetDeviceTypeGroupByPayload<T extends DeviceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTypeGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    diabetic?: boolean
    custom?: boolean
    evaluations?: boolean | DeviceType$evaluationsArgs<ExtArgs>
    _count?: boolean | DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceType"]>

  export type DeviceTypeSelectScalar = {
    id?: boolean
    name?: boolean
    diabetic?: boolean
    custom?: boolean
  }


  export type DeviceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | DeviceType$evaluationsArgs<ExtArgs>
    _count?: boolean | DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DeviceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceType"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      diabetic: boolean
      custom: boolean | null
    }, ExtArgs["result"]["deviceType"]>
    composites: {}
  }


  type DeviceTypeGetPayload<S extends boolean | null | undefined | DeviceTypeDefaultArgs> = $Result.GetResult<Prisma.$DeviceTypePayload, S>

  type DeviceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceTypeCountAggregateInputType | true
    }

  export interface DeviceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceType'], meta: { name: 'DeviceType' } }
    /**
     * Find zero or one DeviceType that matches the filter.
     * @param {DeviceTypeFindUniqueArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DeviceType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceTypeFindUniqueOrThrowArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DeviceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindFirstArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindFirstArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DeviceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindFirstOrThrowArgs} args - Arguments to find a DeviceType
     * @example
     * // Get one DeviceType
     * const deviceType = await prisma.deviceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DeviceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTypes
     * const deviceTypes = await prisma.deviceType.findMany()
     * 
     * // Get first 10 DeviceTypes
     * const deviceTypes = await prisma.deviceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTypeWithIdOnly = await prisma.deviceType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DeviceType.
     * @param {DeviceTypeCreateArgs} args - Arguments to create a DeviceType.
     * @example
     * // Create one DeviceType
     * const DeviceType = await prisma.deviceType.create({
     *   data: {
     *     // ... data to create a DeviceType
     *   }
     * })
     * 
    **/
    create<T extends DeviceTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeCreateArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DeviceTypes.
     * @param {DeviceTypeCreateManyArgs} args - Arguments to create many DeviceTypes.
     * @example
     * // Create many DeviceTypes
     * const deviceType = await prisma.deviceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends DeviceTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTypes and returns the data saved in the database.
     * @param {DeviceTypeCreateManyAndReturnArgs} args - Arguments to create many DeviceTypes.
     * @example
     * // Create many DeviceTypes
     * const deviceType = await prisma.deviceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTypes and only return the `id`
     * const deviceTypeWithIdOnly = await prisma.deviceType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends DeviceTypeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a DeviceType.
     * @param {DeviceTypeDeleteArgs} args - Arguments to delete one DeviceType.
     * @example
     * // Delete one DeviceType
     * const DeviceType = await prisma.deviceType.delete({
     *   where: {
     *     // ... filter to delete one DeviceType
     *   }
     * })
     * 
    **/
    delete<T extends DeviceTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeDeleteArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DeviceType.
     * @param {DeviceTypeUpdateArgs} args - Arguments to update one DeviceType.
     * @example
     * // Update one DeviceType
     * const deviceType = await prisma.deviceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpdateArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DeviceTypes.
     * @param {DeviceTypeDeleteManyArgs} args - Arguments to filter DeviceTypes to delete.
     * @example
     * // Delete a few DeviceTypes
     * const { count } = await prisma.deviceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeviceTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTypes
     * const deviceType = await prisma.deviceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceType.
     * @param {DeviceTypeUpsertArgs} args - Arguments to update or create a DeviceType.
     * @example
     * // Update or create a DeviceType
     * const deviceType = await prisma.deviceType.upsert({
     *   create: {
     *     // ... data to create a DeviceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceType we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeviceTypeUpsertArgs<ExtArgs>>
    ): Prisma__DeviceTypeClient<$Result.GetResult<Prisma.$DeviceTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DeviceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeCountArgs} args - Arguments to filter DeviceTypes to count.
     * @example
     * // Count the number of DeviceTypes
     * const count = await prisma.deviceType.count({
     *   where: {
     *     // ... the filter for the DeviceTypes we want to count
     *   }
     * })
    **/
    count<T extends DeviceTypeCountArgs>(
      args?: Subset<T, DeviceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTypeAggregateArgs>(args: Subset<T, DeviceTypeAggregateArgs>): Prisma.PrismaPromise<GetDeviceTypeAggregateType<T>>

    /**
     * Group by DeviceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTypeGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceType model
   */
  readonly fields: DeviceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends DeviceType$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceType$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DeviceType model
   */ 
  interface DeviceTypeFieldRefs {
    readonly id: FieldRef<"DeviceType", 'String'>
    readonly name: FieldRef<"DeviceType", 'String'>
    readonly diabetic: FieldRef<"DeviceType", 'Boolean'>
    readonly custom: FieldRef<"DeviceType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DeviceType findUnique
   */
  export type DeviceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType findUniqueOrThrow
   */
  export type DeviceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType findFirst
   */
  export type DeviceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTypes.
     */
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType findFirstOrThrow
   */
  export type DeviceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceType to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTypes.
     */
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType findMany
   */
  export type DeviceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTypes to fetch.
     */
    where?: DeviceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTypes to fetch.
     */
    orderBy?: DeviceTypeOrderByWithRelationInput | DeviceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTypes.
     */
    cursor?: DeviceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTypes.
     */
    skip?: number
    distinct?: DeviceTypeScalarFieldEnum | DeviceTypeScalarFieldEnum[]
  }

  /**
   * DeviceType create
   */
  export type DeviceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceType.
     */
    data: XOR<DeviceTypeCreateInput, DeviceTypeUncheckedCreateInput>
  }

  /**
   * DeviceType createMany
   */
  export type DeviceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTypes.
     */
    data: DeviceTypeCreateManyInput | DeviceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceType createManyAndReturn
   */
  export type DeviceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data used to create many DeviceTypes.
     */
    data: DeviceTypeCreateManyInput | DeviceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceType update
   */
  export type DeviceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceType.
     */
    data: XOR<DeviceTypeUpdateInput, DeviceTypeUncheckedUpdateInput>
    /**
     * Choose, which DeviceType to update.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType updateMany
   */
  export type DeviceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTypes.
     */
    data: XOR<DeviceTypeUpdateManyMutationInput, DeviceTypeUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTypes to update
     */
    where?: DeviceTypeWhereInput
  }

  /**
   * DeviceType upsert
   */
  export type DeviceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceType to update in case it exists.
     */
    where: DeviceTypeWhereUniqueInput
    /**
     * In case the DeviceType found by the `where` argument doesn't exist, create a new DeviceType with this data.
     */
    create: XOR<DeviceTypeCreateInput, DeviceTypeUncheckedCreateInput>
    /**
     * In case the DeviceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTypeUpdateInput, DeviceTypeUncheckedUpdateInput>
  }

  /**
   * DeviceType delete
   */
  export type DeviceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
    /**
     * Filter which DeviceType to delete.
     */
    where: DeviceTypeWhereUniqueInput
  }

  /**
   * DeviceType deleteMany
   */
  export type DeviceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTypes to delete
     */
    where?: DeviceTypeWhereInput
  }

  /**
   * DeviceType.evaluations
   */
  export type DeviceType$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * DeviceType without action
   */
  export type DeviceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceType
     */
    select?: DeviceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTypeInclude<ExtArgs> | null
  }


  /**
   * Model VisitType
   */

  export type AggregateVisitType = {
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  export type VisitTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VisitTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type VisitTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type VisitTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type VisitTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type VisitTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type VisitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitType to aggregate.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitTypes
    **/
    _count?: true | VisitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitTypeMaxAggregateInputType
  }

  export type GetVisitTypeAggregateType<T extends VisitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitType[P]>
      : GetScalarType<T[P], AggregateVisitType[P]>
  }




  export type VisitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTypeWhereInput
    orderBy?: VisitTypeOrderByWithAggregationInput | VisitTypeOrderByWithAggregationInput[]
    by: VisitTypeScalarFieldEnum[] | VisitTypeScalarFieldEnum
    having?: VisitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitTypeCountAggregateInputType | true
    _min?: VisitTypeMinAggregateInputType
    _max?: VisitTypeMaxAggregateInputType
  }

  export type VisitTypeGroupByOutputType = {
    id: string
    name: string
    _count: VisitTypeCountAggregateOutputType | null
    _min: VisitTypeMinAggregateOutputType | null
    _max: VisitTypeMaxAggregateOutputType | null
  }

  type GetVisitTypeGroupByPayload<T extends VisitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VisitTypeGroupByOutputType[P]>
        }
      >
    >


  export type VisitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    evaluations?: boolean | VisitType$evaluationsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitType"]>

  export type VisitTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type VisitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | VisitType$evaluationsArgs<ExtArgs>
    _count?: boolean | VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VisitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitType"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["visitType"]>
    composites: {}
  }


  type VisitTypeGetPayload<S extends boolean | null | undefined | VisitTypeDefaultArgs> = $Result.GetResult<Prisma.$VisitTypePayload, S>

  type VisitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitTypeCountAggregateInputType | true
    }

  export interface VisitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitType'], meta: { name: 'VisitType' } }
    /**
     * Find zero or one VisitType that matches the filter.
     * @param {VisitTypeFindUniqueArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VisitTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VisitType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitTypeFindUniqueOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VisitTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VisitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VisitTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindFirstArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VisitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindFirstOrThrowArgs} args - Arguments to find a VisitType
     * @example
     * // Get one VisitType
     * const visitType = await prisma.visitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VisitTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VisitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitTypes
     * const visitTypes = await prisma.visitType.findMany()
     * 
     * // Get first 10 VisitTypes
     * const visitTypes = await prisma.visitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VisitTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VisitType.
     * @param {VisitTypeCreateArgs} args - Arguments to create a VisitType.
     * @example
     * // Create one VisitType
     * const VisitType = await prisma.visitType.create({
     *   data: {
     *     // ... data to create a VisitType
     *   }
     * })
     * 
    **/
    create<T extends VisitTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeCreateArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VisitTypes.
     * @param {VisitTypeCreateManyArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends VisitTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitTypes and returns the data saved in the database.
     * @param {VisitTypeCreateManyAndReturnArgs} args - Arguments to create many VisitTypes.
     * @example
     * // Create many VisitTypes
     * const visitType = await prisma.visitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitTypes and only return the `id`
     * const visitTypeWithIdOnly = await prisma.visitType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends VisitTypeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a VisitType.
     * @param {VisitTypeDeleteArgs} args - Arguments to delete one VisitType.
     * @example
     * // Delete one VisitType
     * const VisitType = await prisma.visitType.delete({
     *   where: {
     *     // ... filter to delete one VisitType
     *   }
     * })
     * 
    **/
    delete<T extends VisitTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeDeleteArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VisitType.
     * @param {VisitTypeUpdateArgs} args - Arguments to update one VisitType.
     * @example
     * // Update one VisitType
     * const visitType = await prisma.visitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VisitTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpdateArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VisitTypes.
     * @param {VisitTypeDeleteManyArgs} args - Arguments to filter VisitTypes to delete.
     * @example
     * // Delete a few VisitTypes
     * const { count } = await prisma.visitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VisitTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VisitTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitTypes
     * const visitType = await prisma.visitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VisitTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitType.
     * @param {VisitTypeUpsertArgs} args - Arguments to update or create a VisitType.
     * @example
     * // Update or create a VisitType
     * const visitType = await prisma.visitType.upsert({
     *   create: {
     *     // ... data to create a VisitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitType we want to update
     *   }
     * })
    **/
    upsert<T extends VisitTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VisitTypeUpsertArgs<ExtArgs>>
    ): Prisma__VisitTypeClient<$Result.GetResult<Prisma.$VisitTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VisitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeCountArgs} args - Arguments to filter VisitTypes to count.
     * @example
     * // Count the number of VisitTypes
     * const count = await prisma.visitType.count({
     *   where: {
     *     // ... the filter for the VisitTypes we want to count
     *   }
     * })
    **/
    count<T extends VisitTypeCountArgs>(
      args?: Subset<T, VisitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitTypeAggregateArgs>(args: Subset<T, VisitTypeAggregateArgs>): Prisma.PrismaPromise<GetVisitTypeAggregateType<T>>

    /**
     * Group by VisitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitTypeGroupByArgs['orderBy'] }
        : { orderBy?: VisitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitType model
   */
  readonly fields: VisitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    evaluations<T extends VisitType$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, VisitType$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VisitType model
   */ 
  interface VisitTypeFieldRefs {
    readonly id: FieldRef<"VisitType", 'String'>
    readonly name: FieldRef<"VisitType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisitType findUnique
   */
  export type VisitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findUniqueOrThrow
   */
  export type VisitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType findFirst
   */
  export type VisitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findFirstOrThrow
   */
  export type VisitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitType to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTypes.
     */
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType findMany
   */
  export type VisitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisitTypes to fetch.
     */
    where?: VisitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTypes to fetch.
     */
    orderBy?: VisitTypeOrderByWithRelationInput | VisitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitTypes.
     */
    cursor?: VisitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTypes.
     */
    skip?: number
    distinct?: VisitTypeScalarFieldEnum | VisitTypeScalarFieldEnum[]
  }

  /**
   * VisitType create
   */
  export type VisitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitType.
     */
    data: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
  }

  /**
   * VisitType createMany
   */
  export type VisitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType createManyAndReturn
   */
  export type VisitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data used to create many VisitTypes.
     */
    data: VisitTypeCreateManyInput | VisitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitType update
   */
  export type VisitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitType.
     */
    data: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
    /**
     * Choose, which VisitType to update.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType updateMany
   */
  export type VisitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitTypes.
     */
    data: XOR<VisitTypeUpdateManyMutationInput, VisitTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisitTypes to update
     */
    where?: VisitTypeWhereInput
  }

  /**
   * VisitType upsert
   */
  export type VisitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitType to update in case it exists.
     */
    where: VisitTypeWhereUniqueInput
    /**
     * In case the VisitType found by the `where` argument doesn't exist, create a new VisitType with this data.
     */
    create: XOR<VisitTypeCreateInput, VisitTypeUncheckedCreateInput>
    /**
     * In case the VisitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitTypeUpdateInput, VisitTypeUncheckedUpdateInput>
  }

  /**
   * VisitType delete
   */
  export type VisitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
    /**
     * Filter which VisitType to delete.
     */
    where: VisitTypeWhereUniqueInput
  }

  /**
   * VisitType deleteMany
   */
  export type VisitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTypes to delete
     */
    where?: VisitTypeWhereInput
  }

  /**
   * VisitType.evaluations
   */
  export type VisitType$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * VisitType without action
   */
  export type VisitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitType
     */
    select?: VisitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTypeInclude<ExtArgs> | null
  }


  /**
   * Model FormSchema
   */

  export type AggregateFormSchema = {
    _count: FormSchemaCountAggregateOutputType | null
    _min: FormSchemaMinAggregateOutputType | null
    _max: FormSchemaMaxAggregateOutputType | null
  }

  export type FormSchemaMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.FormSchemaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSchemaMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: $Enums.FormSchemaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSchemaCountAggregateOutputType = {
    id: number
    title: number
    type: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormSchemaMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSchemaMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSchemaCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormSchemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSchema to aggregate.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSchemas
    **/
    _count?: true | FormSchemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSchemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSchemaMaxAggregateInputType
  }

  export type GetFormSchemaAggregateType<T extends FormSchemaAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSchema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSchema[P]>
      : GetScalarType<T[P], AggregateFormSchema[P]>
  }




  export type FormSchemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSchemaWhereInput
    orderBy?: FormSchemaOrderByWithAggregationInput | FormSchemaOrderByWithAggregationInput[]
    by: FormSchemaScalarFieldEnum[] | FormSchemaScalarFieldEnum
    having?: FormSchemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSchemaCountAggregateInputType | true
    _min?: FormSchemaMinAggregateInputType
    _max?: FormSchemaMaxAggregateInputType
  }

  export type FormSchemaGroupByOutputType = {
    id: string
    title: string
    type: $Enums.FormSchemaType | null
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormSchemaCountAggregateOutputType | null
    _min: FormSchemaMinAggregateOutputType | null
    _max: FormSchemaMaxAggregateOutputType | null
  }

  type GetFormSchemaGroupByPayload<T extends FormSchemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSchemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSchemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSchemaGroupByOutputType[P]>
            : GetScalarType<T[P], FormSchemaGroupByOutputType[P]>
        }
      >
    >


  export type FormSchemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submissions?: boolean | FormSchema$submissionsArgs<ExtArgs>
    _count?: boolean | FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSchema"]>

  export type FormSchemaSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FormSchemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormSchema$submissionsArgs<ExtArgs>
    _count?: boolean | FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FormSchemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSchema"
    objects: {
      submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: $Enums.FormSchemaType | null
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formSchema"]>
    composites: {}
  }


  type FormSchemaGetPayload<S extends boolean | null | undefined | FormSchemaDefaultArgs> = $Result.GetResult<Prisma.$FormSchemaPayload, S>

  type FormSchemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSchemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSchemaCountAggregateInputType | true
    }

  export interface FormSchemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSchema'], meta: { name: 'FormSchema' } }
    /**
     * Find zero or one FormSchema that matches the filter.
     * @param {FormSchemaFindUniqueArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSchemaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormSchema that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSchemaFindUniqueOrThrowArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSchemaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormSchema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindFirstArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSchemaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindFirstArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormSchema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindFirstOrThrowArgs} args - Arguments to find a FormSchema
     * @example
     * // Get one FormSchema
     * const formSchema = await prisma.formSchema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSchemaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormSchemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSchemas
     * const formSchemas = await prisma.formSchema.findMany()
     * 
     * // Get first 10 FormSchemas
     * const formSchemas = await prisma.formSchema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSchemaWithIdOnly = await prisma.formSchema.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSchemaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormSchema.
     * @param {FormSchemaCreateArgs} args - Arguments to create a FormSchema.
     * @example
     * // Create one FormSchema
     * const FormSchema = await prisma.formSchema.create({
     *   data: {
     *     // ... data to create a FormSchema
     *   }
     * })
     * 
    **/
    create<T extends FormSchemaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaCreateArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormSchemas.
     * @param {FormSchemaCreateManyArgs} args - Arguments to create many FormSchemas.
     * @example
     * // Create many FormSchemas
     * const formSchema = await prisma.formSchema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormSchemaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSchemas and returns the data saved in the database.
     * @param {FormSchemaCreateManyAndReturnArgs} args - Arguments to create many FormSchemas.
     * @example
     * // Create many FormSchemas
     * const formSchema = await prisma.formSchema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSchemas and only return the `id`
     * const formSchemaWithIdOnly = await prisma.formSchema.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormSchemaCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormSchema.
     * @param {FormSchemaDeleteArgs} args - Arguments to delete one FormSchema.
     * @example
     * // Delete one FormSchema
     * const FormSchema = await prisma.formSchema.delete({
     *   where: {
     *     // ... filter to delete one FormSchema
     *   }
     * })
     * 
    **/
    delete<T extends FormSchemaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaDeleteArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormSchema.
     * @param {FormSchemaUpdateArgs} args - Arguments to update one FormSchema.
     * @example
     * // Update one FormSchema
     * const formSchema = await prisma.formSchema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSchemaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpdateArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormSchemas.
     * @param {FormSchemaDeleteManyArgs} args - Arguments to filter FormSchemas to delete.
     * @example
     * // Delete a few FormSchemas
     * const { count } = await prisma.formSchema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSchemaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSchemaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSchemas
     * const formSchema = await prisma.formSchema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSchemaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSchema.
     * @param {FormSchemaUpsertArgs} args - Arguments to update or create a FormSchema.
     * @example
     * // Update or create a FormSchema
     * const formSchema = await prisma.formSchema.upsert({
     *   create: {
     *     // ... data to create a FormSchema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSchema we want to update
     *   }
     * })
    **/
    upsert<T extends FormSchemaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSchemaUpsertArgs<ExtArgs>>
    ): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaCountArgs} args - Arguments to filter FormSchemas to count.
     * @example
     * // Count the number of FormSchemas
     * const count = await prisma.formSchema.count({
     *   where: {
     *     // ... the filter for the FormSchemas we want to count
     *   }
     * })
    **/
    count<T extends FormSchemaCountArgs>(
      args?: Subset<T, FormSchemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSchemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSchemaAggregateArgs>(args: Subset<T, FormSchemaAggregateArgs>): Prisma.PrismaPromise<GetFormSchemaAggregateType<T>>

    /**
     * Group by FormSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSchemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSchemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSchemaGroupByArgs['orderBy'] }
        : { orderBy?: FormSchemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSchemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSchemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSchema model
   */
  readonly fields: FormSchemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSchema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSchemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submissions<T extends FormSchema$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, FormSchema$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormSchema model
   */ 
  interface FormSchemaFieldRefs {
    readonly id: FieldRef<"FormSchema", 'String'>
    readonly title: FieldRef<"FormSchema", 'String'>
    readonly type: FieldRef<"FormSchema", 'FormSchemaType'>
    readonly data: FieldRef<"FormSchema", 'Json'>
    readonly createdAt: FieldRef<"FormSchema", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSchema", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSchema findUnique
   */
  export type FormSchemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema findUniqueOrThrow
   */
  export type FormSchemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema findFirst
   */
  export type FormSchemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSchemas.
     */
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema findFirstOrThrow
   */
  export type FormSchemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchema to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSchemas.
     */
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema findMany
   */
  export type FormSchemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter, which FormSchemas to fetch.
     */
    where?: FormSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSchemas to fetch.
     */
    orderBy?: FormSchemaOrderByWithRelationInput | FormSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSchemas.
     */
    cursor?: FormSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSchemas.
     */
    skip?: number
    distinct?: FormSchemaScalarFieldEnum | FormSchemaScalarFieldEnum[]
  }

  /**
   * FormSchema create
   */
  export type FormSchemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSchema.
     */
    data: XOR<FormSchemaCreateInput, FormSchemaUncheckedCreateInput>
  }

  /**
   * FormSchema createMany
   */
  export type FormSchemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSchemas.
     */
    data: FormSchemaCreateManyInput | FormSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSchema createManyAndReturn
   */
  export type FormSchemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data used to create many FormSchemas.
     */
    data: FormSchemaCreateManyInput | FormSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSchema update
   */
  export type FormSchemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSchema.
     */
    data: XOR<FormSchemaUpdateInput, FormSchemaUncheckedUpdateInput>
    /**
     * Choose, which FormSchema to update.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema updateMany
   */
  export type FormSchemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSchemas.
     */
    data: XOR<FormSchemaUpdateManyMutationInput, FormSchemaUncheckedUpdateManyInput>
    /**
     * Filter which FormSchemas to update
     */
    where?: FormSchemaWhereInput
  }

  /**
   * FormSchema upsert
   */
  export type FormSchemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSchema to update in case it exists.
     */
    where: FormSchemaWhereUniqueInput
    /**
     * In case the FormSchema found by the `where` argument doesn't exist, create a new FormSchema with this data.
     */
    create: XOR<FormSchemaCreateInput, FormSchemaUncheckedCreateInput>
    /**
     * In case the FormSchema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSchemaUpdateInput, FormSchemaUncheckedUpdateInput>
  }

  /**
   * FormSchema delete
   */
  export type FormSchemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
    /**
     * Filter which FormSchema to delete.
     */
    where: FormSchemaWhereUniqueInput
  }

  /**
   * FormSchema deleteMany
   */
  export type FormSchemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSchemas to delete
     */
    where?: FormSchemaWhereInput
  }

  /**
   * FormSchema.submissions
   */
  export type FormSchema$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSchema without action
   */
  export type FormSchemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSchema
     */
    select?: FormSchemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSchemaInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    schemaId: string | null
    workbenchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    schemaId: string | null
    workbenchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    schemaId: number
    workbenchId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    schemaId?: true
    workbenchId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    schemaId: string
    workbenchId: string
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    workbenchId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schema?: boolean | FormSchemaDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    schemaId?: boolean
    workbenchId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | FormSchemaDefaultArgs<ExtArgs>
    workbench?: boolean | WorkbenchDefaultArgs<ExtArgs>
  }


  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      schema: Prisma.$FormSchemaPayload<ExtArgs>
      workbench: Prisma.$WorkbenchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schemaId: string
      workbenchId: string
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }


  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSubmissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSubmissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSubmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
    **/
    create<T extends FormSubmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormSubmissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSubmissions and returns the data saved in the database.
     * @param {FormSubmissionCreateManyAndReturnArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSubmissions and only return the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormSubmissionCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
    **/
    delete<T extends FormSubmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSubmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSubmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSubmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends FormSubmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    schema<T extends FormSchemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormSchemaDefaultArgs<ExtArgs>>): Prisma__FormSchemaClient<$Result.GetResult<Prisma.$FormSchemaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    workbench<T extends WorkbenchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkbenchDefaultArgs<ExtArgs>>): Prisma__WorkbenchClient<$Result.GetResult<Prisma.$WorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormSubmission model
   */ 
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly schemaId: FieldRef<"FormSubmission", 'String'>
    readonly workbenchId: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly createdAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission createManyAndReturn
   */
  export type FormSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model FormTemplate
   */

  export type AggregateFormTemplate = {
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  export type FormTemplateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormTemplateCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormTemplateMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormTemplateCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplate to aggregate.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormTemplates
    **/
    _count?: true | FormTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTemplateMaxAggregateInputType
  }

  export type GetFormTemplateAggregateType<T extends FormTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTemplate[P]>
      : GetScalarType<T[P], AggregateFormTemplate[P]>
  }




  export type FormTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithAggregationInput | FormTemplateOrderByWithAggregationInput[]
    by: FormTemplateScalarFieldEnum[] | FormTemplateScalarFieldEnum
    having?: FormTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTemplateCountAggregateInputType | true
    _min?: FormTemplateMinAggregateInputType
    _max?: FormTemplateMaxAggregateInputType
  }

  export type FormTemplateGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  type GetFormTemplateGroupByPayload<T extends FormTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FormTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }



  export type $FormTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formTemplate"]>
    composites: {}
  }


  type FormTemplateGetPayload<S extends boolean | null | undefined | FormTemplateDefaultArgs> = $Result.GetResult<Prisma.$FormTemplatePayload, S>

  type FormTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormTemplateCountAggregateInputType | true
    }

  export interface FormTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormTemplate'], meta: { name: 'FormTemplate' } }
    /**
     * Find zero or one FormTemplate that matches the filter.
     * @param {FormTemplateFindUniqueArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormTemplateFindUniqueOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany()
     * 
     * // Get first 10 FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormTemplate.
     * @param {FormTemplateCreateArgs} args - Arguments to create a FormTemplate.
     * @example
     * // Create one FormTemplate
     * const FormTemplate = await prisma.formTemplate.create({
     *   data: {
     *     // ... data to create a FormTemplate
     *   }
     * })
     * 
    **/
    create<T extends FormTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateCreateArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormTemplates.
     * @param {FormTemplateCreateManyArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FormTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTemplates and returns the data saved in the database.
     * @param {FormTemplateCreateManyAndReturnArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTemplates and only return the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FormTemplateCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FormTemplate.
     * @param {FormTemplateDeleteArgs} args - Arguments to delete one FormTemplate.
     * @example
     * // Delete one FormTemplate
     * const FormTemplate = await prisma.formTemplate.delete({
     *   where: {
     *     // ... filter to delete one FormTemplate
     *   }
     * })
     * 
    **/
    delete<T extends FormTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateDeleteArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormTemplate.
     * @param {FormTemplateUpdateArgs} args - Arguments to update one FormTemplate.
     * @example
     * // Update one FormTemplate
     * const formTemplate = await prisma.formTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpdateArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormTemplates.
     * @param {FormTemplateDeleteManyArgs} args - Arguments to filter FormTemplates to delete.
     * @example
     * // Delete a few FormTemplates
     * const { count } = await prisma.formTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTemplates
     * const formTemplate = await prisma.formTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormTemplate.
     * @param {FormTemplateUpsertArgs} args - Arguments to update or create a FormTemplate.
     * @example
     * // Update or create a FormTemplate
     * const formTemplate = await prisma.formTemplate.upsert({
     *   create: {
     *     // ... data to create a FormTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends FormTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormTemplateUpsertArgs<ExtArgs>>
    ): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateCountArgs} args - Arguments to filter FormTemplates to count.
     * @example
     * // Count the number of FormTemplates
     * const count = await prisma.formTemplate.count({
     *   where: {
     *     // ... the filter for the FormTemplates we want to count
     *   }
     * })
    **/
    count<T extends FormTemplateCountArgs>(
      args?: Subset<T, FormTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTemplateAggregateArgs>(args: Subset<T, FormTemplateAggregateArgs>): Prisma.PrismaPromise<GetFormTemplateAggregateType<T>>

    /**
     * Group by FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FormTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormTemplate model
   */
  readonly fields: FormTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormTemplate model
   */ 
  interface FormTemplateFieldRefs {
    readonly id: FieldRef<"FormTemplate", 'String'>
    readonly userId: FieldRef<"FormTemplate", 'String'>
    readonly title: FieldRef<"FormTemplate", 'String'>
    readonly description: FieldRef<"FormTemplate", 'String'>
    readonly data: FieldRef<"FormTemplate", 'Json'>
    readonly createdAt: FieldRef<"FormTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"FormTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormTemplate findUnique
   */
  export type FormTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findUniqueOrThrow
   */
  export type FormTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findFirst
   */
  export type FormTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findFirstOrThrow
   */
  export type FormTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findMany
   */
  export type FormTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter, which FormTemplates to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate create
   */
  export type FormTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a FormTemplate.
     */
    data: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
  }

  /**
   * FormTemplate createMany
   */
  export type FormTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate createManyAndReturn
   */
  export type FormTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate update
   */
  export type FormTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a FormTemplate.
     */
    data: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
    /**
     * Choose, which FormTemplate to update.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate updateMany
   */
  export type FormTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormTemplates.
     */
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FormTemplates to update
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate upsert
   */
  export type FormTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the FormTemplate to update in case it exists.
     */
    where: FormTemplateWhereUniqueInput
    /**
     * In case the FormTemplate found by the `where` argument doesn't exist, create a new FormTemplate with this data.
     */
    create: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
    /**
     * In case the FormTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
  }

  /**
   * FormTemplate delete
   */
  export type FormTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Filter which FormTemplate to delete.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate deleteMany
   */
  export type FormTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplates to delete
     */
    where?: FormTemplateWhereInput
  }

  /**
   * FormTemplate without action
   */
  export type FormTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
  }


  /**
   * Model CatalogProduct
   */

  export type AggregateCatalogProduct = {
    _count: CatalogProductCountAggregateOutputType | null
    _avg: CatalogProductAvgAggregateOutputType | null
    _sum: CatalogProductSumAggregateOutputType | null
    _min: CatalogProductMinAggregateOutputType | null
    _max: CatalogProductMaxAggregateOutputType | null
  }

  export type CatalogProductAvgAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductSumAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    price: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductAvgAggregateInputType = {
    price?: true
  }

  export type CatalogProductSumAggregateInputType = {
    price?: true
  }

  export type CatalogProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProduct to aggregate.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProducts
    **/
    _count?: true | CatalogProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductMaxAggregateInputType
  }

  export type GetCatalogProductAggregateType<T extends CatalogProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProduct[P]>
      : GetScalarType<T[P], AggregateCatalogProduct[P]>
  }




  export type CatalogProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithAggregationInput | CatalogProductOrderByWithAggregationInput[]
    by: CatalogProductScalarFieldEnum[] | CatalogProductScalarFieldEnum
    having?: CatalogProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductCountAggregateInputType | true
    _avg?: CatalogProductAvgAggregateInputType
    _sum?: CatalogProductSumAggregateInputType
    _min?: CatalogProductMinAggregateInputType
    _max?: CatalogProductMaxAggregateInputType
  }

  export type CatalogProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    price: number | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductCountAggregateOutputType | null
    _avg: CatalogProductAvgAggregateOutputType | null
    _sum: CatalogProductSumAggregateOutputType | null
    _min: CatalogProductMinAggregateOutputType | null
    _max: CatalogProductMaxAggregateOutputType | null
  }

  type GetCatalogProductGroupByPayload<T extends CatalogProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attributes?: boolean | CatalogProduct$attributesArgs<ExtArgs>
    variants?: boolean | CatalogProduct$variantsArgs<ExtArgs>
    categories?: boolean | CatalogProduct$categoriesArgs<ExtArgs>
    vendors?: boolean | CatalogProduct$vendorsArgs<ExtArgs>
    _count?: boolean | CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProduct"]>

  export type CatalogProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | CatalogProduct$attributesArgs<ExtArgs>
    variants?: boolean | CatalogProduct$variantsArgs<ExtArgs>
    categories?: boolean | CatalogProduct$categoriesArgs<ExtArgs>
    vendors?: boolean | CatalogProduct$vendorsArgs<ExtArgs>
    _count?: boolean | CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProduct"
    objects: {
      attributes: Prisma.$CatalogProductAttributePayload<ExtArgs>[]
      variants: Prisma.$CatalogProductVariantPayload<ExtArgs>[]
      categories: Prisma.$CatalogCategoryPayload<ExtArgs>[]
      vendors: Prisma.$CatalogVendorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      price: number | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProduct"]>
    composites: {}
  }


  type CatalogProductGetPayload<S extends boolean | null | undefined | CatalogProductDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductPayload, S>

  type CatalogProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductCountAggregateInputType | true
    }

  export interface CatalogProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProduct'], meta: { name: 'CatalogProduct' } }
    /**
     * Find zero or one CatalogProduct that matches the filter.
     * @param {CatalogProductFindUniqueArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductFindUniqueOrThrowArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindFirstArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindFirstOrThrowArgs} args - Arguments to find a CatalogProduct
     * @example
     * // Get one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProducts
     * const catalogProducts = await prisma.catalogProduct.findMany()
     * 
     * // Get first 10 CatalogProducts
     * const catalogProducts = await prisma.catalogProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductWithIdOnly = await prisma.catalogProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProduct.
     * @param {CatalogProductCreateArgs} args - Arguments to create a CatalogProduct.
     * @example
     * // Create one CatalogProduct
     * const CatalogProduct = await prisma.catalogProduct.create({
     *   data: {
     *     // ... data to create a CatalogProduct
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProducts.
     * @param {CatalogProductCreateManyArgs} args - Arguments to create many CatalogProducts.
     * @example
     * // Create many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProducts and returns the data saved in the database.
     * @param {CatalogProductCreateManyAndReturnArgs} args - Arguments to create many CatalogProducts.
     * @example
     * // Create many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProducts and only return the `id`
     * const catalogProductWithIdOnly = await prisma.catalogProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProduct.
     * @param {CatalogProductDeleteArgs} args - Arguments to delete one CatalogProduct.
     * @example
     * // Delete one CatalogProduct
     * const CatalogProduct = await prisma.catalogProduct.delete({
     *   where: {
     *     // ... filter to delete one CatalogProduct
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProduct.
     * @param {CatalogProductUpdateArgs} args - Arguments to update one CatalogProduct.
     * @example
     * // Update one CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProducts.
     * @param {CatalogProductDeleteManyArgs} args - Arguments to filter CatalogProducts to delete.
     * @example
     * // Delete a few CatalogProducts
     * const { count } = await prisma.catalogProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProducts
     * const catalogProduct = await prisma.catalogProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProduct.
     * @param {CatalogProductUpsertArgs} args - Arguments to update or create a CatalogProduct.
     * @example
     * // Update or create a CatalogProduct
     * const catalogProduct = await prisma.catalogProduct.upsert({
     *   create: {
     *     // ... data to create a CatalogProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductCountArgs} args - Arguments to filter CatalogProducts to count.
     * @example
     * // Count the number of CatalogProducts
     * const count = await prisma.catalogProduct.count({
     *   where: {
     *     // ... the filter for the CatalogProducts we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductCountArgs>(
      args?: Subset<T, CatalogProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductAggregateArgs>(args: Subset<T, CatalogProductAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductAggregateType<T>>

    /**
     * Group by CatalogProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProduct model
   */
  readonly fields: CatalogProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    attributes<T extends CatalogProduct$attributesArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findMany'> | Null>;

    variants<T extends CatalogProduct$variantsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findMany'> | Null>;

    categories<T extends CatalogProduct$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    vendors<T extends CatalogProduct$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProduct$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProduct model
   */ 
  interface CatalogProductFieldRefs {
    readonly id: FieldRef<"CatalogProduct", 'String'>
    readonly name: FieldRef<"CatalogProduct", 'String'>
    readonly description: FieldRef<"CatalogProduct", 'String'>
    readonly image: FieldRef<"CatalogProduct", 'String'>
    readonly price: FieldRef<"CatalogProduct", 'Float'>
    readonly active: FieldRef<"CatalogProduct", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProduct findUnique
   */
  export type CatalogProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct findUniqueOrThrow
   */
  export type CatalogProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct findFirst
   */
  export type CatalogProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProducts.
     */
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct findFirstOrThrow
   */
  export type CatalogProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProduct to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProducts.
     */
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct findMany
   */
  export type CatalogProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProducts to fetch.
     */
    where?: CatalogProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProducts to fetch.
     */
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProducts.
     */
    cursor?: CatalogProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProducts.
     */
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogProduct create
   */
  export type CatalogProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProduct.
     */
    data: XOR<CatalogProductCreateInput, CatalogProductUncheckedCreateInput>
  }

  /**
   * CatalogProduct createMany
   */
  export type CatalogProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProducts.
     */
    data: CatalogProductCreateManyInput | CatalogProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProduct createManyAndReturn
   */
  export type CatalogProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProducts.
     */
    data: CatalogProductCreateManyInput | CatalogProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProduct update
   */
  export type CatalogProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProduct.
     */
    data: XOR<CatalogProductUpdateInput, CatalogProductUncheckedUpdateInput>
    /**
     * Choose, which CatalogProduct to update.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct updateMany
   */
  export type CatalogProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProducts.
     */
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProducts to update
     */
    where?: CatalogProductWhereInput
  }

  /**
   * CatalogProduct upsert
   */
  export type CatalogProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProduct to update in case it exists.
     */
    where: CatalogProductWhereUniqueInput
    /**
     * In case the CatalogProduct found by the `where` argument doesn't exist, create a new CatalogProduct with this data.
     */
    create: XOR<CatalogProductCreateInput, CatalogProductUncheckedCreateInput>
    /**
     * In case the CatalogProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductUpdateInput, CatalogProductUncheckedUpdateInput>
  }

  /**
   * CatalogProduct delete
   */
  export type CatalogProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    /**
     * Filter which CatalogProduct to delete.
     */
    where: CatalogProductWhereUniqueInput
  }

  /**
   * CatalogProduct deleteMany
   */
  export type CatalogProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProducts to delete
     */
    where?: CatalogProductWhereInput
  }

  /**
   * CatalogProduct.attributes
   */
  export type CatalogProduct$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    where?: CatalogProductAttributeWhereInput
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    cursor?: CatalogProductAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProduct.variants
   */
  export type CatalogProduct$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    where?: CatalogProductVariantWhereInput
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    cursor?: CatalogProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProduct.categories
   */
  export type CatalogProduct$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    where?: CatalogCategoryWhereInput
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    cursor?: CatalogCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogProduct.vendors
   */
  export type CatalogProduct$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    where?: CatalogVendorWhereInput
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    cursor?: CatalogVendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogProduct without action
   */
  export type CatalogProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
  }


  /**
   * Model CatalogProductAttribute
   */

  export type AggregateCatalogProductAttribute = {
    _count: CatalogProductAttributeCountAggregateOutputType | null
    _min: CatalogProductAttributeMinAggregateOutputType | null
    _max: CatalogProductAttributeMaxAggregateOutputType | null
  }

  export type CatalogProductAttributeMinAggregateOutputType = {
    id: string | null
    productId: string | null
    type: $Enums.ProductAttributeType | null
    value: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductAttributeMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    type: $Enums.ProductAttributeType | null
    value: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductAttributeCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    value: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductAttributeMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductAttributeMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductAttributeCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    value?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductAttribute to aggregate.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProductAttributes
    **/
    _count?: true | CatalogProductAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductAttributeMaxAggregateInputType
  }

  export type GetCatalogProductAttributeAggregateType<T extends CatalogProductAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProductAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProductAttribute[P]>
      : GetScalarType<T[P], AggregateCatalogProductAttribute[P]>
  }




  export type CatalogProductAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductAttributeWhereInput
    orderBy?: CatalogProductAttributeOrderByWithAggregationInput | CatalogProductAttributeOrderByWithAggregationInput[]
    by: CatalogProductAttributeScalarFieldEnum[] | CatalogProductAttributeScalarFieldEnum
    having?: CatalogProductAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductAttributeCountAggregateInputType | true
    _min?: CatalogProductAttributeMinAggregateInputType
    _max?: CatalogProductAttributeMaxAggregateInputType
  }

  export type CatalogProductAttributeGroupByOutputType = {
    id: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductAttributeCountAggregateOutputType | null
    _min: CatalogProductAttributeMinAggregateOutputType | null
    _max: CatalogProductAttributeMaxAggregateOutputType | null
  }

  type GetCatalogProductAttributeGroupByPayload<T extends CatalogProductAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductAttributeGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProductAttribute"]>

  export type CatalogProductAttributeSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }


  export type $CatalogProductAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProductAttribute"
    objects: {
      product: Prisma.$CatalogProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      type: $Enums.ProductAttributeType
      value: string
      description: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProductAttribute"]>
    composites: {}
  }


  type CatalogProductAttributeGetPayload<S extends boolean | null | undefined | CatalogProductAttributeDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductAttributePayload, S>

  type CatalogProductAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductAttributeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductAttributeCountAggregateInputType | true
    }

  export interface CatalogProductAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProductAttribute'], meta: { name: 'CatalogProductAttribute' } }
    /**
     * Find zero or one CatalogProductAttribute that matches the filter.
     * @param {CatalogProductAttributeFindUniqueArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductAttributeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProductAttribute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductAttributeFindUniqueOrThrowArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProductAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindFirstArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductAttributeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProductAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindFirstOrThrowArgs} args - Arguments to find a CatalogProductAttribute
     * @example
     * // Get one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProductAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProductAttributes
     * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany()
     * 
     * // Get first 10 CatalogProductAttributes
     * const catalogProductAttributes = await prisma.catalogProductAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductAttributeWithIdOnly = await prisma.catalogProductAttribute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductAttributeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProductAttribute.
     * @param {CatalogProductAttributeCreateArgs} args - Arguments to create a CatalogProductAttribute.
     * @example
     * // Create one CatalogProductAttribute
     * const CatalogProductAttribute = await prisma.catalogProductAttribute.create({
     *   data: {
     *     // ... data to create a CatalogProductAttribute
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductAttributeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProductAttributes.
     * @param {CatalogProductAttributeCreateManyArgs} args - Arguments to create many CatalogProductAttributes.
     * @example
     * // Create many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductAttributeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProductAttributes and returns the data saved in the database.
     * @param {CatalogProductAttributeCreateManyAndReturnArgs} args - Arguments to create many CatalogProductAttributes.
     * @example
     * // Create many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProductAttributes and only return the `id`
     * const catalogProductAttributeWithIdOnly = await prisma.catalogProductAttribute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProductAttribute.
     * @param {CatalogProductAttributeDeleteArgs} args - Arguments to delete one CatalogProductAttribute.
     * @example
     * // Delete one CatalogProductAttribute
     * const CatalogProductAttribute = await prisma.catalogProductAttribute.delete({
     *   where: {
     *     // ... filter to delete one CatalogProductAttribute
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductAttributeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProductAttribute.
     * @param {CatalogProductAttributeUpdateArgs} args - Arguments to update one CatalogProductAttribute.
     * @example
     * // Update one CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductAttributeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProductAttributes.
     * @param {CatalogProductAttributeDeleteManyArgs} args - Arguments to filter CatalogProductAttributes to delete.
     * @example
     * // Delete a few CatalogProductAttributes
     * const { count } = await prisma.catalogProductAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductAttributeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductAttributeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProductAttributes
     * const catalogProductAttribute = await prisma.catalogProductAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductAttributeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProductAttribute.
     * @param {CatalogProductAttributeUpsertArgs} args - Arguments to update or create a CatalogProductAttribute.
     * @example
     * // Update or create a CatalogProductAttribute
     * const catalogProductAttribute = await prisma.catalogProductAttribute.upsert({
     *   create: {
     *     // ... data to create a CatalogProductAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProductAttribute we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductAttributeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductAttributeUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductAttributeClient<$Result.GetResult<Prisma.$CatalogProductAttributePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeCountArgs} args - Arguments to filter CatalogProductAttributes to count.
     * @example
     * // Count the number of CatalogProductAttributes
     * const count = await prisma.catalogProductAttribute.count({
     *   where: {
     *     // ... the filter for the CatalogProductAttributes we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductAttributeCountArgs>(
      args?: Subset<T, CatalogProductAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductAttributeAggregateArgs>(args: Subset<T, CatalogProductAttributeAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductAttributeAggregateType<T>>

    /**
     * Group by CatalogProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductAttributeGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProductAttribute model
   */
  readonly fields: CatalogProductAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProductAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends CatalogProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProductDefaultArgs<ExtArgs>>): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProductAttribute model
   */ 
  interface CatalogProductAttributeFieldRefs {
    readonly id: FieldRef<"CatalogProductAttribute", 'String'>
    readonly productId: FieldRef<"CatalogProductAttribute", 'String'>
    readonly type: FieldRef<"CatalogProductAttribute", 'ProductAttributeType'>
    readonly value: FieldRef<"CatalogProductAttribute", 'String'>
    readonly description: FieldRef<"CatalogProductAttribute", 'String'>
    readonly active: FieldRef<"CatalogProductAttribute", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProductAttribute", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProductAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProductAttribute findUnique
   */
  export type CatalogProductAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute findUniqueOrThrow
   */
  export type CatalogProductAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute findFirst
   */
  export type CatalogProductAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductAttributes.
     */
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute findFirstOrThrow
   */
  export type CatalogProductAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttribute to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductAttributes.
     */
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute findMany
   */
  export type CatalogProductAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductAttributes to fetch.
     */
    where?: CatalogProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductAttributes to fetch.
     */
    orderBy?: CatalogProductAttributeOrderByWithRelationInput | CatalogProductAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProductAttributes.
     */
    cursor?: CatalogProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductAttributes.
     */
    skip?: number
    distinct?: CatalogProductAttributeScalarFieldEnum | CatalogProductAttributeScalarFieldEnum[]
  }

  /**
   * CatalogProductAttribute create
   */
  export type CatalogProductAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProductAttribute.
     */
    data: XOR<CatalogProductAttributeCreateInput, CatalogProductAttributeUncheckedCreateInput>
  }

  /**
   * CatalogProductAttribute createMany
   */
  export type CatalogProductAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProductAttributes.
     */
    data: CatalogProductAttributeCreateManyInput | CatalogProductAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductAttribute createManyAndReturn
   */
  export type CatalogProductAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProductAttributes.
     */
    data: CatalogProductAttributeCreateManyInput | CatalogProductAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductAttribute update
   */
  export type CatalogProductAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProductAttribute.
     */
    data: XOR<CatalogProductAttributeUpdateInput, CatalogProductAttributeUncheckedUpdateInput>
    /**
     * Choose, which CatalogProductAttribute to update.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute updateMany
   */
  export type CatalogProductAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProductAttributes.
     */
    data: XOR<CatalogProductAttributeUpdateManyMutationInput, CatalogProductAttributeUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProductAttributes to update
     */
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductAttribute upsert
   */
  export type CatalogProductAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProductAttribute to update in case it exists.
     */
    where: CatalogProductAttributeWhereUniqueInput
    /**
     * In case the CatalogProductAttribute found by the `where` argument doesn't exist, create a new CatalogProductAttribute with this data.
     */
    create: XOR<CatalogProductAttributeCreateInput, CatalogProductAttributeUncheckedCreateInput>
    /**
     * In case the CatalogProductAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductAttributeUpdateInput, CatalogProductAttributeUncheckedUpdateInput>
  }

  /**
   * CatalogProductAttribute delete
   */
  export type CatalogProductAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
    /**
     * Filter which CatalogProductAttribute to delete.
     */
    where: CatalogProductAttributeWhereUniqueInput
  }

  /**
   * CatalogProductAttribute deleteMany
   */
  export type CatalogProductAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductAttributes to delete
     */
    where?: CatalogProductAttributeWhereInput
  }

  /**
   * CatalogProductAttribute without action
   */
  export type CatalogProductAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductAttribute
     */
    select?: CatalogProductAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductAttributeInclude<ExtArgs> | null
  }


  /**
   * Model CatalogProductVariant
   */

  export type AggregateCatalogProductVariant = {
    _count: CatalogProductVariantCountAggregateOutputType | null
    _avg: CatalogProductVariantAvgAggregateOutputType | null
    _sum: CatalogProductVariantSumAggregateOutputType | null
    _min: CatalogProductVariantMinAggregateOutputType | null
    _max: CatalogProductVariantMaxAggregateOutputType | null
  }

  export type CatalogProductVariantAvgAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductVariantSumAggregateOutputType = {
    price: number | null
  }

  export type CatalogProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    name: number
    description: number
    caption: number
    barcode: number
    price: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogProductVariantAvgAggregateInputType = {
    price?: true
  }

  export type CatalogProductVariantSumAggregateInputType = {
    price?: true
  }

  export type CatalogProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    caption?: true
    barcode?: true
    price?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductVariant to aggregate.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogProductVariants
    **/
    _count?: true | CatalogProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogProductVariantMaxAggregateInputType
  }

  export type GetCatalogProductVariantAggregateType<T extends CatalogProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogProductVariant[P]>
      : GetScalarType<T[P], AggregateCatalogProductVariant[P]>
  }




  export type CatalogProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogProductVariantWhereInput
    orderBy?: CatalogProductVariantOrderByWithAggregationInput | CatalogProductVariantOrderByWithAggregationInput[]
    by: CatalogProductVariantScalarFieldEnum[] | CatalogProductVariantScalarFieldEnum
    having?: CatalogProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogProductVariantCountAggregateInputType | true
    _avg?: CatalogProductVariantAvgAggregateInputType
    _sum?: CatalogProductVariantSumAggregateInputType
    _min?: CatalogProductVariantMinAggregateInputType
    _max?: CatalogProductVariantMaxAggregateInputType
  }

  export type CatalogProductVariantGroupByOutputType = {
    id: string
    productId: string
    sku: string
    name: string
    description: string | null
    caption: string | null
    barcode: string | null
    price: number | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogProductVariantCountAggregateOutputType | null
    _avg: CatalogProductVariantAvgAggregateOutputType | null
    _sum: CatalogProductVariantSumAggregateOutputType | null
    _min: CatalogProductVariantMinAggregateOutputType | null
    _max: CatalogProductVariantMaxAggregateOutputType | null
  }

  type GetCatalogProductVariantGroupByPayload<T extends CatalogProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type CatalogProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    caption?: boolean
    barcode?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogProductVariant"]>

  export type CatalogProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    caption?: boolean
    barcode?: boolean
    price?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CatalogProductDefaultArgs<ExtArgs>
  }


  export type $CatalogProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogProductVariant"
    objects: {
      product: Prisma.$CatalogProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      name: string
      description: string | null
      caption: string | null
      barcode: string | null
      price: number | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogProductVariant"]>
    composites: {}
  }


  type CatalogProductVariantGetPayload<S extends boolean | null | undefined | CatalogProductVariantDefaultArgs> = $Result.GetResult<Prisma.$CatalogProductVariantPayload, S>

  type CatalogProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogProductVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogProductVariantCountAggregateInputType | true
    }

  export interface CatalogProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogProductVariant'], meta: { name: 'CatalogProductVariant' } }
    /**
     * Find zero or one CatalogProductVariant that matches the filter.
     * @param {CatalogProductVariantFindUniqueArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogProductVariantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogProductVariant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogProductVariantFindUniqueOrThrowArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindFirstArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogProductVariantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindFirstOrThrowArgs} args - Arguments to find a CatalogProductVariant
     * @example
     * // Get one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogProductVariants
     * const catalogProductVariants = await prisma.catalogProductVariant.findMany()
     * 
     * // Get first 10 CatalogProductVariants
     * const catalogProductVariants = await prisma.catalogProductVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogProductVariantWithIdOnly = await prisma.catalogProductVariant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogProductVariantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogProductVariant.
     * @param {CatalogProductVariantCreateArgs} args - Arguments to create a CatalogProductVariant.
     * @example
     * // Create one CatalogProductVariant
     * const CatalogProductVariant = await prisma.catalogProductVariant.create({
     *   data: {
     *     // ... data to create a CatalogProductVariant
     *   }
     * })
     * 
    **/
    create<T extends CatalogProductVariantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantCreateArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogProductVariants.
     * @param {CatalogProductVariantCreateManyArgs} args - Arguments to create many CatalogProductVariants.
     * @example
     * // Create many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogProductVariantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogProductVariants and returns the data saved in the database.
     * @param {CatalogProductVariantCreateManyAndReturnArgs} args - Arguments to create many CatalogProductVariants.
     * @example
     * // Create many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogProductVariants and only return the `id`
     * const catalogProductVariantWithIdOnly = await prisma.catalogProductVariant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogProductVariant.
     * @param {CatalogProductVariantDeleteArgs} args - Arguments to delete one CatalogProductVariant.
     * @example
     * // Delete one CatalogProductVariant
     * const CatalogProductVariant = await prisma.catalogProductVariant.delete({
     *   where: {
     *     // ... filter to delete one CatalogProductVariant
     *   }
     * })
     * 
    **/
    delete<T extends CatalogProductVariantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantDeleteArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogProductVariant.
     * @param {CatalogProductVariantUpdateArgs} args - Arguments to update one CatalogProductVariant.
     * @example
     * // Update one CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogProductVariantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpdateArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogProductVariants.
     * @param {CatalogProductVariantDeleteManyArgs} args - Arguments to filter CatalogProductVariants to delete.
     * @example
     * // Delete a few CatalogProductVariants
     * const { count } = await prisma.catalogProductVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogProductVariantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogProductVariantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogProductVariants
     * const catalogProductVariant = await prisma.catalogProductVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogProductVariantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogProductVariant.
     * @param {CatalogProductVariantUpsertArgs} args - Arguments to update or create a CatalogProductVariant.
     * @example
     * // Update or create a CatalogProductVariant
     * const catalogProductVariant = await prisma.catalogProductVariant.upsert({
     *   create: {
     *     // ... data to create a CatalogProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogProductVariant we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogProductVariantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogProductVariantUpsertArgs<ExtArgs>>
    ): Prisma__CatalogProductVariantClient<$Result.GetResult<Prisma.$CatalogProductVariantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantCountArgs} args - Arguments to filter CatalogProductVariants to count.
     * @example
     * // Count the number of CatalogProductVariants
     * const count = await prisma.catalogProductVariant.count({
     *   where: {
     *     // ... the filter for the CatalogProductVariants we want to count
     *   }
     * })
    **/
    count<T extends CatalogProductVariantCountArgs>(
      args?: Subset<T, CatalogProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogProductVariantAggregateArgs>(args: Subset<T, CatalogProductVariantAggregateArgs>): Prisma.PrismaPromise<GetCatalogProductVariantAggregateType<T>>

    /**
     * Group by CatalogProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: CatalogProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogProductVariant model
   */
  readonly fields: CatalogProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends CatalogProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogProductDefaultArgs<ExtArgs>>): Prisma__CatalogProductClient<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogProductVariant model
   */ 
  interface CatalogProductVariantFieldRefs {
    readonly id: FieldRef<"CatalogProductVariant", 'String'>
    readonly productId: FieldRef<"CatalogProductVariant", 'String'>
    readonly sku: FieldRef<"CatalogProductVariant", 'String'>
    readonly name: FieldRef<"CatalogProductVariant", 'String'>
    readonly description: FieldRef<"CatalogProductVariant", 'String'>
    readonly caption: FieldRef<"CatalogProductVariant", 'String'>
    readonly barcode: FieldRef<"CatalogProductVariant", 'String'>
    readonly price: FieldRef<"CatalogProductVariant", 'Float'>
    readonly active: FieldRef<"CatalogProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogProductVariant findUnique
   */
  export type CatalogProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant findUniqueOrThrow
   */
  export type CatalogProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant findFirst
   */
  export type CatalogProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductVariants.
     */
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant findFirstOrThrow
   */
  export type CatalogProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariant to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogProductVariants.
     */
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant findMany
   */
  export type CatalogProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which CatalogProductVariants to fetch.
     */
    where?: CatalogProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogProductVariants to fetch.
     */
    orderBy?: CatalogProductVariantOrderByWithRelationInput | CatalogProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogProductVariants.
     */
    cursor?: CatalogProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogProductVariants.
     */
    skip?: number
    distinct?: CatalogProductVariantScalarFieldEnum | CatalogProductVariantScalarFieldEnum[]
  }

  /**
   * CatalogProductVariant create
   */
  export type CatalogProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogProductVariant.
     */
    data: XOR<CatalogProductVariantCreateInput, CatalogProductVariantUncheckedCreateInput>
  }

  /**
   * CatalogProductVariant createMany
   */
  export type CatalogProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogProductVariants.
     */
    data: CatalogProductVariantCreateManyInput | CatalogProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductVariant createManyAndReturn
   */
  export type CatalogProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogProductVariants.
     */
    data: CatalogProductVariantCreateManyInput | CatalogProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogProductVariant update
   */
  export type CatalogProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogProductVariant.
     */
    data: XOR<CatalogProductVariantUpdateInput, CatalogProductVariantUncheckedUpdateInput>
    /**
     * Choose, which CatalogProductVariant to update.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant updateMany
   */
  export type CatalogProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogProductVariants.
     */
    data: XOR<CatalogProductVariantUpdateManyMutationInput, CatalogProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which CatalogProductVariants to update
     */
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductVariant upsert
   */
  export type CatalogProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogProductVariant to update in case it exists.
     */
    where: CatalogProductVariantWhereUniqueInput
    /**
     * In case the CatalogProductVariant found by the `where` argument doesn't exist, create a new CatalogProductVariant with this data.
     */
    create: XOR<CatalogProductVariantCreateInput, CatalogProductVariantUncheckedCreateInput>
    /**
     * In case the CatalogProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogProductVariantUpdateInput, CatalogProductVariantUncheckedUpdateInput>
  }

  /**
   * CatalogProductVariant delete
   */
  export type CatalogProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
    /**
     * Filter which CatalogProductVariant to delete.
     */
    where: CatalogProductVariantWhereUniqueInput
  }

  /**
   * CatalogProductVariant deleteMany
   */
  export type CatalogProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogProductVariants to delete
     */
    where?: CatalogProductVariantWhereInput
  }

  /**
   * CatalogProductVariant without action
   */
  export type CatalogProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProductVariant
     */
    select?: CatalogProductVariantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model CatalogCategory
   */

  export type AggregateCatalogCategory = {
    _count: CatalogCategoryCountAggregateOutputType | null
    _min: CatalogCategoryMinAggregateOutputType | null
    _max: CatalogCategoryMaxAggregateOutputType | null
  }

  export type CatalogCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCategoryCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogCategoryMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCategoryCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCategory to aggregate.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogCategories
    **/
    _count?: true | CatalogCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogCategoryMaxAggregateInputType
  }

  export type GetCatalogCategoryAggregateType<T extends CatalogCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogCategory[P]>
      : GetScalarType<T[P], AggregateCatalogCategory[P]>
  }




  export type CatalogCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogCategoryWhereInput
    orderBy?: CatalogCategoryOrderByWithAggregationInput | CatalogCategoryOrderByWithAggregationInput[]
    by: CatalogCategoryScalarFieldEnum[] | CatalogCategoryScalarFieldEnum
    having?: CatalogCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogCategoryCountAggregateInputType | true
    _min?: CatalogCategoryMinAggregateInputType
    _max?: CatalogCategoryMaxAggregateInputType
  }

  export type CatalogCategoryGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogCategoryCountAggregateOutputType | null
    _min: CatalogCategoryMinAggregateOutputType | null
    _max: CatalogCategoryMaxAggregateOutputType | null
  }

  type GetCatalogCategoryGroupByPayload<T extends CatalogCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CatalogCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | CatalogCategory$productsArgs<ExtArgs>
    _count?: boolean | CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogCategory"]>

  export type CatalogCategorySelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogCategory$productsArgs<ExtArgs>
    _count?: boolean | CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogCategory"
    objects: {
      products: Prisma.$CatalogProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogCategory"]>
    composites: {}
  }


  type CatalogCategoryGetPayload<S extends boolean | null | undefined | CatalogCategoryDefaultArgs> = $Result.GetResult<Prisma.$CatalogCategoryPayload, S>

  type CatalogCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogCategoryCountAggregateInputType | true
    }

  export interface CatalogCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogCategory'], meta: { name: 'CatalogCategory' } }
    /**
     * Find zero or one CatalogCategory that matches the filter.
     * @param {CatalogCategoryFindUniqueArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogCategoryFindUniqueOrThrowArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindFirstArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindFirstOrThrowArgs} args - Arguments to find a CatalogCategory
     * @example
     * // Get one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogCategories
     * const catalogCategories = await prisma.catalogCategory.findMany()
     * 
     * // Get first 10 CatalogCategories
     * const catalogCategories = await prisma.catalogCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogCategoryWithIdOnly = await prisma.catalogCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogCategory.
     * @param {CatalogCategoryCreateArgs} args - Arguments to create a CatalogCategory.
     * @example
     * // Create one CatalogCategory
     * const CatalogCategory = await prisma.catalogCategory.create({
     *   data: {
     *     // ... data to create a CatalogCategory
     *   }
     * })
     * 
    **/
    create<T extends CatalogCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryCreateArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogCategories.
     * @param {CatalogCategoryCreateManyArgs} args - Arguments to create many CatalogCategories.
     * @example
     * // Create many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogCategories and returns the data saved in the database.
     * @param {CatalogCategoryCreateManyAndReturnArgs} args - Arguments to create many CatalogCategories.
     * @example
     * // Create many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogCategories and only return the `id`
     * const catalogCategoryWithIdOnly = await prisma.catalogCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogCategoryCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogCategory.
     * @param {CatalogCategoryDeleteArgs} args - Arguments to delete one CatalogCategory.
     * @example
     * // Delete one CatalogCategory
     * const CatalogCategory = await prisma.catalogCategory.delete({
     *   where: {
     *     // ... filter to delete one CatalogCategory
     *   }
     * })
     * 
    **/
    delete<T extends CatalogCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryDeleteArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogCategory.
     * @param {CatalogCategoryUpdateArgs} args - Arguments to update one CatalogCategory.
     * @example
     * // Update one CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpdateArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogCategories.
     * @param {CatalogCategoryDeleteManyArgs} args - Arguments to filter CatalogCategories to delete.
     * @example
     * // Delete a few CatalogCategories
     * const { count } = await prisma.catalogCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogCategories
     * const catalogCategory = await prisma.catalogCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogCategory.
     * @param {CatalogCategoryUpsertArgs} args - Arguments to update or create a CatalogCategory.
     * @example
     * // Update or create a CatalogCategory
     * const catalogCategory = await prisma.catalogCategory.upsert({
     *   create: {
     *     // ... data to create a CatalogCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogCategory we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogCategoryUpsertArgs<ExtArgs>>
    ): Prisma__CatalogCategoryClient<$Result.GetResult<Prisma.$CatalogCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryCountArgs} args - Arguments to filter CatalogCategories to count.
     * @example
     * // Count the number of CatalogCategories
     * const count = await prisma.catalogCategory.count({
     *   where: {
     *     // ... the filter for the CatalogCategories we want to count
     *   }
     * })
    **/
    count<T extends CatalogCategoryCountArgs>(
      args?: Subset<T, CatalogCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogCategoryAggregateArgs>(args: Subset<T, CatalogCategoryAggregateArgs>): Prisma.PrismaPromise<GetCatalogCategoryAggregateType<T>>

    /**
     * Group by CatalogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CatalogCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogCategory model
   */
  readonly fields: CatalogCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends CatalogCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogCategory model
   */ 
  interface CatalogCategoryFieldRefs {
    readonly id: FieldRef<"CatalogCategory", 'String'>
    readonly name: FieldRef<"CatalogCategory", 'String'>
    readonly parentId: FieldRef<"CatalogCategory", 'String'>
    readonly active: FieldRef<"CatalogCategory", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogCategory findUnique
   */
  export type CatalogCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory findUniqueOrThrow
   */
  export type CatalogCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory findFirst
   */
  export type CatalogCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCategories.
     */
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory findFirstOrThrow
   */
  export type CatalogCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategory to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogCategories.
     */
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory findMany
   */
  export type CatalogCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CatalogCategories to fetch.
     */
    where?: CatalogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogCategories to fetch.
     */
    orderBy?: CatalogCategoryOrderByWithRelationInput | CatalogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogCategories.
     */
    cursor?: CatalogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogCategories.
     */
    skip?: number
    distinct?: CatalogCategoryScalarFieldEnum | CatalogCategoryScalarFieldEnum[]
  }

  /**
   * CatalogCategory create
   */
  export type CatalogCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogCategory.
     */
    data: XOR<CatalogCategoryCreateInput, CatalogCategoryUncheckedCreateInput>
  }

  /**
   * CatalogCategory createMany
   */
  export type CatalogCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogCategories.
     */
    data: CatalogCategoryCreateManyInput | CatalogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogCategory createManyAndReturn
   */
  export type CatalogCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogCategories.
     */
    data: CatalogCategoryCreateManyInput | CatalogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogCategory update
   */
  export type CatalogCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogCategory.
     */
    data: XOR<CatalogCategoryUpdateInput, CatalogCategoryUncheckedUpdateInput>
    /**
     * Choose, which CatalogCategory to update.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory updateMany
   */
  export type CatalogCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogCategories.
     */
    data: XOR<CatalogCategoryUpdateManyMutationInput, CatalogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CatalogCategories to update
     */
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogCategory upsert
   */
  export type CatalogCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogCategory to update in case it exists.
     */
    where: CatalogCategoryWhereUniqueInput
    /**
     * In case the CatalogCategory found by the `where` argument doesn't exist, create a new CatalogCategory with this data.
     */
    create: XOR<CatalogCategoryCreateInput, CatalogCategoryUncheckedCreateInput>
    /**
     * In case the CatalogCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogCategoryUpdateInput, CatalogCategoryUncheckedUpdateInput>
  }

  /**
   * CatalogCategory delete
   */
  export type CatalogCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
    /**
     * Filter which CatalogCategory to delete.
     */
    where: CatalogCategoryWhereUniqueInput
  }

  /**
   * CatalogCategory deleteMany
   */
  export type CatalogCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogCategories to delete
     */
    where?: CatalogCategoryWhereInput
  }

  /**
   * CatalogCategory.products
   */
  export type CatalogCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    cursor?: CatalogProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogCategory without action
   */
  export type CatalogCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCategory
     */
    select?: CatalogCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CatalogVendor
   */

  export type AggregateCatalogVendor = {
    _count: CatalogVendorCountAggregateOutputType | null
    _min: CatalogVendorMinAggregateOutputType | null
    _max: CatalogVendorMaxAggregateOutputType | null
  }

  export type CatalogVendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogVendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogVendorCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogVendorMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogVendorMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogVendorCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogVendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVendor to aggregate.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogVendors
    **/
    _count?: true | CatalogVendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogVendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogVendorMaxAggregateInputType
  }

  export type GetCatalogVendorAggregateType<T extends CatalogVendorAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogVendor[P]>
      : GetScalarType<T[P], AggregateCatalogVendor[P]>
  }




  export type CatalogVendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogVendorWhereInput
    orderBy?: CatalogVendorOrderByWithAggregationInput | CatalogVendorOrderByWithAggregationInput[]
    by: CatalogVendorScalarFieldEnum[] | CatalogVendorScalarFieldEnum
    having?: CatalogVendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogVendorCountAggregateInputType | true
    _min?: CatalogVendorMinAggregateInputType
    _max?: CatalogVendorMaxAggregateInputType
  }

  export type CatalogVendorGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CatalogVendorCountAggregateOutputType | null
    _min: CatalogVendorMinAggregateOutputType | null
    _max: CatalogVendorMaxAggregateOutputType | null
  }

  type GetCatalogVendorGroupByPayload<T extends CatalogVendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogVendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogVendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogVendorGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogVendorGroupByOutputType[P]>
        }
      >
    >


  export type CatalogVendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | CatalogVendor$productsArgs<ExtArgs>
    _count?: boolean | CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogVendor"]>

  export type CatalogVendorSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CatalogVendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CatalogVendor$productsArgs<ExtArgs>
    _count?: boolean | CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CatalogVendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogVendor"
    objects: {
      products: Prisma.$CatalogProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalogVendor"]>
    composites: {}
  }


  type CatalogVendorGetPayload<S extends boolean | null | undefined | CatalogVendorDefaultArgs> = $Result.GetResult<Prisma.$CatalogVendorPayload, S>

  type CatalogVendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogVendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogVendorCountAggregateInputType | true
    }

  export interface CatalogVendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogVendor'], meta: { name: 'CatalogVendor' } }
    /**
     * Find zero or one CatalogVendor that matches the filter.
     * @param {CatalogVendorFindUniqueArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogVendorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogVendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogVendorFindUniqueOrThrowArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogVendorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogVendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindFirstArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogVendorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogVendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindFirstOrThrowArgs} args - Arguments to find a CatalogVendor
     * @example
     * // Get one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogVendorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogVendors
     * const catalogVendors = await prisma.catalogVendor.findMany()
     * 
     * // Get first 10 CatalogVendors
     * const catalogVendors = await prisma.catalogVendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogVendorWithIdOnly = await prisma.catalogVendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogVendorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogVendor.
     * @param {CatalogVendorCreateArgs} args - Arguments to create a CatalogVendor.
     * @example
     * // Create one CatalogVendor
     * const CatalogVendor = await prisma.catalogVendor.create({
     *   data: {
     *     // ... data to create a CatalogVendor
     *   }
     * })
     * 
    **/
    create<T extends CatalogVendorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorCreateArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogVendors.
     * @param {CatalogVendorCreateManyArgs} args - Arguments to create many CatalogVendors.
     * @example
     * // Create many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CatalogVendorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogVendors and returns the data saved in the database.
     * @param {CatalogVendorCreateManyAndReturnArgs} args - Arguments to create many CatalogVendors.
     * @example
     * // Create many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogVendors and only return the `id`
     * const catalogVendorWithIdOnly = await prisma.catalogVendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CatalogVendorCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CatalogVendor.
     * @param {CatalogVendorDeleteArgs} args - Arguments to delete one CatalogVendor.
     * @example
     * // Delete one CatalogVendor
     * const CatalogVendor = await prisma.catalogVendor.delete({
     *   where: {
     *     // ... filter to delete one CatalogVendor
     *   }
     * })
     * 
    **/
    delete<T extends CatalogVendorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorDeleteArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogVendor.
     * @param {CatalogVendorUpdateArgs} args - Arguments to update one CatalogVendor.
     * @example
     * // Update one CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogVendorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpdateArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogVendors.
     * @param {CatalogVendorDeleteManyArgs} args - Arguments to filter CatalogVendors to delete.
     * @example
     * // Delete a few CatalogVendors
     * const { count } = await prisma.catalogVendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogVendorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVendorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogVendors
     * const catalogVendor = await prisma.catalogVendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogVendorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogVendor.
     * @param {CatalogVendorUpsertArgs} args - Arguments to update or create a CatalogVendor.
     * @example
     * // Update or create a CatalogVendor
     * const catalogVendor = await prisma.catalogVendor.upsert({
     *   create: {
     *     // ... data to create a CatalogVendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogVendor we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogVendorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVendorUpsertArgs<ExtArgs>>
    ): Prisma__CatalogVendorClient<$Result.GetResult<Prisma.$CatalogVendorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorCountArgs} args - Arguments to filter CatalogVendors to count.
     * @example
     * // Count the number of CatalogVendors
     * const count = await prisma.catalogVendor.count({
     *   where: {
     *     // ... the filter for the CatalogVendors we want to count
     *   }
     * })
    **/
    count<T extends CatalogVendorCountArgs>(
      args?: Subset<T, CatalogVendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogVendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogVendorAggregateArgs>(args: Subset<T, CatalogVendorAggregateArgs>): Prisma.PrismaPromise<GetCatalogVendorAggregateType<T>>

    /**
     * Group by CatalogVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogVendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogVendorGroupByArgs['orderBy'] }
        : { orderBy?: CatalogVendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogVendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogVendor model
   */
  readonly fields: CatalogVendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogVendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogVendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends CatalogVendor$productsArgs<ExtArgs> = {}>(args?: Subset<T, CatalogVendor$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogVendor model
   */ 
  interface CatalogVendorFieldRefs {
    readonly id: FieldRef<"CatalogVendor", 'String'>
    readonly name: FieldRef<"CatalogVendor", 'String'>
    readonly description: FieldRef<"CatalogVendor", 'String'>
    readonly image: FieldRef<"CatalogVendor", 'String'>
    readonly active: FieldRef<"CatalogVendor", 'Boolean'>
    readonly createdAt: FieldRef<"CatalogVendor", 'DateTime'>
    readonly updatedAt: FieldRef<"CatalogVendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogVendor findUnique
   */
  export type CatalogVendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor findUniqueOrThrow
   */
  export type CatalogVendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor findFirst
   */
  export type CatalogVendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVendors.
     */
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor findFirstOrThrow
   */
  export type CatalogVendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendor to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVendors.
     */
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor findMany
   */
  export type CatalogVendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogVendors to fetch.
     */
    where?: CatalogVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVendors to fetch.
     */
    orderBy?: CatalogVendorOrderByWithRelationInput | CatalogVendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogVendors.
     */
    cursor?: CatalogVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVendors.
     */
    skip?: number
    distinct?: CatalogVendorScalarFieldEnum | CatalogVendorScalarFieldEnum[]
  }

  /**
   * CatalogVendor create
   */
  export type CatalogVendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogVendor.
     */
    data: XOR<CatalogVendorCreateInput, CatalogVendorUncheckedCreateInput>
  }

  /**
   * CatalogVendor createMany
   */
  export type CatalogVendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogVendors.
     */
    data: CatalogVendorCreateManyInput | CatalogVendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogVendor createManyAndReturn
   */
  export type CatalogVendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data used to create many CatalogVendors.
     */
    data: CatalogVendorCreateManyInput | CatalogVendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogVendor update
   */
  export type CatalogVendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogVendor.
     */
    data: XOR<CatalogVendorUpdateInput, CatalogVendorUncheckedUpdateInput>
    /**
     * Choose, which CatalogVendor to update.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor updateMany
   */
  export type CatalogVendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogVendors.
     */
    data: XOR<CatalogVendorUpdateManyMutationInput, CatalogVendorUncheckedUpdateManyInput>
    /**
     * Filter which CatalogVendors to update
     */
    where?: CatalogVendorWhereInput
  }

  /**
   * CatalogVendor upsert
   */
  export type CatalogVendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogVendor to update in case it exists.
     */
    where: CatalogVendorWhereUniqueInput
    /**
     * In case the CatalogVendor found by the `where` argument doesn't exist, create a new CatalogVendor with this data.
     */
    create: XOR<CatalogVendorCreateInput, CatalogVendorUncheckedCreateInput>
    /**
     * In case the CatalogVendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogVendorUpdateInput, CatalogVendorUncheckedUpdateInput>
  }

  /**
   * CatalogVendor delete
   */
  export type CatalogVendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
    /**
     * Filter which CatalogVendor to delete.
     */
    where: CatalogVendorWhereUniqueInput
  }

  /**
   * CatalogVendor deleteMany
   */
  export type CatalogVendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVendors to delete
     */
    where?: CatalogVendorWhereInput
  }

  /**
   * CatalogVendor.products
   */
  export type CatalogVendor$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogProduct
     */
    select?: CatalogProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogProductInclude<ExtArgs> | null
    where?: CatalogProductWhereInput
    orderBy?: CatalogProductOrderByWithRelationInput | CatalogProductOrderByWithRelationInput[]
    cursor?: CatalogProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogProductScalarFieldEnum | CatalogProductScalarFieldEnum[]
  }

  /**
   * CatalogVendor without action
   */
  export type CatalogVendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVendor
     */
    select?: CatalogVendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogVendorInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    entityId: string | null
    entityType: string | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    entityId: string | null
    entityType: string | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    entityId: number
    entityType: number
    action: number
    context: number
    comment: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    entityId?: true
    entityType?: true
    action?: true
    context?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    entityId: string | null
    entityType: string | null
    action: string
    context: JsonValue | null
    comment: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    entityId?: boolean
    entityType?: boolean
    action?: boolean
    context?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    entityId?: boolean
    entityType?: boolean
    action?: boolean
    context?: boolean
    comment?: boolean
    createdAt?: boolean
  }


  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      entityId: string | null
      entityType: string | null
      action: string
      context: Prisma.JsonValue | null
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly context: FieldRef<"AuditLog", 'Json'>
    readonly comment: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Printer
   */

  export type AggregatePrinter = {
    _count: PrinterCountAggregateOutputType | null
    _min: PrinterMinAggregateOutputType | null
    _max: PrinterMaxAggregateOutputType | null
  }

  export type PrinterMinAggregateOutputType = {
    id: string | null
    printerIdentifier: string | null
    tailScaleIP: string | null
    portNumber: string | null
    privateIPAddress: string | null
  }

  export type PrinterMaxAggregateOutputType = {
    id: string | null
    printerIdentifier: string | null
    tailScaleIP: string | null
    portNumber: string | null
    privateIPAddress: string | null
  }

  export type PrinterCountAggregateOutputType = {
    id: number
    printerIdentifier: number
    tailScaleIP: number
    portNumber: number
    privateIPAddress: number
    _all: number
  }


  export type PrinterMinAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
  }

  export type PrinterMaxAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
  }

  export type PrinterCountAggregateInputType = {
    id?: true
    printerIdentifier?: true
    tailScaleIP?: true
    portNumber?: true
    privateIPAddress?: true
    _all?: true
  }

  export type PrinterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Printer to aggregate.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Printers
    **/
    _count?: true | PrinterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrinterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrinterMaxAggregateInputType
  }

  export type GetPrinterAggregateType<T extends PrinterAggregateArgs> = {
        [P in keyof T & keyof AggregatePrinter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrinter[P]>
      : GetScalarType<T[P], AggregatePrinter[P]>
  }




  export type PrinterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrinterWhereInput
    orderBy?: PrinterOrderByWithAggregationInput | PrinterOrderByWithAggregationInput[]
    by: PrinterScalarFieldEnum[] | PrinterScalarFieldEnum
    having?: PrinterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrinterCountAggregateInputType | true
    _min?: PrinterMinAggregateInputType
    _max?: PrinterMaxAggregateInputType
  }

  export type PrinterGroupByOutputType = {
    id: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
    _count: PrinterCountAggregateOutputType | null
    _min: PrinterMinAggregateOutputType | null
    _max: PrinterMaxAggregateOutputType | null
  }

  type GetPrinterGroupByPayload<T extends PrinterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrinterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrinterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrinterGroupByOutputType[P]>
            : GetScalarType<T[P], PrinterGroupByOutputType[P]>
        }
      >
    >


  export type PrinterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    printerIdentifier?: boolean
    tailScaleIP?: boolean
    portNumber?: boolean
    privateIPAddress?: boolean
  }, ExtArgs["result"]["printer"]>

  export type PrinterSelectScalar = {
    id?: boolean
    printerIdentifier?: boolean
    tailScaleIP?: boolean
    portNumber?: boolean
    privateIPAddress?: boolean
  }



  export type $PrinterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Printer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      printerIdentifier: string
      tailScaleIP: string
      portNumber: string
      privateIPAddress: string
    }, ExtArgs["result"]["printer"]>
    composites: {}
  }


  type PrinterGetPayload<S extends boolean | null | undefined | PrinterDefaultArgs> = $Result.GetResult<Prisma.$PrinterPayload, S>

  type PrinterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrinterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrinterCountAggregateInputType | true
    }

  export interface PrinterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Printer'], meta: { name: 'Printer' } }
    /**
     * Find zero or one Printer that matches the filter.
     * @param {PrinterFindUniqueArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrinterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterFindUniqueArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Printer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrinterFindUniqueOrThrowArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PrinterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Printer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindFirstArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrinterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindFirstArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Printer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindFirstOrThrowArgs} args - Arguments to find a Printer
     * @example
     * // Get one Printer
     * const printer = await prisma.printer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PrinterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Printers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Printers
     * const printers = await prisma.printer.findMany()
     * 
     * // Get first 10 Printers
     * const printers = await prisma.printer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printerWithIdOnly = await prisma.printer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PrinterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Printer.
     * @param {PrinterCreateArgs} args - Arguments to create a Printer.
     * @example
     * // Create one Printer
     * const Printer = await prisma.printer.create({
     *   data: {
     *     // ... data to create a Printer
     *   }
     * })
     * 
    **/
    create<T extends PrinterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterCreateArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Printers.
     * @param {PrinterCreateManyArgs} args - Arguments to create many Printers.
     * @example
     * // Create many Printers
     * const printer = await prisma.printer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PrinterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Printers and returns the data saved in the database.
     * @param {PrinterCreateManyAndReturnArgs} args - Arguments to create many Printers.
     * @example
     * // Create many Printers
     * const printer = await prisma.printer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Printers and only return the `id`
     * const printerWithIdOnly = await prisma.printer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PrinterCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Printer.
     * @param {PrinterDeleteArgs} args - Arguments to delete one Printer.
     * @example
     * // Delete one Printer
     * const Printer = await prisma.printer.delete({
     *   where: {
     *     // ... filter to delete one Printer
     *   }
     * })
     * 
    **/
    delete<T extends PrinterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterDeleteArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Printer.
     * @param {PrinterUpdateArgs} args - Arguments to update one Printer.
     * @example
     * // Update one Printer
     * const printer = await prisma.printer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrinterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpdateArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Printers.
     * @param {PrinterDeleteManyArgs} args - Arguments to filter Printers to delete.
     * @example
     * // Delete a few Printers
     * const { count } = await prisma.printer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrinterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrinterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Printers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Printers
     * const printer = await prisma.printer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrinterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Printer.
     * @param {PrinterUpsertArgs} args - Arguments to update or create a Printer.
     * @example
     * // Update or create a Printer
     * const printer = await prisma.printer.upsert({
     *   create: {
     *     // ... data to create a Printer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Printer we want to update
     *   }
     * })
    **/
    upsert<T extends PrinterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PrinterUpsertArgs<ExtArgs>>
    ): Prisma__PrinterClient<$Result.GetResult<Prisma.$PrinterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Printers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterCountArgs} args - Arguments to filter Printers to count.
     * @example
     * // Count the number of Printers
     * const count = await prisma.printer.count({
     *   where: {
     *     // ... the filter for the Printers we want to count
     *   }
     * })
    **/
    count<T extends PrinterCountArgs>(
      args?: Subset<T, PrinterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrinterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Printer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrinterAggregateArgs>(args: Subset<T, PrinterAggregateArgs>): Prisma.PrismaPromise<GetPrinterAggregateType<T>>

    /**
     * Group by Printer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrinterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrinterGroupByArgs['orderBy'] }
        : { orderBy?: PrinterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrinterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrinterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Printer model
   */
  readonly fields: PrinterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Printer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrinterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Printer model
   */ 
  interface PrinterFieldRefs {
    readonly id: FieldRef<"Printer", 'String'>
    readonly printerIdentifier: FieldRef<"Printer", 'String'>
    readonly tailScaleIP: FieldRef<"Printer", 'String'>
    readonly portNumber: FieldRef<"Printer", 'String'>
    readonly privateIPAddress: FieldRef<"Printer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Printer findUnique
   */
  export type PrinterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer findUniqueOrThrow
   */
  export type PrinterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer findFirst
   */
  export type PrinterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Printers.
     */
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer findFirstOrThrow
   */
  export type PrinterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printer to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Printers.
     */
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer findMany
   */
  export type PrinterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter, which Printers to fetch.
     */
    where?: PrinterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Printers to fetch.
     */
    orderBy?: PrinterOrderByWithRelationInput | PrinterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Printers.
     */
    cursor?: PrinterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Printers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Printers.
     */
    skip?: number
    distinct?: PrinterScalarFieldEnum | PrinterScalarFieldEnum[]
  }

  /**
   * Printer create
   */
  export type PrinterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data needed to create a Printer.
     */
    data: XOR<PrinterCreateInput, PrinterUncheckedCreateInput>
  }

  /**
   * Printer createMany
   */
  export type PrinterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Printers.
     */
    data: PrinterCreateManyInput | PrinterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Printer createManyAndReturn
   */
  export type PrinterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data used to create many Printers.
     */
    data: PrinterCreateManyInput | PrinterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Printer update
   */
  export type PrinterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The data needed to update a Printer.
     */
    data: XOR<PrinterUpdateInput, PrinterUncheckedUpdateInput>
    /**
     * Choose, which Printer to update.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer updateMany
   */
  export type PrinterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Printers.
     */
    data: XOR<PrinterUpdateManyMutationInput, PrinterUncheckedUpdateManyInput>
    /**
     * Filter which Printers to update
     */
    where?: PrinterWhereInput
  }

  /**
   * Printer upsert
   */
  export type PrinterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * The filter to search for the Printer to update in case it exists.
     */
    where: PrinterWhereUniqueInput
    /**
     * In case the Printer found by the `where` argument doesn't exist, create a new Printer with this data.
     */
    create: XOR<PrinterCreateInput, PrinterUncheckedCreateInput>
    /**
     * In case the Printer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrinterUpdateInput, PrinterUncheckedUpdateInput>
  }

  /**
   * Printer delete
   */
  export type PrinterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
    /**
     * Filter which Printer to delete.
     */
    where: PrinterWhereUniqueInput
  }

  /**
   * Printer deleteMany
   */
  export type PrinterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Printers to delete
     */
    where?: PrinterWhereInput
  }

  /**
   * Printer without action
   */
  export type PrinterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Printer
     */
    select?: PrinterSelect<ExtArgs> | null
  }


  /**
   * Model CompanyUser
   */

  export type AggregateCompanyUser = {
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  export type CompanyUserMinAggregateOutputType = {
    userId: string | null
    companyId: string | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserMaxAggregateOutputType = {
    userId: string | null
    companyId: string | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserCountAggregateOutputType = {
    userId: number
    companyId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyUserMinAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserMaxAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserCountAggregateInputType = {
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUser to aggregate.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUsers
    **/
    _count?: true | CompanyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserMaxAggregateInputType
  }

  export type GetCompanyUserAggregateType<T extends CompanyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUser[P]>
      : GetScalarType<T[P], AggregateCompanyUser[P]>
  }




  export type CompanyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithAggregationInput | CompanyUserOrderByWithAggregationInput[]
    by: CompanyUserScalarFieldEnum[] | CompanyUserScalarFieldEnum
    having?: CompanyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserCountAggregateInputType | true
    _min?: CompanyUserMinAggregateInputType
    _max?: CompanyUserMaxAggregateInputType
  }

  export type CompanyUserGroupByOutputType = {
    userId: string
    companyId: string
    role: $Enums.CompanyRole
    createdAt: Date
    updatedAt: Date
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  type GetCompanyUserGroupByPayload<T extends CompanyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectScalar = {
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $CompanyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUser"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      companyId: string
      role: $Enums.CompanyRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyUser"]>
    composites: {}
  }


  type CompanyUserGetPayload<S extends boolean | null | undefined | CompanyUserDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPayload, S>

  type CompanyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyUserCountAggregateInputType | true
    }

  export interface CompanyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUser'], meta: { name: 'CompanyUser' } }
    /**
     * Find zero or one CompanyUser that matches the filter.
     * @param {CompanyUserFindUniqueArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyUserFindUniqueOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany()
     * 
     * // Get first 10 CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const companyUserWithUserIdOnly = await prisma.companyUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CompanyUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyUser.
     * @param {CompanyUserCreateArgs} args - Arguments to create a CompanyUser.
     * @example
     * // Create one CompanyUser
     * const CompanyUser = await prisma.companyUser.create({
     *   data: {
     *     // ... data to create a CompanyUser
     *   }
     * })
     * 
    **/
    create<T extends CompanyUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserCreateArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyUsers.
     * @param {CompanyUserCreateManyArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUsers and returns the data saved in the database.
     * @param {CompanyUserCreateManyAndReturnArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUsers and only return the `userId`
     * const companyUserWithUserIdOnly = await prisma.companyUser.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyUserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyUser.
     * @param {CompanyUserDeleteArgs} args - Arguments to delete one CompanyUser.
     * @example
     * // Delete one CompanyUser
     * const CompanyUser = await prisma.companyUser.delete({
     *   where: {
     *     // ... filter to delete one CompanyUser
     *   }
     * })
     * 
    **/
    delete<T extends CompanyUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserDeleteArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyUser.
     * @param {CompanyUserUpdateArgs} args - Arguments to update one CompanyUser.
     * @example
     * // Update one CompanyUser
     * const companyUser = await prisma.companyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpdateArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyUsers.
     * @param {CompanyUserDeleteManyArgs} args - Arguments to filter CompanyUsers to delete.
     * @example
     * // Delete a few CompanyUsers
     * const { count } = await prisma.companyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyUser.
     * @param {CompanyUserUpsertArgs} args - Arguments to update or create a CompanyUser.
     * @example
     * // Update or create a CompanyUser
     * const companyUser = await prisma.companyUser.upsert({
     *   create: {
     *     // ... data to create a CompanyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUser we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserUpsertArgs<ExtArgs>>
    ): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserCountArgs} args - Arguments to filter CompanyUsers to count.
     * @example
     * // Count the number of CompanyUsers
     * const count = await prisma.companyUser.count({
     *   where: {
     *     // ... the filter for the CompanyUsers we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserCountArgs>(
      args?: Subset<T, CompanyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserAggregateArgs>(args: Subset<T, CompanyUserAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserAggregateType<T>>

    /**
     * Group by CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUser model
   */
  readonly fields: CompanyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyUser model
   */ 
  interface CompanyUserFieldRefs {
    readonly userId: FieldRef<"CompanyUser", 'String'>
    readonly companyId: FieldRef<"CompanyUser", 'String'>
    readonly role: FieldRef<"CompanyUser", 'CompanyRole'>
    readonly createdAt: FieldRef<"CompanyUser", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUser findUnique
   */
  export type CompanyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findUniqueOrThrow
   */
  export type CompanyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findFirst
   */
  export type CompanyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findFirstOrThrow
   */
  export type CompanyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findMany
   */
  export type CompanyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUsers to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser create
   */
  export type CompanyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUser.
     */
    data: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
  }

  /**
   * CompanyUser createMany
   */
  export type CompanyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser createManyAndReturn
   */
  export type CompanyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser update
   */
  export type CompanyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUser.
     */
    data: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
    /**
     * Choose, which CompanyUser to update.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser updateMany
   */
  export type CompanyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser upsert
   */
  export type CompanyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUser to update in case it exists.
     */
    where: CompanyUserWhereUniqueInput
    /**
     * In case the CompanyUser found by the `where` argument doesn't exist, create a new CompanyUser with this data.
     */
    create: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
    /**
     * In case the CompanyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
  }

  /**
   * CompanyUser delete
   */
  export type CompanyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter which CompanyUser to delete.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser deleteMany
   */
  export type CompanyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUsers to delete
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser without action
   */
  export type CompanyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
  }


  /**
   * Model CompanyUserPermission
   */

  export type AggregateCompanyUserPermission = {
    _count: CompanyUserPermissionCountAggregateOutputType | null
    _min: CompanyUserPermissionMinAggregateOutputType | null
    _max: CompanyUserPermissionMaxAggregateOutputType | null
  }

  export type CompanyUserPermissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    permission: $Enums.CompanyPermission | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserPermissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    permission: $Enums.CompanyPermission | null
    role: $Enums.CompanyRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyUserPermissionCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    permission: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyUserPermissionMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    permission?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserPermissionMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    permission?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyUserPermissionCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    permission?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyUserPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUserPermission to aggregate.
     */
    where?: CompanyUserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUserPermissions to fetch.
     */
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUserPermissions
    **/
    _count?: true | CompanyUserPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserPermissionMaxAggregateInputType
  }

  export type GetCompanyUserPermissionAggregateType<T extends CompanyUserPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUserPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUserPermission[P]>
      : GetScalarType<T[P], AggregateCompanyUserPermission[P]>
  }




  export type CompanyUserPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserPermissionWhereInput
    orderBy?: CompanyUserPermissionOrderByWithAggregationInput | CompanyUserPermissionOrderByWithAggregationInput[]
    by: CompanyUserPermissionScalarFieldEnum[] | CompanyUserPermissionScalarFieldEnum
    having?: CompanyUserPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserPermissionCountAggregateInputType | true
    _min?: CompanyUserPermissionMinAggregateInputType
    _max?: CompanyUserPermissionMaxAggregateInputType
  }

  export type CompanyUserPermissionGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    permission: $Enums.CompanyPermission
    role: $Enums.CompanyRole
    createdAt: Date
    updatedAt: Date
    _count: CompanyUserPermissionCountAggregateOutputType | null
    _min: CompanyUserPermissionMinAggregateOutputType | null
    _max: CompanyUserPermissionMaxAggregateOutputType | null
  }

  type GetCompanyUserPermissionGroupByPayload<T extends CompanyUserPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserPermissionGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    permission?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUserPermission"]>

  export type CompanyUserPermissionSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    permission?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyUserPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $CompanyUserPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUserPermission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      permission: $Enums.CompanyPermission
      role: $Enums.CompanyRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyUserPermission"]>
    composites: {}
  }


  type CompanyUserPermissionGetPayload<S extends boolean | null | undefined | CompanyUserPermissionDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPermissionPayload, S>

  type CompanyUserPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyUserPermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyUserPermissionCountAggregateInputType | true
    }

  export interface CompanyUserPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUserPermission'], meta: { name: 'CompanyUserPermission' } }
    /**
     * Find zero or one CompanyUserPermission that matches the filter.
     * @param {CompanyUserPermissionFindUniqueArgs} args - Arguments to find a CompanyUserPermission
     * @example
     * // Get one CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyUserPermissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyUserPermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyUserPermissionFindUniqueOrThrowArgs} args - Arguments to find a CompanyUserPermission
     * @example
     * // Get one CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyUserPermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyUserPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionFindFirstArgs} args - Arguments to find a CompanyUserPermission
     * @example
     * // Get one CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyUserPermissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyUserPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionFindFirstOrThrowArgs} args - Arguments to find a CompanyUserPermission
     * @example
     * // Get one CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyUserPermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyUserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUserPermissions
     * const companyUserPermissions = await prisma.companyUserPermission.findMany()
     * 
     * // Get first 10 CompanyUserPermissions
     * const companyUserPermissions = await prisma.companyUserPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyUserPermissionWithIdOnly = await prisma.companyUserPermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyUserPermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyUserPermission.
     * @param {CompanyUserPermissionCreateArgs} args - Arguments to create a CompanyUserPermission.
     * @example
     * // Create one CompanyUserPermission
     * const CompanyUserPermission = await prisma.companyUserPermission.create({
     *   data: {
     *     // ... data to create a CompanyUserPermission
     *   }
     * })
     * 
    **/
    create<T extends CompanyUserPermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionCreateArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyUserPermissions.
     * @param {CompanyUserPermissionCreateManyArgs} args - Arguments to create many CompanyUserPermissions.
     * @example
     * // Create many CompanyUserPermissions
     * const companyUserPermission = await prisma.companyUserPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyUserPermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUserPermissions and returns the data saved in the database.
     * @param {CompanyUserPermissionCreateManyAndReturnArgs} args - Arguments to create many CompanyUserPermissions.
     * @example
     * // Create many CompanyUserPermissions
     * const companyUserPermission = await prisma.companyUserPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUserPermissions and only return the `id`
     * const companyUserPermissionWithIdOnly = await prisma.companyUserPermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyUserPermissionCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyUserPermission.
     * @param {CompanyUserPermissionDeleteArgs} args - Arguments to delete one CompanyUserPermission.
     * @example
     * // Delete one CompanyUserPermission
     * const CompanyUserPermission = await prisma.companyUserPermission.delete({
     *   where: {
     *     // ... filter to delete one CompanyUserPermission
     *   }
     * })
     * 
    **/
    delete<T extends CompanyUserPermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionDeleteArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyUserPermission.
     * @param {CompanyUserPermissionUpdateArgs} args - Arguments to update one CompanyUserPermission.
     * @example
     * // Update one CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUserPermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionUpdateArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyUserPermissions.
     * @param {CompanyUserPermissionDeleteManyArgs} args - Arguments to filter CompanyUserPermissions to delete.
     * @example
     * // Delete a few CompanyUserPermissions
     * const { count } = await prisma.companyUserPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyUserPermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyUserPermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUserPermissions
     * const companyUserPermission = await prisma.companyUserPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUserPermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyUserPermission.
     * @param {CompanyUserPermissionUpsertArgs} args - Arguments to update or create a CompanyUserPermission.
     * @example
     * // Update or create a CompanyUserPermission
     * const companyUserPermission = await prisma.companyUserPermission.upsert({
     *   create: {
     *     // ... data to create a CompanyUserPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUserPermission we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUserPermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUserPermissionUpsertArgs<ExtArgs>>
    ): Prisma__CompanyUserPermissionClient<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyUserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionCountArgs} args - Arguments to filter CompanyUserPermissions to count.
     * @example
     * // Count the number of CompanyUserPermissions
     * const count = await prisma.companyUserPermission.count({
     *   where: {
     *     // ... the filter for the CompanyUserPermissions we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserPermissionCountArgs>(
      args?: Subset<T, CompanyUserPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserPermissionAggregateArgs>(args: Subset<T, CompanyUserPermissionAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserPermissionAggregateType<T>>

    /**
     * Group by CompanyUserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserPermissionGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUserPermission model
   */
  readonly fields: CompanyUserPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUserPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyUserPermission model
   */ 
  interface CompanyUserPermissionFieldRefs {
    readonly id: FieldRef<"CompanyUserPermission", 'String'>
    readonly userId: FieldRef<"CompanyUserPermission", 'String'>
    readonly companyId: FieldRef<"CompanyUserPermission", 'String'>
    readonly permission: FieldRef<"CompanyUserPermission", 'CompanyPermission'>
    readonly role: FieldRef<"CompanyUserPermission", 'CompanyRole'>
    readonly createdAt: FieldRef<"CompanyUserPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyUserPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUserPermission findUnique
   */
  export type CompanyUserPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUserPermission to fetch.
     */
    where: CompanyUserPermissionWhereUniqueInput
  }

  /**
   * CompanyUserPermission findUniqueOrThrow
   */
  export type CompanyUserPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUserPermission to fetch.
     */
    where: CompanyUserPermissionWhereUniqueInput
  }

  /**
   * CompanyUserPermission findFirst
   */
  export type CompanyUserPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUserPermission to fetch.
     */
    where?: CompanyUserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUserPermissions to fetch.
     */
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUserPermissions.
     */
    cursor?: CompanyUserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUserPermissions.
     */
    distinct?: CompanyUserPermissionScalarFieldEnum | CompanyUserPermissionScalarFieldEnum[]
  }

  /**
   * CompanyUserPermission findFirstOrThrow
   */
  export type CompanyUserPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUserPermission to fetch.
     */
    where?: CompanyUserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUserPermissions to fetch.
     */
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUserPermissions.
     */
    cursor?: CompanyUserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUserPermissions.
     */
    distinct?: CompanyUserPermissionScalarFieldEnum | CompanyUserPermissionScalarFieldEnum[]
  }

  /**
   * CompanyUserPermission findMany
   */
  export type CompanyUserPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUserPermissions to fetch.
     */
    where?: CompanyUserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUserPermissions to fetch.
     */
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUserPermissions.
     */
    cursor?: CompanyUserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUserPermissions.
     */
    skip?: number
    distinct?: CompanyUserPermissionScalarFieldEnum | CompanyUserPermissionScalarFieldEnum[]
  }

  /**
   * CompanyUserPermission create
   */
  export type CompanyUserPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUserPermission.
     */
    data: XOR<CompanyUserPermissionCreateInput, CompanyUserPermissionUncheckedCreateInput>
  }

  /**
   * CompanyUserPermission createMany
   */
  export type CompanyUserPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUserPermissions.
     */
    data: CompanyUserPermissionCreateManyInput | CompanyUserPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUserPermission createManyAndReturn
   */
  export type CompanyUserPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyUserPermissions.
     */
    data: CompanyUserPermissionCreateManyInput | CompanyUserPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUserPermission update
   */
  export type CompanyUserPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUserPermission.
     */
    data: XOR<CompanyUserPermissionUpdateInput, CompanyUserPermissionUncheckedUpdateInput>
    /**
     * Choose, which CompanyUserPermission to update.
     */
    where: CompanyUserPermissionWhereUniqueInput
  }

  /**
   * CompanyUserPermission updateMany
   */
  export type CompanyUserPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUserPermissions.
     */
    data: XOR<CompanyUserPermissionUpdateManyMutationInput, CompanyUserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUserPermissions to update
     */
    where?: CompanyUserPermissionWhereInput
  }

  /**
   * CompanyUserPermission upsert
   */
  export type CompanyUserPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUserPermission to update in case it exists.
     */
    where: CompanyUserPermissionWhereUniqueInput
    /**
     * In case the CompanyUserPermission found by the `where` argument doesn't exist, create a new CompanyUserPermission with this data.
     */
    create: XOR<CompanyUserPermissionCreateInput, CompanyUserPermissionUncheckedCreateInput>
    /**
     * In case the CompanyUserPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserPermissionUpdateInput, CompanyUserPermissionUncheckedUpdateInput>
  }

  /**
   * CompanyUserPermission delete
   */
  export type CompanyUserPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    /**
     * Filter which CompanyUserPermission to delete.
     */
    where: CompanyUserPermissionWhereUniqueInput
  }

  /**
   * CompanyUserPermission deleteMany
   */
  export type CompanyUserPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUserPermissions to delete
     */
    where?: CompanyUserPermissionWhereInput
  }

  /**
   * CompanyUserPermission without action
   */
  export type CompanyUserPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
  }


  /**
   * Model CompanyPatient
   */

  export type AggregateCompanyPatient = {
    _count: CompanyPatientCountAggregateOutputType | null
    _min: CompanyPatientMinAggregateOutputType | null
    _max: CompanyPatientMaxAggregateOutputType | null
  }

  export type CompanyPatientMinAggregateOutputType = {
    patientId: string | null
    companyId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyPatientMaxAggregateOutputType = {
    patientId: string | null
    companyId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyPatientCountAggregateOutputType = {
    patientId: number
    companyId: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyPatientMinAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyPatientMaxAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyPatientCountAggregateInputType = {
    patientId?: true
    companyId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyPatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPatient to aggregate.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyPatients
    **/
    _count?: true | CompanyPatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyPatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyPatientMaxAggregateInputType
  }

  export type GetCompanyPatientAggregateType<T extends CompanyPatientAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyPatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyPatient[P]>
      : GetScalarType<T[P], AggregateCompanyPatient[P]>
  }




  export type CompanyPatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPatientWhereInput
    orderBy?: CompanyPatientOrderByWithAggregationInput | CompanyPatientOrderByWithAggregationInput[]
    by: CompanyPatientScalarFieldEnum[] | CompanyPatientScalarFieldEnum
    having?: CompanyPatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyPatientCountAggregateInputType | true
    _min?: CompanyPatientMinAggregateInputType
    _max?: CompanyPatientMaxAggregateInputType
  }

  export type CompanyPatientGroupByOutputType = {
    patientId: string
    companyId: string
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyPatientCountAggregateOutputType | null
    _min: CompanyPatientMinAggregateOutputType | null
    _max: CompanyPatientMaxAggregateOutputType | null
  }

  type GetCompanyPatientGroupByPayload<T extends CompanyPatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyPatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyPatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyPatientGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyPatientGroupByOutputType[P]>
        }
      >
    >


  export type CompanyPatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patientId?: boolean
    companyId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyPatient"]>

  export type CompanyPatientSelectScalar = {
    patientId?: boolean
    companyId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CompanyPatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }


  export type $CompanyPatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyPatient"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      patientId: string
      companyId: string
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyPatient"]>
    composites: {}
  }


  type CompanyPatientGetPayload<S extends boolean | null | undefined | CompanyPatientDefaultArgs> = $Result.GetResult<Prisma.$CompanyPatientPayload, S>

  type CompanyPatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyPatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyPatientCountAggregateInputType | true
    }

  export interface CompanyPatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyPatient'], meta: { name: 'CompanyPatient' } }
    /**
     * Find zero or one CompanyPatient that matches the filter.
     * @param {CompanyPatientFindUniqueArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyPatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompanyPatient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyPatientFindUniqueOrThrowArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyPatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompanyPatient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindFirstArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyPatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompanyPatient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindFirstOrThrowArgs} args - Arguments to find a CompanyPatient
     * @example
     * // Get one CompanyPatient
     * const companyPatient = await prisma.companyPatient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyPatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompanyPatients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyPatients
     * const companyPatients = await prisma.companyPatient.findMany()
     * 
     * // Get first 10 CompanyPatients
     * const companyPatients = await prisma.companyPatient.findMany({ take: 10 })
     * 
     * // Only select the `patientId`
     * const companyPatientWithPatientIdOnly = await prisma.companyPatient.findMany({ select: { patientId: true } })
     * 
    **/
    findMany<T extends CompanyPatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompanyPatient.
     * @param {CompanyPatientCreateArgs} args - Arguments to create a CompanyPatient.
     * @example
     * // Create one CompanyPatient
     * const CompanyPatient = await prisma.companyPatient.create({
     *   data: {
     *     // ... data to create a CompanyPatient
     *   }
     * })
     * 
    **/
    create<T extends CompanyPatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientCreateArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CompanyPatients.
     * @param {CompanyPatientCreateManyArgs} args - Arguments to create many CompanyPatients.
     * @example
     * // Create many CompanyPatients
     * const companyPatient = await prisma.companyPatient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CompanyPatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyPatients and returns the data saved in the database.
     * @param {CompanyPatientCreateManyAndReturnArgs} args - Arguments to create many CompanyPatients.
     * @example
     * // Create many CompanyPatients
     * const companyPatient = await prisma.companyPatient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyPatients and only return the `patientId`
     * const companyPatientWithPatientIdOnly = await prisma.companyPatient.createManyAndReturn({ 
     *   select: { patientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends CompanyPatientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a CompanyPatient.
     * @param {CompanyPatientDeleteArgs} args - Arguments to delete one CompanyPatient.
     * @example
     * // Delete one CompanyPatient
     * const CompanyPatient = await prisma.companyPatient.delete({
     *   where: {
     *     // ... filter to delete one CompanyPatient
     *   }
     * })
     * 
    **/
    delete<T extends CompanyPatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientDeleteArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompanyPatient.
     * @param {CompanyPatientUpdateArgs} args - Arguments to update one CompanyPatient.
     * @example
     * // Update one CompanyPatient
     * const companyPatient = await prisma.companyPatient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyPatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpdateArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompanyPatients.
     * @param {CompanyPatientDeleteManyArgs} args - Arguments to filter CompanyPatients to delete.
     * @example
     * // Delete a few CompanyPatients
     * const { count } = await prisma.companyPatient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyPatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyPatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyPatients
     * const companyPatient = await prisma.companyPatient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyPatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyPatient.
     * @param {CompanyPatientUpsertArgs} args - Arguments to update or create a CompanyPatient.
     * @example
     * // Update or create a CompanyPatient
     * const companyPatient = await prisma.companyPatient.upsert({
     *   create: {
     *     // ... data to create a CompanyPatient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyPatient we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyPatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyPatientUpsertArgs<ExtArgs>>
    ): Prisma__CompanyPatientClient<$Result.GetResult<Prisma.$CompanyPatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompanyPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientCountArgs} args - Arguments to filter CompanyPatients to count.
     * @example
     * // Count the number of CompanyPatients
     * const count = await prisma.companyPatient.count({
     *   where: {
     *     // ... the filter for the CompanyPatients we want to count
     *   }
     * })
    **/
    count<T extends CompanyPatientCountArgs>(
      args?: Subset<T, CompanyPatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyPatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyPatientAggregateArgs>(args: Subset<T, CompanyPatientAggregateArgs>): Prisma.PrismaPromise<GetCompanyPatientAggregateType<T>>

    /**
     * Group by CompanyPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyPatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyPatientGroupByArgs['orderBy'] }
        : { orderBy?: CompanyPatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyPatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyPatient model
   */
  readonly fields: CompanyPatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyPatient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyPatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompanyPatient model
   */ 
  interface CompanyPatientFieldRefs {
    readonly patientId: FieldRef<"CompanyPatient", 'String'>
    readonly companyId: FieldRef<"CompanyPatient", 'String'>
    readonly externalId: FieldRef<"CompanyPatient", 'String'>
    readonly createdAt: FieldRef<"CompanyPatient", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyPatient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyPatient findUnique
   */
  export type CompanyPatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient findUniqueOrThrow
   */
  export type CompanyPatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient findFirst
   */
  export type CompanyPatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPatients.
     */
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient findFirstOrThrow
   */
  export type CompanyPatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatient to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPatients.
     */
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient findMany
   */
  export type CompanyPatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPatients to fetch.
     */
    where?: CompanyPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPatients to fetch.
     */
    orderBy?: CompanyPatientOrderByWithRelationInput | CompanyPatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyPatients.
     */
    cursor?: CompanyPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPatients.
     */
    skip?: number
    distinct?: CompanyPatientScalarFieldEnum | CompanyPatientScalarFieldEnum[]
  }

  /**
   * CompanyPatient create
   */
  export type CompanyPatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyPatient.
     */
    data: XOR<CompanyPatientCreateInput, CompanyPatientUncheckedCreateInput>
  }

  /**
   * CompanyPatient createMany
   */
  export type CompanyPatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyPatients.
     */
    data: CompanyPatientCreateManyInput | CompanyPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPatient createManyAndReturn
   */
  export type CompanyPatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data used to create many CompanyPatients.
     */
    data: CompanyPatientCreateManyInput | CompanyPatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPatient update
   */
  export type CompanyPatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyPatient.
     */
    data: XOR<CompanyPatientUpdateInput, CompanyPatientUncheckedUpdateInput>
    /**
     * Choose, which CompanyPatient to update.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient updateMany
   */
  export type CompanyPatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyPatients.
     */
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyInput>
    /**
     * Filter which CompanyPatients to update
     */
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyPatient upsert
   */
  export type CompanyPatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyPatient to update in case it exists.
     */
    where: CompanyPatientWhereUniqueInput
    /**
     * In case the CompanyPatient found by the `where` argument doesn't exist, create a new CompanyPatient with this data.
     */
    create: XOR<CompanyPatientCreateInput, CompanyPatientUncheckedCreateInput>
    /**
     * In case the CompanyPatient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyPatientUpdateInput, CompanyPatientUncheckedUpdateInput>
  }

  /**
   * CompanyPatient delete
   */
  export type CompanyPatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
    /**
     * Filter which CompanyPatient to delete.
     */
    where: CompanyPatientWhereUniqueInput
  }

  /**
   * CompanyPatient deleteMany
   */
  export type CompanyPatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPatients to delete
     */
    where?: CompanyPatientWhereInput
  }

  /**
   * CompanyPatient without action
   */
  export type CompanyPatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPatient
     */
    select?: CompanyPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPatientInclude<ExtArgs> | null
  }


  /**
   * Model FacilityUser
   */

  export type AggregateFacilityUser = {
    _count: FacilityUserCountAggregateOutputType | null
    _min: FacilityUserMinAggregateOutputType | null
    _max: FacilityUserMaxAggregateOutputType | null
  }

  export type FacilityUserMinAggregateOutputType = {
    userId: string | null
    facilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityUserMaxAggregateOutputType = {
    userId: string | null
    facilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityUserCountAggregateOutputType = {
    userId: number
    facilityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityUserMinAggregateInputType = {
    userId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityUserMaxAggregateInputType = {
    userId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityUserCountAggregateInputType = {
    userId?: true
    facilityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityUser to aggregate.
     */
    where?: FacilityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityUsers to fetch.
     */
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityUsers
    **/
    _count?: true | FacilityUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityUserMaxAggregateInputType
  }

  export type GetFacilityUserAggregateType<T extends FacilityUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityUser[P]>
      : GetScalarType<T[P], AggregateFacilityUser[P]>
  }




  export type FacilityUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityUserWhereInput
    orderBy?: FacilityUserOrderByWithAggregationInput | FacilityUserOrderByWithAggregationInput[]
    by: FacilityUserScalarFieldEnum[] | FacilityUserScalarFieldEnum
    having?: FacilityUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityUserCountAggregateInputType | true
    _min?: FacilityUserMinAggregateInputType
    _max?: FacilityUserMaxAggregateInputType
  }

  export type FacilityUserGroupByOutputType = {
    userId: string
    facilityId: string
    createdAt: Date
    updatedAt: Date
    _count: FacilityUserCountAggregateOutputType | null
    _min: FacilityUserMinAggregateOutputType | null
    _max: FacilityUserMaxAggregateOutputType | null
  }

  type GetFacilityUserGroupByPayload<T extends FacilityUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityUserGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityUserGroupByOutputType[P]>
        }
      >
    >


  export type FacilityUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    facilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityUser"]>

  export type FacilityUserSelectScalar = {
    userId?: boolean
    facilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacilityUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $FacilityUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityUser"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      facilityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facilityUser"]>
    composites: {}
  }


  type FacilityUserGetPayload<S extends boolean | null | undefined | FacilityUserDefaultArgs> = $Result.GetResult<Prisma.$FacilityUserPayload, S>

  type FacilityUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityUserCountAggregateInputType | true
    }

  export interface FacilityUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityUser'], meta: { name: 'FacilityUser' } }
    /**
     * Find zero or one FacilityUser that matches the filter.
     * @param {FacilityUserFindUniqueArgs} args - Arguments to find a FacilityUser
     * @example
     * // Get one FacilityUser
     * const facilityUser = await prisma.facilityUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FacilityUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityUserFindUniqueOrThrowArgs} args - Arguments to find a FacilityUser
     * @example
     * // Get one FacilityUser
     * const facilityUser = await prisma.facilityUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacilityUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FacilityUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserFindFirstArgs} args - Arguments to find a FacilityUser
     * @example
     * // Get one FacilityUser
     * const facilityUser = await prisma.facilityUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FacilityUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserFindFirstOrThrowArgs} args - Arguments to find a FacilityUser
     * @example
     * // Get one FacilityUser
     * const facilityUser = await prisma.facilityUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacilityUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FacilityUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityUsers
     * const facilityUsers = await prisma.facilityUser.findMany()
     * 
     * // Get first 10 FacilityUsers
     * const facilityUsers = await prisma.facilityUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const facilityUserWithUserIdOnly = await prisma.facilityUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends FacilityUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FacilityUser.
     * @param {FacilityUserCreateArgs} args - Arguments to create a FacilityUser.
     * @example
     * // Create one FacilityUser
     * const FacilityUser = await prisma.facilityUser.create({
     *   data: {
     *     // ... data to create a FacilityUser
     *   }
     * })
     * 
    **/
    create<T extends FacilityUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserCreateArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FacilityUsers.
     * @param {FacilityUserCreateManyArgs} args - Arguments to create many FacilityUsers.
     * @example
     * // Create many FacilityUsers
     * const facilityUser = await prisma.facilityUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FacilityUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityUsers and returns the data saved in the database.
     * @param {FacilityUserCreateManyAndReturnArgs} args - Arguments to create many FacilityUsers.
     * @example
     * // Create many FacilityUsers
     * const facilityUser = await prisma.facilityUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityUsers and only return the `userId`
     * const facilityUserWithUserIdOnly = await prisma.facilityUser.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FacilityUserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FacilityUser.
     * @param {FacilityUserDeleteArgs} args - Arguments to delete one FacilityUser.
     * @example
     * // Delete one FacilityUser
     * const FacilityUser = await prisma.facilityUser.delete({
     *   where: {
     *     // ... filter to delete one FacilityUser
     *   }
     * })
     * 
    **/
    delete<T extends FacilityUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserDeleteArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FacilityUser.
     * @param {FacilityUserUpdateArgs} args - Arguments to update one FacilityUser.
     * @example
     * // Update one FacilityUser
     * const facilityUser = await prisma.facilityUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserUpdateArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FacilityUsers.
     * @param {FacilityUserDeleteManyArgs} args - Arguments to filter FacilityUsers to delete.
     * @example
     * // Delete a few FacilityUsers
     * const { count } = await prisma.facilityUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacilityUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityUsers
     * const facilityUser = await prisma.facilityUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacilityUser.
     * @param {FacilityUserUpsertArgs} args - Arguments to update or create a FacilityUser.
     * @example
     * // Update or create a FacilityUser
     * const facilityUser = await prisma.facilityUser.upsert({
     *   create: {
     *     // ... data to create a FacilityUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityUser we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacilityUserUpsertArgs<ExtArgs>>
    ): Prisma__FacilityUserClient<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FacilityUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserCountArgs} args - Arguments to filter FacilityUsers to count.
     * @example
     * // Count the number of FacilityUsers
     * const count = await prisma.facilityUser.count({
     *   where: {
     *     // ... the filter for the FacilityUsers we want to count
     *   }
     * })
    **/
    count<T extends FacilityUserCountArgs>(
      args?: Subset<T, FacilityUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityUserAggregateArgs>(args: Subset<T, FacilityUserAggregateArgs>): Prisma.PrismaPromise<GetFacilityUserAggregateType<T>>

    /**
     * Group by FacilityUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityUserGroupByArgs['orderBy'] }
        : { orderBy?: FacilityUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityUser model
   */
  readonly fields: FacilityUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FacilityUser model
   */ 
  interface FacilityUserFieldRefs {
    readonly userId: FieldRef<"FacilityUser", 'String'>
    readonly facilityId: FieldRef<"FacilityUser", 'String'>
    readonly createdAt: FieldRef<"FacilityUser", 'DateTime'>
    readonly updatedAt: FieldRef<"FacilityUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacilityUser findUnique
   */
  export type FacilityUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter, which FacilityUser to fetch.
     */
    where: FacilityUserWhereUniqueInput
  }

  /**
   * FacilityUser findUniqueOrThrow
   */
  export type FacilityUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter, which FacilityUser to fetch.
     */
    where: FacilityUserWhereUniqueInput
  }

  /**
   * FacilityUser findFirst
   */
  export type FacilityUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter, which FacilityUser to fetch.
     */
    where?: FacilityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityUsers to fetch.
     */
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityUsers.
     */
    cursor?: FacilityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityUsers.
     */
    distinct?: FacilityUserScalarFieldEnum | FacilityUserScalarFieldEnum[]
  }

  /**
   * FacilityUser findFirstOrThrow
   */
  export type FacilityUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter, which FacilityUser to fetch.
     */
    where?: FacilityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityUsers to fetch.
     */
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityUsers.
     */
    cursor?: FacilityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityUsers.
     */
    distinct?: FacilityUserScalarFieldEnum | FacilityUserScalarFieldEnum[]
  }

  /**
   * FacilityUser findMany
   */
  export type FacilityUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter, which FacilityUsers to fetch.
     */
    where?: FacilityUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityUsers to fetch.
     */
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityUsers.
     */
    cursor?: FacilityUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityUsers.
     */
    skip?: number
    distinct?: FacilityUserScalarFieldEnum | FacilityUserScalarFieldEnum[]
  }

  /**
   * FacilityUser create
   */
  export type FacilityUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityUser.
     */
    data: XOR<FacilityUserCreateInput, FacilityUserUncheckedCreateInput>
  }

  /**
   * FacilityUser createMany
   */
  export type FacilityUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityUsers.
     */
    data: FacilityUserCreateManyInput | FacilityUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityUser createManyAndReturn
   */
  export type FacilityUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * The data used to create many FacilityUsers.
     */
    data: FacilityUserCreateManyInput | FacilityUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityUser update
   */
  export type FacilityUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityUser.
     */
    data: XOR<FacilityUserUpdateInput, FacilityUserUncheckedUpdateInput>
    /**
     * Choose, which FacilityUser to update.
     */
    where: FacilityUserWhereUniqueInput
  }

  /**
   * FacilityUser updateMany
   */
  export type FacilityUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityUsers.
     */
    data: XOR<FacilityUserUpdateManyMutationInput, FacilityUserUncheckedUpdateManyInput>
    /**
     * Filter which FacilityUsers to update
     */
    where?: FacilityUserWhereInput
  }

  /**
   * FacilityUser upsert
   */
  export type FacilityUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityUser to update in case it exists.
     */
    where: FacilityUserWhereUniqueInput
    /**
     * In case the FacilityUser found by the `where` argument doesn't exist, create a new FacilityUser with this data.
     */
    create: XOR<FacilityUserCreateInput, FacilityUserUncheckedCreateInput>
    /**
     * In case the FacilityUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUserUpdateInput, FacilityUserUncheckedUpdateInput>
  }

  /**
   * FacilityUser delete
   */
  export type FacilityUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    /**
     * Filter which FacilityUser to delete.
     */
    where: FacilityUserWhereUniqueInput
  }

  /**
   * FacilityUser deleteMany
   */
  export type FacilityUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityUsers to delete
     */
    where?: FacilityUserWhereInput
  }

  /**
   * FacilityUser without action
   */
  export type FacilityUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    password: number
    pin: number
    photoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    pin?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    password: string | null
    pin: string | null
    photoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    pin?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    facilities?: boolean | User$facilitiesArgs<ExtArgs>
    clinician?: boolean | User$clinicianArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    auditsLogs?: boolean | User$auditsLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    pin?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    facilities?: boolean | User$facilitiesArgs<ExtArgs>
    clinician?: boolean | User$clinicianArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    auditsLogs?: boolean | User$auditsLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      companies: Prisma.$CompanyUserPayload<ExtArgs>[]
      permissions: Prisma.$CompanyUserPermissionPayload<ExtArgs>[]
      facilities: Prisma.$FacilityUserPayload<ExtArgs>[]
      clinician: Prisma.$ClinicianPayload<ExtArgs> | null
      notes: Prisma.$WorkbenchNotesPayload<ExtArgs>[]
      auditsLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      password: string | null
      pin: string | null
      photoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPermissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    facilities<T extends User$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    clinician<T extends User$clinicianArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicianArgs<ExtArgs>>): Prisma__ClinicianClient<$Result.GetResult<Prisma.$ClinicianPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkbenchNotesPayload<ExtArgs>, T, 'findMany'> | Null>;

    auditsLogs<T extends User$auditsLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly pin: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUserPermission
     */
    select?: CompanyUserPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserPermissionInclude<ExtArgs> | null
    where?: CompanyUserPermissionWhereInput
    orderBy?: CompanyUserPermissionOrderByWithRelationInput | CompanyUserPermissionOrderByWithRelationInput[]
    cursor?: CompanyUserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserPermissionScalarFieldEnum | CompanyUserPermissionScalarFieldEnum[]
  }

  /**
   * User.facilities
   */
  export type User$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityUser
     */
    select?: FacilityUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityUserInclude<ExtArgs> | null
    where?: FacilityUserWhereInput
    orderBy?: FacilityUserOrderByWithRelationInput | FacilityUserOrderByWithRelationInput[]
    cursor?: FacilityUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityUserScalarFieldEnum | FacilityUserScalarFieldEnum[]
  }

  /**
   * User.clinician
   */
  export type User$clinicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinician
     */
    select?: ClinicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicianInclude<ExtArgs> | null
    where?: ClinicianWhereInput
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkbenchNotes
     */
    select?: WorkbenchNotesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkbenchNotesInclude<ExtArgs> | null
    where?: WorkbenchNotesWhereInput
    orderBy?: WorkbenchNotesOrderByWithRelationInput | WorkbenchNotesOrderByWithRelationInput[]
    cursor?: WorkbenchNotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkbenchNotesScalarFieldEnum | WorkbenchNotesScalarFieldEnum[]
  }

  /**
   * User.auditsLogs
   */
  export type User$auditsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    userId: string | null
    profileId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    userId: string | null
    profileId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    userId: number
    profileId: number
    provider: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    userId?: true
    profileId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    userId: string
    profileId: string
    provider: string
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    profileId?: boolean
    provider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    userId?: boolean
    profileId?: boolean
    provider?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      profileId: string
      provider: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", 'String'>
    readonly profileId: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    key: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    key?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    key: string
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    key?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }


  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApiKeyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApiKeyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApiKeyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
    **/
    create<T extends ApiKeyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ApiKeyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
    **/
    delete<T extends ApiKeyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApiKeyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApiKeyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApiKeyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
    **/
    upsert<T extends ApiKeyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly companyId: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model ViewFlattenedWorkbench
   */

  export type AggregateViewFlattenedWorkbench = {
    _count: ViewFlattenedWorkbenchCountAggregateOutputType | null
    _avg: ViewFlattenedWorkbenchAvgAggregateOutputType | null
    _sum: ViewFlattenedWorkbenchSumAggregateOutputType | null
    _min: ViewFlattenedWorkbenchMinAggregateOutputType | null
    _max: ViewFlattenedWorkbenchMaxAggregateOutputType | null
  }

  export type ViewFlattenedWorkbenchAvgAggregateOutputType = {
    orderSide: number | null
  }

  export type ViewFlattenedWorkbenchSumAggregateOutputType = {
    orderSide: number | null
  }

  export type ViewFlattenedWorkbenchMinAggregateOutputType = {
    workbenchId: string | null
    companyId: string | null
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string | null
    patientId: string | null
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    companySlug: string | null
    createdReason: string | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    orderShoeSize: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
  }

  export type ViewFlattenedWorkbenchMaxAggregateOutputType = {
    workbenchId: string | null
    companyId: string | null
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string | null
    patientId: string | null
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    companySlug: string | null
    createdReason: string | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    orderShoeSize: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
  }

  export type ViewFlattenedWorkbenchCountAggregateOutputType = {
    workbenchId: number
    companyId: number
    workbenchStatus: number
    evaluationId: number
    patientId: number
    orderId: number
    orderStatus: number
    companySlug: number
    createdReason: number
    slicerProfile: number
    poNumber: number
    clinicianName: number
    clinicianId: number
    patientFirstName: number
    patientLastName: number
    orderCreatedAt: number
    authorizationUpdatedAt: number
    orderCompletedAt: number
    isDiabetic: number
    orderSide: number
    orderQuantity: number
    orderShoeSize: number
    orderGender: number
    validatedAt: number
    printingStartedAt: number
    printingStartedBy: number
    grindingCompletedAt: number
    grindingCompletedBy: number
    gluingCompletedAt: number
    gluingCompletedBy: number
    finishingCompletedAt: number
    finishingCompletedBy: number
    shippingCompletedAt: number
    shippingCompletedBy: number
    printingCompletedAt: number
    printingCompletedBy: number
    addonCompletedAt: number
    addonCompletedBy: number
    validationStatus: number
    deviceTypeName: number
    taikaId: number
    taikaDevId: number
    externalId: number
    companyName: number
    _all: number
  }


  export type ViewFlattenedWorkbenchAvgAggregateInputType = {
    orderSide?: true
  }

  export type ViewFlattenedWorkbenchSumAggregateInputType = {
    orderSide?: true
  }

  export type ViewFlattenedWorkbenchMinAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    companySlug?: true
    createdReason?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    orderShoeSize?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
  }

  export type ViewFlattenedWorkbenchMaxAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    companySlug?: true
    createdReason?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    orderShoeSize?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
  }

  export type ViewFlattenedWorkbenchCountAggregateInputType = {
    workbenchId?: true
    companyId?: true
    workbenchStatus?: true
    evaluationId?: true
    patientId?: true
    orderId?: true
    orderStatus?: true
    companySlug?: true
    createdReason?: true
    slicerProfile?: true
    poNumber?: true
    clinicianName?: true
    clinicianId?: true
    patientFirstName?: true
    patientLastName?: true
    orderCreatedAt?: true
    authorizationUpdatedAt?: true
    orderCompletedAt?: true
    isDiabetic?: true
    orderSide?: true
    orderQuantity?: true
    orderShoeSize?: true
    orderGender?: true
    validatedAt?: true
    printingStartedAt?: true
    printingStartedBy?: true
    grindingCompletedAt?: true
    grindingCompletedBy?: true
    gluingCompletedAt?: true
    gluingCompletedBy?: true
    finishingCompletedAt?: true
    finishingCompletedBy?: true
    shippingCompletedAt?: true
    shippingCompletedBy?: true
    printingCompletedAt?: true
    printingCompletedBy?: true
    addonCompletedAt?: true
    addonCompletedBy?: true
    validationStatus?: true
    deviceTypeName?: true
    taikaId?: true
    taikaDevId?: true
    externalId?: true
    companyName?: true
    _all?: true
  }

  export type ViewFlattenedWorkbenchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewFlattenedWorkbench to aggregate.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewFlattenedWorkbenches
    **/
    _count?: true | ViewFlattenedWorkbenchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewFlattenedWorkbenchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewFlattenedWorkbenchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewFlattenedWorkbenchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewFlattenedWorkbenchMaxAggregateInputType
  }

  export type GetViewFlattenedWorkbenchAggregateType<T extends ViewFlattenedWorkbenchAggregateArgs> = {
        [P in keyof T & keyof AggregateViewFlattenedWorkbench]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewFlattenedWorkbench[P]>
      : GetScalarType<T[P], AggregateViewFlattenedWorkbench[P]>
  }




  export type ViewFlattenedWorkbenchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewFlattenedWorkbenchWhereInput
    orderBy?: ViewFlattenedWorkbenchOrderByWithAggregationInput | ViewFlattenedWorkbenchOrderByWithAggregationInput[]
    by: ViewFlattenedWorkbenchScalarFieldEnum[] | ViewFlattenedWorkbenchScalarFieldEnum
    having?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewFlattenedWorkbenchCountAggregateInputType | true
    _avg?: ViewFlattenedWorkbenchAvgAggregateInputType
    _sum?: ViewFlattenedWorkbenchSumAggregateInputType
    _min?: ViewFlattenedWorkbenchMinAggregateInputType
    _max?: ViewFlattenedWorkbenchMaxAggregateInputType
  }

  export type ViewFlattenedWorkbenchGroupByOutputType = {
    workbenchId: string
    companyId: string
    workbenchStatus: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId: string | null
    orderStatus: $Enums.OrderStatus | null
    companySlug: string | null
    createdReason: string | null
    slicerProfile: string | null
    poNumber: string | null
    clinicianName: string | null
    clinicianId: string | null
    patientFirstName: string | null
    patientLastName: string | null
    orderCreatedAt: Date | null
    authorizationUpdatedAt: Date | null
    orderCompletedAt: Date | null
    isDiabetic: boolean | null
    orderSide: number | null
    orderQuantity: string | null
    orderShoeSize: string | null
    orderGender: string | null
    validatedAt: Date | null
    printingStartedAt: Date | null
    printingStartedBy: string | null
    grindingCompletedAt: Date | null
    grindingCompletedBy: string | null
    gluingCompletedAt: Date | null
    gluingCompletedBy: string | null
    finishingCompletedAt: Date | null
    finishingCompletedBy: string | null
    shippingCompletedAt: Date | null
    shippingCompletedBy: string | null
    printingCompletedAt: Date | null
    printingCompletedBy: string | null
    addonCompletedAt: Date | null
    addonCompletedBy: string | null
    validationStatus: boolean | null
    deviceTypeName: string | null
    taikaId: string | null
    taikaDevId: string | null
    externalId: string | null
    companyName: string | null
    _count: ViewFlattenedWorkbenchCountAggregateOutputType | null
    _avg: ViewFlattenedWorkbenchAvgAggregateOutputType | null
    _sum: ViewFlattenedWorkbenchSumAggregateOutputType | null
    _min: ViewFlattenedWorkbenchMinAggregateOutputType | null
    _max: ViewFlattenedWorkbenchMaxAggregateOutputType | null
  }

  type GetViewFlattenedWorkbenchGroupByPayload<T extends ViewFlattenedWorkbenchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewFlattenedWorkbenchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewFlattenedWorkbenchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewFlattenedWorkbenchGroupByOutputType[P]>
            : GetScalarType<T[P], ViewFlattenedWorkbenchGroupByOutputType[P]>
        }
      >
    >


  export type ViewFlattenedWorkbenchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workbenchId?: boolean
    companyId?: boolean
    workbenchStatus?: boolean
    evaluationId?: boolean
    patientId?: boolean
    orderId?: boolean
    orderStatus?: boolean
    companySlug?: boolean
    createdReason?: boolean
    slicerProfile?: boolean
    poNumber?: boolean
    clinicianName?: boolean
    clinicianId?: boolean
    patientFirstName?: boolean
    patientLastName?: boolean
    orderCreatedAt?: boolean
    authorizationUpdatedAt?: boolean
    orderCompletedAt?: boolean
    isDiabetic?: boolean
    orderSide?: boolean
    orderQuantity?: boolean
    orderShoeSize?: boolean
    orderGender?: boolean
    validatedAt?: boolean
    printingStartedAt?: boolean
    printingStartedBy?: boolean
    grindingCompletedAt?: boolean
    grindingCompletedBy?: boolean
    gluingCompletedAt?: boolean
    gluingCompletedBy?: boolean
    finishingCompletedAt?: boolean
    finishingCompletedBy?: boolean
    shippingCompletedAt?: boolean
    shippingCompletedBy?: boolean
    printingCompletedAt?: boolean
    printingCompletedBy?: boolean
    addonCompletedAt?: boolean
    addonCompletedBy?: boolean
    validationStatus?: boolean
    deviceTypeName?: boolean
    taikaId?: boolean
    taikaDevId?: boolean
    externalId?: boolean
    companyName?: boolean
  }, ExtArgs["result"]["viewFlattenedWorkbench"]>

  export type ViewFlattenedWorkbenchSelectScalar = {
    workbenchId?: boolean
    companyId?: boolean
    workbenchStatus?: boolean
    evaluationId?: boolean
    patientId?: boolean
    orderId?: boolean
    orderStatus?: boolean
    companySlug?: boolean
    createdReason?: boolean
    slicerProfile?: boolean
    poNumber?: boolean
    clinicianName?: boolean
    clinicianId?: boolean
    patientFirstName?: boolean
    patientLastName?: boolean
    orderCreatedAt?: boolean
    authorizationUpdatedAt?: boolean
    orderCompletedAt?: boolean
    isDiabetic?: boolean
    orderSide?: boolean
    orderQuantity?: boolean
    orderShoeSize?: boolean
    orderGender?: boolean
    validatedAt?: boolean
    printingStartedAt?: boolean
    printingStartedBy?: boolean
    grindingCompletedAt?: boolean
    grindingCompletedBy?: boolean
    gluingCompletedAt?: boolean
    gluingCompletedBy?: boolean
    finishingCompletedAt?: boolean
    finishingCompletedBy?: boolean
    shippingCompletedAt?: boolean
    shippingCompletedBy?: boolean
    printingCompletedAt?: boolean
    printingCompletedBy?: boolean
    addonCompletedAt?: boolean
    addonCompletedBy?: boolean
    validationStatus?: boolean
    deviceTypeName?: boolean
    taikaId?: boolean
    taikaDevId?: boolean
    externalId?: boolean
    companyName?: boolean
  }



  export type $ViewFlattenedWorkbenchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewFlattenedWorkbench"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      workbenchId: string
      companyId: string
      workbenchStatus: $Enums.WorkbenchStatus | null
      evaluationId: string
      patientId: string
      orderId: string | null
      orderStatus: $Enums.OrderStatus | null
      companySlug: string | null
      createdReason: string | null
      slicerProfile: string | null
      poNumber: string | null
      clinicianName: string | null
      clinicianId: string | null
      patientFirstName: string | null
      patientLastName: string | null
      orderCreatedAt: Date | null
      authorizationUpdatedAt: Date | null
      orderCompletedAt: Date | null
      isDiabetic: boolean | null
      orderSide: number | null
      orderQuantity: string | null
      orderShoeSize: string | null
      orderGender: string | null
      validatedAt: Date | null
      printingStartedAt: Date | null
      printingStartedBy: string | null
      grindingCompletedAt: Date | null
      grindingCompletedBy: string | null
      gluingCompletedAt: Date | null
      gluingCompletedBy: string | null
      finishingCompletedAt: Date | null
      finishingCompletedBy: string | null
      shippingCompletedAt: Date | null
      shippingCompletedBy: string | null
      printingCompletedAt: Date | null
      printingCompletedBy: string | null
      addonCompletedAt: Date | null
      addonCompletedBy: string | null
      validationStatus: boolean | null
      deviceTypeName: string | null
      taikaId: string | null
      taikaDevId: string | null
      externalId: string | null
      companyName: string | null
    }, ExtArgs["result"]["viewFlattenedWorkbench"]>
    composites: {}
  }


  type ViewFlattenedWorkbenchGetPayload<S extends boolean | null | undefined | ViewFlattenedWorkbenchDefaultArgs> = $Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload, S>

  type ViewFlattenedWorkbenchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViewFlattenedWorkbenchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViewFlattenedWorkbenchCountAggregateInputType | true
    }

  export interface ViewFlattenedWorkbenchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewFlattenedWorkbench'], meta: { name: 'ViewFlattenedWorkbench' } }
    /**
     * Find zero or one ViewFlattenedWorkbench that matches the filter.
     * @param {ViewFlattenedWorkbenchFindUniqueArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ViewFlattenedWorkbench that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViewFlattenedWorkbenchFindUniqueOrThrowArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ViewFlattenedWorkbench that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindFirstArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindFirstArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ViewFlattenedWorkbench that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindFirstOrThrowArgs} args - Arguments to find a ViewFlattenedWorkbench
     * @example
     * // Get one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ViewFlattenedWorkbenches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewFlattenedWorkbenches
     * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany()
     * 
     * // Get first 10 ViewFlattenedWorkbenches
     * const viewFlattenedWorkbenches = await prisma.viewFlattenedWorkbench.findMany({ take: 10 })
     * 
     * // Only select the `workbenchId`
     * const viewFlattenedWorkbenchWithWorkbenchIdOnly = await prisma.viewFlattenedWorkbench.findMany({ select: { workbenchId: true } })
     * 
    **/
    findMany<T extends ViewFlattenedWorkbenchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchCreateArgs} args - Arguments to create a ViewFlattenedWorkbench.
     * @example
     * // Create one ViewFlattenedWorkbench
     * const ViewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.create({
     *   data: {
     *     // ... data to create a ViewFlattenedWorkbench
     *   }
     * })
     * 
    **/
    create<T extends ViewFlattenedWorkbenchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchCreateArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ViewFlattenedWorkbenches.
     * @param {ViewFlattenedWorkbenchCreateManyArgs} args - Arguments to create many ViewFlattenedWorkbenches.
     * @example
     * // Create many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewFlattenedWorkbenches and returns the data saved in the database.
     * @param {ViewFlattenedWorkbenchCreateManyAndReturnArgs} args - Arguments to create many ViewFlattenedWorkbenches.
     * @example
     * // Create many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewFlattenedWorkbenches and only return the `workbenchId`
     * const viewFlattenedWorkbenchWithWorkbenchIdOnly = await prisma.viewFlattenedWorkbench.createManyAndReturn({ 
     *   select: { workbenchId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchDeleteArgs} args - Arguments to delete one ViewFlattenedWorkbench.
     * @example
     * // Delete one ViewFlattenedWorkbench
     * const ViewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.delete({
     *   where: {
     *     // ... filter to delete one ViewFlattenedWorkbench
     *   }
     * })
     * 
    **/
    delete<T extends ViewFlattenedWorkbenchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchDeleteArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchUpdateArgs} args - Arguments to update one ViewFlattenedWorkbench.
     * @example
     * // Update one ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ViewFlattenedWorkbenchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpdateArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ViewFlattenedWorkbenches.
     * @param {ViewFlattenedWorkbenchDeleteManyArgs} args - Arguments to filter ViewFlattenedWorkbenches to delete.
     * @example
     * // Delete a few ViewFlattenedWorkbenches
     * const { count } = await prisma.viewFlattenedWorkbench.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewFlattenedWorkbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewFlattenedWorkbenches
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViewFlattenedWorkbench.
     * @param {ViewFlattenedWorkbenchUpsertArgs} args - Arguments to update or create a ViewFlattenedWorkbench.
     * @example
     * // Update or create a ViewFlattenedWorkbench
     * const viewFlattenedWorkbench = await prisma.viewFlattenedWorkbench.upsert({
     *   create: {
     *     // ... data to create a ViewFlattenedWorkbench
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewFlattenedWorkbench we want to update
     *   }
     * })
    **/
    upsert<T extends ViewFlattenedWorkbenchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ViewFlattenedWorkbenchUpsertArgs<ExtArgs>>
    ): Prisma__ViewFlattenedWorkbenchClient<$Result.GetResult<Prisma.$ViewFlattenedWorkbenchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ViewFlattenedWorkbenches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchCountArgs} args - Arguments to filter ViewFlattenedWorkbenches to count.
     * @example
     * // Count the number of ViewFlattenedWorkbenches
     * const count = await prisma.viewFlattenedWorkbench.count({
     *   where: {
     *     // ... the filter for the ViewFlattenedWorkbenches we want to count
     *   }
     * })
    **/
    count<T extends ViewFlattenedWorkbenchCountArgs>(
      args?: Subset<T, ViewFlattenedWorkbenchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewFlattenedWorkbenchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewFlattenedWorkbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewFlattenedWorkbenchAggregateArgs>(args: Subset<T, ViewFlattenedWorkbenchAggregateArgs>): Prisma.PrismaPromise<GetViewFlattenedWorkbenchAggregateType<T>>

    /**
     * Group by ViewFlattenedWorkbench.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewFlattenedWorkbenchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewFlattenedWorkbenchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewFlattenedWorkbenchGroupByArgs['orderBy'] }
        : { orderBy?: ViewFlattenedWorkbenchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewFlattenedWorkbenchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewFlattenedWorkbenchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewFlattenedWorkbench model
   */
  readonly fields: ViewFlattenedWorkbenchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewFlattenedWorkbench.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewFlattenedWorkbenchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ViewFlattenedWorkbench model
   */ 
  interface ViewFlattenedWorkbenchFieldRefs {
    readonly workbenchId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly companyId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly workbenchStatus: FieldRef<"ViewFlattenedWorkbench", 'WorkbenchStatus'>
    readonly evaluationId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderStatus: FieldRef<"ViewFlattenedWorkbench", 'OrderStatus'>
    readonly companySlug: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly createdReason: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly slicerProfile: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly poNumber: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly clinicianName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly clinicianId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientFirstName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly patientLastName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderCreatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly authorizationUpdatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly orderCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly isDiabetic: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly orderSide: FieldRef<"ViewFlattenedWorkbench", 'Int'>
    readonly orderQuantity: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderShoeSize: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly orderGender: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly validatedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingStartedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingStartedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly grindingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly grindingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly gluingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly gluingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly finishingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly finishingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly shippingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly shippingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly printingCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly printingCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly addonCompletedAt: FieldRef<"ViewFlattenedWorkbench", 'DateTime'>
    readonly addonCompletedBy: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly validationStatus: FieldRef<"ViewFlattenedWorkbench", 'Boolean'>
    readonly deviceTypeName: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly taikaId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly taikaDevId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly externalId: FieldRef<"ViewFlattenedWorkbench", 'String'>
    readonly companyName: FieldRef<"ViewFlattenedWorkbench", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViewFlattenedWorkbench findUnique
   */
  export type ViewFlattenedWorkbenchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench findUniqueOrThrow
   */
  export type ViewFlattenedWorkbenchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench findFirst
   */
  export type ViewFlattenedWorkbenchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewFlattenedWorkbenches.
     */
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench findFirstOrThrow
   */
  export type ViewFlattenedWorkbenchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbench to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewFlattenedWorkbenches.
     */
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench findMany
   */
  export type ViewFlattenedWorkbenchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter, which ViewFlattenedWorkbenches to fetch.
     */
    where?: ViewFlattenedWorkbenchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewFlattenedWorkbenches to fetch.
     */
    orderBy?: ViewFlattenedWorkbenchOrderByWithRelationInput | ViewFlattenedWorkbenchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewFlattenedWorkbenches.
     */
    cursor?: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewFlattenedWorkbenches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewFlattenedWorkbenches.
     */
    skip?: number
    distinct?: ViewFlattenedWorkbenchScalarFieldEnum | ViewFlattenedWorkbenchScalarFieldEnum[]
  }

  /**
   * ViewFlattenedWorkbench create
   */
  export type ViewFlattenedWorkbenchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data needed to create a ViewFlattenedWorkbench.
     */
    data: XOR<ViewFlattenedWorkbenchCreateInput, ViewFlattenedWorkbenchUncheckedCreateInput>
  }

  /**
   * ViewFlattenedWorkbench createMany
   */
  export type ViewFlattenedWorkbenchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewFlattenedWorkbenches.
     */
    data: ViewFlattenedWorkbenchCreateManyInput | ViewFlattenedWorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewFlattenedWorkbench createManyAndReturn
   */
  export type ViewFlattenedWorkbenchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data used to create many ViewFlattenedWorkbenches.
     */
    data: ViewFlattenedWorkbenchCreateManyInput | ViewFlattenedWorkbenchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewFlattenedWorkbench update
   */
  export type ViewFlattenedWorkbenchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The data needed to update a ViewFlattenedWorkbench.
     */
    data: XOR<ViewFlattenedWorkbenchUpdateInput, ViewFlattenedWorkbenchUncheckedUpdateInput>
    /**
     * Choose, which ViewFlattenedWorkbench to update.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench updateMany
   */
  export type ViewFlattenedWorkbenchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewFlattenedWorkbenches.
     */
    data: XOR<ViewFlattenedWorkbenchUpdateManyMutationInput, ViewFlattenedWorkbenchUncheckedUpdateManyInput>
    /**
     * Filter which ViewFlattenedWorkbenches to update
     */
    where?: ViewFlattenedWorkbenchWhereInput
  }

  /**
   * ViewFlattenedWorkbench upsert
   */
  export type ViewFlattenedWorkbenchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * The filter to search for the ViewFlattenedWorkbench to update in case it exists.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
    /**
     * In case the ViewFlattenedWorkbench found by the `where` argument doesn't exist, create a new ViewFlattenedWorkbench with this data.
     */
    create: XOR<ViewFlattenedWorkbenchCreateInput, ViewFlattenedWorkbenchUncheckedCreateInput>
    /**
     * In case the ViewFlattenedWorkbench was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewFlattenedWorkbenchUpdateInput, ViewFlattenedWorkbenchUncheckedUpdateInput>
  }

  /**
   * ViewFlattenedWorkbench delete
   */
  export type ViewFlattenedWorkbenchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
    /**
     * Filter which ViewFlattenedWorkbench to delete.
     */
    where: ViewFlattenedWorkbenchWhereUniqueInput
  }

  /**
   * ViewFlattenedWorkbench deleteMany
   */
  export type ViewFlattenedWorkbenchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewFlattenedWorkbenches to delete
     */
    where?: ViewFlattenedWorkbenchWhereInput
  }

  /**
   * ViewFlattenedWorkbench without action
   */
  export type ViewFlattenedWorkbenchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewFlattenedWorkbench
     */
    select?: ViewFlattenedWorkbenchSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    logoUrl: 'logoUrl',
    slug: 'slug',
    preferences: 'preferences',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    companyId: 'companyId',
    type: 'type',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    birthDate: 'birthDate',
    height: 'height',
    weight: 'weight',
    maritalStatus: 'maritalStatus',
    photoUrl: 'photoUrl',
    active: 'active',
    deceasedAt: 'deceasedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    primaryPhysicianId: 'primaryPhysicianId'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const ClinicianScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicianScalarFieldEnum = (typeof ClinicianScalarFieldEnum)[keyof typeof ClinicianScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    poNumber: 'poNumber',
    type: 'type',
    patientId: 'patientId',
    companyId: 'companyId',
    deviceTypeId: 'deviceTypeId',
    isDiabetic: 'isDiabetic',
    isVeteran: 'isVeteran',
    deviceSide: 'deviceSide',
    devicePosition: 'devicePosition',
    appointmentAt: 'appointmentAt',
    appointmentStatus: 'appointmentStatus',
    referringPhysicianId: 'referringPhysicianId',
    diagnosisId: 'diagnosisId',
    diagnosisedAt: 'diagnosisedAt',
    visitTypeId: 'visitTypeId',
    visitedAt: 'visitedAt',
    facilityId: 'facilityId',
    location: 'location',
    prescribedAt: 'prescribedAt',
    prescribedActive: 'prescribedActive',
    primaryInsurance: 'primaryInsurance',
    secondaryInsurance: 'secondaryInsurance',
    submittedAt: 'submittedAt',
    startedAt: 'startedAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const FootScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    workbenchId: 'workbenchId',
    side: 'side',
    shoeSize: 'shoeSize',
    shoeWidth: 'shoeWidth',
    shoeGender: 'shoeGender',
    shoeSystem: 'shoeSystem',
    shoeBrand: 'shoeBrand',
    shoeModel: 'shoeModel',
    questionnaire: 'questionnaire',
    inactiveReason: 'inactiveReason',
    isChild: 'isChild',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FootScalarFieldEnum = (typeof FootScalarFieldEnum)[keyof typeof FootScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    footId: 'footId',
    type: 'type',
    fileUrl: 'fileUrl',
    metadata: 'metadata',
    status: 'status',
    statusCheckpoints: 'statusCheckpoints',
    statusReason: 'statusReason',
    statusUpdatedAt: 'statusUpdatedAt',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    sides: 'sides',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const WorkbenchScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    productId: 'productId',
    evaluationId: 'evaluationId',
    customization: 'customization',
    webhookUrl: 'webhookUrl',
    createdReason: 'createdReason',
    status: 'status',
    failedAt: 'failedAt',
    completedAt: 'completedAt',
    submittedAt: 'submittedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkbenchScalarFieldEnum = (typeof WorkbenchScalarFieldEnum)[keyof typeof WorkbenchScalarFieldEnum]


  export const WorkbenchNotesScalarFieldEnum: {
    id: 'id',
    workbenchId: 'workbenchId',
    title: 'title',
    content: 'content',
    tags: 'tags',
    blocks: 'blocks',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WorkbenchNotesScalarFieldEnum = (typeof WorkbenchNotesScalarFieldEnum)[keyof typeof WorkbenchNotesScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    workbenchId: 'workbenchId',
    status: 'status',
    statusUpdatedAt: 'statusUpdatedAt',
    committedDeliveryAt: 'committedDeliveryAt',
    parcelId: 'parcelId',
    active: 'active',
    authorizationStatus: 'authorizationStatus',
    authorizationUpdatedAt: 'authorizationUpdatedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const FacilityAddressScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    stateOrProvince: 'stateOrProvince',
    postalCode: 'postalCode',
    countryCode: 'countryCode',
    shippingAccountId: 'shippingAccountId',
    shippingAccountCarrier: 'shippingAccountCarrier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    facilityId: 'facilityId'
  };

  export type FacilityAddressScalarFieldEnum = (typeof FacilityAddressScalarFieldEnum)[keyof typeof FacilityAddressScalarFieldEnum]


  export const ShippingPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weight: 'weight',
    weightUnit: 'weightUnit',
    length: 'length',
    width: 'width',
    height: 'height',
    dimensionUnit: 'dimensionUnit',
    insoleCapacity: 'insoleCapacity',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingPackageScalarFieldEnum = (typeof ShippingPackageScalarFieldEnum)[keyof typeof ShippingPackageScalarFieldEnum]


  export const PhysicianScalarFieldEnum: {
    id: 'id',
    name: 'name',
    npi: 'npi',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhysicianScalarFieldEnum = (typeof PhysicianScalarFieldEnum)[keyof typeof PhysicianScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    diabetic: 'diabetic',
    standard: 'standard',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const BillingCodeScalarFieldEnum: {
    id: 'id',
    summary: 'summary',
    description: 'description',
    justifications: 'justifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingCodeScalarFieldEnum = (typeof BillingCodeScalarFieldEnum)[keyof typeof BillingCodeScalarFieldEnum]


  export const DeviceTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    diabetic: 'diabetic',
    custom: 'custom'
  };

  export type DeviceTypeScalarFieldEnum = (typeof DeviceTypeScalarFieldEnum)[keyof typeof DeviceTypeScalarFieldEnum]


  export const VisitTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type VisitTypeScalarFieldEnum = (typeof VisitTypeScalarFieldEnum)[keyof typeof VisitTypeScalarFieldEnum]


  export const FormSchemaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormSchemaScalarFieldEnum = (typeof FormSchemaScalarFieldEnum)[keyof typeof FormSchemaScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    workbenchId: 'workbenchId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const FormTemplateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormTemplateScalarFieldEnum = (typeof FormTemplateScalarFieldEnum)[keyof typeof FormTemplateScalarFieldEnum]


  export const CatalogProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    price: 'price',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductScalarFieldEnum = (typeof CatalogProductScalarFieldEnum)[keyof typeof CatalogProductScalarFieldEnum]


  export const CatalogProductAttributeScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    value: 'value',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductAttributeScalarFieldEnum = (typeof CatalogProductAttributeScalarFieldEnum)[keyof typeof CatalogProductAttributeScalarFieldEnum]


  export const CatalogProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    description: 'description',
    caption: 'caption',
    barcode: 'barcode',
    price: 'price',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogProductVariantScalarFieldEnum = (typeof CatalogProductVariantScalarFieldEnum)[keyof typeof CatalogProductVariantScalarFieldEnum]


  export const CatalogCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogCategoryScalarFieldEnum = (typeof CatalogCategoryScalarFieldEnum)[keyof typeof CatalogCategoryScalarFieldEnum]


  export const CatalogVendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogVendorScalarFieldEnum = (typeof CatalogVendorScalarFieldEnum)[keyof typeof CatalogVendorScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    entityId: 'entityId',
    entityType: 'entityType',
    action: 'action',
    context: 'context',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const PrinterScalarFieldEnum: {
    id: 'id',
    printerIdentifier: 'printerIdentifier',
    tailScaleIP: 'tailScaleIP',
    portNumber: 'portNumber',
    privateIPAddress: 'privateIPAddress'
  };

  export type PrinterScalarFieldEnum = (typeof PrinterScalarFieldEnum)[keyof typeof PrinterScalarFieldEnum]


  export const CompanyUserScalarFieldEnum: {
    userId: 'userId',
    companyId: 'companyId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyUserScalarFieldEnum = (typeof CompanyUserScalarFieldEnum)[keyof typeof CompanyUserScalarFieldEnum]


  export const CompanyUserPermissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    permission: 'permission',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyUserPermissionScalarFieldEnum = (typeof CompanyUserPermissionScalarFieldEnum)[keyof typeof CompanyUserPermissionScalarFieldEnum]


  export const CompanyPatientScalarFieldEnum: {
    patientId: 'patientId',
    companyId: 'companyId',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyPatientScalarFieldEnum = (typeof CompanyPatientScalarFieldEnum)[keyof typeof CompanyPatientScalarFieldEnum]


  export const FacilityUserScalarFieldEnum: {
    userId: 'userId',
    facilityId: 'facilityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityUserScalarFieldEnum = (typeof FacilityUserScalarFieldEnum)[keyof typeof FacilityUserScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    password: 'password',
    pin: 'pin',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    userId: 'userId',
    profileId: 'profileId',
    provider: 'provider',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ViewFlattenedWorkbenchScalarFieldEnum: {
    workbenchId: 'workbenchId',
    companyId: 'companyId',
    workbenchStatus: 'workbenchStatus',
    evaluationId: 'evaluationId',
    patientId: 'patientId',
    orderId: 'orderId',
    orderStatus: 'orderStatus',
    companySlug: 'companySlug',
    createdReason: 'createdReason',
    slicerProfile: 'slicerProfile',
    poNumber: 'poNumber',
    clinicianName: 'clinicianName',
    clinicianId: 'clinicianId',
    patientFirstName: 'patientFirstName',
    patientLastName: 'patientLastName',
    orderCreatedAt: 'orderCreatedAt',
    authorizationUpdatedAt: 'authorizationUpdatedAt',
    orderCompletedAt: 'orderCompletedAt',
    isDiabetic: 'isDiabetic',
    orderSide: 'orderSide',
    orderQuantity: 'orderQuantity',
    orderShoeSize: 'orderShoeSize',
    orderGender: 'orderGender',
    validatedAt: 'validatedAt',
    printingStartedAt: 'printingStartedAt',
    printingStartedBy: 'printingStartedBy',
    grindingCompletedAt: 'grindingCompletedAt',
    grindingCompletedBy: 'grindingCompletedBy',
    gluingCompletedAt: 'gluingCompletedAt',
    gluingCompletedBy: 'gluingCompletedBy',
    finishingCompletedAt: 'finishingCompletedAt',
    finishingCompletedBy: 'finishingCompletedBy',
    shippingCompletedAt: 'shippingCompletedAt',
    shippingCompletedBy: 'shippingCompletedBy',
    printingCompletedAt: 'printingCompletedAt',
    printingCompletedBy: 'printingCompletedBy',
    addonCompletedAt: 'addonCompletedAt',
    addonCompletedBy: 'addonCompletedBy',
    validationStatus: 'validationStatus',
    deviceTypeName: 'deviceTypeName',
    taikaId: 'taikaId',
    taikaDevId: 'taikaDevId',
    externalId: 'externalId',
    companyName: 'companyName'
  };

  export type ViewFlattenedWorkbenchScalarFieldEnum = (typeof ViewFlattenedWorkbenchScalarFieldEnum)[keyof typeof ViewFlattenedWorkbenchScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FacilityType'
   */
  export type EnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType'>
    


  /**
   * Reference to a field of type 'FacilityType[]'
   */
  export type ListEnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'CareType'
   */
  export type EnumCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareType'>
    


  /**
   * Reference to a field of type 'CareType[]'
   */
  export type ListEnumCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareType[]'>
    


  /**
   * Reference to a field of type 'Side'
   */
  export type EnumSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Side'>
    


  /**
   * Reference to a field of type 'Side[]'
   */
  export type ListEnumSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Side[]'>
    


  /**
   * Reference to a field of type 'VerticalPosition'
   */
  export type EnumVerticalPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerticalPosition'>
    


  /**
   * Reference to a field of type 'VerticalPosition[]'
   */
  export type ListEnumVerticalPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerticalPosition[]'>
    


  /**
   * Reference to a field of type 'ShoeWidth'
   */
  export type EnumShoeWidthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeWidth'>
    


  /**
   * Reference to a field of type 'ShoeWidth[]'
   */
  export type ListEnumShoeWidthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeWidth[]'>
    


  /**
   * Reference to a field of type 'ShoeSystem'
   */
  export type EnumShoeSystemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeSystem'>
    


  /**
   * Reference to a field of type 'ShoeSystem[]'
   */
  export type ListEnumShoeSystemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShoeSystem[]'>
    


  /**
   * Reference to a field of type 'InactiveFootReason'
   */
  export type EnumInactiveFootReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InactiveFootReason'>
    


  /**
   * Reference to a field of type 'InactiveFootReason[]'
   */
  export type ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InactiveFootReason[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'AssetStatus[]'
   */
  export type ListEnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus[]'>
    


  /**
   * Reference to a field of type 'WorkbenchCreatedReason'
   */
  export type EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchCreatedReason'>
    


  /**
   * Reference to a field of type 'WorkbenchCreatedReason[]'
   */
  export type ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchCreatedReason[]'>
    


  /**
   * Reference to a field of type 'WorkbenchStatus'
   */
  export type EnumWorkbenchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchStatus'>
    


  /**
   * Reference to a field of type 'WorkbenchStatus[]'
   */
  export type ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkbenchStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'OrderAuthorizationStatus'
   */
  export type EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAuthorizationStatus'>
    


  /**
   * Reference to a field of type 'OrderAuthorizationStatus[]'
   */
  export type ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAuthorizationStatus[]'>
    


  /**
   * Reference to a field of type 'Carrier'
   */
  export type EnumCarrierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Carrier'>
    


  /**
   * Reference to a field of type 'Carrier[]'
   */
  export type ListEnumCarrierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Carrier[]'>
    


  /**
   * Reference to a field of type 'WeightUnit'
   */
  export type EnumWeightUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeightUnit'>
    


  /**
   * Reference to a field of type 'WeightUnit[]'
   */
  export type ListEnumWeightUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeightUnit[]'>
    


  /**
   * Reference to a field of type 'DimensionUnit'
   */
  export type EnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit'>
    


  /**
   * Reference to a field of type 'DimensionUnit[]'
   */
  export type ListEnumDimensionUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DimensionUnit[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DiagnosisStandard'
   */
  export type EnumDiagnosisStandardFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiagnosisStandard'>
    


  /**
   * Reference to a field of type 'DiagnosisStandard[]'
   */
  export type ListEnumDiagnosisStandardFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiagnosisStandard[]'>
    


  /**
   * Reference to a field of type 'FormSchemaType'
   */
  export type EnumFormSchemaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormSchemaType'>
    


  /**
   * Reference to a field of type 'FormSchemaType[]'
   */
  export type ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormSchemaType[]'>
    


  /**
   * Reference to a field of type 'ProductAttributeType'
   */
  export type EnumProductAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAttributeType'>
    


  /**
   * Reference to a field of type 'ProductAttributeType[]'
   */
  export type ListEnumProductAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductAttributeType[]'>
    


  /**
   * Reference to a field of type 'CompanyRole'
   */
  export type EnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole'>
    


  /**
   * Reference to a field of type 'CompanyRole[]'
   */
  export type ListEnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole[]'>
    


  /**
   * Reference to a field of type 'CompanyPermission'
   */
  export type EnumCompanyPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyPermission'>
    


  /**
   * Reference to a field of type 'CompanyPermission[]'
   */
  export type ListEnumCompanyPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyPermission[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    url?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    slug?: StringFilter<"Company"> | string
    preferences?: JsonNullableFilter<"Company">
    active?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    facilities?: FacilityListRelationFilter
    evaluations?: EvaluationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    packages?: ShippingPackageListRelationFilter
    users?: CompanyUserListRelationFilter
    permissions?: CompanyUserPermissionListRelationFilter
    patients?: CompanyPatientListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    slug?: SortOrder
    preferences?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilities?: FacilityOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    packages?: ShippingPackageOrderByRelationAggregateInput
    users?: CompanyUserOrderByRelationAggregateInput
    permissions?: CompanyUserPermissionOrderByRelationAggregateInput
    patients?: CompanyPatientOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    url?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    preferences?: JsonNullableFilter<"Company">
    active?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    facilities?: FacilityListRelationFilter
    evaluations?: EvaluationListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    packages?: ShippingPackageListRelationFilter
    users?: CompanyUserListRelationFilter
    permissions?: CompanyUserPermissionListRelationFilter
    patients?: CompanyPatientListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "slug">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    slug?: SortOrder
    preferences?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    url?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    slug?: StringWithAggregatesFilter<"Company"> | string
    preferences?: JsonNullableWithAggregatesFilter<"Company">
    active?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    address?: XOR<FacilityAddressNullableRelationFilter, FacilityAddressWhereInput> | null
    users?: FacilityUserListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    address?: FacilityAddressOrderByWithRelationInput
    users?: FacilityUserOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    address?: XOR<FacilityAddressNullableRelationFilter, FacilityAddressWhereInput> | null
    users?: FacilityUserListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }, "id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facility"> | string
    name?: StringWithAggregatesFilter<"Facility"> | string
    companyId?: StringWithAggregatesFilter<"Facility"> | string
    type?: EnumFacilityTypeWithAggregatesFilter<"Facility"> | $Enums.FacilityType
    active?: BoolWithAggregatesFilter<"Facility"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
    primaryPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    feet?: FootListRelationFilter
    evaluations?: EvaluationListRelationFilter
    workbenches?: WorkbenchListRelationFilter
    companies?: CompanyPatientListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    deceasedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrderInput | SortOrder
    primaryPhysician?: PhysicianOrderByWithRelationInput
    feet?: FootOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
    companies?: CompanyPatientOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
    primaryPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    feet?: FootListRelationFilter
    evaluations?: EvaluationListRelationFilter
    workbenches?: WorkbenchListRelationFilter
    companies?: CompanyPatientListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    deceasedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    height?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    active?: BoolWithAggregatesFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
  }

  export type ClinicianWhereInput = {
    AND?: ClinicianWhereInput | ClinicianWhereInput[]
    OR?: ClinicianWhereInput[]
    NOT?: ClinicianWhereInput | ClinicianWhereInput[]
    id?: StringFilter<"Clinician"> | string
    name?: StringFilter<"Clinician"> | string
    userId?: StringNullableFilter<"Clinician"> | string | null
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    evaluations?: EvaluationListRelationFilter
  }

  export type ClinicianOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type ClinicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    userId?: string
    AND?: ClinicianWhereInput | ClinicianWhereInput[]
    OR?: ClinicianWhereInput[]
    NOT?: ClinicianWhereInput | ClinicianWhereInput[]
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    evaluations?: EvaluationListRelationFilter
  }, "id" | "name" | "userId">

  export type ClinicianOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicianCountOrderByAggregateInput
    _max?: ClinicianMaxOrderByAggregateInput
    _min?: ClinicianMinOrderByAggregateInput
  }

  export type ClinicianScalarWhereWithAggregatesInput = {
    AND?: ClinicianScalarWhereWithAggregatesInput | ClinicianScalarWhereWithAggregatesInput[]
    OR?: ClinicianScalarWhereWithAggregatesInput[]
    NOT?: ClinicianScalarWhereWithAggregatesInput | ClinicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinician"> | string
    name?: StringWithAggregatesFilter<"Clinician"> | string
    userId?: StringNullableWithAggregatesFilter<"Clinician"> | string | null
    active?: BoolWithAggregatesFilter<"Clinician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinician"> | Date | string
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deviceType?: XOR<DeviceTypeNullableRelationFilter, DeviceTypeWhereInput> | null
    visitType?: XOR<VisitTypeNullableRelationFilter, VisitTypeWhereInput> | null
    referringPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    diagnosis?: XOR<DiagnosisNullableRelationFilter, DiagnosisWhereInput> | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    clinicians?: ClinicianListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrderInput | SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrderInput | SortOrder
    devicePosition?: SortOrderInput | SortOrder
    appointmentAt?: SortOrderInput | SortOrder
    appointmentStatus?: SortOrderInput | SortOrder
    referringPhysicianId?: SortOrderInput | SortOrder
    diagnosisId?: SortOrderInput | SortOrder
    diagnosisedAt?: SortOrderInput | SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitedAt?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    prescribedAt?: SortOrderInput | SortOrder
    prescribedActive?: SortOrder
    primaryInsurance?: SortOrderInput | SortOrder
    secondaryInsurance?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    deviceType?: DeviceTypeOrderByWithRelationInput
    visitType?: VisitTypeOrderByWithRelationInput
    referringPhysician?: PhysicianOrderByWithRelationInput
    diagnosis?: DiagnosisOrderByWithRelationInput
    facility?: FacilityOrderByWithRelationInput
    clinicians?: ClinicianOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_companyId?: EvaluationIdCompanyIdCompoundUniqueInput
    externalId_companyId?: EvaluationExternalIdCompanyIdCompoundUniqueInput
    poNumber_companyId?: EvaluationPoNumberCompanyIdCompoundUniqueInput
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deviceType?: XOR<DeviceTypeNullableRelationFilter, DeviceTypeWhereInput> | null
    visitType?: XOR<VisitTypeNullableRelationFilter, VisitTypeWhereInput> | null
    referringPhysician?: XOR<PhysicianNullableRelationFilter, PhysicianWhereInput> | null
    diagnosis?: XOR<DiagnosisNullableRelationFilter, DiagnosisWhereInput> | null
    facility?: XOR<FacilityNullableRelationFilter, FacilityWhereInput> | null
    clinicians?: ClinicianListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }, "id" | "id_companyId" | "externalId_companyId" | "poNumber_companyId">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrderInput | SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrderInput | SortOrder
    devicePosition?: SortOrderInput | SortOrder
    appointmentAt?: SortOrderInput | SortOrder
    appointmentStatus?: SortOrderInput | SortOrder
    referringPhysicianId?: SortOrderInput | SortOrder
    diagnosisId?: SortOrderInput | SortOrder
    diagnosisedAt?: SortOrderInput | SortOrder
    visitTypeId?: SortOrderInput | SortOrder
    visitedAt?: SortOrderInput | SortOrder
    facilityId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    prescribedAt?: SortOrderInput | SortOrder
    prescribedActive?: SortOrder
    primaryInsurance?: SortOrderInput | SortOrder
    secondaryInsurance?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evaluation"> | string
    externalId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    poNumber?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    type?: EnumCareTypeWithAggregatesFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringWithAggregatesFilter<"Evaluation"> | string
    companyId?: StringWithAggregatesFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    isDiabetic?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    isVeteran?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableWithAggregatesFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableWithAggregatesFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    location?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolWithAggregatesFilter<"Evaluation"> | boolean
    primaryInsurance?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
  }

  export type FootWhereInput = {
    AND?: FootWhereInput | FootWhereInput[]
    OR?: FootWhereInput[]
    NOT?: FootWhereInput | FootWhereInput[]
    id?: StringFilter<"Foot"> | string
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthFilter<"Foot"> | $Enums.ShoeWidth
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    assets?: AssetListRelationFilter
  }

  export type FootOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrderInput | SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrderInput | SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrderInput | SortOrder
    shoeModel?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    workbench?: WorkbenchOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type FootWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FootWhereInput | FootWhereInput[]
    OR?: FootWhereInput[]
    NOT?: FootWhereInput | FootWhereInput[]
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthFilter<"Foot"> | $Enums.ShoeWidth
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    assets?: AssetListRelationFilter
  }, "id">

  export type FootOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrderInput | SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrderInput | SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrderInput | SortOrder
    shoeModel?: SortOrderInput | SortOrder
    questionnaire?: SortOrderInput | SortOrder
    inactiveReason?: SortOrderInput | SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FootCountOrderByAggregateInput
    _avg?: FootAvgOrderByAggregateInput
    _max?: FootMaxOrderByAggregateInput
    _min?: FootMinOrderByAggregateInput
    _sum?: FootSumOrderByAggregateInput
  }

  export type FootScalarWhereWithAggregatesInput = {
    AND?: FootScalarWhereWithAggregatesInput | FootScalarWhereWithAggregatesInput[]
    OR?: FootScalarWhereWithAggregatesInput[]
    NOT?: FootScalarWhereWithAggregatesInput | FootScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Foot"> | string
    patientId?: StringWithAggregatesFilter<"Foot"> | string
    workbenchId?: StringWithAggregatesFilter<"Foot"> | string
    side?: EnumSideWithAggregatesFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableWithAggregatesFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthWithAggregatesFilter<"Foot"> | $Enums.ShoeWidth
    shoeGender?: EnumGenderNullableWithAggregatesFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemWithAggregatesFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableWithAggregatesFilter<"Foot"> | string | null
    shoeModel?: StringNullableWithAggregatesFilter<"Foot"> | string | null
    questionnaire?: JsonNullableWithAggregatesFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableWithAggregatesFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolWithAggregatesFilter<"Foot"> | boolean
    active?: BoolWithAggregatesFilter<"Foot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Foot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Foot"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    foot?: XOR<FootRelationFilter, FootWhereInput>
    workbenches?: WorkbenchListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foot?: FootOrderByWithRelationInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    foot?: XOR<FootRelationFilter, FootWhereInput>
    workbenches?: WorkbenchListRelationFilter
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    footId?: StringWithAggregatesFilter<"Asset"> | string
    type?: EnumProductTypeWithAggregatesFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Asset">
    status?: EnumAssetStatusWithAggregatesFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Asset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    buildingBlocks?: ProductListRelationFilter
    usedByProducts?: ProductListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingBlocks?: ProductOrderByRelationAggregateInput
    usedByProducts?: ProductOrderByRelationAggregateInput
    workbenches?: WorkbenchOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    buildingBlocks?: ProductListRelationFilter
    usedByProducts?: ProductListRelationFilter
    workbenches?: WorkbenchListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type WorkbenchWhereInput = {
    AND?: WorkbenchWhereInput | WorkbenchWhereInput[]
    OR?: WorkbenchWhereInput[]
    NOT?: WorkbenchWhereInput | WorkbenchWhereInput[]
    id?: StringFilter<"Workbench"> | string
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
    assets?: AssetListRelationFilter
    orders?: OrderListRelationFilter
    feet?: FootListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    notes?: WorkbenchNotesListRelationFilter
  }

  export type WorkbenchOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    evaluation?: EvaluationOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    feet?: FootOrderByRelationAggregateInput
    formSubmissions?: FormSubmissionOrderByRelationAggregateInput
    notes?: WorkbenchNotesOrderByRelationAggregateInput
  }

  export type WorkbenchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkbenchWhereInput | WorkbenchWhereInput[]
    OR?: WorkbenchWhereInput[]
    NOT?: WorkbenchWhereInput | WorkbenchWhereInput[]
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    evaluation?: XOR<EvaluationRelationFilter, EvaluationWhereInput>
    assets?: AssetListRelationFilter
    orders?: OrderListRelationFilter
    feet?: FootListRelationFilter
    formSubmissions?: FormSubmissionListRelationFilter
    notes?: WorkbenchNotesListRelationFilter
  }, "id">

  export type WorkbenchOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    status?: SortOrder
    failedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkbenchCountOrderByAggregateInput
    _max?: WorkbenchMaxOrderByAggregateInput
    _min?: WorkbenchMinOrderByAggregateInput
  }

  export type WorkbenchScalarWhereWithAggregatesInput = {
    AND?: WorkbenchScalarWhereWithAggregatesInput | WorkbenchScalarWhereWithAggregatesInput[]
    OR?: WorkbenchScalarWhereWithAggregatesInput[]
    NOT?: WorkbenchScalarWhereWithAggregatesInput | WorkbenchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workbench"> | string
    patientId?: StringWithAggregatesFilter<"Workbench"> | string
    productId?: StringWithAggregatesFilter<"Workbench"> | string
    evaluationId?: StringWithAggregatesFilter<"Workbench"> | string
    customization?: JsonNullableWithAggregatesFilter<"Workbench">
    webhookUrl?: StringNullableWithAggregatesFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableWithAggregatesFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusWithAggregatesFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workbench"> | Date | string
  }

  export type WorkbenchNotesWhereInput = {
    AND?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    OR?: WorkbenchNotesWhereInput[]
    NOT?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    id?: StringFilter<"WorkbenchNotes"> | string
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type WorkbenchNotesOrderByWithRelationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    blocks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workbench?: WorkbenchOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type WorkbenchNotesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    OR?: WorkbenchNotesWhereInput[]
    NOT?: WorkbenchNotesWhereInput | WorkbenchNotesWhereInput[]
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type WorkbenchNotesOrderByWithAggregationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    blocks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkbenchNotesCountOrderByAggregateInput
    _max?: WorkbenchNotesMaxOrderByAggregateInput
    _min?: WorkbenchNotesMinOrderByAggregateInput
  }

  export type WorkbenchNotesScalarWhereWithAggregatesInput = {
    AND?: WorkbenchNotesScalarWhereWithAggregatesInput | WorkbenchNotesScalarWhereWithAggregatesInput[]
    OR?: WorkbenchNotesScalarWhereWithAggregatesInput[]
    NOT?: WorkbenchNotesScalarWhereWithAggregatesInput | WorkbenchNotesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkbenchNotes"> | string
    workbenchId?: StringWithAggregatesFilter<"WorkbenchNotes"> | string
    title?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableWithAggregatesFilter<"WorkbenchNotes">
    createdAt?: DateTimeWithAggregatesFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WorkbenchNotes"> | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    committedDeliveryAt?: SortOrderInput | SortOrder
    parcelId?: SortOrderInput | SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workbench?: WorkbenchOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrderInput | SortOrder
    committedDeliveryAt?: SortOrderInput | SortOrder
    parcelId?: SortOrderInput | SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    workbenchId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    parcelId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    active?: BoolWithAggregatesFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusWithAggregatesFilter<"Order"> | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type FacilityAddressWhereInput = {
    AND?: FacilityAddressWhereInput | FacilityAddressWhereInput[]
    OR?: FacilityAddressWhereInput[]
    NOT?: FacilityAddressWhereInput | FacilityAddressWhereInput[]
    id?: StringFilter<"FacilityAddress"> | string
    name?: StringNullableFilter<"FacilityAddress"> | string | null
    addressLine1?: StringFilter<"FacilityAddress"> | string
    addressLine2?: StringNullableFilter<"FacilityAddress"> | string | null
    city?: StringFilter<"FacilityAddress"> | string
    stateOrProvince?: StringFilter<"FacilityAddress"> | string
    postalCode?: StringFilter<"FacilityAddress"> | string
    countryCode?: StringFilter<"FacilityAddress"> | string
    shippingAccountId?: StringNullableFilter<"FacilityAddress"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableFilter<"FacilityAddress"> | $Enums.Carrier | null
    createdAt?: DateTimeFilter<"FacilityAddress"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityAddress"> | Date | string
    facilityId?: StringFilter<"FacilityAddress"> | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
  }

  export type FacilityAddressOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrderInput | SortOrder
    shippingAccountCarrier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityId?: SortOrder
    facility?: FacilityOrderByWithRelationInput
  }

  export type FacilityAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facilityId?: string
    AND?: FacilityAddressWhereInput | FacilityAddressWhereInput[]
    OR?: FacilityAddressWhereInput[]
    NOT?: FacilityAddressWhereInput | FacilityAddressWhereInput[]
    name?: StringNullableFilter<"FacilityAddress"> | string | null
    addressLine1?: StringFilter<"FacilityAddress"> | string
    addressLine2?: StringNullableFilter<"FacilityAddress"> | string | null
    city?: StringFilter<"FacilityAddress"> | string
    stateOrProvince?: StringFilter<"FacilityAddress"> | string
    postalCode?: StringFilter<"FacilityAddress"> | string
    countryCode?: StringFilter<"FacilityAddress"> | string
    shippingAccountId?: StringNullableFilter<"FacilityAddress"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableFilter<"FacilityAddress"> | $Enums.Carrier | null
    createdAt?: DateTimeFilter<"FacilityAddress"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityAddress"> | Date | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
  }, "id" | "facilityId">

  export type FacilityAddressOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrderInput | SortOrder
    shippingAccountCarrier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityId?: SortOrder
    _count?: FacilityAddressCountOrderByAggregateInput
    _max?: FacilityAddressMaxOrderByAggregateInput
    _min?: FacilityAddressMinOrderByAggregateInput
  }

  export type FacilityAddressScalarWhereWithAggregatesInput = {
    AND?: FacilityAddressScalarWhereWithAggregatesInput | FacilityAddressScalarWhereWithAggregatesInput[]
    OR?: FacilityAddressScalarWhereWithAggregatesInput[]
    NOT?: FacilityAddressScalarWhereWithAggregatesInput | FacilityAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacilityAddress"> | string
    name?: StringNullableWithAggregatesFilter<"FacilityAddress"> | string | null
    addressLine1?: StringWithAggregatesFilter<"FacilityAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"FacilityAddress"> | string | null
    city?: StringWithAggregatesFilter<"FacilityAddress"> | string
    stateOrProvince?: StringWithAggregatesFilter<"FacilityAddress"> | string
    postalCode?: StringWithAggregatesFilter<"FacilityAddress"> | string
    countryCode?: StringWithAggregatesFilter<"FacilityAddress"> | string
    shippingAccountId?: StringNullableWithAggregatesFilter<"FacilityAddress"> | string | null
    shippingAccountCarrier?: EnumCarrierNullableWithAggregatesFilter<"FacilityAddress"> | $Enums.Carrier | null
    createdAt?: DateTimeWithAggregatesFilter<"FacilityAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacilityAddress"> | Date | string
    facilityId?: StringWithAggregatesFilter<"FacilityAddress"> | string
  }

  export type ShippingPackageWhereInput = {
    AND?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    OR?: ShippingPackageWhereInput[]
    NOT?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    id?: StringFilter<"ShippingPackage"> | string
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ShippingPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ShippingPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    OR?: ShippingPackageWhereInput[]
    NOT?: ShippingPackageWhereInput | ShippingPackageWhereInput[]
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type ShippingPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingPackageCountOrderByAggregateInput
    _avg?: ShippingPackageAvgOrderByAggregateInput
    _max?: ShippingPackageMaxOrderByAggregateInput
    _min?: ShippingPackageMinOrderByAggregateInput
    _sum?: ShippingPackageSumOrderByAggregateInput
  }

  export type ShippingPackageScalarWhereWithAggregatesInput = {
    AND?: ShippingPackageScalarWhereWithAggregatesInput | ShippingPackageScalarWhereWithAggregatesInput[]
    OR?: ShippingPackageScalarWhereWithAggregatesInput[]
    NOT?: ShippingPackageScalarWhereWithAggregatesInput | ShippingPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingPackage"> | string
    name?: StringWithAggregatesFilter<"ShippingPackage"> | string
    weight?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitWithAggregatesFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    width?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    height?: FloatWithAggregatesFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitWithAggregatesFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntWithAggregatesFilter<"ShippingPackage"> | number
    companyId?: StringWithAggregatesFilter<"ShippingPackage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingPackage"> | Date | string
  }

  export type PhysicianWhereInput = {
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    id?: StringFilter<"Physician"> | string
    name?: StringFilter<"Physician"> | string
    npi?: StringNullableFilter<"Physician"> | string | null
    active?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    evaluations?: EvaluationListRelationFilter
    patient?: PatientListRelationFilter
  }

  export type PhysicianOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
    patient?: PatientOrderByRelationAggregateInput
  }

  export type PhysicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    npi?: string
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    name?: StringFilter<"Physician"> | string
    active?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    evaluations?: EvaluationListRelationFilter
    patient?: PatientListRelationFilter
  }, "id" | "npi">

  export type PhysicianOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhysicianCountOrderByAggregateInput
    _max?: PhysicianMaxOrderByAggregateInput
    _min?: PhysicianMinOrderByAggregateInput
  }

  export type PhysicianScalarWhereWithAggregatesInput = {
    AND?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    OR?: PhysicianScalarWhereWithAggregatesInput[]
    NOT?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Physician"> | string
    name?: StringWithAggregatesFilter<"Physician"> | string
    npi?: StringNullableWithAggregatesFilter<"Physician"> | string | null
    active?: BoolWithAggregatesFilter<"Physician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: StringFilter<"Diagnosis"> | string
    code?: StringFilter<"Diagnosis"> | string
    description?: StringFilter<"Diagnosis"> | string
    diabetic?: BoolFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    evaluations?: EvaluationListRelationFilter
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    description?: StringFilter<"Diagnosis"> | string
    diabetic?: BoolFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    evaluations?: EvaluationListRelationFilter
  }, "id" | "code">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Diagnosis"> | string
    code?: StringWithAggregatesFilter<"Diagnosis"> | string
    description?: StringWithAggregatesFilter<"Diagnosis"> | string
    diabetic?: BoolWithAggregatesFilter<"Diagnosis"> | boolean
    standard?: EnumDiagnosisStandardWithAggregatesFilter<"Diagnosis"> | $Enums.DiagnosisStandard
    createdAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type BillingCodeWhereInput = {
    AND?: BillingCodeWhereInput | BillingCodeWhereInput[]
    OR?: BillingCodeWhereInput[]
    NOT?: BillingCodeWhereInput | BillingCodeWhereInput[]
    id?: StringFilter<"BillingCode"> | string
    summary?: StringNullableFilter<"BillingCode"> | string | null
    description?: StringFilter<"BillingCode"> | string
    justifications?: JsonNullableFilter<"BillingCode">
    createdAt?: DateTimeFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeFilter<"BillingCode"> | Date | string
  }

  export type BillingCodeOrderByWithRelationInput = {
    id?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrder
    justifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingCodeWhereInput | BillingCodeWhereInput[]
    OR?: BillingCodeWhereInput[]
    NOT?: BillingCodeWhereInput | BillingCodeWhereInput[]
    summary?: StringNullableFilter<"BillingCode"> | string | null
    description?: StringFilter<"BillingCode"> | string
    justifications?: JsonNullableFilter<"BillingCode">
    createdAt?: DateTimeFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeFilter<"BillingCode"> | Date | string
  }, "id">

  export type BillingCodeOrderByWithAggregationInput = {
    id?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrder
    justifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingCodeCountOrderByAggregateInput
    _max?: BillingCodeMaxOrderByAggregateInput
    _min?: BillingCodeMinOrderByAggregateInput
  }

  export type BillingCodeScalarWhereWithAggregatesInput = {
    AND?: BillingCodeScalarWhereWithAggregatesInput | BillingCodeScalarWhereWithAggregatesInput[]
    OR?: BillingCodeScalarWhereWithAggregatesInput[]
    NOT?: BillingCodeScalarWhereWithAggregatesInput | BillingCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingCode"> | string
    summary?: StringNullableWithAggregatesFilter<"BillingCode"> | string | null
    description?: StringWithAggregatesFilter<"BillingCode"> | string
    justifications?: JsonNullableWithAggregatesFilter<"BillingCode">
    createdAt?: DateTimeWithAggregatesFilter<"BillingCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingCode"> | Date | string
  }

  export type DeviceTypeWhereInput = {
    AND?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    OR?: DeviceTypeWhereInput[]
    NOT?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    id?: StringFilter<"DeviceType"> | string
    name?: StringFilter<"DeviceType"> | string
    diabetic?: BoolFilter<"DeviceType"> | boolean
    custom?: BoolNullableFilter<"DeviceType"> | boolean | null
    evaluations?: EvaluationListRelationFilter
  }

  export type DeviceTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrderInput | SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type DeviceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    OR?: DeviceTypeWhereInput[]
    NOT?: DeviceTypeWhereInput | DeviceTypeWhereInput[]
    diabetic?: BoolFilter<"DeviceType"> | boolean
    custom?: BoolNullableFilter<"DeviceType"> | boolean | null
    evaluations?: EvaluationListRelationFilter
  }, "id" | "name">

  export type DeviceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrderInput | SortOrder
    _count?: DeviceTypeCountOrderByAggregateInput
    _max?: DeviceTypeMaxOrderByAggregateInput
    _min?: DeviceTypeMinOrderByAggregateInput
  }

  export type DeviceTypeScalarWhereWithAggregatesInput = {
    AND?: DeviceTypeScalarWhereWithAggregatesInput | DeviceTypeScalarWhereWithAggregatesInput[]
    OR?: DeviceTypeScalarWhereWithAggregatesInput[]
    NOT?: DeviceTypeScalarWhereWithAggregatesInput | DeviceTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceType"> | string
    name?: StringWithAggregatesFilter<"DeviceType"> | string
    diabetic?: BoolWithAggregatesFilter<"DeviceType"> | boolean
    custom?: BoolNullableWithAggregatesFilter<"DeviceType"> | boolean | null
  }

  export type VisitTypeWhereInput = {
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    id?: StringFilter<"VisitType"> | string
    name?: StringFilter<"VisitType"> | string
    evaluations?: EvaluationListRelationFilter
  }

  export type VisitTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type VisitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VisitTypeWhereInput | VisitTypeWhereInput[]
    OR?: VisitTypeWhereInput[]
    NOT?: VisitTypeWhereInput | VisitTypeWhereInput[]
    evaluations?: EvaluationListRelationFilter
  }, "id" | "name">

  export type VisitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: VisitTypeCountOrderByAggregateInput
    _max?: VisitTypeMaxOrderByAggregateInput
    _min?: VisitTypeMinOrderByAggregateInput
  }

  export type VisitTypeScalarWhereWithAggregatesInput = {
    AND?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    OR?: VisitTypeScalarWhereWithAggregatesInput[]
    NOT?: VisitTypeScalarWhereWithAggregatesInput | VisitTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitType"> | string
    name?: StringWithAggregatesFilter<"VisitType"> | string
  }

  export type FormSchemaWhereInput = {
    AND?: FormSchemaWhereInput | FormSchemaWhereInput[]
    OR?: FormSchemaWhereInput[]
    NOT?: FormSchemaWhereInput | FormSchemaWhereInput[]
    id?: StringFilter<"FormSchema"> | string
    title?: StringFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonFilter<"FormSchema">
    createdAt?: DateTimeFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeFilter<"FormSchema"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormSchemaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormSchemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormSchemaWhereInput | FormSchemaWhereInput[]
    OR?: FormSchemaWhereInput[]
    NOT?: FormSchemaWhereInput | FormSchemaWhereInput[]
    title?: StringFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonFilter<"FormSchema">
    createdAt?: DateTimeFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeFilter<"FormSchema"> | Date | string
    submissions?: FormSubmissionListRelationFilter
  }, "id">

  export type FormSchemaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormSchemaCountOrderByAggregateInput
    _max?: FormSchemaMaxOrderByAggregateInput
    _min?: FormSchemaMinOrderByAggregateInput
  }

  export type FormSchemaScalarWhereWithAggregatesInput = {
    AND?: FormSchemaScalarWhereWithAggregatesInput | FormSchemaScalarWhereWithAggregatesInput[]
    OR?: FormSchemaScalarWhereWithAggregatesInput[]
    NOT?: FormSchemaScalarWhereWithAggregatesInput | FormSchemaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSchema"> | string
    title?: StringWithAggregatesFilter<"FormSchema"> | string
    type?: EnumFormSchemaTypeNullableWithAggregatesFilter<"FormSchema"> | $Enums.FormSchemaType | null
    data?: JsonWithAggregatesFilter<"FormSchema">
    createdAt?: DateTimeWithAggregatesFilter<"FormSchema"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSchema"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    schema?: XOR<FormSchemaRelationFilter, FormSchemaWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schema?: FormSchemaOrderByWithRelationInput
    workbench?: WorkbenchOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workbenchId_schemaId?: FormSubmissionWorkbenchIdSchemaIdCompoundUniqueInput
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    schema?: XOR<FormSchemaRelationFilter, FormSchemaWhereInput>
    workbench?: XOR<WorkbenchRelationFilter, WorkbenchWhereInput>
  }, "id" | "workbenchId_schemaId">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    schemaId?: StringWithAggregatesFilter<"FormSubmission"> | string
    workbenchId?: StringWithAggregatesFilter<"FormSubmission"> | string
    data?: JsonWithAggregatesFilter<"FormSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type FormTemplateWhereInput = {
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    id?: StringFilter<"FormTemplate"> | string
    userId?: StringFilter<"FormTemplate"> | string
    title?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    data?: JsonFilter<"FormTemplate">
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
  }

  export type FormTemplateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    userId?: StringFilter<"FormTemplate"> | string
    title?: StringFilter<"FormTemplate"> | string
    description?: StringNullableFilter<"FormTemplate"> | string | null
    data?: JsonFilter<"FormTemplate">
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
  }, "id">

  export type FormTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormTemplateCountOrderByAggregateInput
    _max?: FormTemplateMaxOrderByAggregateInput
    _min?: FormTemplateMinOrderByAggregateInput
  }

  export type FormTemplateScalarWhereWithAggregatesInput = {
    AND?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    OR?: FormTemplateScalarWhereWithAggregatesInput[]
    NOT?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormTemplate"> | string
    userId?: StringWithAggregatesFilter<"FormTemplate"> | string
    title?: StringWithAggregatesFilter<"FormTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"FormTemplate"> | string | null
    data?: JsonWithAggregatesFilter<"FormTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
  }

  export type CatalogProductWhereInput = {
    AND?: CatalogProductWhereInput | CatalogProductWhereInput[]
    OR?: CatalogProductWhereInput[]
    NOT?: CatalogProductWhereInput | CatalogProductWhereInput[]
    id?: StringFilter<"CatalogProduct"> | string
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    attributes?: CatalogProductAttributeListRelationFilter
    variants?: CatalogProductVariantListRelationFilter
    categories?: CatalogCategoryListRelationFilter
    vendors?: CatalogVendorListRelationFilter
  }

  export type CatalogProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attributes?: CatalogProductAttributeOrderByRelationAggregateInput
    variants?: CatalogProductVariantOrderByRelationAggregateInput
    categories?: CatalogCategoryOrderByRelationAggregateInput
    vendors?: CatalogVendorOrderByRelationAggregateInput
  }

  export type CatalogProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogProductWhereInput | CatalogProductWhereInput[]
    OR?: CatalogProductWhereInput[]
    NOT?: CatalogProductWhereInput | CatalogProductWhereInput[]
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    attributes?: CatalogProductAttributeListRelationFilter
    variants?: CatalogProductVariantListRelationFilter
    categories?: CatalogCategoryListRelationFilter
    vendors?: CatalogVendorListRelationFilter
  }, "id">

  export type CatalogProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductCountOrderByAggregateInput
    _avg?: CatalogProductAvgOrderByAggregateInput
    _max?: CatalogProductMaxOrderByAggregateInput
    _min?: CatalogProductMinOrderByAggregateInput
    _sum?: CatalogProductSumOrderByAggregateInput
  }

  export type CatalogProductScalarWhereWithAggregatesInput = {
    AND?: CatalogProductScalarWhereWithAggregatesInput | CatalogProductScalarWhereWithAggregatesInput[]
    OR?: CatalogProductScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductScalarWhereWithAggregatesInput | CatalogProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProduct"> | string
    name?: StringWithAggregatesFilter<"CatalogProduct"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProduct"> | string | null
    image?: StringNullableWithAggregatesFilter<"CatalogProduct"> | string | null
    price?: FloatNullableWithAggregatesFilter<"CatalogProduct"> | number | null
    active?: BoolWithAggregatesFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProduct"> | Date | string
  }

  export type CatalogProductAttributeWhereInput = {
    AND?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    OR?: CatalogProductAttributeWhereInput[]
    NOT?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    id?: StringFilter<"CatalogProductAttribute"> | string
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }

  export type CatalogProductAttributeOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: CatalogProductOrderByWithRelationInput
  }

  export type CatalogProductAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    OR?: CatalogProductAttributeWhereInput[]
    NOT?: CatalogProductAttributeWhereInput | CatalogProductAttributeWhereInput[]
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }, "id">

  export type CatalogProductAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductAttributeCountOrderByAggregateInput
    _max?: CatalogProductAttributeMaxOrderByAggregateInput
    _min?: CatalogProductAttributeMinOrderByAggregateInput
  }

  export type CatalogProductAttributeScalarWhereWithAggregatesInput = {
    AND?: CatalogProductAttributeScalarWhereWithAggregatesInput | CatalogProductAttributeScalarWhereWithAggregatesInput[]
    OR?: CatalogProductAttributeScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductAttributeScalarWhereWithAggregatesInput | CatalogProductAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    productId?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeWithAggregatesFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringWithAggregatesFilter<"CatalogProductAttribute"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProductAttribute"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProductAttribute"> | Date | string
  }

  export type CatalogProductVariantWhereInput = {
    AND?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    OR?: CatalogProductVariantWhereInput[]
    NOT?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    id?: StringFilter<"CatalogProductVariant"> | string
    productId?: StringFilter<"CatalogProductVariant"> | string
    sku?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }

  export type CatalogProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: CatalogProductOrderByWithRelationInput
  }

  export type CatalogProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    OR?: CatalogProductVariantWhereInput[]
    NOT?: CatalogProductVariantWhereInput | CatalogProductVariantWhereInput[]
    productId?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    product?: XOR<CatalogProductRelationFilter, CatalogProductWhereInput>
  }, "id" | "sku">

  export type CatalogProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogProductVariantCountOrderByAggregateInput
    _avg?: CatalogProductVariantAvgOrderByAggregateInput
    _max?: CatalogProductVariantMaxOrderByAggregateInput
    _min?: CatalogProductVariantMinOrderByAggregateInput
    _sum?: CatalogProductVariantSumOrderByAggregateInput
  }

  export type CatalogProductVariantScalarWhereWithAggregatesInput = {
    AND?: CatalogProductVariantScalarWhereWithAggregatesInput | CatalogProductVariantScalarWhereWithAggregatesInput[]
    OR?: CatalogProductVariantScalarWhereWithAggregatesInput[]
    NOT?: CatalogProductVariantScalarWhereWithAggregatesInput | CatalogProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    productId?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    sku?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    name?: StringWithAggregatesFilter<"CatalogProductVariant"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableWithAggregatesFilter<"CatalogProductVariant"> | number | null
    active?: BoolWithAggregatesFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogProductVariant"> | Date | string
  }

  export type CatalogCategoryWhereInput = {
    AND?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    OR?: CatalogCategoryWhereInput[]
    NOT?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    id?: StringFilter<"CatalogCategory"> | string
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    products?: CatalogProductListRelationFilter
  }

  export type CatalogCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: CatalogProductOrderByRelationAggregateInput
  }

  export type CatalogCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    OR?: CatalogCategoryWhereInput[]
    NOT?: CatalogCategoryWhereInput | CatalogCategoryWhereInput[]
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    products?: CatalogProductListRelationFilter
  }, "id">

  export type CatalogCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogCategoryCountOrderByAggregateInput
    _max?: CatalogCategoryMaxOrderByAggregateInput
    _min?: CatalogCategoryMinOrderByAggregateInput
  }

  export type CatalogCategoryScalarWhereWithAggregatesInput = {
    AND?: CatalogCategoryScalarWhereWithAggregatesInput | CatalogCategoryScalarWhereWithAggregatesInput[]
    OR?: CatalogCategoryScalarWhereWithAggregatesInput[]
    NOT?: CatalogCategoryScalarWhereWithAggregatesInput | CatalogCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogCategory"> | string
    name?: StringWithAggregatesFilter<"CatalogCategory"> | string
    parentId?: StringNullableWithAggregatesFilter<"CatalogCategory"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogCategory"> | Date | string
  }

  export type CatalogVendorWhereInput = {
    AND?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    OR?: CatalogVendorWhereInput[]
    NOT?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    id?: StringFilter<"CatalogVendor"> | string
    name?: StringFilter<"CatalogVendor"> | string
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    products?: CatalogProductListRelationFilter
  }

  export type CatalogVendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: CatalogProductOrderByRelationAggregateInput
  }

  export type CatalogVendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    OR?: CatalogVendorWhereInput[]
    NOT?: CatalogVendorWhereInput | CatalogVendorWhereInput[]
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    products?: CatalogProductListRelationFilter
  }, "id" | "name">

  export type CatalogVendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogVendorCountOrderByAggregateInput
    _max?: CatalogVendorMaxOrderByAggregateInput
    _min?: CatalogVendorMinOrderByAggregateInput
  }

  export type CatalogVendorScalarWhereWithAggregatesInput = {
    AND?: CatalogVendorScalarWhereWithAggregatesInput | CatalogVendorScalarWhereWithAggregatesInput[]
    OR?: CatalogVendorScalarWhereWithAggregatesInput[]
    NOT?: CatalogVendorScalarWhereWithAggregatesInput | CatalogVendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogVendor"> | string
    name?: StringWithAggregatesFilter<"CatalogVendor"> | string
    description?: StringNullableWithAggregatesFilter<"CatalogVendor"> | string | null
    image?: StringNullableWithAggregatesFilter<"CatalogVendor"> | string | null
    active?: BoolWithAggregatesFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatalogVendor"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    companyId?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    context?: JsonNullableWithAggregatesFilter<"AuditLog">
    comment?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type PrinterWhereInput = {
    AND?: PrinterWhereInput | PrinterWhereInput[]
    OR?: PrinterWhereInput[]
    NOT?: PrinterWhereInput | PrinterWhereInput[]
    id?: StringFilter<"Printer"> | string
    printerIdentifier?: StringFilter<"Printer"> | string
    tailScaleIP?: StringFilter<"Printer"> | string
    portNumber?: StringFilter<"Printer"> | string
    privateIPAddress?: StringFilter<"Printer"> | string
  }

  export type PrinterOrderByWithRelationInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    printerIdentifier?: string
    tailScaleIP?: string
    portNumber?: string
    privateIPAddress?: string
    AND?: PrinterWhereInput | PrinterWhereInput[]
    OR?: PrinterWhereInput[]
    NOT?: PrinterWhereInput | PrinterWhereInput[]
  }, "id" | "printerIdentifier" | "tailScaleIP" | "portNumber" | "privateIPAddress">

  export type PrinterOrderByWithAggregationInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
    _count?: PrinterCountOrderByAggregateInput
    _max?: PrinterMaxOrderByAggregateInput
    _min?: PrinterMinOrderByAggregateInput
  }

  export type PrinterScalarWhereWithAggregatesInput = {
    AND?: PrinterScalarWhereWithAggregatesInput | PrinterScalarWhereWithAggregatesInput[]
    OR?: PrinterScalarWhereWithAggregatesInput[]
    NOT?: PrinterScalarWhereWithAggregatesInput | PrinterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Printer"> | string
    printerIdentifier?: StringWithAggregatesFilter<"Printer"> | string
    tailScaleIP?: StringWithAggregatesFilter<"Printer"> | string
    portNumber?: StringWithAggregatesFilter<"Printer"> | string
    privateIPAddress?: StringWithAggregatesFilter<"Printer"> | string
  }

  export type CompanyUserWhereInput = {
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CompanyUserOrderByWithRelationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CompanyUserWhereUniqueInput = Prisma.AtLeast<{
    userId_companyId?: CompanyUserUserIdCompanyIdCompoundUniqueInput
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_companyId">

  export type CompanyUserOrderByWithAggregationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyUserCountOrderByAggregateInput
    _max?: CompanyUserMaxOrderByAggregateInput
    _min?: CompanyUserMinOrderByAggregateInput
  }

  export type CompanyUserScalarWhereWithAggregatesInput = {
    AND?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    OR?: CompanyUserScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"CompanyUser"> | string
    companyId?: StringWithAggregatesFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleWithAggregatesFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
  }

  export type CompanyUserPermissionWhereInput = {
    AND?: CompanyUserPermissionWhereInput | CompanyUserPermissionWhereInput[]
    OR?: CompanyUserPermissionWhereInput[]
    NOT?: CompanyUserPermissionWhereInput | CompanyUserPermissionWhereInput[]
    id?: StringFilter<"CompanyUserPermission"> | string
    userId?: StringFilter<"CompanyUserPermission"> | string
    companyId?: StringFilter<"CompanyUserPermission"> | string
    permission?: EnumCompanyPermissionFilter<"CompanyUserPermission"> | $Enums.CompanyPermission
    role?: EnumCompanyRoleFilter<"CompanyUserPermission"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CompanyUserPermissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    permission?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyUserPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_companyId_permission?: CompanyUserPermissionUserIdCompanyIdPermissionCompoundUniqueInput
    AND?: CompanyUserPermissionWhereInput | CompanyUserPermissionWhereInput[]
    OR?: CompanyUserPermissionWhereInput[]
    NOT?: CompanyUserPermissionWhereInput | CompanyUserPermissionWhereInput[]
    userId?: StringFilter<"CompanyUserPermission"> | string
    companyId?: StringFilter<"CompanyUserPermission"> | string
    permission?: EnumCompanyPermissionFilter<"CompanyUserPermission"> | $Enums.CompanyPermission
    role?: EnumCompanyRoleFilter<"CompanyUserPermission"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "userId_companyId_permission">

  export type CompanyUserPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    permission?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyUserPermissionCountOrderByAggregateInput
    _max?: CompanyUserPermissionMaxOrderByAggregateInput
    _min?: CompanyUserPermissionMinOrderByAggregateInput
  }

  export type CompanyUserPermissionScalarWhereWithAggregatesInput = {
    AND?: CompanyUserPermissionScalarWhereWithAggregatesInput | CompanyUserPermissionScalarWhereWithAggregatesInput[]
    OR?: CompanyUserPermissionScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserPermissionScalarWhereWithAggregatesInput | CompanyUserPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyUserPermission"> | string
    userId?: StringWithAggregatesFilter<"CompanyUserPermission"> | string
    companyId?: StringWithAggregatesFilter<"CompanyUserPermission"> | string
    permission?: EnumCompanyPermissionWithAggregatesFilter<"CompanyUserPermission"> | $Enums.CompanyPermission
    role?: EnumCompanyRoleWithAggregatesFilter<"CompanyUserPermission"> | $Enums.CompanyRole
    createdAt?: DateTimeWithAggregatesFilter<"CompanyUserPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyUserPermission"> | Date | string
  }

  export type CompanyPatientWhereInput = {
    AND?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    OR?: CompanyPatientWhereInput[]
    NOT?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type CompanyPatientOrderByWithRelationInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type CompanyPatientWhereUniqueInput = Prisma.AtLeast<{
    externalId_companyId?: CompanyPatientExternalIdCompanyIdCompoundUniqueInput
    patientId_companyId?: CompanyPatientPatientIdCompanyIdCompoundUniqueInput
    AND?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    OR?: CompanyPatientWhereInput[]
    NOT?: CompanyPatientWhereInput | CompanyPatientWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "patientId_companyId" | "externalId_companyId">

  export type CompanyPatientOrderByWithAggregationInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyPatientCountOrderByAggregateInput
    _max?: CompanyPatientMaxOrderByAggregateInput
    _min?: CompanyPatientMinOrderByAggregateInput
  }

  export type CompanyPatientScalarWhereWithAggregatesInput = {
    AND?: CompanyPatientScalarWhereWithAggregatesInput | CompanyPatientScalarWhereWithAggregatesInput[]
    OR?: CompanyPatientScalarWhereWithAggregatesInput[]
    NOT?: CompanyPatientScalarWhereWithAggregatesInput | CompanyPatientScalarWhereWithAggregatesInput[]
    patientId?: StringWithAggregatesFilter<"CompanyPatient"> | string
    companyId?: StringWithAggregatesFilter<"CompanyPatient"> | string
    externalId?: StringNullableWithAggregatesFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyPatient"> | Date | string
  }

  export type FacilityUserWhereInput = {
    AND?: FacilityUserWhereInput | FacilityUserWhereInput[]
    OR?: FacilityUserWhereInput[]
    NOT?: FacilityUserWhereInput | FacilityUserWhereInput[]
    userId?: StringFilter<"FacilityUser"> | string
    facilityId?: StringFilter<"FacilityUser"> | string
    createdAt?: DateTimeFilter<"FacilityUser"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityUser"> | Date | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FacilityUserOrderByWithRelationInput = {
    userId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FacilityUserWhereUniqueInput = Prisma.AtLeast<{
    userId_facilityId?: FacilityUserUserIdFacilityIdCompoundUniqueInput
    AND?: FacilityUserWhereInput | FacilityUserWhereInput[]
    OR?: FacilityUserWhereInput[]
    NOT?: FacilityUserWhereInput | FacilityUserWhereInput[]
    userId?: StringFilter<"FacilityUser"> | string
    facilityId?: StringFilter<"FacilityUser"> | string
    createdAt?: DateTimeFilter<"FacilityUser"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityUser"> | Date | string
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_facilityId">

  export type FacilityUserOrderByWithAggregationInput = {
    userId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityUserCountOrderByAggregateInput
    _max?: FacilityUserMaxOrderByAggregateInput
    _min?: FacilityUserMinOrderByAggregateInput
  }

  export type FacilityUserScalarWhereWithAggregatesInput = {
    AND?: FacilityUserScalarWhereWithAggregatesInput | FacilityUserScalarWhereWithAggregatesInput[]
    OR?: FacilityUserScalarWhereWithAggregatesInput[]
    NOT?: FacilityUserScalarWhereWithAggregatesInput | FacilityUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"FacilityUser"> | string
    facilityId?: StringWithAggregatesFilter<"FacilityUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FacilityUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacilityUser"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    companies?: CompanyUserListRelationFilter
    permissions?: CompanyUserPermissionListRelationFilter
    facilities?: FacilityUserListRelationFilter
    clinician?: XOR<ClinicianNullableRelationFilter, ClinicianWhereInput> | null
    notes?: WorkbenchNotesListRelationFilter
    auditsLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    companies?: CompanyUserOrderByRelationAggregateInput
    permissions?: CompanyUserPermissionOrderByRelationAggregateInput
    facilities?: FacilityUserOrderByRelationAggregateInput
    clinician?: ClinicianOrderByWithRelationInput
    notes?: WorkbenchNotesOrderByRelationAggregateInput
    auditsLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    companies?: CompanyUserListRelationFilter
    permissions?: CompanyUserPermissionListRelationFilter
    facilities?: FacilityUserListRelationFilter
    clinician?: XOR<ClinicianNullableRelationFilter, ClinicianWhereInput> | null
    notes?: WorkbenchNotesListRelationFilter
    auditsLogs?: AuditLogListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    pin?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    profileId_provider?: AccountProfileIdProviderCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "profileId_provider">

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Account"> | string
    profileId?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    id_companyId?: ApiKeyIdCompanyIdCompoundUniqueInput
    key_companyId?: ApiKeyKeyCompanyIdCompoundUniqueInput
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "key" | "id_companyId" | "key_companyId">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    companyId?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type ViewFlattenedWorkbenchWhereInput = {
    AND?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    OR?: ViewFlattenedWorkbenchWhereInput[]
    NOT?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    workbenchId?: StringFilter<"ViewFlattenedWorkbench"> | string
    companyId?: StringFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    companySlug?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    createdReason?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    slicerProfile?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeSize?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
  }

  export type ViewFlattenedWorkbenchOrderByWithRelationInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrderInput | SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderStatus?: SortOrderInput | SortOrder
    companySlug?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    slicerProfile?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    clinicianName?: SortOrderInput | SortOrder
    clinicianId?: SortOrderInput | SortOrder
    patientFirstName?: SortOrderInput | SortOrder
    patientLastName?: SortOrderInput | SortOrder
    orderCreatedAt?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    orderCompletedAt?: SortOrderInput | SortOrder
    isDiabetic?: SortOrderInput | SortOrder
    orderSide?: SortOrderInput | SortOrder
    orderQuantity?: SortOrderInput | SortOrder
    orderShoeSize?: SortOrderInput | SortOrder
    orderGender?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    printingStartedAt?: SortOrderInput | SortOrder
    printingStartedBy?: SortOrderInput | SortOrder
    grindingCompletedAt?: SortOrderInput | SortOrder
    grindingCompletedBy?: SortOrderInput | SortOrder
    gluingCompletedAt?: SortOrderInput | SortOrder
    gluingCompletedBy?: SortOrderInput | SortOrder
    finishingCompletedAt?: SortOrderInput | SortOrder
    finishingCompletedBy?: SortOrderInput | SortOrder
    shippingCompletedAt?: SortOrderInput | SortOrder
    shippingCompletedBy?: SortOrderInput | SortOrder
    printingCompletedAt?: SortOrderInput | SortOrder
    printingCompletedBy?: SortOrderInput | SortOrder
    addonCompletedAt?: SortOrderInput | SortOrder
    addonCompletedBy?: SortOrderInput | SortOrder
    validationStatus?: SortOrderInput | SortOrder
    deviceTypeName?: SortOrderInput | SortOrder
    taikaId?: SortOrderInput | SortOrder
    taikaDevId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
  }

  export type ViewFlattenedWorkbenchWhereUniqueInput = Prisma.AtLeast<{
    workbenchId?: string
    AND?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    OR?: ViewFlattenedWorkbenchWhereInput[]
    NOT?: ViewFlattenedWorkbenchWhereInput | ViewFlattenedWorkbenchWhereInput[]
    companyId?: StringFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    companySlug?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    createdReason?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    slicerProfile?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeSize?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableFilter<"ViewFlattenedWorkbench"> | string | null
  }, "workbenchId">

  export type ViewFlattenedWorkbenchOrderByWithAggregationInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrderInput | SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderStatus?: SortOrderInput | SortOrder
    companySlug?: SortOrderInput | SortOrder
    createdReason?: SortOrderInput | SortOrder
    slicerProfile?: SortOrderInput | SortOrder
    poNumber?: SortOrderInput | SortOrder
    clinicianName?: SortOrderInput | SortOrder
    clinicianId?: SortOrderInput | SortOrder
    patientFirstName?: SortOrderInput | SortOrder
    patientLastName?: SortOrderInput | SortOrder
    orderCreatedAt?: SortOrderInput | SortOrder
    authorizationUpdatedAt?: SortOrderInput | SortOrder
    orderCompletedAt?: SortOrderInput | SortOrder
    isDiabetic?: SortOrderInput | SortOrder
    orderSide?: SortOrderInput | SortOrder
    orderQuantity?: SortOrderInput | SortOrder
    orderShoeSize?: SortOrderInput | SortOrder
    orderGender?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    printingStartedAt?: SortOrderInput | SortOrder
    printingStartedBy?: SortOrderInput | SortOrder
    grindingCompletedAt?: SortOrderInput | SortOrder
    grindingCompletedBy?: SortOrderInput | SortOrder
    gluingCompletedAt?: SortOrderInput | SortOrder
    gluingCompletedBy?: SortOrderInput | SortOrder
    finishingCompletedAt?: SortOrderInput | SortOrder
    finishingCompletedBy?: SortOrderInput | SortOrder
    shippingCompletedAt?: SortOrderInput | SortOrder
    shippingCompletedBy?: SortOrderInput | SortOrder
    printingCompletedAt?: SortOrderInput | SortOrder
    printingCompletedBy?: SortOrderInput | SortOrder
    addonCompletedAt?: SortOrderInput | SortOrder
    addonCompletedBy?: SortOrderInput | SortOrder
    validationStatus?: SortOrderInput | SortOrder
    deviceTypeName?: SortOrderInput | SortOrder
    taikaId?: SortOrderInput | SortOrder
    taikaDevId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    _count?: ViewFlattenedWorkbenchCountOrderByAggregateInput
    _avg?: ViewFlattenedWorkbenchAvgOrderByAggregateInput
    _max?: ViewFlattenedWorkbenchMaxOrderByAggregateInput
    _min?: ViewFlattenedWorkbenchMinOrderByAggregateInput
    _sum?: ViewFlattenedWorkbenchSumOrderByAggregateInput
  }

  export type ViewFlattenedWorkbenchScalarWhereWithAggregatesInput = {
    AND?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput | ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    OR?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    NOT?: ViewFlattenedWorkbenchScalarWhereWithAggregatesInput | ViewFlattenedWorkbenchScalarWhereWithAggregatesInput[]
    workbenchId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    companyId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    workbenchStatus?: EnumWorkbenchStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.WorkbenchStatus | null
    evaluationId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    patientId?: StringWithAggregatesFilter<"ViewFlattenedWorkbench"> | string
    orderId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderStatus?: EnumOrderStatusNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | $Enums.OrderStatus | null
    companySlug?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    createdReason?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    slicerProfile?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    poNumber?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    clinicianId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    patientFirstName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    patientLastName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderCreatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    authorizationUpdatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    orderCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    isDiabetic?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    orderSide?: IntNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | number | null
    orderQuantity?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderShoeSize?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    orderGender?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingStartedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    grindingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    grindingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    gluingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    gluingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    finishingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    finishingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    shippingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    shippingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    printingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    printingCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    addonCompletedAt?: DateTimeNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | Date | string | null
    addonCompletedBy?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    validationStatus?: BoolNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | boolean | null
    deviceTypeName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    taikaId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    taikaDevId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"ViewFlattenedWorkbench"> | string | null
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    address?: FacilityAddressCreateNestedOneWithoutFacilityInput
    users?: FacilityUserCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: FacilityAddressUncheckedCreateNestedOneWithoutFacilityInput
    users?: FacilityUserUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    address?: FacilityAddressUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: FacilityAddressUncheckedUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicianCreateInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutClinicianInput
    evaluations?: EvaluationCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUncheckedCreateInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutClinicianNestedInput
    evaluations?: EvaluationUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianCreateManyInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateManyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootCreateInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootCreateManyInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    foot: FootCreateNestedOneWithoutAssetsInput
    workbenches?: WorkbenchCreateNestedManyWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foot?: FootUpdateOneRequiredWithoutAssetsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchCreateManyInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesCreateInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workbench: WorkbenchCreateNestedOneWithoutNotesInput
    createdByUser?: UserCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workbench?: WorkbenchUpdateOneRequiredWithoutNotesNestedInput
    createdByUser?: UserUpdateOneWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesCreateManyInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    workbenchId: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityAddressCreateInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type FacilityAddressUncheckedCreateInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityId: string
  }

  export type FacilityAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type FacilityAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityId?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityAddressCreateManyInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityId: string
  }

  export type FacilityAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityId?: StringFieldUpdateOperationsInput | string
  }

  export type ShippingPackageCreateInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackagesInput
  }

  export type ShippingPackageUncheckedCreateInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type ShippingPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageCreateManyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicianCreateInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutReferringPhysicianInput
    patient?: PatientCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUncheckedCreateInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput
    patient?: PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutReferringPhysicianNestedInput
    patient?: PatientUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput
    patient?: PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianCreateManyInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhysicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhysicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisCreateManyInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeCreateInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUncheckedCreateInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeCreateManyInput = {
    id?: string
    summary?: string | null
    description: string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    justifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTypeCreateInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
    evaluations?: EvaluationCreateNestedManyWithoutDeviceTypeInput
  }

  export type DeviceTypeUncheckedCreateInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDeviceTypeInput
  }

  export type DeviceTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
    evaluations?: EvaluationUpdateManyWithoutDeviceTypeNestedInput
  }

  export type DeviceTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutDeviceTypeNestedInput
  }

  export type DeviceTypeCreateManyInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VisitTypeCreateInput = {
    id?: string
    name: string
    evaluations?: EvaluationCreateNestedManyWithoutVisitTypeInput
  }

  export type VisitTypeUncheckedCreateInput = {
    id?: string
    name: string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutVisitTypeInput
  }

  export type VisitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    evaluations?: EvaluationUpdateManyWithoutVisitTypeNestedInput
  }

  export type VisitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutVisitTypeNestedInput
  }

  export type VisitTypeCreateManyInput = {
    id?: string
    name: string
  }

  export type VisitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VisitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FormSchemaCreateInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionCreateNestedManyWithoutSchemaInput
  }

  export type FormSchemaUncheckedCreateInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type FormSchemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUpdateManyWithoutSchemaNestedInput
  }

  export type FormSchemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type FormSchemaCreateManyInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSchemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: FormSchemaCreateNestedOneWithoutSubmissionsInput
    workbench: WorkbenchCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    schemaId: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    schemaId: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: CatalogProductCreateNestedOneWithoutAttributesInput
  }

  export type CatalogProductAttributeUncheckedCreateInput = {
    id?: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CatalogProductUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type CatalogProductAttributeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateManyInput = {
    id?: string
    productId: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: CatalogProductCreateNestedOneWithoutVariantsInput
  }

  export type CatalogProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CatalogProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type CatalogProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantCreateManyInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductCreateNestedManyWithoutCategoriesInput
  }

  export type CatalogCategoryUncheckedCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CatalogCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CatalogCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CatalogCategoryCreateManyInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductCreateNestedManyWithoutVendorsInput
  }

  export type CatalogVendorUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: CatalogProductUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type CatalogVendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUpdateManyWithoutVendorsNestedInput
  }

  export type CatalogVendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: CatalogProductUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type CatalogVendorCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsLogsInput
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsLogsNestedInput
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrinterCreateInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUncheckedCreateInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterCreateManyInput = {
    id?: string
    printerIdentifier: string
    tailScaleIP: string
    portNumber: string
    privateIPAddress: string
  }

  export type PrinterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type PrinterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    printerIdentifier?: StringFieldUpdateOperationsInput | string
    tailScaleIP?: StringFieldUpdateOperationsInput | string
    portNumber?: StringFieldUpdateOperationsInput | string
    privateIPAddress?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUserCreateInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateInput = {
    userId: string
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserUpdateInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateManyInput = {
    userId: string
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserUpdateManyMutationInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionCreateInput = {
    id?: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPermissionsInput
    company: CompanyCreateNestedOneWithoutPermissionsInput
  }

  export type CompanyUserPermissionUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type CompanyUserPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientCreateInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPatientsInput
    patient: PatientCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyPatientUncheckedCreateInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientUpdateInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPatientsNestedInput
    patient?: PatientUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyPatientUncheckedUpdateInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientCreateManyInput = {
    patientId: string
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientUpdateManyMutationInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUncheckedUpdateManyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityUserUncheckedCreateInput = {
    userId: string
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutFacilitiesNestedInput
  }

  export type FacilityUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserCreateManyInput = {
    userId: string
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    userId: string
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    userId: string
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    key: string
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    key: string
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewFlattenedWorkbenchCreateInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    companySlug?: string | null
    createdReason?: string | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    orderShoeSize?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUncheckedCreateInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    companySlug?: string | null
    createdReason?: string | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    orderShoeSize?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUpdateInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableStringFieldUpdateOperationsInput | string | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchUncheckedUpdateInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableStringFieldUpdateOperationsInput | string | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchCreateManyInput = {
    workbenchId: string
    companyId: string
    workbenchStatus?: $Enums.WorkbenchStatus | null
    evaluationId: string
    patientId: string
    orderId?: string | null
    orderStatus?: $Enums.OrderStatus | null
    companySlug?: string | null
    createdReason?: string | null
    slicerProfile?: string | null
    poNumber?: string | null
    clinicianName?: string | null
    clinicianId?: string | null
    patientFirstName?: string | null
    patientLastName?: string | null
    orderCreatedAt?: Date | string | null
    authorizationUpdatedAt?: Date | string | null
    orderCompletedAt?: Date | string | null
    isDiabetic?: boolean | null
    orderSide?: number | null
    orderQuantity?: string | null
    orderShoeSize?: string | null
    orderGender?: string | null
    validatedAt?: Date | string | null
    printingStartedAt?: Date | string | null
    printingStartedBy?: string | null
    grindingCompletedAt?: Date | string | null
    grindingCompletedBy?: string | null
    gluingCompletedAt?: Date | string | null
    gluingCompletedBy?: string | null
    finishingCompletedAt?: Date | string | null
    finishingCompletedBy?: string | null
    shippingCompletedAt?: Date | string | null
    shippingCompletedBy?: string | null
    printingCompletedAt?: Date | string | null
    printingCompletedBy?: string | null
    addonCompletedAt?: Date | string | null
    addonCompletedBy?: string | null
    validationStatus?: boolean | null
    deviceTypeName?: string | null
    taikaId?: string | null
    taikaDevId?: string | null
    externalId?: string | null
    companyName?: string | null
  }

  export type ViewFlattenedWorkbenchUpdateManyMutationInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableStringFieldUpdateOperationsInput | string | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewFlattenedWorkbenchUncheckedUpdateManyInput = {
    workbenchId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workbenchStatus?: NullableEnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus | null
    evaluationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    companySlug?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableStringFieldUpdateOperationsInput | string | null
    slicerProfile?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicianId?: NullableStringFieldUpdateOperationsInput | string | null
    patientFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    patientLastName?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDiabetic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderSide?: NullableIntFieldUpdateOperationsInput | number | null
    orderQuantity?: NullableStringFieldUpdateOperationsInput | string | null
    orderShoeSize?: NullableStringFieldUpdateOperationsInput | string | null
    orderGender?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingStartedBy?: NullableStringFieldUpdateOperationsInput | string | null
    grindingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grindingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    gluingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gluingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    finishingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    printingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    printingCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addonCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addonCompletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    taikaId?: NullableStringFieldUpdateOperationsInput | string | null
    taikaDevId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FacilityListRelationFilter = {
    every?: FacilityWhereInput
    some?: FacilityWhereInput
    none?: FacilityWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ShippingPackageListRelationFilter = {
    every?: ShippingPackageWhereInput
    some?: ShippingPackageWhereInput
    none?: ShippingPackageWhereInput
  }

  export type CompanyUserListRelationFilter = {
    every?: CompanyUserWhereInput
    some?: CompanyUserWhereInput
    none?: CompanyUserWhereInput
  }

  export type CompanyUserPermissionListRelationFilter = {
    every?: CompanyUserPermissionWhereInput
    some?: CompanyUserPermissionWhereInput
    none?: CompanyUserPermissionWhereInput
  }

  export type CompanyPatientListRelationFilter = {
    every?: CompanyPatientWhereInput
    some?: CompanyPatientWhereInput
    none?: CompanyPatientWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FacilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingPackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyUserPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyPatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    preferences?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logoUrl?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type FacilityAddressNullableRelationFilter = {
    is?: FacilityAddressWhereInput | null
    isNot?: FacilityAddressWhereInput | null
  }

  export type FacilityUserListRelationFilter = {
    every?: FacilityUserWhereInput
    some?: FacilityUserWhereInput
    none?: FacilityUserWhereInput
  }

  export type FacilityUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type PhysicianNullableRelationFilter = {
    is?: PhysicianWhereInput | null
    isNot?: PhysicianWhereInput | null
  }

  export type FootListRelationFilter = {
    every?: FootWhereInput
    some?: FootWhereInput
    none?: FootWhereInput
  }

  export type WorkbenchListRelationFilter = {
    every?: WorkbenchWhereInput
    some?: WorkbenchWhereInput
    none?: WorkbenchWhereInput
  }

  export type FootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    maritalStatus?: SortOrder
    photoUrl?: SortOrder
    active?: SortOrder
    deceasedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryPhysicianId?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClinicianCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicianMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicianMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeFilter<$PrismaModel> | $Enums.CareType
  }

  export type EnumSideNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableFilter<$PrismaModel> | $Enums.Side | null
  }

  export type EnumVerticalPositionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableFilter<$PrismaModel> | $Enums.VerticalPosition | null
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type DeviceTypeNullableRelationFilter = {
    is?: DeviceTypeWhereInput | null
    isNot?: DeviceTypeWhereInput | null
  }

  export type VisitTypeNullableRelationFilter = {
    is?: VisitTypeWhereInput | null
    isNot?: VisitTypeWhereInput | null
  }

  export type DiagnosisNullableRelationFilter = {
    is?: DiagnosisWhereInput | null
    isNot?: DiagnosisWhereInput | null
  }

  export type FacilityNullableRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type ClinicianListRelationFilter = {
    every?: ClinicianWhereInput
    some?: ClinicianWhereInput
    none?: ClinicianWhereInput
  }

  export type ClinicianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationIdCompanyIdCompoundUniqueInput = {
    id: string
    companyId: string
  }

  export type EvaluationExternalIdCompanyIdCompoundUniqueInput = {
    externalId: string
    companyId: string
  }

  export type EvaluationPoNumberCompanyIdCompoundUniqueInput = {
    poNumber: string
    companyId: string
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    patientId?: SortOrder
    companyId?: SortOrder
    deviceTypeId?: SortOrder
    isDiabetic?: SortOrder
    isVeteran?: SortOrder
    deviceSide?: SortOrder
    devicePosition?: SortOrder
    appointmentAt?: SortOrder
    appointmentStatus?: SortOrder
    referringPhysicianId?: SortOrder
    diagnosisId?: SortOrder
    diagnosisedAt?: SortOrder
    visitTypeId?: SortOrder
    visitedAt?: SortOrder
    facilityId?: SortOrder
    location?: SortOrder
    prescribedAt?: SortOrder
    prescribedActive?: SortOrder
    primaryInsurance?: SortOrder
    secondaryInsurance?: SortOrder
    submittedAt?: SortOrder
    startedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTypeFilter<$PrismaModel>
  }

  export type EnumSideNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableWithAggregatesFilter<$PrismaModel> | $Enums.Side | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSideNullableFilter<$PrismaModel>
    _max?: NestedEnumSideNullableFilter<$PrismaModel>
  }

  export type EnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerticalPosition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
    _max?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
  }

  export type EnumSideFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideFilter<$PrismaModel> | $Enums.Side
  }

  export type EnumShoeWidthFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeWidthFilter<$PrismaModel> | $Enums.ShoeWidth
  }

  export type EnumShoeSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemFilter<$PrismaModel> | $Enums.ShoeSystem
  }

  export type EnumInactiveFootReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel> | $Enums.InactiveFootReason | null
  }

  export type WorkbenchRelationFilter = {
    is?: WorkbenchWhereInput
    isNot?: WorkbenchWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FootCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    questionnaire?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootAvgOrderByAggregateInput = {
    shoeSize?: SortOrder
  }

  export type FootMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    workbenchId?: SortOrder
    side?: SortOrder
    shoeSize?: SortOrder
    shoeWidth?: SortOrder
    shoeGender?: SortOrder
    shoeSystem?: SortOrder
    shoeBrand?: SortOrder
    shoeModel?: SortOrder
    inactiveReason?: SortOrder
    isChild?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FootSumOrderByAggregateInput = {
    shoeSize?: SortOrder
  }

  export type EnumSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideWithAggregatesFilter<$PrismaModel> | $Enums.Side
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSideFilter<$PrismaModel>
    _max?: NestedEnumSideFilter<$PrismaModel>
  }

  export type EnumShoeWidthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeWidthWithAggregatesFilter<$PrismaModel> | $Enums.ShoeWidth
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeWidthFilter<$PrismaModel>
    _max?: NestedEnumShoeWidthFilter<$PrismaModel>
  }

  export type EnumShoeSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel> | $Enums.ShoeSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeSystemFilter<$PrismaModel>
    _max?: NestedEnumShoeSystemFilter<$PrismaModel>
  }

  export type EnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.InactiveFootReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type EnumAssetStatusNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel> | null
    has?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    hasSome?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FootRelationFilter = {
    is?: FootWhereInput
    isNot?: FootWhereInput
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    statusCheckpoints?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    footId?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusUpdatedAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type EnumSideNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    has?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sides?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchCreatedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
  }

  export type EnumWorkbenchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusFilter<$PrismaModel> | $Enums.WorkbenchStatus
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type EvaluationRelationFilter = {
    is?: EvaluationWhereInput
    isNot?: EvaluationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type WorkbenchNotesListRelationFilter = {
    every?: WorkbenchNotesWhereInput
    some?: WorkbenchNotesWhereInput
    none?: WorkbenchNotesWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchNotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkbenchCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    customization?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkbenchMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkbenchMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    productId?: SortOrder
    evaluationId?: SortOrder
    webhookUrl?: SortOrder
    createdReason?: SortOrder
    status?: SortOrder
    failedAt?: SortOrder
    completedAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
  }

  export type EnumWorkbenchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WorkbenchNotesCountOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    blocks?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkbenchNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkbenchNotesMinOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumOrderAuthorizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    workbenchId?: SortOrder
    status?: SortOrder
    statusUpdatedAt?: SortOrder
    committedDeliveryAt?: SortOrder
    parcelId?: SortOrder
    active?: SortOrder
    authorizationStatus?: SortOrder
    authorizationUpdatedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
  }

  export type EnumCarrierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableFilter<$PrismaModel> | $Enums.Carrier | null
  }

  export type FacilityRelationFilter = {
    is?: FacilityWhereInput
    isNot?: FacilityWhereInput
  }

  export type FacilityAddressCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityId?: SortOrder
  }

  export type FacilityAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityId?: SortOrder
  }

  export type FacilityAddressMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    stateOrProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    shippingAccountId?: SortOrder
    shippingAccountCarrier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityId?: SortOrder
  }

  export type EnumCarrierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel> | $Enums.Carrier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCarrierNullableFilter<$PrismaModel>
    _max?: NestedEnumCarrierNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumWeightUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitFilter<$PrismaModel> | $Enums.WeightUnit
  }

  export type EnumDimensionUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitFilter<$PrismaModel> | $Enums.DimensionUnit
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ShippingPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageAvgOrderByAggregateInput = {
    weight?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    insoleCapacity?: SortOrder
  }

  export type ShippingPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    dimensionUnit?: SortOrder
    insoleCapacity?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingPackageSumOrderByAggregateInput = {
    weight?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    insoleCapacity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumWeightUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel> | $Enums.WeightUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeightUnitFilter<$PrismaModel>
    _max?: NestedEnumWeightUnitFilter<$PrismaModel>
  }

  export type EnumDimensionUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhysicianCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicianMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhysicianMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npi?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDiagnosisStandardFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardFilter<$PrismaModel> | $Enums.DiagnosisStandard
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    diabetic?: SortOrder
    standard?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDiagnosisStandardWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel> | $Enums.DiagnosisStandard
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
    _max?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
  }

  export type BillingCodeCountOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    justifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingCodeMinOrderByAggregateInput = {
    id?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DeviceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type DeviceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type DeviceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    diabetic?: SortOrder
    custom?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type VisitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VisitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type VisitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumFormSchemaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel> | $Enums.FormSchemaType | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FormSchemaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSchemaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSchemaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FormSchemaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FormSchemaRelationFilter = {
    is?: FormSchemaWhereInput
    isNot?: FormSchemaWhereInput
  }

  export type FormSubmissionWorkbenchIdSchemaIdCompoundUniqueInput = {
    workbenchId: string
    schemaId: string
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    workbenchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeListRelationFilter = {
    every?: CatalogProductAttributeWhereInput
    some?: CatalogProductAttributeWhereInput
    none?: CatalogProductAttributeWhereInput
  }

  export type CatalogProductVariantListRelationFilter = {
    every?: CatalogProductVariantWhereInput
    some?: CatalogProductVariantWhereInput
    none?: CatalogProductVariantWhereInput
  }

  export type CatalogCategoryListRelationFilter = {
    every?: CatalogCategoryWhereInput
    some?: CatalogCategoryWhereInput
    none?: CatalogCategoryWhereInput
  }

  export type CatalogVendorListRelationFilter = {
    every?: CatalogVendorWhereInput
    some?: CatalogVendorWhereInput
    none?: CatalogVendorWhereInput
  }

  export type CatalogProductAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogVendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumProductAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeFilter<$PrismaModel> | $Enums.ProductAttributeType
  }

  export type CatalogProductRelationFilter = {
    is?: CatalogProductWhereInput
    isNot?: CatalogProductWhereInput
  }

  export type CatalogProductAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
  }

  export type CatalogProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    caption?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogProductVariantSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CatalogProductListRelationFilter = {
    every?: CatalogProductWhereInput
    some?: CatalogProductWhereInput
    none?: CatalogProductWhereInput
  }

  export type CatalogProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogVendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    context?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type PrinterCountOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterMaxOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type PrinterMinOrderByAggregateInput = {
    id?: SortOrder
    printerIdentifier?: SortOrder
    tailScaleIP?: SortOrder
    portNumber?: SortOrder
    privateIPAddress?: SortOrder
  }

  export type EnumCompanyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleFilter<$PrismaModel> | $Enums.CompanyRole
  }

  export type CompanyUserUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type CompanyUserCountOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserMinOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyRoleFilter<$PrismaModel>
    _max?: NestedEnumCompanyRoleFilter<$PrismaModel>
  }

  export type EnumCompanyPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyPermission | EnumCompanyPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyPermissionFilter<$PrismaModel> | $Enums.CompanyPermission
  }

  export type CompanyUserPermissionUserIdCompanyIdPermissionCompoundUniqueInput = {
    userId: string
    companyId: string
    permission: $Enums.CompanyPermission
  }

  export type CompanyUserPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    permission?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    permission?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyUserPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    permission?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCompanyPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyPermission | EnumCompanyPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyPermissionWithAggregatesFilter<$PrismaModel> | $Enums.CompanyPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyPermissionFilter<$PrismaModel>
    _max?: NestedEnumCompanyPermissionFilter<$PrismaModel>
  }

  export type CompanyPatientExternalIdCompanyIdCompoundUniqueInput = {
    externalId: string
    companyId: string
  }

  export type CompanyPatientPatientIdCompanyIdCompoundUniqueInput = {
    patientId: string
    companyId: string
  }

  export type CompanyPatientCountOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyPatientMaxOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyPatientMinOrderByAggregateInput = {
    patientId?: SortOrder
    companyId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityUserUserIdFacilityIdCompoundUniqueInput = {
    userId: string
    facilityId: string
  }

  export type FacilityUserCountOrderByAggregateInput = {
    userId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityUserMinOrderByAggregateInput = {
    userId?: SortOrder
    facilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ClinicianNullableRelationFilter = {
    is?: ClinicianWhereInput | null
    isNot?: ClinicianWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountProfileIdProviderCompoundUniqueInput = {
    profileId: string
    provider: string
  }

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder
    profileId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyIdCompanyIdCompoundUniqueInput = {
    id: string
    companyId: string
  }

  export type ApiKeyKeyCompanyIdCompoundUniqueInput = {
    key: string
    companyId: string
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkbenchStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
  }

  export type EnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ViewFlattenedWorkbenchCountOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    companySlug?: SortOrder
    createdReason?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    orderShoeSize?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchAvgOrderByAggregateInput = {
    orderSide?: SortOrder
  }

  export type ViewFlattenedWorkbenchMaxOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    companySlug?: SortOrder
    createdReason?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    orderShoeSize?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchMinOrderByAggregateInput = {
    workbenchId?: SortOrder
    companyId?: SortOrder
    workbenchStatus?: SortOrder
    evaluationId?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    orderStatus?: SortOrder
    companySlug?: SortOrder
    createdReason?: SortOrder
    slicerProfile?: SortOrder
    poNumber?: SortOrder
    clinicianName?: SortOrder
    clinicianId?: SortOrder
    patientFirstName?: SortOrder
    patientLastName?: SortOrder
    orderCreatedAt?: SortOrder
    authorizationUpdatedAt?: SortOrder
    orderCompletedAt?: SortOrder
    isDiabetic?: SortOrder
    orderSide?: SortOrder
    orderQuantity?: SortOrder
    orderShoeSize?: SortOrder
    orderGender?: SortOrder
    validatedAt?: SortOrder
    printingStartedAt?: SortOrder
    printingStartedBy?: SortOrder
    grindingCompletedAt?: SortOrder
    grindingCompletedBy?: SortOrder
    gluingCompletedAt?: SortOrder
    gluingCompletedBy?: SortOrder
    finishingCompletedAt?: SortOrder
    finishingCompletedBy?: SortOrder
    shippingCompletedAt?: SortOrder
    shippingCompletedBy?: SortOrder
    printingCompletedAt?: SortOrder
    printingCompletedBy?: SortOrder
    addonCompletedAt?: SortOrder
    addonCompletedBy?: SortOrder
    validationStatus?: SortOrder
    deviceTypeName?: SortOrder
    taikaId?: SortOrder
    taikaDevId?: SortOrder
    externalId?: SortOrder
    companyName?: SortOrder
  }

  export type ViewFlattenedWorkbenchSumOrderByAggregateInput = {
    orderSide?: SortOrder
  }

  export type EnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FacilityCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ShippingPackageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyUserPermissionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput> | CompanyUserPermissionCreateWithoutCompanyInput[] | CompanyUserPermissionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutCompanyInput | CompanyUserPermissionCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserPermissionCreateManyCompanyInputEnvelope
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
  }

  export type CompanyPatientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput> | CompanyUserPermissionCreateWithoutCompanyInput[] | CompanyUserPermissionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutCompanyInput | CompanyUserPermissionCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserPermissionCreateManyCompanyInputEnvelope
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
  }

  export type CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FacilityUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutCompanyInput | FacilityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutCompanyInput | FacilityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutCompanyInput | FacilityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCompanyInput | EvaluationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCompanyInput | EvaluationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCompanyInput | EvaluationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutCompanyInput | ApiKeyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutCompanyInput | ApiKeyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutCompanyInput | ApiKeyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ShippingPackageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    upsert?: ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput | ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    set?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    disconnect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    delete?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    update?: ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput | ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShippingPackageUpdateManyWithWhereWithoutCompanyInput | ShippingPackageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyUserPermissionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput> | CompanyUserPermissionCreateWithoutCompanyInput[] | CompanyUserPermissionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutCompanyInput | CompanyUserPermissionCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserPermissionUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserPermissionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserPermissionCreateManyCompanyInputEnvelope
    set?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    disconnect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    delete?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    update?: CompanyUserPermissionUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserPermissionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserPermissionUpdateManyWithWhereWithoutCompanyInput | CompanyUserPermissionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
  }

  export type CompanyPatientUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput | CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput | CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutCompanyInput | CompanyPatientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput> | FacilityCreateWithoutCompanyInput[] | FacilityUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutCompanyInput | FacilityCreateOrConnectWithoutCompanyInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutCompanyInput | FacilityUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FacilityCreateManyCompanyInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutCompanyInput | FacilityUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutCompanyInput | FacilityUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput> | EvaluationCreateWithoutCompanyInput[] | EvaluationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCompanyInput | EvaluationCreateOrConnectWithoutCompanyInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCompanyInput | EvaluationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EvaluationCreateManyCompanyInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCompanyInput | EvaluationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCompanyInput | EvaluationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput> | ApiKeyCreateWithoutCompanyInput[] | ApiKeyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutCompanyInput | ApiKeyCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutCompanyInput | ApiKeyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiKeyCreateManyCompanyInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutCompanyInput | ApiKeyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutCompanyInput | ApiKeyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput> | ShippingPackageCreateWithoutCompanyInput[] | ShippingPackageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShippingPackageCreateOrConnectWithoutCompanyInput | ShippingPackageCreateOrConnectWithoutCompanyInput[]
    upsert?: ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput | ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShippingPackageCreateManyCompanyInputEnvelope
    set?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    disconnect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    delete?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    connect?: ShippingPackageWhereUniqueInput | ShippingPackageWhereUniqueInput[]
    update?: ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput | ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShippingPackageUpdateManyWithWhereWithoutCompanyInput | ShippingPackageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput> | CompanyUserPermissionCreateWithoutCompanyInput[] | CompanyUserPermissionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutCompanyInput | CompanyUserPermissionCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserPermissionUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserPermissionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserPermissionCreateManyCompanyInputEnvelope
    set?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    disconnect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    delete?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    update?: CompanyUserPermissionUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserPermissionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserPermissionUpdateManyWithWhereWithoutCompanyInput | CompanyUserPermissionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
  }

  export type CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput> | CompanyPatientCreateWithoutCompanyInput[] | CompanyPatientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutCompanyInput | CompanyPatientCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput | CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyPatientCreateManyCompanyInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput | CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutCompanyInput | CompanyPatientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFacilitiesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FacilityAddressCreateNestedOneWithoutFacilityInput = {
    create?: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: FacilityAddressCreateOrConnectWithoutFacilityInput
    connect?: FacilityAddressWhereUniqueInput
  }

  export type FacilityUserCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput> | FacilityUserCreateWithoutFacilityInput[] | FacilityUserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutFacilityInput | FacilityUserCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityUserCreateManyFacilityInputEnvelope
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type FacilityAddressUncheckedCreateNestedOneWithoutFacilityInput = {
    create?: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: FacilityAddressCreateOrConnectWithoutFacilityInput
    connect?: FacilityAddressWhereUniqueInput
  }

  export type FacilityUserUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput> | FacilityUserCreateWithoutFacilityInput[] | FacilityUserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutFacilityInput | FacilityUserCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityUserCreateManyFacilityInputEnvelope
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EnumFacilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.FacilityType
  }

  export type CompanyUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFacilitiesInput
    upsert?: CompanyUpsertWithoutFacilitiesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFacilitiesInput, CompanyUpdateWithoutFacilitiesInput>, CompanyUncheckedUpdateWithoutFacilitiesInput>
  }

  export type FacilityAddressUpdateOneWithoutFacilityNestedInput = {
    create?: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: FacilityAddressCreateOrConnectWithoutFacilityInput
    upsert?: FacilityAddressUpsertWithoutFacilityInput
    disconnect?: FacilityAddressWhereInput | boolean
    delete?: FacilityAddressWhereInput | boolean
    connect?: FacilityAddressWhereUniqueInput
    update?: XOR<XOR<FacilityAddressUpdateToOneWithWhereWithoutFacilityInput, FacilityAddressUpdateWithoutFacilityInput>, FacilityAddressUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityUserUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput> | FacilityUserCreateWithoutFacilityInput[] | FacilityUserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutFacilityInput | FacilityUserCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityUserUpsertWithWhereUniqueWithoutFacilityInput | FacilityUserUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityUserCreateManyFacilityInputEnvelope
    set?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    disconnect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    delete?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    update?: FacilityUserUpdateWithWhereUniqueWithoutFacilityInput | FacilityUserUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityUserUpdateManyWithWhereWithoutFacilityInput | FacilityUserUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutFacilityInput | EvaluationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutFacilityInput | EvaluationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutFacilityInput | EvaluationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type FacilityAddressUncheckedUpdateOneWithoutFacilityNestedInput = {
    create?: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: FacilityAddressCreateOrConnectWithoutFacilityInput
    upsert?: FacilityAddressUpsertWithoutFacilityInput
    disconnect?: FacilityAddressWhereInput | boolean
    delete?: FacilityAddressWhereInput | boolean
    connect?: FacilityAddressWhereUniqueInput
    update?: XOR<XOR<FacilityAddressUpdateToOneWithWhereWithoutFacilityInput, FacilityAddressUpdateWithoutFacilityInput>, FacilityAddressUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityUserUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput> | FacilityUserCreateWithoutFacilityInput[] | FacilityUserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutFacilityInput | FacilityUserCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityUserUpsertWithWhereUniqueWithoutFacilityInput | FacilityUserUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityUserCreateManyFacilityInputEnvelope
    set?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    disconnect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    delete?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    update?: FacilityUserUpdateWithWhereUniqueWithoutFacilityInput | FacilityUserUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityUserUpdateManyWithWhereWithoutFacilityInput | FacilityUserUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput> | EvaluationCreateWithoutFacilityInput[] | EvaluationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutFacilityInput | EvaluationCreateOrConnectWithoutFacilityInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutFacilityInput | EvaluationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EvaluationCreateManyFacilityInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutFacilityInput | EvaluationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutFacilityInput | EvaluationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PhysicianCreateNestedOneWithoutPatientInput = {
    create?: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPatientInput
    connect?: PhysicianWhereUniqueInput
  }

  export type FootCreateNestedManyWithoutPatientInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutPatientInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutPatientInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type CompanyPatientCreateNestedManyWithoutPatientInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type FootUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type CompanyPatientUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type PhysicianUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPatientInput
    upsert?: PhysicianUpsertWithoutPatientInput
    disconnect?: PhysicianWhereInput | boolean
    delete?: PhysicianWhereInput | boolean
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutPatientInput, PhysicianUpdateWithoutPatientInput>, PhysicianUncheckedUpdateWithoutPatientInput>
  }

  export type FootUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutPatientInput | FootUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutPatientInput | FootUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FootUpdateManyWithWhereWithoutPatientInput | FootUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPatientInput | EvaluationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPatientInput | EvaluationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPatientInput | EvaluationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutPatientNestedInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutPatientInput | WorkbenchUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutPatientInput | WorkbenchUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutPatientInput | WorkbenchUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type CompanyPatientUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutPatientInput | CompanyPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutPatientInput | CompanyPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutPatientInput | CompanyPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type FootUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput> | FootCreateWithoutPatientInput[] | FootUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FootCreateOrConnectWithoutPatientInput | FootCreateOrConnectWithoutPatientInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutPatientInput | FootUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FootCreateManyPatientInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutPatientInput | FootUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FootUpdateManyWithWhereWithoutPatientInput | FootUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput> | EvaluationCreateWithoutPatientInput[] | EvaluationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPatientInput | EvaluationCreateOrConnectWithoutPatientInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPatientInput | EvaluationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPatientInput | EvaluationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPatientInput | EvaluationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput> | WorkbenchCreateWithoutPatientInput[] | WorkbenchUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutPatientInput | WorkbenchCreateOrConnectWithoutPatientInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutPatientInput | WorkbenchUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: WorkbenchCreateManyPatientInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutPatientInput | WorkbenchUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutPatientInput | WorkbenchUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput> | CompanyPatientCreateWithoutPatientInput[] | CompanyPatientUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: CompanyPatientCreateOrConnectWithoutPatientInput | CompanyPatientCreateOrConnectWithoutPatientInput[]
    upsert?: CompanyPatientUpsertWithWhereUniqueWithoutPatientInput | CompanyPatientUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: CompanyPatientCreateManyPatientInputEnvelope
    set?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    disconnect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    delete?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    connect?: CompanyPatientWhereUniqueInput | CompanyPatientWhereUniqueInput[]
    update?: CompanyPatientUpdateWithWhereUniqueWithoutPatientInput | CompanyPatientUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: CompanyPatientUpdateManyWithWhereWithoutPatientInput | CompanyPatientUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClinicianInput = {
    create?: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicianInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutCliniciansInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutCliniciansInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutClinicianNestedInput = {
    create?: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicianInput
    upsert?: UserUpsertWithoutClinicianInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinicianInput, UserUpdateWithoutClinicianInput>, UserUncheckedUpdateWithoutClinicianInput>
  }

  export type EvaluationUpdateManyWithoutCliniciansNestedInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCliniciansInput | EvaluationUpsertWithWhereUniqueWithoutCliniciansInput[]
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCliniciansInput | EvaluationUpdateWithWhereUniqueWithoutCliniciansInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCliniciansInput | EvaluationUpdateManyWithWhereWithoutCliniciansInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput = {
    create?: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput> | EvaluationCreateWithoutCliniciansInput[] | EvaluationUncheckedCreateWithoutCliniciansInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCliniciansInput | EvaluationCreateOrConnectWithoutCliniciansInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCliniciansInput | EvaluationUpsertWithWhereUniqueWithoutCliniciansInput[]
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCliniciansInput | EvaluationUpdateWithWhereUniqueWithoutCliniciansInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCliniciansInput | EvaluationUpdateManyWithWhereWithoutCliniciansInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEvaluationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DeviceTypeCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DeviceTypeCreateOrConnectWithoutEvaluationsInput
    connect?: DeviceTypeWhereUniqueInput
  }

  export type VisitTypeCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutEvaluationsInput
    connect?: VisitTypeWhereUniqueInput
  }

  export type PhysicianCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutEvaluationsInput
    connect?: PhysicianWhereUniqueInput
  }

  export type DiagnosisCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEvaluationsInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type FacilityCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEvaluationsInput
    connect?: FacilityWhereUniqueInput
  }

  export type ClinicianCreateNestedManyWithoutEvaluationsInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type EnumCareTypeFieldUpdateOperationsInput = {
    set?: $Enums.CareType
  }

  export type NullableEnumSideFieldUpdateOperationsInput = {
    set?: $Enums.Side | null
  }

  export type NullableEnumVerticalPositionFieldUpdateOperationsInput = {
    set?: $Enums.VerticalPosition | null
  }

  export type PatientUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    upsert?: PatientUpsertWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEvaluationsInput, PatientUpdateWithoutEvaluationsInput>, PatientUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CompanyUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEvaluationsInput
    upsert?: CompanyUpsertWithoutEvaluationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEvaluationsInput, CompanyUpdateWithoutEvaluationsInput>, CompanyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DeviceTypeUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DeviceTypeCreateOrConnectWithoutEvaluationsInput
    upsert?: DeviceTypeUpsertWithoutEvaluationsInput
    disconnect?: DeviceTypeWhereInput | boolean
    delete?: DeviceTypeWhereInput | boolean
    connect?: DeviceTypeWhereUniqueInput
    update?: XOR<XOR<DeviceTypeUpdateToOneWithWhereWithoutEvaluationsInput, DeviceTypeUpdateWithoutEvaluationsInput>, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type VisitTypeUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: VisitTypeCreateOrConnectWithoutEvaluationsInput
    upsert?: VisitTypeUpsertWithoutEvaluationsInput
    disconnect?: VisitTypeWhereInput | boolean
    delete?: VisitTypeWhereInput | boolean
    connect?: VisitTypeWhereUniqueInput
    update?: XOR<XOR<VisitTypeUpdateToOneWithWhereWithoutEvaluationsInput, VisitTypeUpdateWithoutEvaluationsInput>, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PhysicianUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutEvaluationsInput
    upsert?: PhysicianUpsertWithoutEvaluationsInput
    disconnect?: PhysicianWhereInput | boolean
    delete?: PhysicianWhereInput | boolean
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutEvaluationsInput, PhysicianUpdateWithoutEvaluationsInput>, PhysicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DiagnosisUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEvaluationsInput
    upsert?: DiagnosisUpsertWithoutEvaluationsInput
    disconnect?: DiagnosisWhereInput | boolean
    delete?: DiagnosisWhereInput | boolean
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutEvaluationsInput, DiagnosisUpdateWithoutEvaluationsInput>, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
  }

  export type FacilityUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEvaluationsInput
    upsert?: FacilityUpsertWithoutEvaluationsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutEvaluationsInput, FacilityUpdateWithoutEvaluationsInput>, FacilityUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ClinicianUpdateManyWithoutEvaluationsNestedInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    upsert?: ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput | ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput[]
    set?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    disconnect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    delete?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    update?: ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput | ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput[]
    updateMany?: ClinicianUpdateManyWithWhereWithoutEvaluationsInput | ClinicianUpdateManyWithWhereWithoutEvaluationsInput[]
    deleteMany?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput | WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput | WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutEvaluationInput | WorkbenchUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput = {
    create?: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput> | ClinicianCreateWithoutEvaluationsInput[] | ClinicianUncheckedCreateWithoutEvaluationsInput[]
    connectOrCreate?: ClinicianCreateOrConnectWithoutEvaluationsInput | ClinicianCreateOrConnectWithoutEvaluationsInput[]
    upsert?: ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput | ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput[]
    set?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    disconnect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    delete?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    connect?: ClinicianWhereUniqueInput | ClinicianWhereUniqueInput[]
    update?: ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput | ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput[]
    updateMany?: ClinicianUpdateManyWithWhereWithoutEvaluationsInput | ClinicianUpdateManyWithWhereWithoutEvaluationsInput[]
    deleteMany?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput> | WorkbenchCreateWithoutEvaluationInput[] | WorkbenchUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutEvaluationInput | WorkbenchCreateOrConnectWithoutEvaluationInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput | WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: WorkbenchCreateManyEvaluationInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput | WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutEvaluationInput | WorkbenchUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutFeetInput = {
    create?: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFeetInput
    connect?: PatientWhereUniqueInput
  }

  export type WorkbenchCreateNestedOneWithoutFeetInput = {
    create?: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFeetInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutFootInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutFootInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type EnumSideFieldUpdateOperationsInput = {
    set?: $Enums.Side
  }

  export type EnumShoeWidthFieldUpdateOperationsInput = {
    set?: $Enums.ShoeWidth
  }

  export type EnumShoeSystemFieldUpdateOperationsInput = {
    set?: $Enums.ShoeSystem
  }

  export type NullableEnumInactiveFootReasonFieldUpdateOperationsInput = {
    set?: $Enums.InactiveFootReason | null
  }

  export type PatientUpdateOneRequiredWithoutFeetNestedInput = {
    create?: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFeetInput
    upsert?: PatientUpsertWithoutFeetInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutFeetInput, PatientUpdateWithoutFeetInput>, PatientUncheckedUpdateWithoutFeetInput>
  }

  export type WorkbenchUpdateOneRequiredWithoutFeetNestedInput = {
    create?: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFeetInput
    upsert?: WorkbenchUpsertWithoutFeetInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutFeetInput, WorkbenchUpdateWithoutFeetInput>, WorkbenchUncheckedUpdateWithoutFeetInput>
  }

  export type AssetUpdateManyWithoutFootNestedInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutFootInput | AssetUpsertWithWhereUniqueWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutFootInput | AssetUpdateWithWhereUniqueWithoutFootInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutFootInput | AssetUpdateManyWithWhereWithoutFootInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutFootNestedInput = {
    create?: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput> | AssetCreateWithoutFootInput[] | AssetUncheckedCreateWithoutFootInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutFootInput | AssetCreateOrConnectWithoutFootInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutFootInput | AssetUpsertWithWhereUniqueWithoutFootInput[]
    createMany?: AssetCreateManyFootInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutFootInput | AssetUpdateWithWhereUniqueWithoutFootInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutFootInput | AssetUpdateManyWithWhereWithoutFootInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCreatestatusCheckpointsInput = {
    set: $Enums.AssetStatus[]
  }

  export type FootCreateNestedOneWithoutAssetsInput = {
    create?: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: FootCreateOrConnectWithoutAssetsInput
    connect?: FootWhereUniqueInput
  }

  export type WorkbenchCreateNestedManyWithoutAssetsInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type AssetUpdatestatusCheckpointsInput = {
    set?: $Enums.AssetStatus[]
    push?: $Enums.AssetStatus | $Enums.AssetStatus[]
  }

  export type FootUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: FootCreateOrConnectWithoutAssetsInput
    upsert?: FootUpsertWithoutAssetsInput
    connect?: FootWhereUniqueInput
    update?: XOR<XOR<FootUpdateToOneWithWhereWithoutAssetsInput, FootUpdateWithoutAssetsInput>, FootUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkbenchUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutAssetsInput | WorkbenchUpsertWithWhereUniqueWithoutAssetsInput[]
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutAssetsInput | WorkbenchUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutAssetsInput | WorkbenchUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput> | WorkbenchCreateWithoutAssetsInput[] | WorkbenchUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutAssetsInput | WorkbenchCreateOrConnectWithoutAssetsInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutAssetsInput | WorkbenchUpsertWithWhereUniqueWithoutAssetsInput[]
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutAssetsInput | WorkbenchUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutAssetsInput | WorkbenchUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type ProductCreatesidesInput = {
    set: $Enums.Side[]
  }

  export type ProductCreateNestedManyWithoutUsedByProductsInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBuildingBlocksInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkbenchCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUsedByProductsInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkbenchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
  }

  export type ProductUpdatesidesInput = {
    set?: $Enums.Side[]
    push?: $Enums.Side | $Enums.Side[]
  }

  export type ProductUpdateManyWithoutUsedByProductsNestedInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUsedByProductsInput | ProductUpsertWithWhereUniqueWithoutUsedByProductsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUsedByProductsInput | ProductUpdateWithWhereUniqueWithoutUsedByProductsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUsedByProductsInput | ProductUpdateManyWithWhereWithoutUsedByProductsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBuildingBlocksNestedInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput | ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput | ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBuildingBlocksInput | ProductUpdateManyWithWhereWithoutBuildingBlocksInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkbenchUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutProductInput | WorkbenchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutProductInput | WorkbenchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutProductInput | WorkbenchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput = {
    create?: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput> | ProductCreateWithoutUsedByProductsInput[] | ProductUncheckedCreateWithoutUsedByProductsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUsedByProductsInput | ProductCreateOrConnectWithoutUsedByProductsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUsedByProductsInput | ProductUpsertWithWhereUniqueWithoutUsedByProductsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUsedByProductsInput | ProductUpdateWithWhereUniqueWithoutUsedByProductsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUsedByProductsInput | ProductUpdateManyWithWhereWithoutUsedByProductsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput = {
    create?: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput> | ProductCreateWithoutBuildingBlocksInput[] | ProductUncheckedCreateWithoutBuildingBlocksInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBuildingBlocksInput | ProductCreateOrConnectWithoutBuildingBlocksInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput | ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput | ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBuildingBlocksInput | ProductUpdateManyWithWhereWithoutBuildingBlocksInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkbenchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput> | WorkbenchCreateWithoutProductInput[] | WorkbenchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkbenchCreateOrConnectWithoutProductInput | WorkbenchCreateOrConnectWithoutProductInput[]
    upsert?: WorkbenchUpsertWithWhereUniqueWithoutProductInput | WorkbenchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkbenchCreateManyProductInputEnvelope
    set?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    disconnect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    delete?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    connect?: WorkbenchWhereUniqueInput | WorkbenchWhereUniqueInput[]
    update?: WorkbenchUpdateWithWhereUniqueWithoutProductInput | WorkbenchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkbenchUpdateManyWithWhereWithoutProductInput | WorkbenchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutWorkbenchesInput
    connect?: PatientWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWorkbenchesInput
    connect?: ProductWhereUniqueInput
  }

  export type EvaluationCreateNestedOneWithoutWorkbenchesInput = {
    create?: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutWorkbenchesInput
    connect?: EvaluationWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutWorkbenchesInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FootCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type WorkbenchNotesCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutWorkbenchesInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FootUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchCreatedReason | null
  }

  export type EnumWorkbenchStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchStatus
  }

  export type PatientUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutWorkbenchesInput
    upsert?: PatientUpsertWithoutWorkbenchesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutWorkbenchesInput, PatientUpdateWithoutWorkbenchesInput>, PatientUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type ProductUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWorkbenchesInput
    upsert?: ProductUpsertWithoutWorkbenchesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWorkbenchesInput, ProductUpdateWithoutWorkbenchesInput>, ProductUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput = {
    create?: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutWorkbenchesInput
    upsert?: EvaluationUpsertWithoutWorkbenchesInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutWorkbenchesInput, EvaluationUpdateWithoutWorkbenchesInput>, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type AssetUpdateManyWithoutWorkbenchesNestedInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkbenchesInput | AssetUpsertWithWhereUniqueWithoutWorkbenchesInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkbenchesInput | AssetUpdateWithWhereUniqueWithoutWorkbenchesInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkbenchesInput | AssetUpdateManyWithWhereWithoutWorkbenchesInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkbenchInput | OrderUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkbenchInput | OrderUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkbenchInput | OrderUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FootUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutWorkbenchInput | FootUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutWorkbenchInput | FootUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FootUpdateManyWithWhereWithoutWorkbenchInput | FootUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput | FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput | WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput = {
    create?: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput> | AssetCreateWithoutWorkbenchesInput[] | AssetUncheckedCreateWithoutWorkbenchesInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkbenchesInput | AssetCreateOrConnectWithoutWorkbenchesInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkbenchesInput | AssetUpsertWithWhereUniqueWithoutWorkbenchesInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkbenchesInput | AssetUpdateWithWhereUniqueWithoutWorkbenchesInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkbenchesInput | AssetUpdateManyWithWhereWithoutWorkbenchesInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput> | OrderCreateWithoutWorkbenchInput[] | OrderUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkbenchInput | OrderCreateOrConnectWithoutWorkbenchInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkbenchInput | OrderUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: OrderCreateManyWorkbenchInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkbenchInput | OrderUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkbenchInput | OrderUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FootUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput> | FootCreateWithoutWorkbenchInput[] | FootUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FootCreateOrConnectWithoutWorkbenchInput | FootCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FootUpsertWithWhereUniqueWithoutWorkbenchInput | FootUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FootCreateManyWorkbenchInputEnvelope
    set?: FootWhereUniqueInput | FootWhereUniqueInput[]
    disconnect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    delete?: FootWhereUniqueInput | FootWhereUniqueInput[]
    connect?: FootWhereUniqueInput | FootWhereUniqueInput[]
    update?: FootUpdateWithWhereUniqueWithoutWorkbenchInput | FootUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FootUpdateManyWithWhereWithoutWorkbenchInput | FootUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FootScalarWhereInput | FootScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput> | FormSubmissionCreateWithoutWorkbenchInput[] | FormSubmissionUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutWorkbenchInput | FormSubmissionCreateOrConnectWithoutWorkbenchInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: FormSubmissionCreateManyWorkbenchInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput | FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput | FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput> | WorkbenchNotesCreateWithoutWorkbenchInput[] | WorkbenchNotesUncheckedCreateWithoutWorkbenchInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutWorkbenchInput | WorkbenchNotesCreateOrConnectWithoutWorkbenchInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput[]
    createMany?: WorkbenchNotesCreateManyWorkbenchInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput | WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput | WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type WorkbenchNotesCreatetagsInput = {
    set: string[]
  }

  export type WorkbenchCreateNestedOneWithoutNotesInput = {
    create?: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutNotesInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkbenchNotesUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkbenchUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutNotesInput
    upsert?: WorkbenchUpsertWithoutNotesInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutNotesInput, WorkbenchUpdateWithoutNotesInput>, WorkbenchUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type WorkbenchCreateNestedOneWithoutOrdersInput = {
    create?: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutOrdersInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumOrderAuthorizationStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderAuthorizationStatus
  }

  export type WorkbenchUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutOrdersInput
    upsert?: WorkbenchUpsertWithoutOrdersInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutOrdersInput, WorkbenchUpdateWithoutOrdersInput>, WorkbenchUncheckedUpdateWithoutOrdersInput>
  }

  export type FacilityCreateNestedOneWithoutAddressInput = {
    create?: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutAddressInput
    connect?: FacilityWhereUniqueInput
  }

  export type NullableEnumCarrierFieldUpdateOperationsInput = {
    set?: $Enums.Carrier | null
  }

  export type FacilityUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutAddressInput
    upsert?: FacilityUpsertWithoutAddressInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutAddressInput, FacilityUpdateWithoutAddressInput>, FacilityUncheckedUpdateWithoutAddressInput>
  }

  export type CompanyCreateNestedOneWithoutPackagesInput = {
    create?: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackagesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumWeightUnitFieldUpdateOperationsInput = {
    set?: $Enums.WeightUnit
  }

  export type EnumDimensionUnitFieldUpdateOperationsInput = {
    set?: $Enums.DimensionUnit
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackagesInput
    upsert?: CompanyUpsertWithoutPackagesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPackagesInput, CompanyUpdateWithoutPackagesInput>, CompanyUncheckedUpdateWithoutPackagesInput>
  }

  export type EvaluationCreateNestedManyWithoutReferringPhysicianInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutPrimaryPhysicianInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type EvaluationUpdateManyWithoutReferringPhysicianNestedInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput | EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutPrimaryPhysicianNestedInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput | PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput = {
    create?: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput> | EvaluationCreateWithoutReferringPhysicianInput[] | EvaluationUncheckedCreateWithoutReferringPhysicianInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutReferringPhysicianInput | EvaluationCreateOrConnectWithoutReferringPhysicianInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput[]
    createMany?: EvaluationCreateManyReferringPhysicianInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput | EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput | EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput = {
    create?: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput> | PatientCreateWithoutPrimaryPhysicianInput[] | PatientUncheckedCreateWithoutPrimaryPhysicianInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutPrimaryPhysicianInput | PatientCreateOrConnectWithoutPrimaryPhysicianInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput[]
    createMany?: PatientCreateManyPrimaryPhysicianInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput | PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput | PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EnumDiagnosisStandardFieldUpdateOperationsInput = {
    set?: $Enums.DiagnosisStandard
  }

  export type EvaluationUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput | EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput | EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDiagnosisInput | EvaluationUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput> | EvaluationCreateWithoutDiagnosisInput[] | EvaluationUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDiagnosisInput | EvaluationCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput | EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EvaluationCreateManyDiagnosisInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput | EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDiagnosisInput | EvaluationUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutDeviceTypeInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutDeviceTypeInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EvaluationUpdateManyWithoutDeviceTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDeviceTypeInput | EvaluationUpdateManyWithWhereWithoutDeviceTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutDeviceTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput> | EvaluationCreateWithoutDeviceTypeInput[] | EvaluationUncheckedCreateWithoutDeviceTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutDeviceTypeInput | EvaluationCreateOrConnectWithoutDeviceTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput[]
    createMany?: EvaluationCreateManyDeviceTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput | EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutDeviceTypeInput | EvaluationUpdateManyWithWhereWithoutDeviceTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutVisitTypeInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutVisitTypeInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUpdateManyWithoutVisitTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput | EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput | EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutVisitTypeInput | EvaluationUpdateManyWithWhereWithoutVisitTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutVisitTypeNestedInput = {
    create?: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput> | EvaluationCreateWithoutVisitTypeInput[] | EvaluationUncheckedCreateWithoutVisitTypeInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutVisitTypeInput | EvaluationCreateOrConnectWithoutVisitTypeInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput | EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput[]
    createMany?: EvaluationCreateManyVisitTypeInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput | EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutVisitTypeInput | EvaluationUpdateManyWithWhereWithoutVisitTypeInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutSchemaInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutSchemaInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type NullableEnumFormSchemaTypeFieldUpdateOperationsInput = {
    set?: $Enums.FormSchemaType | null
  }

  export type FormSubmissionUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput | FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput | FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSchemaInput | FormSubmissionUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput> | FormSubmissionCreateWithoutSchemaInput[] | FormSubmissionUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutSchemaInput | FormSubmissionCreateOrConnectWithoutSchemaInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput | FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: FormSubmissionCreateManySchemaInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput | FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutSchemaInput | FormSubmissionUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormSchemaCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormSchemaCreateOrConnectWithoutSubmissionsInput
    connect?: FormSchemaWhereUniqueInput
  }

  export type WorkbenchCreateNestedOneWithoutFormSubmissionsInput = {
    create?: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFormSubmissionsInput
    connect?: WorkbenchWhereUniqueInput
  }

  export type FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormSchemaCreateOrConnectWithoutSubmissionsInput
    upsert?: FormSchemaUpsertWithoutSubmissionsInput
    connect?: FormSchemaWhereUniqueInput
    update?: XOR<XOR<FormSchemaUpdateToOneWithWhereWithoutSubmissionsInput, FormSchemaUpdateWithoutSubmissionsInput>, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
  }

  export type WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput = {
    create?: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: WorkbenchCreateOrConnectWithoutFormSubmissionsInput
    upsert?: WorkbenchUpsertWithoutFormSubmissionsInput
    connect?: WorkbenchWhereUniqueInput
    update?: XOR<XOR<WorkbenchUpdateToOneWithWhereWithoutFormSubmissionsInput, WorkbenchUpdateWithoutFormSubmissionsInput>, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type CatalogProductAttributeCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
  }

  export type CatalogProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
  }

  export type CatalogCategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
  }

  export type CatalogVendorCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
  }

  export type CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
  }

  export type CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
  }

  export type CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
  }

  export type CatalogVendorUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
  }

  export type CatalogProductAttributeUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    set?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    disconnect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    delete?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    update?: CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductAttributeUpdateManyWithWhereWithoutProductInput | CatalogProductAttributeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
  }

  export type CatalogProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput | CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    set?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    disconnect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    delete?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    update?: CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput | CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductVariantUpdateManyWithWhereWithoutProductInput | CatalogProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
  }

  export type CatalogCategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput | CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    disconnect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    delete?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    update?: CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput | CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogCategoryUpdateManyWithWhereWithoutProductsInput | CatalogCategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
  }

  export type CatalogVendorUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogVendorUpsertWithWhereUniqueWithoutProductsInput | CatalogVendorUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    disconnect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    delete?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    update?: CatalogVendorUpdateWithWhereUniqueWithoutProductsInput | CatalogVendorUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogVendorUpdateManyWithWhereWithoutProductsInput | CatalogVendorUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
  }

  export type CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput> | CatalogProductAttributeCreateWithoutProductInput[] | CatalogProductAttributeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductAttributeCreateOrConnectWithoutProductInput | CatalogProductAttributeCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductAttributeCreateManyProductInputEnvelope
    set?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    disconnect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    delete?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    connect?: CatalogProductAttributeWhereUniqueInput | CatalogProductAttributeWhereUniqueInput[]
    update?: CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput | CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductAttributeUpdateManyWithWhereWithoutProductInput | CatalogProductAttributeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
  }

  export type CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput> | CatalogProductVariantCreateWithoutProductInput[] | CatalogProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CatalogProductVariantCreateOrConnectWithoutProductInput | CatalogProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput | CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CatalogProductVariantCreateManyProductInputEnvelope
    set?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    disconnect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    delete?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    connect?: CatalogProductVariantWhereUniqueInput | CatalogProductVariantWhereUniqueInput[]
    update?: CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput | CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CatalogProductVariantUpdateManyWithWhereWithoutProductInput | CatalogProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
  }

  export type CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput> | CatalogCategoryCreateWithoutProductsInput[] | CatalogCategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogCategoryCreateOrConnectWithoutProductsInput | CatalogCategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput | CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    disconnect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    delete?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    connect?: CatalogCategoryWhereUniqueInput | CatalogCategoryWhereUniqueInput[]
    update?: CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput | CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogCategoryUpdateManyWithWhereWithoutProductsInput | CatalogCategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
  }

  export type CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput> | CatalogVendorCreateWithoutProductsInput[] | CatalogVendorUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CatalogVendorCreateOrConnectWithoutProductsInput | CatalogVendorCreateOrConnectWithoutProductsInput[]
    upsert?: CatalogVendorUpsertWithWhereUniqueWithoutProductsInput | CatalogVendorUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    disconnect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    delete?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    connect?: CatalogVendorWhereUniqueInput | CatalogVendorWhereUniqueInput[]
    update?: CatalogVendorUpdateWithWhereUniqueWithoutProductsInput | CatalogVendorUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CatalogVendorUpdateManyWithWhereWithoutProductsInput | CatalogVendorUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
  }

  export type CatalogProductCreateNestedOneWithoutAttributesInput = {
    create?: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutAttributesInput
    connect?: CatalogProductWhereUniqueInput
  }

  export type EnumProductAttributeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductAttributeType
  }

  export type CatalogProductUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutAttributesInput
    upsert?: CatalogProductUpsertWithoutAttributesInput
    connect?: CatalogProductWhereUniqueInput
    update?: XOR<XOR<CatalogProductUpdateToOneWithWhereWithoutAttributesInput, CatalogProductUpdateWithoutAttributesInput>, CatalogProductUncheckedUpdateWithoutAttributesInput>
  }

  export type CatalogProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVariantsInput
    connect?: CatalogProductWhereUniqueInput
  }

  export type CatalogProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVariantsInput
    upsert?: CatalogProductUpsertWithoutVariantsInput
    connect?: CatalogProductWhereUniqueInput
    update?: XOR<XOR<CatalogProductUpdateToOneWithWhereWithoutVariantsInput, CatalogProductUpdateWithoutVariantsInput>, CatalogProductUncheckedUpdateWithoutVariantsInput>
  }

  export type CatalogProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput | CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput | CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutCategoriesInput | CatalogProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput> | CatalogProductCreateWithoutCategoriesInput[] | CatalogProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutCategoriesInput | CatalogProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput | CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput | CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutCategoriesInput | CatalogProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductCreateNestedManyWithoutVendorsInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
  }

  export type CatalogProductUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutVendorsInput | CatalogProductUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutVendorsInput | CatalogProductUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutVendorsInput | CatalogProductUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type CatalogProductUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput> | CatalogProductCreateWithoutVendorsInput[] | CatalogProductUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: CatalogProductCreateOrConnectWithoutVendorsInput | CatalogProductCreateOrConnectWithoutVendorsInput[]
    upsert?: CatalogProductUpsertWithWhereUniqueWithoutVendorsInput | CatalogProductUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    disconnect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    delete?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    connect?: CatalogProductWhereUniqueInput | CatalogProductWhereUniqueInput[]
    update?: CatalogProductUpdateWithWhereUniqueWithoutVendorsInput | CatalogProductUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: CatalogProductUpdateManyWithWhereWithoutVendorsInput | CatalogProductUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditsLogsInput = {
    create?: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditsLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsLogsInput
    upsert?: UserUpsertWithoutAuditsLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsLogsInput, UserUpdateWithoutAuditsLogsInput>, UserUncheckedUpdateWithoutAuditsLogsInput>
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCompanyRoleFieldUpdateOperationsInput = {
    set?: $Enums.CompanyRole
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<CompanyCreateWithoutPermissionsInput, CompanyUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPermissionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumCompanyPermissionFieldUpdateOperationsInput = {
    set?: $Enums.CompanyPermission
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type CompanyUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<CompanyCreateWithoutPermissionsInput, CompanyUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPermissionsInput
    upsert?: CompanyUpsertWithoutPermissionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPermissionsInput, CompanyUpdateWithoutPermissionsInput>, CompanyUncheckedUpdateWithoutPermissionsInput>
  }

  export type CompanyCreateNestedOneWithoutPatientsInput = {
    create?: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPatientsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCompaniesInput
    connect?: PatientWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPatientsInput
    upsert?: CompanyUpsertWithoutPatientsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPatientsInput, CompanyUpdateWithoutPatientsInput>, CompanyUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCompaniesInput
    upsert?: PatientUpsertWithoutCompaniesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutCompaniesInput, PatientUpdateWithoutCompaniesInput>, PatientUncheckedUpdateWithoutCompaniesInput>
  }

  export type FacilityCreateNestedOneWithoutUsersInput = {
    create?: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutUsersInput
    connect?: FacilityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<UserCreateWithoutFacilitiesInput, UserUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFacilitiesInput
    connect?: UserWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutUsersInput
    upsert?: FacilityUpsertWithoutUsersInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutUsersInput, FacilityUpdateWithoutUsersInput>, FacilityUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<UserCreateWithoutFacilitiesInput, UserUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFacilitiesInput
    upsert?: UserUpsertWithoutFacilitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFacilitiesInput, UserUpdateWithoutFacilitiesInput>, UserUncheckedUpdateWithoutFacilitiesInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyUserPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput> | CompanyUserPermissionCreateWithoutUserInput[] | CompanyUserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutUserInput | CompanyUserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserPermissionCreateManyUserInputEnvelope
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
  }

  export type FacilityUserCreateNestedManyWithoutUserInput = {
    create?: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput> | FacilityUserCreateWithoutUserInput[] | FacilityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutUserInput | FacilityUserCreateOrConnectWithoutUserInput[]
    createMany?: FacilityUserCreateManyUserInputEnvelope
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
  }

  export type ClinicianCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    connect?: ClinicianWhereUniqueInput
  }

  export type WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput> | CompanyUserPermissionCreateWithoutUserInput[] | CompanyUserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutUserInput | CompanyUserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserPermissionCreateManyUserInputEnvelope
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
  }

  export type FacilityUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput> | FacilityUserCreateWithoutUserInput[] | FacilityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutUserInput | FacilityUserCreateOrConnectWithoutUserInput[]
    createMany?: FacilityUserCreateManyUserInputEnvelope
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
  }

  export type ClinicianUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    connect?: ClinicianWhereUniqueInput
  }

  export type WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyUserPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput> | CompanyUserPermissionCreateWithoutUserInput[] | CompanyUserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutUserInput | CompanyUserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserPermissionUpsertWithWhereUniqueWithoutUserInput | CompanyUserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserPermissionCreateManyUserInputEnvelope
    set?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    disconnect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    delete?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    update?: CompanyUserPermissionUpdateWithWhereUniqueWithoutUserInput | CompanyUserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserPermissionUpdateManyWithWhereWithoutUserInput | CompanyUserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
  }

  export type FacilityUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput> | FacilityUserCreateWithoutUserInput[] | FacilityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutUserInput | FacilityUserCreateOrConnectWithoutUserInput[]
    upsert?: FacilityUserUpsertWithWhereUniqueWithoutUserInput | FacilityUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FacilityUserCreateManyUserInputEnvelope
    set?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    disconnect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    delete?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    update?: FacilityUserUpdateWithWhereUniqueWithoutUserInput | FacilityUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FacilityUserUpdateManyWithWhereWithoutUserInput | FacilityUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
  }

  export type ClinicianUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    upsert?: ClinicianUpsertWithoutUserInput
    disconnect?: ClinicianWhereInput | boolean
    delete?: ClinicianWhereInput | boolean
    connect?: ClinicianWhereUniqueInput
    update?: XOR<XOR<ClinicianUpdateToOneWithWhereWithoutUserInput, ClinicianUpdateWithoutUserInput>, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput | WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput> | CompanyUserPermissionCreateWithoutUserInput[] | CompanyUserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserPermissionCreateOrConnectWithoutUserInput | CompanyUserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserPermissionUpsertWithWhereUniqueWithoutUserInput | CompanyUserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserPermissionCreateManyUserInputEnvelope
    set?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    disconnect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    delete?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    connect?: CompanyUserPermissionWhereUniqueInput | CompanyUserPermissionWhereUniqueInput[]
    update?: CompanyUserPermissionUpdateWithWhereUniqueWithoutUserInput | CompanyUserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserPermissionUpdateManyWithWhereWithoutUserInput | CompanyUserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
  }

  export type FacilityUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput> | FacilityUserCreateWithoutUserInput[] | FacilityUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FacilityUserCreateOrConnectWithoutUserInput | FacilityUserCreateOrConnectWithoutUserInput[]
    upsert?: FacilityUserUpsertWithWhereUniqueWithoutUserInput | FacilityUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FacilityUserCreateManyUserInputEnvelope
    set?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    disconnect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    delete?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    connect?: FacilityUserWhereUniqueInput | FacilityUserWhereUniqueInput[]
    update?: FacilityUserUpdateWithWhereUniqueWithoutUserInput | FacilityUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FacilityUserUpdateManyWithWhereWithoutUserInput | FacilityUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
  }

  export type ClinicianUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClinicianCreateOrConnectWithoutUserInput
    upsert?: ClinicianUpsertWithoutUserInput
    disconnect?: ClinicianWhereInput | boolean
    delete?: ClinicianWhereInput | boolean
    connect?: ClinicianWhereUniqueInput
    update?: XOR<XOR<ClinicianUpdateToOneWithWhereWithoutUserInput, ClinicianUpdateWithoutUserInput>, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput> | WorkbenchNotesCreateWithoutCreatedByUserInput[] | WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput | WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: WorkbenchNotesCreateManyCreatedByUserInputEnvelope
    set?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    disconnect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    delete?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    connect?: WorkbenchNotesWhereUniqueInput | WorkbenchNotesWhereUniqueInput[]
    update?: WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput | WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput | WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type CompanyCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiKeysInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiKeysInput
    upsert?: CompanyUpsertWithoutApiKeysInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutApiKeysInput, CompanyUpdateWithoutApiKeysInput>, CompanyUncheckedUpdateWithoutApiKeysInput>
  }

  export type NullableEnumWorkbenchStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkbenchStatus | null
  }

  export type NullableEnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCareTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeFilter<$PrismaModel> | $Enums.CareType
  }

  export type NestedEnumSideNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableFilter<$PrismaModel> | $Enums.Side | null
  }

  export type NestedEnumVerticalPositionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableFilter<$PrismaModel> | $Enums.VerticalPosition | null
  }

  export type NestedEnumCareTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareType | EnumCareTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareType[] | ListEnumCareTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTypeFilter<$PrismaModel>
  }

  export type NestedEnumSideNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel> | null
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSideNullableWithAggregatesFilter<$PrismaModel> | $Enums.Side | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSideNullableFilter<$PrismaModel>
    _max?: NestedEnumSideNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerticalPosition | EnumVerticalPositionFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerticalPosition[] | ListEnumVerticalPositionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerticalPositionNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerticalPosition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
    _max?: NestedEnumVerticalPositionNullableFilter<$PrismaModel>
  }

  export type NestedEnumSideFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideFilter<$PrismaModel> | $Enums.Side
  }

  export type NestedEnumShoeWidthFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeWidthFilter<$PrismaModel> | $Enums.ShoeWidth
  }

  export type NestedEnumShoeSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemFilter<$PrismaModel> | $Enums.ShoeSystem
  }

  export type NestedEnumInactiveFootReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel> | $Enums.InactiveFootReason | null
  }

  export type NestedEnumSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Side | EnumSideFieldRefInput<$PrismaModel>
    in?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.Side[] | ListEnumSideFieldRefInput<$PrismaModel>
    not?: NestedEnumSideWithAggregatesFilter<$PrismaModel> | $Enums.Side
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSideFilter<$PrismaModel>
    _max?: NestedEnumSideFilter<$PrismaModel>
  }

  export type NestedEnumShoeWidthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeWidth | EnumShoeWidthFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeWidth[] | ListEnumShoeWidthFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeWidthWithAggregatesFilter<$PrismaModel> | $Enums.ShoeWidth
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeWidthFilter<$PrismaModel>
    _max?: NestedEnumShoeWidthFilter<$PrismaModel>
  }

  export type NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShoeSystem | EnumShoeSystemFieldRefInput<$PrismaModel>
    in?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShoeSystem[] | ListEnumShoeSystemFieldRefInput<$PrismaModel>
    not?: NestedEnumShoeSystemWithAggregatesFilter<$PrismaModel> | $Enums.ShoeSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShoeSystemFilter<$PrismaModel>
    _max?: NestedEnumShoeSystemFilter<$PrismaModel>
  }

  export type NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InactiveFootReason | EnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InactiveFootReason[] | ListEnumInactiveFootReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInactiveFootReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.InactiveFootReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumInactiveFootReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
  }

  export type NestedEnumWorkbenchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusFilter<$PrismaModel> | $Enums.WorkbenchStatus
  }

  export type NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchCreatedReason | EnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchCreatedReason[] | ListEnumWorkbenchCreatedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchCreatedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchCreatedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchCreatedReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkbenchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderAuthorizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAuthorizationStatus | EnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAuthorizationStatus[] | ListEnumOrderAuthorizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAuthorizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderAuthorizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderAuthorizationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCarrierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableFilter<$PrismaModel> | $Enums.Carrier | null
  }

  export type NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Carrier | EnumCarrierFieldRefInput<$PrismaModel> | null
    in?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Carrier[] | ListEnumCarrierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCarrierNullableWithAggregatesFilter<$PrismaModel> | $Enums.Carrier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCarrierNullableFilter<$PrismaModel>
    _max?: NestedEnumCarrierNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumWeightUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitFilter<$PrismaModel> | $Enums.WeightUnit
  }

  export type NestedEnumDimensionUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitFilter<$PrismaModel> | $Enums.DimensionUnit
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeightUnit | EnumWeightUnitFieldRefInput<$PrismaModel>
    in?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeightUnit[] | ListEnumWeightUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumWeightUnitWithAggregatesFilter<$PrismaModel> | $Enums.WeightUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeightUnitFilter<$PrismaModel>
    _max?: NestedEnumWeightUnitFilter<$PrismaModel>
  }

  export type NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DimensionUnit | EnumDimensionUnitFieldRefInput<$PrismaModel>
    in?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.DimensionUnit[] | ListEnumDimensionUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumDimensionUnitWithAggregatesFilter<$PrismaModel> | $Enums.DimensionUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDimensionUnitFilter<$PrismaModel>
    _max?: NestedEnumDimensionUnitFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumDiagnosisStandardFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardFilter<$PrismaModel> | $Enums.DiagnosisStandard
  }

  export type NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiagnosisStandard | EnumDiagnosisStandardFieldRefInput<$PrismaModel>
    in?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiagnosisStandard[] | ListEnumDiagnosisStandardFieldRefInput<$PrismaModel>
    not?: NestedEnumDiagnosisStandardWithAggregatesFilter<$PrismaModel> | $Enums.DiagnosisStandard
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
    _max?: NestedEnumDiagnosisStandardFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFormSchemaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel> | $Enums.FormSchemaType | null
  }

  export type NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormSchemaType | EnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FormSchemaType[] | ListEnumFormSchemaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFormSchemaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FormSchemaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFormSchemaTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProductAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeFilter<$PrismaModel> | $Enums.ProductAttributeType
  }

  export type NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductAttributeType | EnumProductAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductAttributeType[] | ListEnumProductAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumProductAttributeTypeFilter<$PrismaModel>
  }

  export type NestedEnumCompanyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleFilter<$PrismaModel> | $Enums.CompanyRole
  }

  export type NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRole | EnumCompanyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyRole[] | ListEnumCompanyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyRoleWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyRoleFilter<$PrismaModel>
    _max?: NestedEnumCompanyRoleFilter<$PrismaModel>
  }

  export type NestedEnumCompanyPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyPermission | EnumCompanyPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyPermissionFilter<$PrismaModel> | $Enums.CompanyPermission
  }

  export type NestedEnumCompanyPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyPermission | EnumCompanyPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyPermission[] | ListEnumCompanyPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyPermissionWithAggregatesFilter<$PrismaModel> | $Enums.CompanyPermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyPermissionFilter<$PrismaModel>
    _max?: NestedEnumCompanyPermissionFilter<$PrismaModel>
  }

  export type NestedEnumWorkbenchStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
  }

  export type NestedEnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkbenchStatus | EnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WorkbenchStatus[] | ListEnumWorkbenchStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWorkbenchStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.WorkbenchStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumWorkbenchStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FacilityCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: FacilityAddressCreateNestedOneWithoutFacilityInput
    users?: FacilityUserCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: FacilityAddressUncheckedCreateNestedOneWithoutFacilityInput
    users?: FacilityUserUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput>
  }

  export type FacilityCreateManyCompanyInputEnvelope = {
    data: FacilityCreateManyCompanyInput | FacilityCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput>
  }

  export type EvaluationCreateManyCompanyInputEnvelope = {
    data: EvaluationCreateManyCompanyInput | EvaluationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput>
  }

  export type ApiKeyCreateManyCompanyInputEnvelope = {
    data: ApiKeyCreateManyCompanyInput | ApiKeyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ShippingPackageCreateWithoutCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageCreateOrConnectWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    create: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput>
  }

  export type ShippingPackageCreateManyCompanyInputEnvelope = {
    data: ShippingPackageCreateManyCompanyInput | ShippingPackageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserCreateWithoutCompanyInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyUserUncheckedCreateWithoutCompanyInput = {
    userId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserCreateManyCompanyInputEnvelope = {
    data: CompanyUserCreateManyCompanyInput | CompanyUserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserPermissionCreateWithoutCompanyInput = {
    id?: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type CompanyUserPermissionUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserPermissionWhereUniqueInput
    create: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserPermissionCreateManyCompanyInputEnvelope = {
    data: CompanyUserPermissionCreateManyCompanyInput | CompanyUserPermissionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPatientCreateWithoutCompanyInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyPatientUncheckedCreateWithoutCompanyInput = {
    patientId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateOrConnectWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    create: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyPatientCreateManyCompanyInputEnvelope = {
    data: CompanyPatientCreateManyCompanyInput | CompanyPatientCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditsLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutCompanyInput, FacilityUncheckedUpdateWithoutCompanyInput>
    create: XOR<FacilityCreateWithoutCompanyInput, FacilityUncheckedCreateWithoutCompanyInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutCompanyInput, FacilityUncheckedUpdateWithoutCompanyInput>
  }

  export type FacilityUpdateManyWithWhereWithoutCompanyInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FacilityScalarWhereInput = {
    AND?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    OR?: FacilityScalarWhereInput[]
    NOT?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    companyId?: StringFilter<"Facility"> | string
    type?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    active?: BoolFilter<"Facility"> | boolean
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutCompanyInput, EvaluationUncheckedUpdateWithoutCompanyInput>
    create: XOR<EvaluationCreateWithoutCompanyInput, EvaluationUncheckedCreateWithoutCompanyInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutCompanyInput, EvaluationUncheckedUpdateWithoutCompanyInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutCompanyInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    externalId?: StringNullableFilter<"Evaluation"> | string | null
    poNumber?: StringNullableFilter<"Evaluation"> | string | null
    type?: EnumCareTypeFilter<"Evaluation"> | $Enums.CareType
    patientId?: StringFilter<"Evaluation"> | string
    companyId?: StringFilter<"Evaluation"> | string
    deviceTypeId?: StringNullableFilter<"Evaluation"> | string | null
    isDiabetic?: BoolFilter<"Evaluation"> | boolean
    isVeteran?: BoolFilter<"Evaluation"> | boolean
    deviceSide?: EnumSideNullableFilter<"Evaluation"> | $Enums.Side | null
    devicePosition?: EnumVerticalPositionNullableFilter<"Evaluation"> | $Enums.VerticalPosition | null
    appointmentAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    appointmentStatus?: StringNullableFilter<"Evaluation"> | string | null
    referringPhysicianId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisId?: StringNullableFilter<"Evaluation"> | string | null
    diagnosisedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    visitTypeId?: StringNullableFilter<"Evaluation"> | string | null
    visitedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    facilityId?: StringNullableFilter<"Evaluation"> | string | null
    location?: StringNullableFilter<"Evaluation"> | string | null
    prescribedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    prescribedActive?: BoolFilter<"Evaluation"> | boolean
    primaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    secondaryInsurance?: StringNullableFilter<"Evaluation"> | string | null
    submittedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Evaluation"> | Date | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutCompanyInput, ApiKeyUncheckedUpdateWithoutCompanyInput>
    create: XOR<ApiKeyCreateWithoutCompanyInput, ApiKeyUncheckedCreateWithoutCompanyInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutCompanyInput, ApiKeyUncheckedUpdateWithoutCompanyInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutCompanyInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    companyId?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type ShippingPackageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    update: XOR<ShippingPackageUpdateWithoutCompanyInput, ShippingPackageUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShippingPackageCreateWithoutCompanyInput, ShippingPackageUncheckedCreateWithoutCompanyInput>
  }

  export type ShippingPackageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShippingPackageWhereUniqueInput
    data: XOR<ShippingPackageUpdateWithoutCompanyInput, ShippingPackageUncheckedUpdateWithoutCompanyInput>
  }

  export type ShippingPackageUpdateManyWithWhereWithoutCompanyInput = {
    where: ShippingPackageScalarWhereInput
    data: XOR<ShippingPackageUpdateManyMutationInput, ShippingPackageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShippingPackageScalarWhereInput = {
    AND?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
    OR?: ShippingPackageScalarWhereInput[]
    NOT?: ShippingPackageScalarWhereInput | ShippingPackageScalarWhereInput[]
    id?: StringFilter<"ShippingPackage"> | string
    name?: StringFilter<"ShippingPackage"> | string
    weight?: FloatFilter<"ShippingPackage"> | number
    weightUnit?: EnumWeightUnitFilter<"ShippingPackage"> | $Enums.WeightUnit
    length?: FloatFilter<"ShippingPackage"> | number
    width?: FloatFilter<"ShippingPackage"> | number
    height?: FloatFilter<"ShippingPackage"> | number
    dimensionUnit?: EnumDimensionUnitFilter<"ShippingPackage"> | $Enums.DimensionUnit
    insoleCapacity?: IntFilter<"ShippingPackage"> | number
    companyId?: StringFilter<"ShippingPackage"> | string
    createdAt?: DateTimeFilter<"ShippingPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingPackage"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyUserScalarWhereInput = {
    AND?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    OR?: CompanyUserScalarWhereInput[]
    NOT?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: EnumCompanyRoleFilter<"CompanyUser"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUser"> | Date | string
  }

  export type CompanyUserPermissionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserPermissionWhereUniqueInput
    update: XOR<CompanyUserPermissionUpdateWithoutCompanyInput, CompanyUserPermissionUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserPermissionCreateWithoutCompanyInput, CompanyUserPermissionUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserPermissionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserPermissionWhereUniqueInput
    data: XOR<CompanyUserPermissionUpdateWithoutCompanyInput, CompanyUserPermissionUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserPermissionUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserPermissionScalarWhereInput
    data: XOR<CompanyUserPermissionUpdateManyMutationInput, CompanyUserPermissionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyUserPermissionScalarWhereInput = {
    AND?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
    OR?: CompanyUserPermissionScalarWhereInput[]
    NOT?: CompanyUserPermissionScalarWhereInput | CompanyUserPermissionScalarWhereInput[]
    id?: StringFilter<"CompanyUserPermission"> | string
    userId?: StringFilter<"CompanyUserPermission"> | string
    companyId?: StringFilter<"CompanyUserPermission"> | string
    permission?: EnumCompanyPermissionFilter<"CompanyUserPermission"> | $Enums.CompanyPermission
    role?: EnumCompanyRoleFilter<"CompanyUserPermission"> | $Enums.CompanyRole
    createdAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyUserPermission"> | Date | string
  }

  export type CompanyPatientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    update: XOR<CompanyPatientUpdateWithoutCompanyInput, CompanyPatientUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyPatientCreateWithoutCompanyInput, CompanyPatientUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyPatientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyPatientWhereUniqueInput
    data: XOR<CompanyPatientUpdateWithoutCompanyInput, CompanyPatientUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyPatientUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyPatientScalarWhereInput
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyPatientScalarWhereInput = {
    AND?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
    OR?: CompanyPatientScalarWhereInput[]
    NOT?: CompanyPatientScalarWhereInput | CompanyPatientScalarWhereInput[]
    patientId?: StringFilter<"CompanyPatient"> | string
    companyId?: StringFilter<"CompanyPatient"> | string
    externalId?: StringNullableFilter<"CompanyPatient"> | string | null
    createdAt?: DateTimeFilter<"CompanyPatient"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyPatient"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    context?: JsonNullableFilter<"AuditLog">
    comment?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CompanyCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFacilitiesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityAddressCreateWithoutFacilityInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityAddressUncheckedCreateWithoutFacilityInput = {
    id?: string
    name?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    stateOrProvince: string
    postalCode: string
    countryCode: string
    shippingAccountId?: string | null
    shippingAccountCarrier?: $Enums.Carrier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityAddressCreateOrConnectWithoutFacilityInput = {
    where: FacilityAddressWhereUniqueInput
    create: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityUserCreateWithoutFacilityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacilitiesInput
  }

  export type FacilityUserUncheckedCreateWithoutFacilityInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserCreateOrConnectWithoutFacilityInput = {
    where: FacilityUserWhereUniqueInput
    create: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityUserCreateManyFacilityInputEnvelope = {
    data: FacilityUserCreateManyFacilityInput | FacilityUserCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput>
  }

  export type EvaluationCreateManyFacilityInputEnvelope = {
    data: EvaluationCreateManyFacilityInput | EvaluationCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutFacilitiesInput = {
    update: XOR<CompanyUpdateWithoutFacilitiesInput, CompanyUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<CompanyCreateWithoutFacilitiesInput, CompanyUncheckedCreateWithoutFacilitiesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFacilitiesInput, CompanyUncheckedUpdateWithoutFacilitiesInput>
  }

  export type CompanyUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FacilityAddressUpsertWithoutFacilityInput = {
    update: XOR<FacilityAddressUpdateWithoutFacilityInput, FacilityAddressUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityAddressCreateWithoutFacilityInput, FacilityAddressUncheckedCreateWithoutFacilityInput>
    where?: FacilityAddressWhereInput
  }

  export type FacilityAddressUpdateToOneWithWhereWithoutFacilityInput = {
    where?: FacilityAddressWhereInput
    data: XOR<FacilityAddressUpdateWithoutFacilityInput, FacilityAddressUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityAddressUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityAddressUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    stateOrProvince?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    shippingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAccountCarrier?: NullableEnumCarrierFieldUpdateOperationsInput | $Enums.Carrier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityUserWhereUniqueInput
    update: XOR<FacilityUserUpdateWithoutFacilityInput, FacilityUserUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityUserCreateWithoutFacilityInput, FacilityUserUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityUserUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityUserWhereUniqueInput
    data: XOR<FacilityUserUpdateWithoutFacilityInput, FacilityUserUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityUserUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityUserScalarWhereInput
    data: XOR<FacilityUserUpdateManyMutationInput, FacilityUserUncheckedUpdateManyWithoutFacilityInput>
  }

  export type FacilityUserScalarWhereInput = {
    AND?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
    OR?: FacilityUserScalarWhereInput[]
    NOT?: FacilityUserScalarWhereInput | FacilityUserScalarWhereInput[]
    userId?: StringFilter<"FacilityUser"> | string
    facilityId?: StringFilter<"FacilityUser"> | string
    createdAt?: DateTimeFilter<"FacilityUser"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityUser"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutFacilityInput, EvaluationUncheckedUpdateWithoutFacilityInput>
    create: XOR<EvaluationCreateWithoutFacilityInput, EvaluationUncheckedCreateWithoutFacilityInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutFacilityInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutFacilityInput, EvaluationUncheckedUpdateWithoutFacilityInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutFacilityInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutFacilityInput>
  }

  export type PhysicianCreateWithoutPatientInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutReferringPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutPatientInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutReferringPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutPatientInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
  }

  export type FootCreateWithoutPatientInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateWithoutPatientInput = {
    id?: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootCreateOrConnectWithoutPatientInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput>
  }

  export type FootCreateManyPatientInputEnvelope = {
    data: FootCreateManyPatientInput | FootCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationCreateManyPatientInputEnvelope = {
    data: EvaluationCreateManyPatientInput | EvaluationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type WorkbenchCreateWithoutPatientInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutPatientInput = {
    id?: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput>
  }

  export type WorkbenchCreateManyPatientInputEnvelope = {
    data: WorkbenchCreateManyPatientInput | WorkbenchCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPatientCreateWithoutPatientInput = {
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPatientsInput
  }

  export type CompanyPatientUncheckedCreateWithoutPatientInput = {
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateOrConnectWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    create: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput>
  }

  export type CompanyPatientCreateManyPatientInputEnvelope = {
    data: CompanyPatientCreateManyPatientInput | CompanyPatientCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PhysicianUpsertWithoutPatientInput = {
    update: XOR<PhysicianUpdateWithoutPatientInput, PhysicianUncheckedUpdateWithoutPatientInput>
    create: XOR<PhysicianCreateWithoutPatientInput, PhysicianUncheckedCreateWithoutPatientInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutPatientInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutPatientInput, PhysicianUncheckedUpdateWithoutPatientInput>
  }

  export type PhysicianUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutReferringPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutReferringPhysicianNestedInput
  }

  export type FootUpsertWithWhereUniqueWithoutPatientInput = {
    where: FootWhereUniqueInput
    update: XOR<FootUpdateWithoutPatientInput, FootUncheckedUpdateWithoutPatientInput>
    create: XOR<FootCreateWithoutPatientInput, FootUncheckedCreateWithoutPatientInput>
  }

  export type FootUpdateWithWhereUniqueWithoutPatientInput = {
    where: FootWhereUniqueInput
    data: XOR<FootUpdateWithoutPatientInput, FootUncheckedUpdateWithoutPatientInput>
  }

  export type FootUpdateManyWithWhereWithoutPatientInput = {
    where: FootScalarWhereInput
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyWithoutPatientInput>
  }

  export type FootScalarWhereInput = {
    AND?: FootScalarWhereInput | FootScalarWhereInput[]
    OR?: FootScalarWhereInput[]
    NOT?: FootScalarWhereInput | FootScalarWhereInput[]
    id?: StringFilter<"Foot"> | string
    patientId?: StringFilter<"Foot"> | string
    workbenchId?: StringFilter<"Foot"> | string
    side?: EnumSideFilter<"Foot"> | $Enums.Side
    shoeSize?: FloatNullableFilter<"Foot"> | number | null
    shoeWidth?: EnumShoeWidthFilter<"Foot"> | $Enums.ShoeWidth
    shoeGender?: EnumGenderNullableFilter<"Foot"> | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFilter<"Foot"> | $Enums.ShoeSystem
    shoeBrand?: StringNullableFilter<"Foot"> | string | null
    shoeModel?: StringNullableFilter<"Foot"> | string | null
    questionnaire?: JsonNullableFilter<"Foot">
    inactiveReason?: EnumInactiveFootReasonNullableFilter<"Foot"> | $Enums.InactiveFootReason | null
    isChild?: BoolFilter<"Foot"> | boolean
    active?: BoolFilter<"Foot"> | boolean
    createdAt?: DateTimeFilter<"Foot"> | Date | string
    updatedAt?: DateTimeFilter<"Foot"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutPatientInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutPatientInput>
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutPatientInput, WorkbenchUncheckedUpdateWithoutPatientInput>
    create: XOR<WorkbenchCreateWithoutPatientInput, WorkbenchUncheckedCreateWithoutPatientInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutPatientInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutPatientInput, WorkbenchUncheckedUpdateWithoutPatientInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutPatientInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutPatientInput>
  }

  export type WorkbenchScalarWhereInput = {
    AND?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
    OR?: WorkbenchScalarWhereInput[]
    NOT?: WorkbenchScalarWhereInput | WorkbenchScalarWhereInput[]
    id?: StringFilter<"Workbench"> | string
    patientId?: StringFilter<"Workbench"> | string
    productId?: StringFilter<"Workbench"> | string
    evaluationId?: StringFilter<"Workbench"> | string
    customization?: JsonNullableFilter<"Workbench">
    webhookUrl?: StringNullableFilter<"Workbench"> | string | null
    createdReason?: EnumWorkbenchCreatedReasonNullableFilter<"Workbench"> | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFilter<"Workbench"> | $Enums.WorkbenchStatus
    failedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"Workbench"> | Date | string | null
    createdAt?: DateTimeFilter<"Workbench"> | Date | string
    updatedAt?: DateTimeFilter<"Workbench"> | Date | string
  }

  export type CompanyPatientUpsertWithWhereUniqueWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    update: XOR<CompanyPatientUpdateWithoutPatientInput, CompanyPatientUncheckedUpdateWithoutPatientInput>
    create: XOR<CompanyPatientCreateWithoutPatientInput, CompanyPatientUncheckedCreateWithoutPatientInput>
  }

  export type CompanyPatientUpdateWithWhereUniqueWithoutPatientInput = {
    where: CompanyPatientWhereUniqueInput
    data: XOR<CompanyPatientUpdateWithoutPatientInput, CompanyPatientUncheckedUpdateWithoutPatientInput>
  }

  export type CompanyPatientUpdateManyWithWhereWithoutPatientInput = {
    where: CompanyPatientScalarWhereInput
    data: XOR<CompanyPatientUpdateManyMutationInput, CompanyPatientUncheckedUpdateManyWithoutPatientInput>
  }

  export type UserCreateWithoutClinicianInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicianInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicianInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
  }

  export type EvaluationCreateWithoutCliniciansInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutCliniciansInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput>
  }

  export type UserUpsertWithoutClinicianInput = {
    update: XOR<UserUpdateWithoutClinicianInput, UserUncheckedUpdateWithoutClinicianInput>
    create: XOR<UserCreateWithoutClinicianInput, UserUncheckedCreateWithoutClinicianInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinicianInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinicianInput, UserUncheckedUpdateWithoutClinicianInput>
  }

  export type UserUpdateWithoutClinicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutCliniciansInput, EvaluationUncheckedUpdateWithoutCliniciansInput>
    create: XOR<EvaluationCreateWithoutCliniciansInput, EvaluationUncheckedCreateWithoutCliniciansInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutCliniciansInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutCliniciansInput, EvaluationUncheckedUpdateWithoutCliniciansInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutCliniciansInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutCliniciansInput>
  }

  export type PatientCreateWithoutEvaluationsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEvaluationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
  }

  export type CompanyCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEvaluationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
  }

  export type DeviceTypeCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    diabetic?: boolean
    custom?: boolean | null
  }

  export type DeviceTypeCreateOrConnectWithoutEvaluationsInput = {
    where: DeviceTypeWhereUniqueInput
    create: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
  }

  export type VisitTypeCreateWithoutEvaluationsInput = {
    id?: string
    name: string
  }

  export type VisitTypeUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
  }

  export type VisitTypeCreateOrConnectWithoutEvaluationsInput = {
    where: VisitTypeWhereUniqueInput
    create: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
  }

  export type PhysicianCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    npi?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientUncheckedCreateNestedManyWithoutPrimaryPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutEvaluationsInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type DiagnosisCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    description: string
    diabetic?: boolean
    standard: $Enums.DiagnosisStandard
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutEvaluationsInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
  }

  export type FacilityCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    address?: FacilityAddressCreateNestedOneWithoutFacilityInput
    users?: FacilityUserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: FacilityAddressUncheckedCreateNestedOneWithoutFacilityInput
    users?: FacilityUserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutEvaluationsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
  }

  export type ClinicianCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutClinicianInput
  }

  export type ClinicianUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    userId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianCreateOrConnectWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    create: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type WorkbenchCreateWithoutEvaluationInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutEvaluationInput = {
    id?: string
    patientId: string
    productId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput>
  }

  export type WorkbenchCreateManyEvaluationInputEnvelope = {
    data: WorkbenchCreateManyEvaluationInput | WorkbenchCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutEvaluationsInput = {
    update: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PatientUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type CompanyUpsertWithoutEvaluationsInput = {
    update: XOR<CompanyUpdateWithoutEvaluationsInput, CompanyUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<CompanyCreateWithoutEvaluationsInput, CompanyUncheckedCreateWithoutEvaluationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEvaluationsInput, CompanyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type CompanyUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DeviceTypeUpsertWithoutEvaluationsInput = {
    update: XOR<DeviceTypeUpdateWithoutEvaluationsInput, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DeviceTypeCreateWithoutEvaluationsInput, DeviceTypeUncheckedCreateWithoutEvaluationsInput>
    where?: DeviceTypeWhereInput
  }

  export type DeviceTypeUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: DeviceTypeWhereInput
    data: XOR<DeviceTypeUpdateWithoutEvaluationsInput, DeviceTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DeviceTypeUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceTypeUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    custom?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type VisitTypeUpsertWithoutEvaluationsInput = {
    update: XOR<VisitTypeUpdateWithoutEvaluationsInput, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<VisitTypeCreateWithoutEvaluationsInput, VisitTypeUncheckedCreateWithoutEvaluationsInput>
    where?: VisitTypeWhereInput
  }

  export type VisitTypeUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: VisitTypeWhereInput
    data: XOR<VisitTypeUpdateWithoutEvaluationsInput, VisitTypeUncheckedUpdateWithoutEvaluationsInput>
  }

  export type VisitTypeUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VisitTypeUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhysicianUpsertWithoutEvaluationsInput = {
    update: XOR<PhysicianUpdateWithoutEvaluationsInput, PhysicianUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PhysicianCreateWithoutEvaluationsInput, PhysicianUncheckedCreateWithoutEvaluationsInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutEvaluationsInput, PhysicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PhysicianUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npi?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUncheckedUpdateManyWithoutPrimaryPhysicianNestedInput
  }

  export type DiagnosisUpsertWithoutEvaluationsInput = {
    update: XOR<DiagnosisUpdateWithoutEvaluationsInput, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DiagnosisCreateWithoutEvaluationsInput, DiagnosisUncheckedCreateWithoutEvaluationsInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutEvaluationsInput, DiagnosisUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DiagnosisUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    diabetic?: BoolFieldUpdateOperationsInput | boolean
    standard?: EnumDiagnosisStandardFieldUpdateOperationsInput | $Enums.DiagnosisStandard
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUpsertWithoutEvaluationsInput = {
    update: XOR<FacilityUpdateWithoutEvaluationsInput, FacilityUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<FacilityCreateWithoutEvaluationsInput, FacilityUncheckedCreateWithoutEvaluationsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutEvaluationsInput, FacilityUncheckedUpdateWithoutEvaluationsInput>
  }

  export type FacilityUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    address?: FacilityAddressUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: FacilityAddressUncheckedUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type ClinicianUpsertWithWhereUniqueWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    update: XOR<ClinicianUpdateWithoutEvaluationsInput, ClinicianUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<ClinicianCreateWithoutEvaluationsInput, ClinicianUncheckedCreateWithoutEvaluationsInput>
  }

  export type ClinicianUpdateWithWhereUniqueWithoutEvaluationsInput = {
    where: ClinicianWhereUniqueInput
    data: XOR<ClinicianUpdateWithoutEvaluationsInput, ClinicianUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ClinicianUpdateManyWithWhereWithoutEvaluationsInput = {
    where: ClinicianScalarWhereInput
    data: XOR<ClinicianUpdateManyMutationInput, ClinicianUncheckedUpdateManyWithoutEvaluationsInput>
  }

  export type ClinicianScalarWhereInput = {
    AND?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
    OR?: ClinicianScalarWhereInput[]
    NOT?: ClinicianScalarWhereInput | ClinicianScalarWhereInput[]
    id?: StringFilter<"Clinician"> | string
    name?: StringFilter<"Clinician"> | string
    userId?: StringNullableFilter<"Clinician"> | string | null
    active?: BoolFilter<"Clinician"> | boolean
    createdAt?: DateTimeFilter<"Clinician"> | Date | string
    updatedAt?: DateTimeFilter<"Clinician"> | Date | string
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutEvaluationInput, WorkbenchUncheckedUpdateWithoutEvaluationInput>
    create: XOR<WorkbenchCreateWithoutEvaluationInput, WorkbenchUncheckedCreateWithoutEvaluationInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutEvaluationInput, WorkbenchUncheckedUpdateWithoutEvaluationInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutEvaluationInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type PatientCreateWithoutFeetInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutFeetInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutFeetInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
  }

  export type WorkbenchCreateWithoutFeetInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutFeetInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutFeetInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
  }

  export type AssetCreateWithoutFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchCreateNestedManyWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type AssetCreateOrConnectWithoutFootInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput>
  }

  export type AssetCreateManyFootInputEnvelope = {
    data: AssetCreateManyFootInput | AssetCreateManyFootInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutFeetInput = {
    update: XOR<PatientUpdateWithoutFeetInput, PatientUncheckedUpdateWithoutFeetInput>
    create: XOR<PatientCreateWithoutFeetInput, PatientUncheckedCreateWithoutFeetInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutFeetInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutFeetInput, PatientUncheckedUpdateWithoutFeetInput>
  }

  export type PatientUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type WorkbenchUpsertWithoutFeetInput = {
    update: XOR<WorkbenchUpdateWithoutFeetInput, WorkbenchUncheckedUpdateWithoutFeetInput>
    create: XOR<WorkbenchCreateWithoutFeetInput, WorkbenchUncheckedCreateWithoutFeetInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutFeetInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutFeetInput, WorkbenchUncheckedUpdateWithoutFeetInput>
  }

  export type WorkbenchUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutFootInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutFootInput, AssetUncheckedUpdateWithoutFootInput>
    create: XOR<AssetCreateWithoutFootInput, AssetUncheckedCreateWithoutFootInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutFootInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutFootInput, AssetUncheckedUpdateWithoutFootInput>
  }

  export type AssetUpdateManyWithWhereWithoutFootInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutFootInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    footId?: StringFilter<"Asset"> | string
    type?: EnumProductTypeFilter<"Asset"> | $Enums.ProductType
    fileUrl?: StringNullableFilter<"Asset"> | string | null
    metadata?: JsonNullableFilter<"Asset">
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    statusCheckpoints?: EnumAssetStatusNullableListFilter<"Asset">
    statusReason?: StringNullableFilter<"Asset"> | string | null
    statusUpdatedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    active?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type FootCreateWithoutAssetsInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    workbench: WorkbenchCreateNestedOneWithoutFeetInput
  }

  export type FootUncheckedCreateWithoutAssetsInput = {
    id?: string
    patientId: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootCreateOrConnectWithoutAssetsInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
  }

  export type WorkbenchCreateWithoutAssetsInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutAssetsInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput>
  }

  export type FootUpsertWithoutAssetsInput = {
    update: XOR<FootUpdateWithoutAssetsInput, FootUncheckedUpdateWithoutAssetsInput>
    create: XOR<FootCreateWithoutAssetsInput, FootUncheckedCreateWithoutAssetsInput>
    where?: FootWhereInput
  }

  export type FootUpdateToOneWithWhereWithoutAssetsInput = {
    where?: FootWhereInput
    data: XOR<FootUpdateWithoutAssetsInput, FootUncheckedUpdateWithoutAssetsInput>
  }

  export type FootUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
  }

  export type FootUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutAssetsInput, WorkbenchUncheckedUpdateWithoutAssetsInput>
    create: XOR<WorkbenchCreateWithoutAssetsInput, WorkbenchUncheckedCreateWithoutAssetsInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutAssetsInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutAssetsInput, WorkbenchUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutAssetsInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutAssetsInput>
  }

  export type ProductCreateWithoutUsedByProductsInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUsedByProductsInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput>
  }

  export type ProductCreateWithoutBuildingBlocksInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBuildingBlocksInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput>
  }

  export type WorkbenchCreateWithoutProductInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutProductInput = {
    id?: string
    patientId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput>
  }

  export type WorkbenchCreateManyProductInputEnvelope = {
    data: WorkbenchCreateManyProductInput | WorkbenchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUsedByProductsInput, ProductUncheckedUpdateWithoutUsedByProductsInput>
    create: XOR<ProductCreateWithoutUsedByProductsInput, ProductUncheckedCreateWithoutUsedByProductsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUsedByProductsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUsedByProductsInput, ProductUncheckedUpdateWithoutUsedByProductsInput>
  }

  export type ProductUpdateManyWithWhereWithoutUsedByProductsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUsedByProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    sides?: EnumSideNullableListFilter<"Product">
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBuildingBlocksInput, ProductUncheckedUpdateWithoutBuildingBlocksInput>
    create: XOR<ProductCreateWithoutBuildingBlocksInput, ProductUncheckedCreateWithoutBuildingBlocksInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBuildingBlocksInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBuildingBlocksInput, ProductUncheckedUpdateWithoutBuildingBlocksInput>
  }

  export type ProductUpdateManyWithWhereWithoutBuildingBlocksInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBuildingBlocksInput>
  }

  export type WorkbenchUpsertWithWhereUniqueWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    update: XOR<WorkbenchUpdateWithoutProductInput, WorkbenchUncheckedUpdateWithoutProductInput>
    create: XOR<WorkbenchCreateWithoutProductInput, WorkbenchUncheckedCreateWithoutProductInput>
  }

  export type WorkbenchUpdateWithWhereUniqueWithoutProductInput = {
    where: WorkbenchWhereUniqueInput
    data: XOR<WorkbenchUpdateWithoutProductInput, WorkbenchUncheckedUpdateWithoutProductInput>
  }

  export type WorkbenchUpdateManyWithWhereWithoutProductInput = {
    where: WorkbenchScalarWhereInput
    data: XOR<WorkbenchUpdateManyMutationInput, WorkbenchUncheckedUpdateManyWithoutProductInput>
  }

  export type PatientCreateWithoutWorkbenchesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutWorkbenchesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
  }

  export type ProductCreateWithoutWorkbenchesInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductCreateNestedManyWithoutBuildingBlocksInput
  }

  export type ProductUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    name: string
    type: $Enums.ProductType
    sides?: ProductCreatesidesInput | $Enums.Side[]
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingBlocks?: ProductUncheckedCreateNestedManyWithoutUsedByProductsInput
    usedByProducts?: ProductUncheckedCreateNestedManyWithoutBuildingBlocksInput
  }

  export type ProductCreateOrConnectWithoutWorkbenchesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
  }

  export type EvaluationCreateWithoutWorkbenchesInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
  }

  export type EvaluationCreateOrConnectWithoutWorkbenchesInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
  }

  export type AssetCreateWithoutWorkbenchesInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    foot: FootCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutWorkbenchesInput = {
    id?: string
    footId: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput>
  }

  export type OrderCreateWithoutWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput>
  }

  export type OrderCreateManyWorkbenchInputEnvelope = {
    data: OrderCreateManyWorkbenchInput | OrderCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type FootCreateWithoutWorkbenchInput = {
    id?: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFeetInput
    assets?: AssetCreateNestedManyWithoutFootInput
  }

  export type FootUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    patientId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutFootInput
  }

  export type FootCreateOrConnectWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    create: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput>
  }

  export type FootCreateManyWorkbenchInputEnvelope = {
    data: FootCreateManyWorkbenchInput | FootCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutWorkbenchInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: FormSchemaCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    schemaId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput>
  }

  export type FormSubmissionCreateManyWorkbenchInputEnvelope = {
    data: FormSubmissionCreateManyWorkbenchInput | FormSubmissionCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type WorkbenchNotesCreateWithoutWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdByUser?: UserCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateWithoutWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesCreateOrConnectWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    create: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesCreateManyWorkbenchInputEnvelope = {
    data: WorkbenchNotesCreateManyWorkbenchInput | WorkbenchNotesCreateManyWorkbenchInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutWorkbenchesInput = {
    update: XOR<PatientUpdateWithoutWorkbenchesInput, PatientUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<PatientCreateWithoutWorkbenchesInput, PatientUncheckedCreateWithoutWorkbenchesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutWorkbenchesInput, PatientUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type PatientUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ProductUpsertWithoutWorkbenchesInput = {
    update: XOR<ProductUpdateWithoutWorkbenchesInput, ProductUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<ProductCreateWithoutWorkbenchesInput, ProductUncheckedCreateWithoutWorkbenchesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWorkbenchesInput, ProductUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type ProductUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
  }

  export type ProductUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
  }

  export type EvaluationUpsertWithoutWorkbenchesInput = {
    update: XOR<EvaluationUpdateWithoutWorkbenchesInput, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<EvaluationCreateWithoutWorkbenchesInput, EvaluationUncheckedCreateWithoutWorkbenchesInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutWorkbenchesInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutWorkbenchesInput, EvaluationUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type EvaluationUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutWorkbenchesInput, AssetUncheckedUpdateWithoutWorkbenchesInput>
    create: XOR<AssetCreateWithoutWorkbenchesInput, AssetUncheckedCreateWithoutWorkbenchesInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutWorkbenchesInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutWorkbenchesInput, AssetUncheckedUpdateWithoutWorkbenchesInput>
  }

  export type AssetUpdateManyWithWhereWithoutWorkbenchesInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutWorkbenchesInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWorkbenchInput, OrderUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<OrderCreateWithoutWorkbenchInput, OrderUncheckedCreateWithoutWorkbenchInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWorkbenchInput, OrderUncheckedUpdateWithoutWorkbenchInput>
  }

  export type OrderUpdateManyWithWhereWithoutWorkbenchInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    workbenchId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    statusUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    committedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    parcelId?: StringNullableFilter<"Order"> | string | null
    active?: BoolFilter<"Order"> | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFilter<"Order"> | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type FootUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    update: XOR<FootUpdateWithoutWorkbenchInput, FootUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<FootCreateWithoutWorkbenchInput, FootUncheckedCreateWithoutWorkbenchInput>
  }

  export type FootUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: FootWhereUniqueInput
    data: XOR<FootUpdateWithoutWorkbenchInput, FootUncheckedUpdateWithoutWorkbenchInput>
  }

  export type FootUpdateManyWithWhereWithoutWorkbenchInput = {
    where: FootScalarWhereInput
    data: XOR<FootUpdateManyMutationInput, FootUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutWorkbenchInput, FormSubmissionUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<FormSubmissionCreateWithoutWorkbenchInput, FormSubmissionUncheckedCreateWithoutWorkbenchInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutWorkbenchInput, FormSubmissionUncheckedUpdateWithoutWorkbenchInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutWorkbenchInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    schemaId?: StringFilter<"FormSubmission"> | string
    workbenchId?: StringFilter<"FormSubmission"> | string
    data?: JsonFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type WorkbenchNotesUpsertWithWhereUniqueWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    update: XOR<WorkbenchNotesUpdateWithoutWorkbenchInput, WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput>
    create: XOR<WorkbenchNotesCreateWithoutWorkbenchInput, WorkbenchNotesUncheckedCreateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesUpdateWithWhereUniqueWithoutWorkbenchInput = {
    where: WorkbenchNotesWhereUniqueInput
    data: XOR<WorkbenchNotesUpdateWithoutWorkbenchInput, WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput>
  }

  export type WorkbenchNotesUpdateManyWithWhereWithoutWorkbenchInput = {
    where: WorkbenchNotesScalarWhereInput
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchInput>
  }

  export type WorkbenchNotesScalarWhereInput = {
    AND?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
    OR?: WorkbenchNotesScalarWhereInput[]
    NOT?: WorkbenchNotesScalarWhereInput | WorkbenchNotesScalarWhereInput[]
    id?: StringFilter<"WorkbenchNotes"> | string
    workbenchId?: StringFilter<"WorkbenchNotes"> | string
    title?: StringNullableFilter<"WorkbenchNotes"> | string | null
    content?: StringNullableFilter<"WorkbenchNotes"> | string | null
    tags?: StringNullableListFilter<"WorkbenchNotes">
    blocks?: JsonNullableFilter<"WorkbenchNotes">
    createdAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    createdBy?: StringNullableFilter<"WorkbenchNotes"> | string | null
    updatedAt?: DateTimeFilter<"WorkbenchNotes"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WorkbenchNotes"> | Date | string | null
  }

  export type WorkbenchCreateWithoutNotesInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutNotesInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutNotesInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type WorkbenchUpsertWithoutNotesInput = {
    update: XOR<WorkbenchUpdateWithoutNotesInput, WorkbenchUncheckedUpdateWithoutNotesInput>
    create: XOR<WorkbenchCreateWithoutNotesInput, WorkbenchUncheckedCreateWithoutNotesInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutNotesInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutNotesInput, WorkbenchUncheckedUpdateWithoutNotesInput>
  }

  export type WorkbenchUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkbenchCreateWithoutOrdersInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutOrdersInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    formSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutOrdersInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
  }

  export type WorkbenchUpsertWithoutOrdersInput = {
    update: XOR<WorkbenchUpdateWithoutOrdersInput, WorkbenchUncheckedUpdateWithoutOrdersInput>
    create: XOR<WorkbenchCreateWithoutOrdersInput, WorkbenchUncheckedCreateWithoutOrdersInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutOrdersInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutOrdersInput, WorkbenchUncheckedUpdateWithoutOrdersInput>
  }

  export type WorkbenchUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type FacilityCreateWithoutAddressInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    users?: FacilityUserCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: FacilityUserUncheckedCreateNestedManyWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutAddressInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
  }

  export type FacilityUpsertWithoutAddressInput = {
    update: XOR<FacilityUpdateWithoutAddressInput, FacilityUncheckedUpdateWithoutAddressInput>
    create: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutAddressInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutAddressInput, FacilityUncheckedUpdateWithoutAddressInput>
  }

  export type FacilityUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    users?: FacilityUserUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: FacilityUserUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type CompanyCreateWithoutPackagesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPackagesInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPackagesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
  }

  export type CompanyUpsertWithoutPackagesInput = {
    update: XOR<CompanyUpdateWithoutPackagesInput, CompanyUncheckedUpdateWithoutPackagesInput>
    create: XOR<CompanyCreateWithoutPackagesInput, CompanyUncheckedCreateWithoutPackagesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPackagesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPackagesInput, CompanyUncheckedUpdateWithoutPackagesInput>
  }

  export type CompanyUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EvaluationCreateWithoutReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput>
  }

  export type EvaluationCreateManyReferringPhysicianInputEnvelope = {
    data: EvaluationCreateManyReferringPhysicianInput | EvaluationCreateManyReferringPhysicianInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
    companies?: CompanyPatientUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput>
  }

  export type PatientCreateManyPrimaryPhysicianInputEnvelope = {
    data: PatientCreateManyPrimaryPhysicianInput | PatientCreateManyPrimaryPhysicianInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutReferringPhysicianInput, EvaluationUncheckedUpdateWithoutReferringPhysicianInput>
    create: XOR<EvaluationCreateWithoutReferringPhysicianInput, EvaluationUncheckedCreateWithoutReferringPhysicianInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutReferringPhysicianInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutReferringPhysicianInput, EvaluationUncheckedUpdateWithoutReferringPhysicianInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutReferringPhysicianInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutReferringPhysicianInput>
  }

  export type PatientUpsertWithWhereUniqueWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutPrimaryPhysicianInput, PatientUncheckedUpdateWithoutPrimaryPhysicianInput>
    create: XOR<PatientCreateWithoutPrimaryPhysicianInput, PatientUncheckedCreateWithoutPrimaryPhysicianInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutPrimaryPhysicianInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutPrimaryPhysicianInput, PatientUncheckedUpdateWithoutPrimaryPhysicianInput>
  }

  export type PatientUpdateManyWithWhereWithoutPrimaryPhysicianInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutPrimaryPhysicianInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    firstName?: StringNullableFilter<"Patient"> | string | null
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringNullableFilter<"Patient"> | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    photoUrl?: StringNullableFilter<"Patient"> | string | null
    active?: BoolFilter<"Patient"> | boolean
    deceasedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    primaryPhysicianId?: StringNullableFilter<"Patient"> | string | null
  }

  export type EvaluationCreateWithoutDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput>
  }

  export type EvaluationCreateManyDiagnosisInputEnvelope = {
    data: EvaluationCreateManyDiagnosisInput | EvaluationCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutDiagnosisInput, EvaluationUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<EvaluationCreateWithoutDiagnosisInput, EvaluationUncheckedCreateWithoutDiagnosisInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutDiagnosisInput, EvaluationUncheckedUpdateWithoutDiagnosisInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutDiagnosisInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type EvaluationCreateWithoutDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    visitType?: VisitTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput>
  }

  export type EvaluationCreateManyDeviceTypeInputEnvelope = {
    data: EvaluationCreateManyDeviceTypeInput | EvaluationCreateManyDeviceTypeInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutDeviceTypeInput, EvaluationUncheckedUpdateWithoutDeviceTypeInput>
    create: XOR<EvaluationCreateWithoutDeviceTypeInput, EvaluationUncheckedCreateWithoutDeviceTypeInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutDeviceTypeInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutDeviceTypeInput, EvaluationUncheckedUpdateWithoutDeviceTypeInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutDeviceTypeInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutDeviceTypeInput>
  }

  export type EvaluationCreateWithoutVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    company: CompanyCreateNestedOneWithoutEvaluationsInput
    deviceType?: DeviceTypeCreateNestedOneWithoutEvaluationsInput
    referringPhysician?: PhysicianCreateNestedOneWithoutEvaluationsInput
    diagnosis?: DiagnosisCreateNestedOneWithoutEvaluationsInput
    facility?: FacilityCreateNestedOneWithoutEvaluationsInput
    clinicians?: ClinicianCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicians?: ClinicianUncheckedCreateNestedManyWithoutEvaluationsInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput>
  }

  export type EvaluationCreateManyVisitTypeInputEnvelope = {
    data: EvaluationCreateManyVisitTypeInput | EvaluationCreateManyVisitTypeInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutVisitTypeInput, EvaluationUncheckedUpdateWithoutVisitTypeInput>
    create: XOR<EvaluationCreateWithoutVisitTypeInput, EvaluationUncheckedCreateWithoutVisitTypeInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutVisitTypeInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutVisitTypeInput, EvaluationUncheckedUpdateWithoutVisitTypeInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutVisitTypeInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutVisitTypeInput>
  }

  export type FormSubmissionCreateWithoutSchemaInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workbench: WorkbenchCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutSchemaInput = {
    id?: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput>
  }

  export type FormSubmissionCreateManySchemaInputEnvelope = {
    data: FormSubmissionCreateManySchemaInput | FormSubmissionCreateManySchemaInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutSchemaInput, FormSubmissionUncheckedUpdateWithoutSchemaInput>
    create: XOR<FormSubmissionCreateWithoutSchemaInput, FormSubmissionUncheckedCreateWithoutSchemaInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutSchemaInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutSchemaInput, FormSubmissionUncheckedUpdateWithoutSchemaInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutSchemaInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutSchemaInput>
  }

  export type FormSchemaCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    type?: $Enums.FormSchemaType | null
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSchemaCreateOrConnectWithoutSubmissionsInput = {
    where: FormSchemaWhereUniqueInput
    create: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
  }

  export type WorkbenchCreateWithoutFormSubmissionsInput = {
    id?: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutWorkbenchesInput
    product: ProductCreateNestedOneWithoutWorkbenchesInput
    evaluation: EvaluationCreateNestedOneWithoutWorkbenchesInput
    assets?: AssetCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderCreateNestedManyWithoutWorkbenchInput
    feet?: FootCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchUncheckedCreateWithoutFormSubmissionsInput = {
    id?: string
    patientId: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutWorkbenchesInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkbenchInput
    feet?: FootUncheckedCreateNestedManyWithoutWorkbenchInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutWorkbenchInput
  }

  export type WorkbenchCreateOrConnectWithoutFormSubmissionsInput = {
    where: WorkbenchWhereUniqueInput
    create: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
  }

  export type FormSchemaUpsertWithoutSubmissionsInput = {
    update: XOR<FormSchemaUpdateWithoutSubmissionsInput, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormSchemaCreateWithoutSubmissionsInput, FormSchemaUncheckedCreateWithoutSubmissionsInput>
    where?: FormSchemaWhereInput
  }

  export type FormSchemaUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormSchemaWhereInput
    data: XOR<FormSchemaUpdateWithoutSubmissionsInput, FormSchemaUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormSchemaUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSchemaUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumFormSchemaTypeFieldUpdateOperationsInput | $Enums.FormSchemaType | null
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpsertWithoutFormSubmissionsInput = {
    update: XOR<WorkbenchUpdateWithoutFormSubmissionsInput, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
    create: XOR<WorkbenchCreateWithoutFormSubmissionsInput, WorkbenchUncheckedCreateWithoutFormSubmissionsInput>
    where?: WorkbenchWhereInput
  }

  export type WorkbenchUpdateToOneWithWhereWithoutFormSubmissionsInput = {
    where?: WorkbenchWhereInput
    data: XOR<WorkbenchUpdateWithoutFormSubmissionsInput, WorkbenchUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type WorkbenchUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type CatalogProductAttributeCreateWithoutProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUncheckedCreateWithoutProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeCreateOrConnectWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    create: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductAttributeCreateManyProductInputEnvelope = {
    data: CatalogProductAttributeCreateManyProductInput | CatalogProductAttributeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CatalogProductVariantCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantCreateOrConnectWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    create: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductVariantCreateManyProductInputEnvelope = {
    data: CatalogProductVariantCreateManyProductInput | CatalogProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CatalogCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    parentId?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCategoryCreateOrConnectWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    create: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CatalogVendorCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogVendorCreateOrConnectWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    create: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput>
  }

  export type CatalogProductAttributeUpsertWithWhereUniqueWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    update: XOR<CatalogProductAttributeUpdateWithoutProductInput, CatalogProductAttributeUncheckedUpdateWithoutProductInput>
    create: XOR<CatalogProductAttributeCreateWithoutProductInput, CatalogProductAttributeUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductAttributeUpdateWithWhereUniqueWithoutProductInput = {
    where: CatalogProductAttributeWhereUniqueInput
    data: XOR<CatalogProductAttributeUpdateWithoutProductInput, CatalogProductAttributeUncheckedUpdateWithoutProductInput>
  }

  export type CatalogProductAttributeUpdateManyWithWhereWithoutProductInput = {
    where: CatalogProductAttributeScalarWhereInput
    data: XOR<CatalogProductAttributeUpdateManyMutationInput, CatalogProductAttributeUncheckedUpdateManyWithoutProductInput>
  }

  export type CatalogProductAttributeScalarWhereInput = {
    AND?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
    OR?: CatalogProductAttributeScalarWhereInput[]
    NOT?: CatalogProductAttributeScalarWhereInput | CatalogProductAttributeScalarWhereInput[]
    id?: StringFilter<"CatalogProductAttribute"> | string
    productId?: StringFilter<"CatalogProductAttribute"> | string
    type?: EnumProductAttributeTypeFilter<"CatalogProductAttribute"> | $Enums.ProductAttributeType
    value?: StringFilter<"CatalogProductAttribute"> | string
    description?: StringNullableFilter<"CatalogProductAttribute"> | string | null
    active?: BoolFilter<"CatalogProductAttribute"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductAttribute"> | Date | string
  }

  export type CatalogProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    update: XOR<CatalogProductVariantUpdateWithoutProductInput, CatalogProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<CatalogProductVariantCreateWithoutProductInput, CatalogProductVariantUncheckedCreateWithoutProductInput>
  }

  export type CatalogProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: CatalogProductVariantWhereUniqueInput
    data: XOR<CatalogProductVariantUpdateWithoutProductInput, CatalogProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type CatalogProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: CatalogProductVariantScalarWhereInput
    data: XOR<CatalogProductVariantUpdateManyMutationInput, CatalogProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type CatalogProductVariantScalarWhereInput = {
    AND?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
    OR?: CatalogProductVariantScalarWhereInput[]
    NOT?: CatalogProductVariantScalarWhereInput | CatalogProductVariantScalarWhereInput[]
    id?: StringFilter<"CatalogProductVariant"> | string
    productId?: StringFilter<"CatalogProductVariant"> | string
    sku?: StringFilter<"CatalogProductVariant"> | string
    name?: StringFilter<"CatalogProductVariant"> | string
    description?: StringNullableFilter<"CatalogProductVariant"> | string | null
    caption?: StringNullableFilter<"CatalogProductVariant"> | string | null
    barcode?: StringNullableFilter<"CatalogProductVariant"> | string | null
    price?: FloatNullableFilter<"CatalogProductVariant"> | number | null
    active?: BoolFilter<"CatalogProductVariant"> | boolean
    createdAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProductVariant"> | Date | string
  }

  export type CatalogCategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    update: XOR<CatalogCategoryUpdateWithoutProductsInput, CatalogCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CatalogCategoryCreateWithoutProductsInput, CatalogCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CatalogCategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CatalogCategoryWhereUniqueInput
    data: XOR<CatalogCategoryUpdateWithoutProductsInput, CatalogCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CatalogCategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CatalogCategoryScalarWhereInput
    data: XOR<CatalogCategoryUpdateManyMutationInput, CatalogCategoryUncheckedUpdateManyWithoutProductsInput>
  }

  export type CatalogCategoryScalarWhereInput = {
    AND?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
    OR?: CatalogCategoryScalarWhereInput[]
    NOT?: CatalogCategoryScalarWhereInput | CatalogCategoryScalarWhereInput[]
    id?: StringFilter<"CatalogCategory"> | string
    name?: StringFilter<"CatalogCategory"> | string
    parentId?: StringNullableFilter<"CatalogCategory"> | string | null
    active?: BoolFilter<"CatalogCategory"> | boolean
    createdAt?: DateTimeFilter<"CatalogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogCategory"> | Date | string
  }

  export type CatalogVendorUpsertWithWhereUniqueWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    update: XOR<CatalogVendorUpdateWithoutProductsInput, CatalogVendorUncheckedUpdateWithoutProductsInput>
    create: XOR<CatalogVendorCreateWithoutProductsInput, CatalogVendorUncheckedCreateWithoutProductsInput>
  }

  export type CatalogVendorUpdateWithWhereUniqueWithoutProductsInput = {
    where: CatalogVendorWhereUniqueInput
    data: XOR<CatalogVendorUpdateWithoutProductsInput, CatalogVendorUncheckedUpdateWithoutProductsInput>
  }

  export type CatalogVendorUpdateManyWithWhereWithoutProductsInput = {
    where: CatalogVendorScalarWhereInput
    data: XOR<CatalogVendorUpdateManyMutationInput, CatalogVendorUncheckedUpdateManyWithoutProductsInput>
  }

  export type CatalogVendorScalarWhereInput = {
    AND?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
    OR?: CatalogVendorScalarWhereInput[]
    NOT?: CatalogVendorScalarWhereInput | CatalogVendorScalarWhereInput[]
    id?: StringFilter<"CatalogVendor"> | string
    name?: StringFilter<"CatalogVendor"> | string
    description?: StringNullableFilter<"CatalogVendor"> | string | null
    image?: StringNullableFilter<"CatalogVendor"> | string | null
    active?: BoolFilter<"CatalogVendor"> | boolean
    createdAt?: DateTimeFilter<"CatalogVendor"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogVendor"> | Date | string
  }

  export type CatalogProductCreateWithoutAttributesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutAttributesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutAttributesInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
  }

  export type CatalogProductUpsertWithoutAttributesInput = {
    update: XOR<CatalogProductUpdateWithoutAttributesInput, CatalogProductUncheckedUpdateWithoutAttributesInput>
    create: XOR<CatalogProductCreateWithoutAttributesInput, CatalogProductUncheckedCreateWithoutAttributesInput>
    where?: CatalogProductWhereInput
  }

  export type CatalogProductUpdateToOneWithWhereWithoutAttributesInput = {
    where?: CatalogProductWhereInput
    data: XOR<CatalogProductUpdateWithoutAttributesInput, CatalogProductUncheckedUpdateWithoutAttributesInput>
  }

  export type CatalogProductUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutVariantsInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
  }

  export type CatalogProductUpsertWithoutVariantsInput = {
    update: XOR<CatalogProductUpdateWithoutVariantsInput, CatalogProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<CatalogProductCreateWithoutVariantsInput, CatalogProductUncheckedCreateWithoutVariantsInput>
    where?: CatalogProductWhereInput
  }

  export type CatalogProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: CatalogProductWhereInput
    data: XOR<CatalogProductUpdateWithoutVariantsInput, CatalogProductUncheckedUpdateWithoutVariantsInput>
  }

  export type CatalogProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    vendors?: CatalogVendorCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    vendors?: CatalogVendorUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CatalogProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    update: XOR<CatalogProductUpdateWithoutCategoriesInput, CatalogProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CatalogProductCreateWithoutCategoriesInput, CatalogProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CatalogProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: CatalogProductWhereUniqueInput
    data: XOR<CatalogProductUpdateWithoutCategoriesInput, CatalogProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type CatalogProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: CatalogProductScalarWhereInput
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CatalogProductScalarWhereInput = {
    AND?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
    OR?: CatalogProductScalarWhereInput[]
    NOT?: CatalogProductScalarWhereInput | CatalogProductScalarWhereInput[]
    id?: StringFilter<"CatalogProduct"> | string
    name?: StringFilter<"CatalogProduct"> | string
    description?: StringNullableFilter<"CatalogProduct"> | string | null
    image?: StringNullableFilter<"CatalogProduct"> | string | null
    price?: FloatNullableFilter<"CatalogProduct"> | number | null
    active?: BoolFilter<"CatalogProduct"> | boolean
    createdAt?: DateTimeFilter<"CatalogProduct"> | Date | string
    updatedAt?: DateTimeFilter<"CatalogProduct"> | Date | string
  }

  export type CatalogProductCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductUncheckedCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: CatalogProductAttributeUncheckedCreateNestedManyWithoutProductInput
    variants?: CatalogProductVariantUncheckedCreateNestedManyWithoutProductInput
    categories?: CatalogCategoryUncheckedCreateNestedManyWithoutProductsInput
  }

  export type CatalogProductCreateOrConnectWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    create: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput>
  }

  export type CatalogProductUpsertWithWhereUniqueWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    update: XOR<CatalogProductUpdateWithoutVendorsInput, CatalogProductUncheckedUpdateWithoutVendorsInput>
    create: XOR<CatalogProductCreateWithoutVendorsInput, CatalogProductUncheckedCreateWithoutVendorsInput>
  }

  export type CatalogProductUpdateWithWhereUniqueWithoutVendorsInput = {
    where: CatalogProductWhereUniqueInput
    data: XOR<CatalogProductUpdateWithoutVendorsInput, CatalogProductUncheckedUpdateWithoutVendorsInput>
  }

  export type CatalogProductUpdateManyWithWhereWithoutVendorsInput = {
    where: CatalogProductScalarWhereInput
    data: XOR<CatalogProductUpdateManyMutationInput, CatalogProductUncheckedUpdateManyWithoutVendorsInput>
  }

  export type UserCreateWithoutAuditsLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditsLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditsLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditsLogsInput = {
    update: XOR<UserUpdateWithoutAuditsLogsInput, UserUncheckedUpdateWithoutAuditsLogsInput>
    create: XOR<UserCreateWithoutAuditsLogsInput, UserUncheckedCreateWithoutAuditsLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsLogsInput, UserUncheckedUpdateWithoutAuditsLogsInput>
  }

  export type UserUpdateWithoutAuditsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type CompanyCreateWithoutPermissionsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPermissionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPermissionsInput, CompanyUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutPermissionsInput = {
    update: XOR<CompanyUpdateWithoutPermissionsInput, CompanyUncheckedUpdateWithoutPermissionsInput>
    create: XOR<CompanyCreateWithoutPermissionsInput, CompanyUncheckedCreateWithoutPermissionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPermissionsInput, CompanyUncheckedUpdateWithoutPermissionsInput>
  }

  export type CompanyUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPatientsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPatientsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
  }

  export type PatientCreateWithoutCompaniesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysician?: PhysicianCreateNestedOneWithoutPatientInput
    feet?: FootCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCompaniesInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryPhysicianId?: string | null
    feet?: FootUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    workbenches?: WorkbenchUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCompaniesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutPatientsInput = {
    update: XOR<CompanyUpdateWithoutPatientsInput, CompanyUncheckedUpdateWithoutPatientsInput>
    create: XOR<CompanyCreateWithoutPatientsInput, CompanyUncheckedCreateWithoutPatientsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPatientsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPatientsInput, CompanyUncheckedUpdateWithoutPatientsInput>
  }

  export type CompanyUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PatientUpsertWithoutCompaniesInput = {
    update: XOR<PatientUpdateWithoutCompaniesInput, PatientUncheckedUpdateWithoutCompaniesInput>
    create: XOR<PatientCreateWithoutCompaniesInput, PatientUncheckedCreateWithoutCompaniesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutCompaniesInput, PatientUncheckedUpdateWithoutCompaniesInput>
  }

  export type PatientUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysician?: PhysicianUpdateOneWithoutPatientNestedInput
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type FacilityCreateWithoutUsersInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFacilitiesInput
    address?: FacilityAddressCreateNestedOneWithoutFacilityInput
    evaluations?: EvaluationCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    companyId: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: FacilityAddressUncheckedCreateNestedOneWithoutFacilityInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutUsersInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutFacilitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFacilitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFacilitiesInput, UserUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityUpsertWithoutUsersInput = {
    update: XOR<FacilityUpdateWithoutUsersInput, FacilityUncheckedUpdateWithoutUsersInput>
    create: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutUsersInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutUsersInput, FacilityUncheckedUpdateWithoutUsersInput>
  }

  export type FacilityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFacilitiesNestedInput
    address?: FacilityAddressUpdateOneWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: FacilityAddressUncheckedUpdateOneWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type UserUpsertWithoutFacilitiesInput = {
    update: XOR<UserUpdateWithoutFacilitiesInput, UserUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<UserCreateWithoutFacilitiesInput, UserUncheckedCreateWithoutFacilitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFacilitiesInput, UserUncheckedUpdateWithoutFacilitiesInput>
  }

  export type UserUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserCreateWithoutUserInput = {
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutUserInput = {
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserCreateManyUserInputEnvelope = {
    data: CompanyUserCreateManyUserInput | CompanyUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserPermissionCreateWithoutUserInput = {
    id?: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPermissionsInput
  }

  export type CompanyUserPermissionUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionCreateOrConnectWithoutUserInput = {
    where: CompanyUserPermissionWhereUniqueInput
    create: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserPermissionCreateManyUserInputEnvelope = {
    data: CompanyUserPermissionCreateManyUserInput | CompanyUserPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUserCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutUsersInput
  }

  export type FacilityUserUncheckedCreateWithoutUserInput = {
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserCreateOrConnectWithoutUserInput = {
    where: FacilityUserWhereUniqueInput
    create: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput>
  }

  export type FacilityUserCreateManyUserInputEnvelope = {
    data: FacilityUserCreateManyUserInput | FacilityUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicianCreateWithoutUserInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCliniciansInput
  }

  export type ClinicianCreateOrConnectWithoutUserInput = {
    where: ClinicianWhereUniqueInput
    create: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
  }

  export type WorkbenchNotesCreateWithoutCreatedByUserInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workbench: WorkbenchCreateNestedOneWithoutNotesInput
  }

  export type WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkbenchNotesCreateOrConnectWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    create: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesCreateManyCreatedByUserInputEnvelope = {
    data: WorkbenchNotesCreateManyCreatedByUserInput | WorkbenchNotesCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    userId?: StringFilter<"Account"> | string
    profileId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyUserPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserPermissionWhereUniqueInput
    update: XOR<CompanyUserPermissionUpdateWithoutUserInput, CompanyUserPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserPermissionCreateWithoutUserInput, CompanyUserPermissionUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserPermissionWhereUniqueInput
    data: XOR<CompanyUserPermissionUpdateWithoutUserInput, CompanyUserPermissionUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserPermissionUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserPermissionScalarWhereInput
    data: XOR<CompanyUserPermissionUpdateManyMutationInput, CompanyUserPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type FacilityUserUpsertWithWhereUniqueWithoutUserInput = {
    where: FacilityUserWhereUniqueInput
    update: XOR<FacilityUserUpdateWithoutUserInput, FacilityUserUncheckedUpdateWithoutUserInput>
    create: XOR<FacilityUserCreateWithoutUserInput, FacilityUserUncheckedCreateWithoutUserInput>
  }

  export type FacilityUserUpdateWithWhereUniqueWithoutUserInput = {
    where: FacilityUserWhereUniqueInput
    data: XOR<FacilityUserUpdateWithoutUserInput, FacilityUserUncheckedUpdateWithoutUserInput>
  }

  export type FacilityUserUpdateManyWithWhereWithoutUserInput = {
    where: FacilityUserScalarWhereInput
    data: XOR<FacilityUserUpdateManyMutationInput, FacilityUserUncheckedUpdateManyWithoutUserInput>
  }

  export type ClinicianUpsertWithoutUserInput = {
    update: XOR<ClinicianUpdateWithoutUserInput, ClinicianUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicianCreateWithoutUserInput, ClinicianUncheckedCreateWithoutUserInput>
    where?: ClinicianWhereInput
  }

  export type ClinicianUpdateToOneWithWhereWithoutUserInput = {
    where?: ClinicianWhereInput
    data: XOR<ClinicianUpdateWithoutUserInput, ClinicianUncheckedUpdateWithoutUserInput>
  }

  export type ClinicianUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutCliniciansNestedInput
  }

  export type ClinicianUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutCliniciansNestedInput
  }

  export type WorkbenchNotesUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    update: XOR<WorkbenchNotesUpdateWithoutCreatedByUserInput, WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<WorkbenchNotesCreateWithoutCreatedByUserInput, WorkbenchNotesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: WorkbenchNotesWhereUniqueInput
    data: XOR<WorkbenchNotesUpdateWithoutCreatedByUserInput, WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type WorkbenchNotesUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: WorkbenchNotesScalarWhereInput
    data: XOR<WorkbenchNotesUpdateManyMutationInput, WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUserCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutUserInput
    facilities?: FacilityUserCreateNestedManyWithoutUserInput
    clinician?: ClinicianCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password?: string | null
    pin?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutUserInput
    facilities?: FacilityUserUncheckedCreateNestedManyWithoutUserInput
    clinician?: ClinicianUncheckedCreateNestedOneWithoutUserInput
    notes?: WorkbenchNotesUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditsLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUserUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutUserNestedInput
    facilities?: FacilityUserUncheckedUpdateManyWithoutUserNestedInput
    clinician?: ClinicianUncheckedUpdateOneWithoutUserNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditsLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutApiKeysInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    url?: string | null
    logoUrl?: string | null
    slug: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutCompanyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutCompanyInput
    packages?: ShippingPackageUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    permissions?: CompanyUserPermissionUncheckedCreateNestedManyWithoutCompanyInput
    patients?: CompanyPatientUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutApiKeysInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
  }

  export type CompanyUpsertWithoutApiKeysInput = {
    update: XOR<CompanyUpdateWithoutApiKeysInput, CompanyUncheckedUpdateWithoutApiKeysInput>
    create: XOR<CompanyCreateWithoutApiKeysInput, CompanyUncheckedCreateWithoutApiKeysInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutApiKeysInput, CompanyUncheckedUpdateWithoutApiKeysInput>
  }

  export type CompanyUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutCompanyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutCompanyNestedInput
    packages?: ShippingPackageUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    permissions?: CompanyUserPermissionUncheckedUpdateManyWithoutCompanyNestedInput
    patients?: CompanyPatientUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FacilityCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.FacilityType
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyCompanyInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyCompanyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingPackageCreateManyCompanyInput = {
    id?: string
    name: string
    weight: number
    weightUnit?: $Enums.WeightUnit
    length: number
    width: number
    height: number
    dimensionUnit?: $Enums.DimensionUnit
    insoleCapacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateManyCompanyInput = {
    userId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionCreateManyCompanyInput = {
    id?: string
    userId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateManyCompanyInput = {
    patientId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    userId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type FacilityUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: FacilityAddressUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: FacilityAddressUncheckedUpdateOneWithoutFacilityNestedInput
    users?: FacilityUserUncheckedUpdateManyWithoutFacilityNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingPackageUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    weightUnit?: EnumWeightUnitFieldUpdateOperationsInput | $Enums.WeightUnit
    length?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    dimensionUnit?: EnumDimensionUnitFieldUpdateOperationsInput | $Enums.DimensionUnit
    insoleCapacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutCompanyInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type CompanyUserPermissionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUpdateWithoutCompanyInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyPatientUncheckedUpdateWithoutCompanyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUncheckedUpdateManyWithoutCompanyInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserCreateManyFacilityInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyFacilityInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserUpdateWithoutFacilityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacilitiesNestedInput
  }

  export type FacilityUserUncheckedUpdateWithoutFacilityInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserUncheckedUpdateManyWithoutFacilityInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootCreateManyPatientInput = {
    id?: string
    workbenchId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyPatientInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchCreateManyPatientInput = {
    id?: string
    productId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPatientCreateManyPatientInput = {
    companyId: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUpdateWithoutPatientInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type CompanyPatientUncheckedUpdateWithoutPatientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPatientUncheckedUpdateManyWithoutPatientInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutCliniciansInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateManyEvaluationInput = {
    id?: string
    patientId: string
    productId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicianUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutClinicianNestedInput
  }

  export type ClinicianUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicianUncheckedUpdateManyWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyFootInput = {
    id?: string
    type: $Enums.ProductType
    fileUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.AssetStatus
    statusCheckpoints?: AssetCreatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: string | null
    statusUpdatedAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUpdateManyWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbenches?: WorkbenchUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutFootInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    product?: ProductUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchCreateManyProductInput = {
    id?: string
    patientId: string
    evaluationId: string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdReason?: $Enums.WorkbenchCreatedReason | null
    status?: $Enums.WorkbenchStatus
    failedAt?: Date | string | null
    completedAt?: Date | string | null
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUpdateManyWithoutUsedByProductsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingBlocks?: ProductUncheckedUpdateManyWithoutUsedByProductsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUsedByProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedByProducts?: ProductUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedByProducts?: ProductUncheckedUpdateManyWithoutBuildingBlocksNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBuildingBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    sides?: ProductUpdatesidesInput | $Enums.Side[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutWorkbenchesNestedInput
    evaluation?: EvaluationUpdateOneRequiredWithoutWorkbenchesNestedInput
    assets?: AssetUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutWorkbenchesNestedInput
    orders?: OrderUncheckedUpdateManyWithoutWorkbenchNestedInput
    feet?: FootUncheckedUpdateManyWithoutWorkbenchNestedInput
    formSubmissions?: FormSubmissionUncheckedUpdateManyWithoutWorkbenchNestedInput
    notes?: WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchNestedInput
  }

  export type WorkbenchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    customization?: NullableJsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdReason?: NullableEnumWorkbenchCreatedReasonFieldUpdateOperationsInput | $Enums.WorkbenchCreatedReason | null
    status?: EnumWorkbenchStatusFieldUpdateOperationsInput | $Enums.WorkbenchStatus
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyWorkbenchInput = {
    id?: string
    status?: $Enums.OrderStatus
    statusUpdatedAt?: Date | string | null
    committedDeliveryAt?: Date | string | null
    parcelId?: string | null
    active?: boolean
    authorizationStatus: $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FootCreateManyWorkbenchInput = {
    id?: string
    patientId: string
    side: $Enums.Side
    shoeSize?: number | null
    shoeWidth?: $Enums.ShoeWidth
    shoeGender?: $Enums.Gender | null
    shoeSystem?: $Enums.ShoeSystem
    shoeBrand?: string | null
    shoeModel?: string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: $Enums.InactiveFootReason | null
    isChild?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionCreateManyWorkbenchInput = {
    id?: string
    schemaId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchNotesCreateManyWorkbenchInput = {
    id?: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foot?: FootUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutWorkbenchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    footId?: StringFieldUpdateOperationsInput | string
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    statusCheckpoints?: AssetUpdatestatusCheckpointsInput | $Enums.AssetStatus[]
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    committedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcelId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    authorizationStatus?: EnumOrderAuthorizationStatusFieldUpdateOperationsInput | $Enums.OrderAuthorizationStatus
    authorizationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FootUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFeetNestedInput
    assets?: AssetUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutFootNestedInput
  }

  export type FootUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    side?: EnumSideFieldUpdateOperationsInput | $Enums.Side
    shoeSize?: NullableFloatFieldUpdateOperationsInput | number | null
    shoeWidth?: EnumShoeWidthFieldUpdateOperationsInput | $Enums.ShoeWidth
    shoeGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    shoeSystem?: EnumShoeSystemFieldUpdateOperationsInput | $Enums.ShoeSystem
    shoeBrand?: NullableStringFieldUpdateOperationsInput | string | null
    shoeModel?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaire?: NullableJsonNullValueInput | InputJsonValue
    inactiveReason?: NullableEnumInactiveFootReasonFieldUpdateOperationsInput | $Enums.InactiveFootReason | null
    isChild?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: FormSchemaUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutWorkbenchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationCreateManyReferringPhysicianInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyPrimaryPhysicianInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    height?: number | null
    weight?: number | null
    maritalStatus?: $Enums.MaritalStatus | null
    photoUrl?: string | null
    active?: boolean
    deceasedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutReferringPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feet?: FootUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feet?: FootUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutPatientNestedInput
    companies?: CompanyPatientUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutPrimaryPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    deceasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyDiagnosisInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyDeviceTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitTypeId?: string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    visitType?: VisitTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutDeviceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyVisitTypeInput = {
    id?: string
    externalId?: string | null
    poNumber?: string | null
    type: $Enums.CareType
    patientId: string
    companyId: string
    deviceTypeId?: string | null
    isDiabetic?: boolean
    isVeteran?: boolean
    deviceSide?: $Enums.Side | null
    devicePosition?: $Enums.VerticalPosition | null
    appointmentAt?: Date | string | null
    appointmentStatus?: string | null
    referringPhysicianId?: string | null
    diagnosisId?: string | null
    diagnosisedAt?: Date | string | null
    visitedAt?: Date | string | null
    facilityId?: string | null
    location?: string | null
    prescribedAt?: Date | string | null
    prescribedActive?: boolean
    primaryInsurance?: string | null
    secondaryInsurance?: string | null
    submittedAt?: Date | string | null
    startedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEvaluationsNestedInput
    deviceType?: DeviceTypeUpdateOneWithoutEvaluationsNestedInput
    referringPhysician?: PhysicianUpdateOneWithoutEvaluationsNestedInput
    diagnosis?: DiagnosisUpdateOneWithoutEvaluationsNestedInput
    facility?: FacilityUpdateOneWithoutEvaluationsNestedInput
    clinicians?: ClinicianUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicians?: ClinicianUncheckedUpdateManyWithoutEvaluationsNestedInput
    workbenches?: WorkbenchUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutVisitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    poNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCareTypeFieldUpdateOperationsInput | $Enums.CareType
    patientId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deviceTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    isDiabetic?: BoolFieldUpdateOperationsInput | boolean
    isVeteran?: BoolFieldUpdateOperationsInput | boolean
    deviceSide?: NullableEnumSideFieldUpdateOperationsInput | $Enums.Side | null
    devicePosition?: NullableEnumVerticalPositionFieldUpdateOperationsInput | $Enums.VerticalPosition | null
    appointmentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referringPhysicianId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisId?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    prescribedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prescribedActive?: BoolFieldUpdateOperationsInput | boolean
    primaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryInsurance?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManySchemaInput = {
    id?: string
    workbenchId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormSubmissionUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workbench?: WorkbenchUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeCreateManyProductInput = {
    id?: string
    type: $Enums.ProductAttributeType
    value: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductVariantCreateManyProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    caption?: string | null
    barcode?: string | null
    price?: number | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogProductAttributeUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductAttributeUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumProductAttributeTypeFieldUpdateOperationsInput | $Enums.ProductAttributeType
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCategoryUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogVendorUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    vendors?: CatalogVendorUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    vendors?: CatalogVendorUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogProductUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: CatalogProductAttributeUncheckedUpdateManyWithoutProductNestedInput
    variants?: CatalogProductVariantUncheckedUpdateManyWithoutProductNestedInput
    categories?: CatalogCategoryUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CatalogProductUncheckedUpdateManyWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    profileId: string
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateManyUserInput = {
    companyId: string
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserPermissionCreateManyUserInput = {
    id?: string
    companyId: string
    permission: $Enums.CompanyPermission
    role?: $Enums.CompanyRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUserCreateManyUserInput = {
    facilityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkbenchNotesCreateManyCreatedByUserInput = {
    id?: string
    workbenchId: string
    title?: string | null
    content?: string | null
    tags?: WorkbenchNotesCreatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    companyId: string
    entityId?: string | null
    entityType?: string | null
    action: string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutUserInput = {
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type CompanyUserPermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    permission?: EnumCompanyPermissionFieldUpdateOperationsInput | $Enums.CompanyPermission
    role?: EnumCompanyRoleFieldUpdateOperationsInput | $Enums.CompanyRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutUsersNestedInput
  }

  export type FacilityUserUncheckedUpdateWithoutUserInput = {
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUserUncheckedUpdateManyWithoutUserInput = {
    facilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkbenchNotesUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workbench?: WorkbenchUpdateOneRequiredWithoutNotesNestedInput
  }

  export type WorkbenchNotesUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkbenchNotesUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workbenchId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WorkbenchNotesUpdatetagsInput | string[]
    blocks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCountOutputTypeDefaultArgs instead
     */
    export type FacilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicianCountOutputTypeDefaultArgs instead
     */
    export type ClinicianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationCountOutputTypeDefaultArgs instead
     */
    export type EvaluationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FootCountOutputTypeDefaultArgs instead
     */
    export type FootCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FootCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCountOutputTypeDefaultArgs instead
     */
    export type AssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchCountOutputTypeDefaultArgs instead
     */
    export type WorkbenchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhysicianCountOutputTypeDefaultArgs instead
     */
    export type PhysicianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhysicianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisCountOutputTypeDefaultArgs instead
     */
    export type DiagnosisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTypeCountOutputTypeDefaultArgs instead
     */
    export type DeviceTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitTypeCountOutputTypeDefaultArgs instead
     */
    export type VisitTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSchemaCountOutputTypeDefaultArgs instead
     */
    export type FormSchemaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSchemaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductCountOutputTypeDefaultArgs instead
     */
    export type CatalogProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogCategoryCountOutputTypeDefaultArgs instead
     */
    export type CatalogCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogVendorCountOutputTypeDefaultArgs instead
     */
    export type CatalogVendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogVendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityDefaultArgs instead
     */
    export type FacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicianDefaultArgs instead
     */
    export type ClinicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDefaultArgs instead
     */
    export type EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FootDefaultArgs instead
     */
    export type FootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FootDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchDefaultArgs instead
     */
    export type WorkbenchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkbenchNotesDefaultArgs instead
     */
    export type WorkbenchNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkbenchNotesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityAddressDefaultArgs instead
     */
    export type FacilityAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityAddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShippingPackageDefaultArgs instead
     */
    export type ShippingPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShippingPackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhysicianDefaultArgs instead
     */
    export type PhysicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhysicianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisDefaultArgs instead
     */
    export type DiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillingCodeDefaultArgs instead
     */
    export type BillingCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillingCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTypeDefaultArgs instead
     */
    export type DeviceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitTypeDefaultArgs instead
     */
    export type VisitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSchemaDefaultArgs instead
     */
    export type FormSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSchemaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionDefaultArgs instead
     */
    export type FormSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormTemplateDefaultArgs instead
     */
    export type FormTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductDefaultArgs instead
     */
    export type CatalogProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductAttributeDefaultArgs instead
     */
    export type CatalogProductAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductAttributeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogProductVariantDefaultArgs instead
     */
    export type CatalogProductVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogProductVariantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogCategoryDefaultArgs instead
     */
    export type CatalogCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogVendorDefaultArgs instead
     */
    export type CatalogVendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogVendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrinterDefaultArgs instead
     */
    export type PrinterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrinterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyUserDefaultArgs instead
     */
    export type CompanyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyUserPermissionDefaultArgs instead
     */
    export type CompanyUserPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyUserPermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyPatientDefaultArgs instead
     */
    export type CompanyPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyPatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityUserDefaultArgs instead
     */
    export type FacilityUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViewFlattenedWorkbenchDefaultArgs instead
     */
    export type ViewFlattenedWorkbenchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViewFlattenedWorkbenchDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}